!function (module1) {
  var _objectWithoutProperties;
  module1.link("@babel/runtime/helpers/objectWithoutProperties", {
    default: function (v) {
      _objectWithoutProperties = v;
    }
  }, 0);
  var _regeneratorRuntime;
  module1.link("@babel/runtime/regenerator", {
    default: function (v) {
      _regeneratorRuntime = v;
    }
  }, 1);
  var _assertThisInitialized;
  module1.link("@babel/runtime/helpers/assertThisInitialized", {
    default: function (v) {
      _assertThisInitialized = v;
    }
  }, 2);
  var _objectSpread;
  module1.link("@babel/runtime/helpers/objectSpread2", {
    default: function (v) {
      _objectSpread = v;
    }
  }, 3);
  var _createClass;
  module1.link("@babel/runtime/helpers/createClass", {
    default: function (v) {
      _createClass = v;
    }
  }, 4);
  var _slicedToArray;
  module1.link("@babel/runtime/helpers/slicedToArray", {
    default: function (v) {
      _slicedToArray = v;
    }
  }, 5);
  var _toConsumableArray;
  module1.link("@babel/runtime/helpers/toConsumableArray", {
    default: function (v) {
      _toConsumableArray = v;
    }
  }, 6);
  var _typeof;
  module1.link("@babel/runtime/helpers/typeof", {
    default: function (v) {
      _typeof = v;
    }
  }, 7);
  var _createForOfIteratorHelperLoose;
  module1.link("@babel/runtime/helpers/createForOfIteratorHelperLoose", {
    default: function (v) {
      _createForOfIteratorHelperLoose = v;
    }
  }, 8);
  var _inheritsLoose;
  module1.link("@babel/runtime/helpers/inheritsLoose", {
    default: function (v) {
      _inheritsLoose = v;
    }
  }, 9);
  var _wrapNativeSuper;
  module1.link("@babel/runtime/helpers/wrapNativeSuper", {
    default: function (v) {
      _wrapNativeSuper = v;
    }
  }, 10);
  const _excluded = ["start"],
    _excluded2 = ["blueprint"],
    _excluded3 = ["transition", "disabled", "group"],
    _excluded4 = ["component"],
    _excluded5 = ["activated", "id"],
    _excluded6 = ["id", "activated", "children"],
    _excluded7 = ["id", "activated", "children"],
    _excluded8 = ["selected", "id"],
    _excluded9 = ["id", "selected", "children"],
    _excluded10 = ["id", "selected", "children"],
    _excluded11 = ["modelValue", "color"],
    _excluded12 = ["modelValue"],
    _excluded13 = ["class"],
    _excluded14 = ["a"],
    _excluded15 = ["label"],
    _excluded16 = ["getValue", "getColor"],
    _excluded17 = ["modelValue"],
    _excluded18 = ["class"],
    _excluded19 = ["raw"],
    _excluded20 = ["modelValue"],
    _excluded21 = ["class"],
    _excluded22 = ["once", "immediate"];
  var _arrayInstrumentation, _ErrorTypeStrings$, _ErrorTypeMessages;
  var _a;
  var package_default = {
    name: "meteor-vite",
    version: "1.11.2",
    description: "",
    files: ["dist"],
    main: "",
    exports: {
      "./plugin": {
        "import": ["./dist/plugin/index.mjs"],
        require: ["./dist/plugin/index.js"]
      },
      "./client": "./dist/client/index.mjs"
    },
    scripts: {
      start: "ts-node-dev src/bin/debug/watch-mocks.ts",
      watch: "tsup --watch --dts --sourcemap",
      build: "rm -rf ./dist && tsup-node",
      prepare: "npm run build",
      test: "vitest"
    },
    tsup: [{
      entry: ["./src/bin/worker.ts", "./src/client/index.ts"],
      outDir: "dist",
      format: "esm",
      sourcemap: true,
      dts: false
    }, {
      entry: ["./src/plugin/index.ts"],
      outDir: "dist/plugin",
      format: ["cjs", "esm"],
      sourcemap: true,
      dts: true
    }],
    typesVersions: {
      "*": {
        plugin: ["./dist/plugin/index.d.mts", "./dist/plugin/index.d.ts"],
        client: ["./dist/client/index.d.mts"]
      }
    },
    keywords: ["meteor", "vite"],
    author: "",
    bugs: {
      url: "https://github.com/JorgenVatle/meteor-vite/issues"
    },
    homepage: "https://github.com/JorgenVatle/meteor-vite#readme",
    license: "ISC",
    dependencies: {
      "@babel/parser": "^7.22.5",
      "@babel/traverse": "^7.22.5",
      "p-limit": "^3.1.0",
      picocolors: "^1.0.0",
      simpleddp: "^2.2.4",
      ws: "^8.18.0"
    },
    peerDependencies: {
      vite: ">=3.0.0"
    },
    devDependencies: {
      "@babel/generator": "^7.23.6",
      "@babel/types": "^7.22.5",
      "@sveltejs/vite-plugin-svelte": "^2.4.2",
      "@types/babel__generator": "^7.6.8",
      "@types/node": "^20.3.3",
      "@types/simpleddp": "^2.2.4",
      "@types/ws": "^8.5.12",
      "ts-node-dev": "^2.0.0",
      tsup: "^7.1.0",
      typescript: "^5.1.6",
      vite: "^4.5.5",
      vitest: "^0.32.2"
    }
  };
  function validateStub(stubbedPackage, _ref10) {
    var exportKeys = _ref10.exportKeys,
      packageName = _ref10.packageName,
      requestId = _ref10.requestId,
      warnOnly = _ref10.warnOnly;
    console.debug("Meteor-Vite package validation:", {
      packageName: packageName,
      stubbedPackage: stubbedPackage,
      exportKeys: exportKeys,
      warnOnly: warnOnly
    });
    var errors = [];
    exportKeys.forEach(function (key) {
      if (!stubbedPackage) {
        errors.push(new ImportException("Was not able to import Meteor package: \"" + packageName + "\"", {
          requestId: requestId,
          packageName: packageName
        }));
      }
      if (typeof stubbedPackage[key] === "undefined") {
        errors.push(new UndefinedExportException("Could not import Meteor package into the client: export '" + key + "' is undefined", {
          requestId: requestId,
          packageName: packageName,
          exportName: key
        }));
      }
    });
    errors.forEach(function (error, i) {
      if (warnOnly) {
        return console.warn(error);
      }
      if (errors.length - 1 >= i) {
        throw error;
      }
      console.error(error);
    });
  }
  var MeteorViteError = /*#__PURE__*/function (_Error) {
    function MeteorViteError(message, _ref11) {
      var _this;
      var packageName = _ref11.packageName,
        requestId = _ref11.requestId,
        exportName = _ref11.exportName;
      var footerLines = ["\u26A1 Affected package: " + packageName, "\u26A1 Export name: { " + exportName + " }", "\u26A1 Vite Request ID: " + requestId, "", "\u26A0\uFE0F Open an issue - it's likely an issue with meteor-vite rather than '" + packageName + "'", "    " + package_default.bugs.url, "", "\uD83D\uDD13  At your own risk, you can disable validation for the '" + packageName + "' package", "    This may allow the app to continue running, but can lead to other things breaking.", "    " + package_default.homepage + "#stub-validation"].join("\n");
      _this = _Error.call(this, message) || this;
      _this.name = "[meteor-vite] \u26A0\uFE0F " + _this.constructor.name;
      _this.stack += "\n\n" + footerLines;
      return _this;
    }
    _inheritsLoose(MeteorViteError, _Error);
    return MeteorViteError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var ImportException = /*#__PURE__*/function (_MeteorViteError) {
    function ImportException() {
      return _MeteorViteError.apply(this, arguments) || this;
    }
    _inheritsLoose(ImportException, _MeteorViteError);
    return ImportException;
  }(MeteorViteError);
  var UndefinedExportException = /*#__PURE__*/function (_MeteorViteError2) {
    function UndefinedExportException() {
      return _MeteorViteError2.apply(this, arguments) || this;
    }
    _inheritsLoose(UndefinedExportException, _MeteorViteError2);
    return UndefinedExportException;
  }(MeteorViteError);
  var g$1 = typeof window !== "undefined" ? window : global$1;
  var m$1 = g$1.Package["meteor"];
  var m2$2;
  var require$2 = Package.modules.meteorInstall({
    "__vite_stub0.js": function (require3, exports, module) {
      m2$2 = require3("meteor/meteor");
      validateStub(m2$2, {
        "requestId": "meteor/meteor",
        "packageName": "meteor/meteor",
        "exportKeys": ["Meteor", "global", "meteorEnv"],
        "warnOnly": true
      });
    }
  }, {
    "extensions": [".js"]
  });
  require$2("/__vite_stub0.js");
  var Meteor = m$1.Meteor;
  var global$1 = m$1.global;
  m$1.meteorEnv;
  /**
  * @vue/shared v3.5.12
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  function makeMap(str) {
    var map3 = /* @__PURE__ */Object.create(null);
    for (var _iterator = _createForOfIteratorHelperLoose(str.split(",")), _step2; !(_step2 = _iterator()).done;) {
      var key = _step2.value;
      map3[key] = 1;
    }
    return function (val) {
      return val in map3;
    };
  }
  var EMPTY_OBJ = !!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
  var EMPTY_ARR = !!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
  var NOOP = function () {};
  var NO = function () {
    return false;
  };
  var isOn$1 = function (key) {
    return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  };
  var isModelListener = function (key) {
    return key.startsWith("onUpdate:");
  };
  var extend = Object.assign;
  var remove = function (arr, el) {
    var i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var hasOwn = function (val, key) {
    return hasOwnProperty$1.call(val, key);
  };
  var isArray$1 = Array.isArray;
  var isMap = function (val) {
    return toTypeString(val) === "[object Map]";
  };
  var isSet = function (val) {
    return toTypeString(val) === "[object Set]";
  };
  var isFunction$1 = function (val) {
    return typeof val === "function";
  };
  var isString = function (val) {
    return typeof val === "string";
  };
  var isSymbol = function (val) {
    return _typeof(val) === "symbol";
  };
  var isObject$1 = function (val) {
    return val !== null && _typeof(val) === "object";
  };
  var isPromise = function (val) {
    return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = function (value) {
    return objectToString.call(value);
  };
  var toRawType = function (value) {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject$2 = function (val) {
    return toTypeString(val) === "[object Object]";
  };
  var isIntegerKey = function (key) {
    return isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  };
  var isReservedProp = /* @__PURE__ */makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  var isBuiltInDirective = /* @__PURE__ */makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
  var cacheStringFunction = function (fn) {
    var cache = /* @__PURE__ */Object.create(null);
    return function (str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : "";
    });
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction(function (str) {
    return str.replace(hyphenateRE, "-$1").toLowerCase();
  });
  var capitalize = cacheStringFunction(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  var toHandlerKey = cacheStringFunction(function (str) {
    var s = str ? "on" + capitalize(str) : "";
    return s;
  });
  var hasChanged = function (value, oldValue) {
    return !Object.is(value, oldValue);
  };
  var invokeArrayFns = function (fns) {
    for (var _len3 = arguments.length, arg = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      arg[_key3 - 1] = arguments[_key3];
    }
    for (var _i2 = 0; _i2 < fns.length; _i2++) {
      fns[_i2].apply(fns, arg);
    }
  };
  var def = function (obj, key, value) {
    var writable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable: writable,
      value: value
    });
  };
  var looseToNumber = function (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var toNumber = function (val) {
    var n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = function () {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$1(value)) {
      var res = {};
      for (var _i3 = 0; _i3 < value.length; _i3++) {
        var item = value[_i3];
        var normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (var key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject$1(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:([^]+)/;
  var styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    var ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    var res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray$1(value)) {
      for (var _i4 = 0; _i4 < value.length; _i4++) {
        var normalized = normalizeClass(value[_i4]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$1(value)) {
      for (var name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  var isHTMLTag = /* @__PURE__ */makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */makeMap(SVG_TAGS);
  var isMathMLTag = /* @__PURE__ */makeMap(MATH_TAGS);
  var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
  var isSpecialBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  var isRef$1 = function (val) {
    return !!(val && val["__v_isRef"] === true);
  };
  var toDisplayString = function (val) {
    return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = function (_key, val) {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      var _ref14;
      return _ref14 = {}, _ref14["Map(" + val.size + ")"] = _toConsumableArray(val.entries()).reduce(function (entries, _ref12, i) {
        var _ref13 = _slicedToArray(_ref12, 2),
          key = _ref13[0],
          val2 = _ref13[1];
        entries[stringifySymbol(key, i) + " =>"] = val2;
        return entries;
      }, {}), _ref14;
    } else if (isSet(val)) {
      var _ref15;
      return _ref15 = {}, _ref15["Set(" + val.size + ")"] = _toConsumableArray(val.values()).map(function (v) {
        return stringifySymbol(v);
      }), _ref15;
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$2(val)) {
      return String(val);
    }
    return val;
  };
  var stringifySymbol = function (v) {
    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var _a2;
    return isSymbol(v) ? "Symbol(" + ((_a2 = v.description) != null ? _a2 : i) + ")" : v;
  };
  /**
  * @vue/reactivity v3.5.12
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function warn$3(msg) {
    var _console;
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    (_console = console).warn.apply(_console, ["[Vue warn] " + msg].concat(args));
  }
  var activeEffectScope;
  var EffectScope = /*#__PURE__*/function () {
    function EffectScope() {
      var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
      }
    }
    var _proto = EffectScope.prototype;
    _proto.pause = function pause() {
      if (this._active) {
        this._isPaused = true;
        var _i5, l;
        if (this.scopes) {
          for (_i5 = 0, l = this.scopes.length; _i5 < l; _i5++) {
            this.scopes[_i5].pause();
          }
        }
        for (_i5 = 0, l = this.effects.length; _i5 < l; _i5++) {
          this.effects[_i5].pause();
        }
      }
    };
    _proto.resume = function resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          var _i6, l;
          if (this.scopes) {
            for (_i6 = 0, l = this.scopes.length; _i6 < l; _i6++) {
              this.scopes[_i6].resume();
            }
          }
          for (_i6 = 0, l = this.effects.length; _i6 < l; _i6++) {
            this.effects[_i6].resume();
          }
        }
      }
    };
    _proto.run = function run(fn) {
      if (this._active) {
        var currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else if (!!(process.env.NODE_ENV !== "production")) {
        warn$3("cannot run an inactive effect scope.");
      }
    };
    _proto.on = function on() {
      activeEffectScope = this;
    };
    _proto.off = function off() {
      activeEffectScope = this.parent;
    };
    _proto.stop = function stop(fromParent) {
      if (this._active) {
        var _i7, l;
        for (_i7 = 0, l = this.effects.length; _i7 < l; _i7++) {
          this.effects[_i7].stop();
        }
        for (_i7 = 0, l = this.cleanups.length; _i7 < l; _i7++) {
          this.cleanups[_i7]();
        }
        if (this.scopes) {
          for (_i7 = 0, l = this.scopes.length; _i7 < l; _i7++) {
            this.scopes[_i7].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          var last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    };
    return _createClass(EffectScope, [{
      key: "active",
      get: function () {
        return this._active;
      }
    }]);
  }();
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    } else if (!!(process.env.NODE_ENV !== "production") && !failSilently) {
      warn$3("onScopeDispose() is called when there is no active effect scope to be associated with.");
    }
  }
  var activeSub;
  var pausedQueueEffects = /* @__PURE__ */new WeakSet();
  var ReactiveEffect = /*#__PURE__*/function () {
    function ReactiveEffect(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    var _proto2 = ReactiveEffect.prototype;
    _proto2.pause = function pause() {
      this.flags |= 64;
    };
    _proto2.resume = function resume() {
      if (this.flags & 64) {
        this.flags &= ~64;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    };
    _proto2.notify = function notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    };
    _proto2.run = function run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      var prevEffect = activeSub;
      var prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        if (!!(process.env.NODE_ENV !== "production") && activeSub !== this) {
          warn$3("Active effect was not restored correctly - this is likely a Vue internal bug.");
        }
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= ~2;
      }
    };
    _proto2.stop = function stop() {
      if (this.flags & 1) {
        for (var link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= ~1;
      }
    };
    _proto2.trigger = function trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    };
    _proto2.runIfDirty = function runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    };
    return _createClass(ReactiveEffect, [{
      key: "dirty",
      get: function () {
        return isDirty(this);
      }
    }]);
  }();
  var batchDepth = 0;
  var batchedSub;
  var batchedComputed;
  function batch(sub) {
    var isComputed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    sub.flags |= 8;
    if (isComputed) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      var e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        var next = e.next;
        e.next = void 0;
        e.flags &= ~8;
        e = next;
      }
    }
    var error;
    while (batchedSub) {
      var _e2 = batchedSub;
      batchedSub = void 0;
      while (_e2) {
        var _next = _e2.next;
        _e2.next = void 0;
        _e2.flags &= ~8;
        if (_e2.flags & 1) {
          try {
            ;
            _e2.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        _e2 = _next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (var link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    var head;
    var tail = sub.depsTail;
    var link = tail;
    while (link) {
      var prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (var link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= ~16;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    var dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
      computed2.flags &= ~2;
      return;
    }
    var prevSub = activeSub;
    var prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      var value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= ~2;
    }
  }
  function removeSub(link) {
    var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var dep = link.dep,
      prevSub = link.prevSub,
      nextSub = link.nextSub;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (!!(process.env.NODE_ENV !== "production") && dep.subsHead === link) {
      dep.subsHead = nextSub;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= ~4;
        for (var l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && ! --dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    var prevDep = link.prevDep,
      nextDep = link.nextDep;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    var last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    var cleanup = e.cleanup;
    e.cleanup = void 0;
    if (cleanup) {
      var prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  var globalVersion = 0;
  var Link = function Link(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  };
  var Dep = /*#__PURE__*/function () {
    function Dep(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      if (!!(process.env.NODE_ENV !== "production")) {
        this.subsHead = void 0;
      }
    }
    var _proto3 = Dep.prototype;
    _proto3.track = function track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      var link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          var next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      if (!!(process.env.NODE_ENV !== "production") && activeSub.onTrack) {
        activeSub.onTrack(extend({
          effect: activeSub
        }, debugInfo));
      }
      return link;
    };
    _proto3.trigger = function trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    };
    _proto3.notify = function notify(debugInfo) {
      startBatch();
      try {
        if (!!(process.env.NODE_ENV !== "production")) {
          for (var head = this.subsHead; head; head = head.nextSub) {
            if (head.sub.onTrigger && !(head.sub.flags & 8)) {
              head.sub.onTrigger(extend({
                effect: head.sub
              }, debugInfo));
            }
          }
        }
        for (var link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    };
    return Dep;
  }();
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      var computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (var l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      var currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      if (!!(process.env.NODE_ENV !== "production") && link.dep.subsHead === void 0) {
        link.dep.subsHead = link;
      }
      link.dep.subs = link;
    }
  }
  var targetMap = /* @__PURE__ */new WeakMap();
  var ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Object iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Map keys iterate" : "");
  var ARRAY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Array iterate" : "");
  function track(target, type, key) {
    if (shouldTrack && activeSub) {
      var depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */new Map());
      }
      var dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      if (!!(process.env.NODE_ENV !== "production")) {
        dep.track({
          target: target,
          type: type,
          key: key
        });
      } else {
        dep.track();
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    var depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    var run2 = function (dep) {
      if (dep) {
        if (!!(process.env.NODE_ENV !== "production")) {
          dep.trigger({
            target: target,
            type: type,
            key: key,
            newValue: newValue,
            oldValue: oldValue,
            oldTarget: oldTarget
          });
        } else {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run2);
    } else {
      var targetIsArray = isArray$1(target);
      var isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        var newLength = Number(newValue);
        depsMap.forEach(function (dep, key2) {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run2(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run2(depsMap.get(key));
        }
        if (isArrayIndex) {
          run2(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run2(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run2(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run2(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run2(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run2(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run2(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    var depMap = targetMap.get(object);
    return depMap && depMap.get(key);
  }
  function reactiveReadArray(array) {
    var raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  var arrayInstrumentations = (_arrayInstrumentation = {
    __proto__: null
  }, _arrayInstrumentation[Symbol.iterator] = function () {
    return iterator(this, Symbol.iterator, toReactive);
  }, _arrayInstrumentation.concat = function () {
    var _reactiveReadArray;
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return (_reactiveReadArray = reactiveReadArray(this)).concat.apply(_reactiveReadArray, _toConsumableArray(args.map(function (x) {
      return isArray$1(x) ? reactiveReadArray(x) : x;
    })));
  }, _arrayInstrumentation.entries = function () {
    return iterator(this, "entries", function (value) {
      value[1] = toReactive(value[1]);
      return value;
    });
  }, _arrayInstrumentation.every = function (fn, thisArg) {
    return apply$1(this, "every", fn, thisArg, void 0, arguments);
  }, _arrayInstrumentation.filter = function (fn, thisArg) {
    return apply$1(this, "filter", fn, thisArg, function (v) {
      return v.map(toReactive);
    }, arguments);
  }, _arrayInstrumentation.find = function (fn, thisArg) {
    return apply$1(this, "find", fn, thisArg, toReactive, arguments);
  }, _arrayInstrumentation.findIndex = function (fn, thisArg) {
    return apply$1(this, "findIndex", fn, thisArg, void 0, arguments);
  }, _arrayInstrumentation.findLast = function (fn, thisArg) {
    return apply$1(this, "findLast", fn, thisArg, toReactive, arguments);
  }, _arrayInstrumentation.findLastIndex = function (fn, thisArg) {
    return apply$1(this, "findLastIndex", fn, thisArg, void 0, arguments);
  }, _arrayInstrumentation.forEach = function (fn, thisArg) {
    return apply$1(this, "forEach", fn, thisArg, void 0, arguments);
  }, _arrayInstrumentation.includes = function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return searchProxy(this, "includes", args);
  }, _arrayInstrumentation.indexOf = function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return searchProxy(this, "indexOf", args);
  }, _arrayInstrumentation.join = function (separator) {
    return reactiveReadArray(this).join(separator);
  }, _arrayInstrumentation.lastIndexOf = function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return searchProxy(this, "lastIndexOf", args);
  }, _arrayInstrumentation.map = function (fn, thisArg) {
    return apply$1(this, "map", fn, thisArg, void 0, arguments);
  }, _arrayInstrumentation.pop = function () {
    return noTracking(this, "pop");
  }, _arrayInstrumentation.push = function () {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return noTracking(this, "push", args);
  }, _arrayInstrumentation.reduce = function (fn) {
    for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
      args[_key10 - 1] = arguments[_key10];
    }
    return reduce(this, "reduce", fn, args);
  }, _arrayInstrumentation.reduceRight = function (fn) {
    for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
      args[_key11 - 1] = arguments[_key11];
    }
    return reduce(this, "reduceRight", fn, args);
  }, _arrayInstrumentation.shift = function () {
    return noTracking(this, "shift");
  }, _arrayInstrumentation.some = function (fn, thisArg) {
    return apply$1(this, "some", fn, thisArg, void 0, arguments);
  }, _arrayInstrumentation.splice = function () {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return noTracking(this, "splice", args);
  }, _arrayInstrumentation.toReversed = function () {
    return reactiveReadArray(this).toReversed();
  }, _arrayInstrumentation.toSorted = function (comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  }, _arrayInstrumentation.toSpliced = function () {
    var _reactiveReadArray2;
    return (_reactiveReadArray2 = reactiveReadArray(this)).toSpliced.apply(_reactiveReadArray2, arguments);
  }, _arrayInstrumentation.unshift = function () {
    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      args[_key13] = arguments[_key13];
    }
    return noTracking(this, "unshift", args);
  }, _arrayInstrumentation.values = function () {
    return iterator(this, "values", toReactive);
  }, _arrayInstrumentation);
  function iterator(self2, method, wrapValue) {
    var arr = shallowReadArray(self2);
    var iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = function () {
        var result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  var arrayProto = Array.prototype;
  function apply$1(self2, method, fn, thisArg, wrappedRetFn, args) {
    var arr = shallowReadArray(self2);
    var needsWrap = arr !== self2 && !isShallow(self2);
    var methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      var result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    var wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function (item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function (item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    var result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    var arr = shallowReadArray(self2);
    var wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function (acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function (acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method].apply(arr, [wrappedFn].concat(_toConsumableArray(args)));
  }
  function searchProxy(self2, method, args) {
    var arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    var res = arr[method].apply(arr, _toConsumableArray(args));
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method].apply(arr, _toConsumableArray(args));
    }
    return res;
  }
  function noTracking(self2, method) {
    var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    pauseTracking();
    startBatch();
    var res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  var isNonTrackableKeys = /* @__PURE__ */makeMap("__proto__,__v_isRef,__isVue");
  var builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(function (key) {
    return key !== "arguments" && key !== "caller";
  }).map(function (key) {
    return Symbol[key];
  }).filter(isSymbol));
  function hasOwnProperty(key) {
    if (!isSymbol(key)) key = String(key);
    var obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  var BaseReactiveHandler = /*#__PURE__*/function () {
    function BaseReactiveHandler() {
      var _isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var _isShallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    var _proto4 = BaseReactiveHandler.prototype;
    _proto4.get = function get(target, key, receiver) {
      var isReadonly2 = this._isReadonly,
        isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      var targetIsArray = isArray$1(target);
      if (!isReadonly2) {
        var fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty;
        }
      }
      var res = Reflect.get(target, key, isRef(target) ? target : receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$1(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    };
    return BaseReactiveHandler;
  }();
  var MutableReactiveHandler = /*#__PURE__*/function (_BaseReactiveHandler) {
    function MutableReactiveHandler() {
      var isShallow2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return _BaseReactiveHandler.call(this, false, isShallow2) || this;
    }
    _inheritsLoose(MutableReactiveHandler, _BaseReactiveHandler);
    var _proto5 = MutableReactiveHandler.prototype;
    _proto5.set = function set(target, key, value, receiver) {
      var oldValue = target[key];
      if (!this._isShallow) {
        var isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      var hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      var result = Reflect.set(target, key, value, isRef(target) ? target : receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
    _proto5.deleteProperty = function deleteProperty(target, key) {
      var hadKey = hasOwn(target, key);
      var oldValue = target[key];
      var result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    };
    _proto5.has = function has(target, key) {
      var result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    };
    _proto5.ownKeys = function ownKeys(target) {
      track(target, "iterate", isArray$1(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    };
    return MutableReactiveHandler;
  }(BaseReactiveHandler);
  var ReadonlyReactiveHandler = /*#__PURE__*/function (_BaseReactiveHandler2) {
    function ReadonlyReactiveHandler() {
      var isShallow2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return _BaseReactiveHandler2.call(this, true, isShallow2) || this;
    }
    _inheritsLoose(ReadonlyReactiveHandler, _BaseReactiveHandler2);
    var _proto6 = ReadonlyReactiveHandler.prototype;
    _proto6.set = function set(target, key) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$3("Set operation on key \"" + String(key) + "\" failed: target is readonly.", target);
      }
      return true;
    };
    _proto6.deleteProperty = function deleteProperty(target, key) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$3("Delete operation on key \"" + String(key) + "\" failed: target is readonly.", target);
      }
      return true;
    };
    return ReadonlyReactiveHandler;
  }(BaseReactiveHandler);
  var mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();
  var readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();
  var shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);
  var shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);
  var toShallow = function (value) {
    return value;
  };
  var getProto = function (v) {
    return Reflect.getPrototypeOf(v);
  };
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function () {
      var _ref16;
      var target = this["__v_raw"];
      var rawTarget = toRaw(target);
      var targetIsMap = isMap(rawTarget);
      var isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      var isKeyOnly = method === "keys" && targetIsMap;
      var innerIterator = target[method].apply(target, arguments);
      var wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return _ref16 = {
        next: function () {
          var _innerIterator$next = innerIterator.next(),
            value = _innerIterator$next.value,
            done = _innerIterator$next.done;
          return done ? {
            value: value,
            done: done
          } : {
            value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
            done: done
          };
        }
      }, _ref16[Symbol.iterator] = function () {
        return this;
      }, _ref16;
    };
  }
  function createReadonlyMethod(type) {
    return function () {
      if (!!(process.env.NODE_ENV !== "production")) {
        var key = (arguments.length <= 0 ? undefined : arguments[0]) ? "on key \"" + (arguments.length <= 0 ? undefined : arguments[0]) + "\" " : "";
        warn$3(capitalize(type) + " operation " + key + "failed: target is readonly.", toRaw(this));
      }
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    var instrumentations = {
      get: function (key) {
        var target = this["__v_raw"];
        var rawTarget = toRaw(target);
        var rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        var _getProto = getProto(rawTarget),
          has2 = _getProto.has;
        var wrap2 = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap2(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap2(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        var target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has: function (key) {
        var target = this["__v_raw"];
        var rawTarget = toRaw(target);
        var rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach: function (callback, thisArg) {
        var observed = this;
        var target = observed["__v_raw"];
        var rawTarget = toRaw(target);
        var wrap2 = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach(function (value, key) {
          return callback.call(thisArg, wrap2(value), wrap2(key), observed);
        });
      }
    };
    extend(instrumentations, readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      "delete": createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add: function (value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        var target = toRaw(this);
        var proto = getProto(target);
        var hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set: function (key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        var target = toRaw(this);
        var _getProto2 = getProto(target),
          has2 = _getProto2.has,
          get2 = _getProto2.get;
        var hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        } else if (!!(process.env.NODE_ENV !== "production")) {
          checkIdentityKeys(target, has2, key);
        }
        var oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      "delete": function (key) {
        var target = toRaw(this);
        var _getProto3 = getProto(target),
          has2 = _getProto3.has,
          get2 = _getProto3.get;
        var hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        } else if (!!(process.env.NODE_ENV !== "production")) {
          checkIdentityKeys(target, has2, key);
        }
        var oldValue = get2 ? get2.call(target, key) : void 0;
        var result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear: function () {
        var target = toRaw(this);
        var hadItems = target.size !== 0;
        var oldTarget = !!(process.env.NODE_ENV !== "production") ? isMap(target) ? new Map(target) : new Set(target) : void 0;
        var result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0, oldTarget);
        }
        return result;
      }
    });
    var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach(function (method) {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    var instrumentations = createInstrumentations(isReadonly2, shallow);
    return function (target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: /* @__PURE__ */createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    var rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      var type = toRawType(target);
      warn$3("Reactive " + type + " contains both the raw and reactive versions of the same object" + (type === "Map" ? " as keys" : "") + ", which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.");
    }
  }
  var reactiveMap = /* @__PURE__ */new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */new WeakMap();
  var readonlyMap = /* @__PURE__ */new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$1(target)) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$3("value cannot be made " + (isReadonly2 ? "readonly" : "reactive") + ": " + String(target));
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    var existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    var targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    var proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    var raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  var toReactive = function (value) {
    return isObject$1(value) ? reactive(value) : value;
  };
  var toReadonly = function (value) {
    return isObject$1(value) ? readonly(value) : value;
  };
  function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  var RefImpl = /*#__PURE__*/function () {
    function RefImpl(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    return _createClass(RefImpl, [{
      key: "value",
      get: function () {
        if (!!(process.env.NODE_ENV !== "production")) {
          this.dep.track({
            target: this,
            type: "get",
            key: "value"
          });
        } else {
          this.dep.track();
        }
        return this._value;
      },
      set: function (newValue) {
        var oldValue = this._rawValue;
        var useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue;
          this._value = useDirectValue ? newValue : toReactive(newValue);
          if (!!(process.env.NODE_ENV !== "production")) {
            this.dep.trigger({
              target: this,
              type: "set",
              key: "value",
              newValue: newValue,
              oldValue: oldValue
            });
          } else {
            this.dep.trigger();
          }
        }
      }
    }]);
  }();
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  var shallowUnwrapHandlers = {
    get: function (target, key, receiver) {
      return key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver));
    },
    set: function (target, key, value, receiver) {
      var oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  var CustomRefImpl = /*#__PURE__*/function () {
    function CustomRefImpl(factory) {
      this["__v_isRef"] = true;
      this._value = void 0;
      var dep = this.dep = new Dep();
      var _factory = factory(dep.track.bind(dep), dep.trigger.bind(dep)),
        get2 = _factory.get,
        set = _factory.set;
      this._get = get2;
      this._set = set;
    }
    return _createClass(CustomRefImpl, [{
      key: "value",
      get: function () {
        return this._value = this._get();
      },
      set: function (newVal) {
        this._set(newVal);
      }
    }]);
  }();
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    if (!!(process.env.NODE_ENV !== "production") && !isProxy(object)) {
      warn$3("toRefs() expects a reactive object but received a plain one.");
    }
    var ret = isArray$1(object) ? new Array(object.length) : {};
    for (var key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  var ObjectRefImpl = /*#__PURE__*/function () {
    function ObjectRefImpl(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    return _createClass(ObjectRefImpl, [{
      key: "value",
      get: function () {
        var val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
      },
      set: function (newVal) {
        this._object[this._key] = newVal;
      }
    }, {
      key: "dep",
      get: function () {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }]);
  }();
  var GetterRefImpl = /*#__PURE__*/function () {
    function GetterRefImpl(_getter) {
      this._getter = _getter;
      this["__v_isRef"] = true;
      this["__v_isReadonly"] = true;
      this._value = void 0;
    }
    return _createClass(GetterRefImpl, [{
      key: "value",
      get: function () {
        return this._value = this._getter();
      }
    }]);
  }();
  function toRef(source, key, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$1(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$1(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    var val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  var ComputedRefImpl = /*#__PURE__*/function () {
    function ComputedRefImpl(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    var _proto7 = ComputedRefImpl.prototype;
    _proto7.notify = function notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && activeSub !== this) {
        batch(this, true);
        return true;
      } else if (!!(process.env.NODE_ENV !== "production")) ;
    };
    return _createClass(ComputedRefImpl, [{
      key: "value",
      get: function () {
        var link = !!(process.env.NODE_ENV !== "production") ? this.dep.track({
          target: this,
          type: "get",
          key: "value"
        }) : this.dep.track();
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      },
      set: function (newValue) {
        if (this.setter) {
          this.setter(newValue);
        } else if (!!(process.env.NODE_ENV !== "production")) {
          warn$3("Write operation failed: computed value is readonly");
        }
      }
    }]);
  }();
  function computed$1(getterOrOptions, debugOptions) {
    var isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var getter;
    var setter;
    if (isFunction$1(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    var cRef = new ComputedRefImpl(getter, setter, isSSR);
    if (!!(process.env.NODE_ENV !== "production") && debugOptions && !isSSR) {
      cRef.onTrack = debugOptions.onTrack;
      cRef.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  var INITIAL_WATCHER_VALUE = {};
  var cleanupMap = /* @__PURE__ */new WeakMap();
  var activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn) {
    var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var owner = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : activeWatcher;
    if (owner) {
      var cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    } else if (!!(process.env.NODE_ENV !== "production") && !failSilently) {
      warn$3("onWatcherCleanup() was called when there was no active watcher to associate with.");
    }
  }
  function watch$1(source, cb) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ;
    var immediate = options.immediate,
      deep = options.deep,
      once = options.once,
      scheduler = options.scheduler,
      augmentJob = options.augmentJob,
      call = options.call;
    var warnInvalidSource = function (s) {
      (options.onWarn || warn$3)("Invalid watch source: ", s, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
    };
    var reactiveGetter = function (source2) {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);
      return traverse(source2);
    };
    var effect;
    var getter;
    var cleanup;
    var boundCleanup;
    var forceTrigger = false;
    var isMultiSource = false;
    if (isRef(source)) {
      getter = function () {
        return source.value;
      };
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = function () {
        return reactiveGetter(source);
      };
      forceTrigger = true;
    } else if (isArray$1(source)) {
      isMultiSource = true;
      forceTrigger = source.some(function (s) {
        return isReactive(s) || isShallow(s);
      });
      getter = function () {
        return source.map(function (s) {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return call ? call(s, 2) : s();
          } else {
            !!(process.env.NODE_ENV !== "production") && warnInvalidSource(s);
          }
        });
      };
    } else if (isFunction$1(source)) {
      if (cb) {
        getter = call ? function () {
          return call(source, 2);
        } : source;
      } else {
        getter = function () {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          var currentEffect = activeWatcher;
          activeWatcher = effect;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
      !!(process.env.NODE_ENV !== "production") && warnInvalidSource(source);
    }
    if (cb && deep) {
      var baseGetter = getter;
      var depth = deep === true ? Infinity : deep;
      getter = function () {
        return traverse(baseGetter(), depth);
      };
    }
    var scope = getCurrentScope();
    var watchHandle = function () {
      effect.stop();
      if (scope) {
        remove(scope.effects, effect);
      }
    };
    if (once && cb) {
      var _cb = cb;
      cb = function () {
        _cb.apply(void 0, arguments);
        watchHandle();
      };
    }
    var oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    var job = function (immediateFirstRun) {
      if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        var newValue = effect.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {
          return hasChanged(v, oldValue[i]);
        }) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          var currentWatcher = activeWatcher;
          activeWatcher = effect;
          try {
            var args = [newValue, oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, boundCleanup];
            call ? call(cb, 3, args) : cb.apply(void 0, args);
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect = new ReactiveEffect(getter);
    effect.scheduler = scheduler ? function () {
      return scheduler(job, false);
    } : job;
    boundCleanup = function (fn) {
      return onWatcherCleanup(fn, false, effect);
    };
    cleanup = effect.onStop = function () {
      var cleanups = cleanupMap.get(effect);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (var _iterator2 = _createForOfIteratorHelperLoose(cleanups), _step3; !(_step3 = _iterator2()).done;) {
            var cleanup2 = _step3.value;
            cleanup2();
          }
        }
        cleanupMap.delete(effect);
      }
    };
    if (!!(process.env.NODE_ENV !== "production")) {
      effect.onTrack = options.onTrack;
      effect.onTrigger = options.onTrigger;
    }
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect.run();
    }
    watchHandle.pause = effect.pause.bind(effect);
    watchHandle.resume = effect.resume.bind(effect);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value) {
    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    var seen = arguments.length > 2 ? arguments[2] : undefined;
    if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$1(value)) {
      for (var _i8 = 0; _i8 < value.length; _i8++) {
        traverse(value[_i8], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach(function (v) {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$2(value)) {
      for (var key in value) {
        traverse(value[key], depth, seen);
      }
      for (var _iterator3 = _createForOfIteratorHelperLoose(Object.getOwnPropertySymbols(value)), _step4; !(_step4 = _iterator3()).done;) {
        var _key14 = _step4.value;
        if (Object.prototype.propertyIsEnumerable.call(value, _key14)) {
          traverse(value[_key14], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.12
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  var isWarning = false;
  function warn$1(msg) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    var instance = stack.length ? stack[stack.length - 1].component : null;
    var appWarnHandler = instance && instance.appContext.config.warnHandler;
    var trace = getComponentTrace();
    for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key15 = 1; _key15 < _len14; _key15++) {
      args[_key15 - 1] = arguments[_key15];
    }
    if (appWarnHandler) {
      callWithErrorHandling(appWarnHandler, instance, 11, [msg + args.map(function (a) {
        var _a2, _b;
        return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
      }).join(""), instance && instance.proxy, trace.map(function (_ref17) {
        var vnode = _ref17.vnode;
        return "at <" + formatComponentName(instance, vnode.type) + ">";
      }).join("\n"), trace]);
    } else {
      var _console2;
      var warnArgs = ["[Vue warn]: " + msg].concat(args);
      if (trace.length && true) {
        warnArgs.push.apply(warnArgs, ["\n"].concat(_toConsumableArray(formatTrace(trace))));
      }
      (_console2 = console).warn.apply(_console2, _toConsumableArray(warnArgs));
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    var currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    var normalizedStack = [];
    while (currentVNode) {
      var last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      var parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    var logs = [];
    trace.forEach(function (entry, i) {
      logs.push.apply(logs, _toConsumableArray(i === 0 ? [] : ["\n"]).concat(_toConsumableArray(formatTraceEntry(entry))));
    });
    return logs;
  }
  function formatTraceEntry(_ref18) {
    var vnode = _ref18.vnode,
      recurseCount = _ref18.recurseCount;
    var postfix = recurseCount > 0 ? "... (" + recurseCount + " recursive calls)" : "";
    var isRoot = vnode.component ? vnode.component.parent == null : false;
    var open = " at <" + formatComponentName(vnode.component, vnode.type, isRoot);
    var close2 = ">" + postfix;
    return vnode.props ? [open].concat(_toConsumableArray(formatProps(vnode.props)), [close2]) : [open + close2];
  }
  function formatProps(props) {
    var res = [];
    var keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach(function (key) {
      res.push.apply(res, _toConsumableArray(formatProp(key, props[key])));
    });
    if (keys2.length > 3) {
      res.push(" ...");
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [key + "=" + value];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [key + "=" + value];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [key + "=Ref<", value, ">"];
    } else if (isFunction$1(value)) {
      return [key + "=fn" + (value.name ? "<" + value.name + ">" : "")];
    } else {
      value = toRaw(value);
      return raw ? value : [key + "=", value];
    }
  }
  function assertNumber(val, type) {
    if (!!!(process.env.NODE_ENV !== "production")) return;
    if (val === void 0) {
      return;
    } else if (typeof val !== "number") {
      warn$1(type + " is not a valid number - got " + JSON.stringify(val) + ".");
    } else if (isNaN(val)) {
      warn$1(type + " is NaN - the duration expression might be incorrect.");
    }
  }
  var ErrorTypeStrings$1 = (_ErrorTypeStrings$ = {}, _ErrorTypeStrings$["sp"] = "serverPrefetch hook", _ErrorTypeStrings$["bc"] = "beforeCreate hook", _ErrorTypeStrings$["c"] = "created hook", _ErrorTypeStrings$["bm"] = "beforeMount hook", _ErrorTypeStrings$["m"] = "mounted hook", _ErrorTypeStrings$["bu"] = "beforeUpdate hook", _ErrorTypeStrings$["u"] = "updated", _ErrorTypeStrings$["bum"] = "beforeUnmount hook", _ErrorTypeStrings$["um"] = "unmounted hook", _ErrorTypeStrings$["a"] = "activated hook", _ErrorTypeStrings$["da"] = "deactivated hook", _ErrorTypeStrings$["ec"] = "errorCaptured hook", _ErrorTypeStrings$["rtc"] = "renderTracked hook", _ErrorTypeStrings$["rtg"] = "renderTriggered hook", _ErrorTypeStrings$[0] = "setup function", _ErrorTypeStrings$[1] = "render function", _ErrorTypeStrings$[2] = "watcher getter", _ErrorTypeStrings$[3] = "watcher callback", _ErrorTypeStrings$[4] = "watcher cleanup function", _ErrorTypeStrings$[5] = "native event handler", _ErrorTypeStrings$[6] = "component event handler", _ErrorTypeStrings$[7] = "vnode hook", _ErrorTypeStrings$[8] = "directive hook", _ErrorTypeStrings$[9] = "transition hook", _ErrorTypeStrings$[10] = "app errorHandler", _ErrorTypeStrings$[11] = "app warnHandler", _ErrorTypeStrings$[12] = "ref function", _ErrorTypeStrings$[13] = "async component loader", _ErrorTypeStrings$[14] = "scheduler flush", _ErrorTypeStrings$[15] = "component update", _ErrorTypeStrings$[16] = "app unmount cleanup function", _ErrorTypeStrings$);
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn.apply(void 0, _toConsumableArray(args)) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$1(fn)) {
      var res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch(function (err) {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$1(fn)) {
      var values = [];
      for (var _i9 = 0; _i9 < fn.length; _i9++) {
        values.push(callWithAsyncErrorHandling(fn[_i9], instance, type, args));
      }
      return values;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1("Invalid value type passed to callWithAsyncErrorHandling(): " + _typeof(fn));
    }
  }
  function handleError(err, instance, type) {
    var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var contextVNode = instance ? instance.vnode : null;
    var _ref19 = instance && instance.appContext.config || EMPTY_OBJ,
      errorHandler = _ref19.errorHandler,
      throwUnhandledErrorInProduction = _ref19.throwUnhandledErrorInProduction;
    if (instance) {
      var cur = instance.parent;
      var exposedInstance = instance.proxy;
      var errorInfo = !!(process.env.NODE_ENV !== "production") ? ErrorTypeStrings$1[type] : "https://vuejs.org/error-reference/#runtime-" + type;
      while (cur) {
        var errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (var _i10 = 0; _i10 < errorCapturedHooks.length; _i10++) {
            if (errorCapturedHooks[_i10](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [err, exposedInstance, errorInfo]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode) {
    var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var throwInProd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    if (!!(process.env.NODE_ENV !== "production")) {
      var info = ErrorTypeStrings$1[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1("Unhandled error" + (info ? " during execution of " + info : ""));
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  var queue = [];
  var flushIndex = -1;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = /* @__PURE__ */Promise.resolve();
  var currentFlushPromise = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn) {
    var p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex$1(id) {
    var start = flushIndex + 1;
    var end = queue.length;
    while (start < end) {
      var middle = start + end >>> 1;
      var middleJob = queue[middle];
      var middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      var jobId = getId(job);
      var lastJob = queue[queue.length - 1];
      if (!lastJob || !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex$1(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$1(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push.apply(pendingPostFlushCbs, _toConsumableArray(cb));
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen) {
    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : flushIndex + 1;
    if (!!(process.env.NODE_ENV !== "production")) {
      seen = seen || /* @__PURE__ */new Map();
    }
    for (; i < queue.length; i++) {
      var cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (!!(process.env.NODE_ENV !== "production") && checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= ~1;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= ~1;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      var deduped = _toConsumableArray(new Set(pendingPostFlushCbs)).sort(function (a, b) {
        return getId(a) - getId(b);
      });
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        var _activePostFlushCbs;
        (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, _toConsumableArray(deduped));
        return;
      }
      activePostFlushCbs = deduped;
      if (!!(process.env.NODE_ENV !== "production")) {
        seen = seen || /* @__PURE__ */new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        var cb = activePostFlushCbs[postFlushIndex];
        if (!!(process.env.NODE_ENV !== "production") && checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.flags & 4) {
          cb.flags &= ~1;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= ~1;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = function (job) {
    return job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  };
  function flushJobs(seen) {
    if (!!(process.env.NODE_ENV !== "production")) {
      seen = seen || /* @__PURE__ */new Map();
    }
    var check = !!(process.env.NODE_ENV !== "production") ? function (job) {
      return checkRecursiveUpdates(seen, job);
    } : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        var job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (!!(process.env.NODE_ENV !== "production") && check(job)) {
            continue;
          }
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(job, job.i, job.i ? 15 : 14);
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        var _job = queue[flushIndex];
        if (_job) {
          _job.flags &= ~1;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs(seen);
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    var count = seen.get(fn) || 0;
    if (count > RECURSION_LIMIT) {
      var instance = fn.i;
      var componentName = instance && getComponentName(instance.type);
      handleError("Maximum recursive updates exceeded" + (componentName ? " in component <" + componentName + ">" : "") + ". This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.", null, 10);
      return true;
    }
    seen.set(fn, count + 1);
    return false;
  }
  var isHmrUpdating = false;
  var hmrDirtyComponents = /* @__PURE__ */new Map();
  if (!!(process.env.NODE_ENV !== "production")) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = /* @__PURE__ */new Map();
  function registerHMR(instance) {
    var id = instance.type.__hmrId;
    var record = map.get(id);
    if (!record) {
      createRecord(id, instance.type);
      record = map.get(id);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    var record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    _toConsumableArray(record.instances).forEach(function (instance) {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    var record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    var instances = _toConsumableArray(record.instances);
    var _loop = function () {
      var instance = instances[_i11];
      var oldComp = normalizeClassComponent(instance.type);
      var dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        queueJob(function () {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
      }
      if (instance.root.ce && instance !== instance.root) {
        instance.root.ce._removeChildStyle(oldComp);
      }
    };
    for (var _i11 = 0; _i11 < instances.length; _i11++) {
      _loop();
    }
    queuePostFlushCb(function () {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (var key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return function (id, arg) {
      try {
        return fn(id, arg);
      } catch (e) {
        console.error(e);
        console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
      }
    };
  }
  var devtools$1;
  var buffer = [];
  var devtoolsNotInstalled = false;
  function emit$1(event) {
    for (var _len15 = arguments.length, args = new Array(_len15 > 1 ? _len15 - 1 : 0), _key16 = 1; _key16 < _len15; _key16++) {
      args[_key16 - 1] = arguments[_key16];
    }
    if (devtools$1) {
      var _devtools$;
      (_devtools$ = devtools$1).emit.apply(_devtools$, [event].concat(args));
    } else if (!devtoolsNotInstalled) {
      buffer.push({
        event: event,
        args: args
      });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a2, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(function (_ref20) {
        var _devtools$2;
        var event = _ref20.event,
          args = _ref20.args;
        return (_devtools$2 = devtools$1).emit.apply(_devtools$2, [event].concat(_toConsumableArray(args)));
      });
      buffer = [];
    } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
      var replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push(function (newHook) {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(function () {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version2) {
    emit$1("app:init", app, version2, {
      Fragment: Fragment$1,
      Text: Text$1,
      Comment: Comment,
      Static: Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  var devtoolsComponentAdded = /* @__PURE__ */createDevtoolsComponentHook("component:added");
  var devtoolsComponentUpdated = /* @__PURE__ */createDevtoolsComponentHook("component:updated");
  var _devtoolsComponentRemoved = /* @__PURE__ */createDevtoolsComponentHook("component:removed");
  var devtoolsComponentRemoved = function (component) {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && !devtools$1.cleanupBuffer(component)) {
      _devtoolsComponentRemoved(component);
    }
  };
  /*! #__NO_SIDE_EFFECTS__ */
  function createDevtoolsComponentHook(hook) {
    return function (component) {
      emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
  }
  var devtoolsPerfStart = /* @__PURE__ */createDevtoolsPerformanceHook("perf:start");
  var devtoolsPerfEnd = /* @__PURE__ */createDevtoolsPerformanceHook("perf:end");
  function createDevtoolsPerformanceHook(hook) {
    return function (component, type, time) {
      emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit", component.appContext.app, component, event, params);
  }
  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    var prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn) {
    var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;
    var isNonScopedSlot = arguments.length > 2 ? arguments[2] : undefined;
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    var renderFnWithContext = function () {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      var prevInstance = setCurrentRenderingInstance(ctx);
      var res;
      try {
        res = fn.apply(void 0, arguments);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      if (!!(process.env.NODE_ENV !== "production") || false) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives2) {
    if (currentRenderingInstance === null) {
      !!(process.env.NODE_ENV !== "production") && warn$1("withDirectives can only be used inside render functions.");
      return vnode;
    }
    var instance = getComponentPublicInstance(currentRenderingInstance);
    var bindings = vnode.dirs || (vnode.dirs = []);
    for (var _i12 = 0; _i12 < directives2.length; _i12++) {
      var _directives2$_i = _slicedToArray(directives2[_i12], 4),
        dir = _directives2$_i[0],
        value = _directives2$_i[1],
        arg = _directives2$_i[2],
        _directives2$_i$ = _directives2$_i[3],
        modifiers2 = _directives2$_i$ === void 0 ? EMPTY_OBJ : _directives2$_i$;
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir: dir,
          instance: instance,
          value: value,
          oldValue: void 0,
          arg: arg,
          modifiers: modifiers2
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    var bindings = vnode.dirs;
    var oldBindings = prevVNode && prevVNode.dirs;
    for (var _i13 = 0; _i13 < bindings.length; _i13++) {
      var binding = bindings[_i13];
      if (oldBindings) {
        binding.oldValue = oldBindings[_i13].value;
      }
      var hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [vnode.el, binding, vnode, prevVNode]);
        resetTracking();
      }
    }
  }
  var TeleportEndKey = Symbol("_vte");
  var isTeleport = function (type) {
    return type.__isTeleport;
  };
  var isTeleportDisabled = function (props) {
    return props && (props.disabled || props.disabled === "");
  };
  var isTeleportDeferred = function (props) {
    return props && (props.defer || props.defer === "");
  };
  var isTargetSVG = function (target) {
    return typeof SVGElement !== "undefined" && target instanceof SVGElement;
  };
  var isTargetMathML = function (target) {
    return typeof MathMLElement === "function" && target instanceof MathMLElement;
  };
  var resolveTarget = function (props, select) {
    var targetSelector = props && props.to;
    if (isString(targetSelector)) {
      if (!select) {
        !!(process.env.NODE_ENV !== "production") && warn$1("Current renderer does not support string target for Teleports. (missing querySelector renderer option)");
        return null;
      } else {
        var target = select(targetSelector);
        if (!!(process.env.NODE_ENV !== "production") && !target && !isTeleportDisabled(props)) {
          warn$1("Failed to locate Teleport target with selector \"" + targetSelector + "\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.");
        }
        return target;
      }
    } else {
      if (!!(process.env.NODE_ENV !== "production") && !targetSelector && !isTeleportDisabled(props)) {
        warn$1("Invalid Teleport target: " + targetSelector);
      }
      return targetSelector;
    }
  };
  var TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process: function (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      var mountChildren = internals.mc,
        patchChildren = internals.pc,
        patchBlockChildren = internals.pbc,
        _internals$o = internals.o,
        insert = _internals$o.insert,
        querySelector = _internals$o.querySelector,
        createText = _internals$o.createText,
        createComment = _internals$o.createComment;
      var disabled = isTeleportDisabled(n2.props);
      var shapeFlag = n2.shapeFlag,
        children = n2.children,
        dynamicChildren = n2.dynamicChildren;
      if (!!(process.env.NODE_ENV !== "production") && isHmrUpdating) {
        optimized = false;
        dynamicChildren = null;
      }
      if (n1 == null) {
        var placeholder = n2.el = !!(process.env.NODE_ENV !== "production") ? createComment("teleport start") : createText("");
        var mainAnchor = n2.anchor = !!(process.env.NODE_ENV !== "production") ? createComment("teleport end") : createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        var mount = function (container2, anchor2) {
          if (shapeFlag & 16) {
            if (parentComponent && parentComponent.isCE) {
              parentComponent.ce._teleportTarget = container2;
            }
            mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          }
        };
        var mountToTarget = function () {
          var target = n2.target = resolveTarget(n2.props, querySelector);
          var targetAnchor = prepareAnchor(target, n2, createText, insert);
          if (target) {
            if (namespace !== "svg" && isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace !== "mathml" && isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (!disabled) {
              mount(target, targetAnchor);
              updateCssVars(n2, false);
            }
          } else if (!!(process.env.NODE_ENV !== "production") && !disabled) {
            warn$1("Invalid Teleport target on mount:", target, "(" + _typeof(target) + ")");
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
          updateCssVars(n2, true);
        }
        if (isTeleportDeferred(n2.props)) {
          queuePostRenderEffect(mountToTarget, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        var _mainAnchor = n2.anchor = n1.anchor;
        var target = n2.target = n1.target;
        var targetAnchor = n2.targetAnchor = n1.targetAnchor;
        var wasDisabled = isTeleportDisabled(n1.props);
        var currentContainer = wasDisabled ? container : target;
        var currentAnchor = wasDisabled ? _mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds);
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, false);
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(n2, container, _mainAnchor, internals, 1);
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            var nextTarget = n2.target = resolveTarget(n2.props, querySelector);
            if (nextTarget) {
              moveTeleport(n2, nextTarget, null, internals, 0);
            } else if (!!(process.env.NODE_ENV !== "production")) {
              warn$1("Invalid Teleport target on update:", target, "(" + _typeof(target) + ")");
            }
          } else if (wasDisabled) {
            moveTeleport(n2, target, targetAnchor, internals, 1);
          }
        }
        updateCssVars(n2, disabled);
      }
    },
    remove: function (vnode, parentComponent, parentSuspense, _ref21, doRemove) {
      var unmount = _ref21.um,
        hostRemove = _ref21.o.remove;
      var shapeFlag = vnode.shapeFlag,
        children = vnode.children,
        anchor = vnode.anchor,
        targetStart = vnode.targetStart,
        targetAnchor = vnode.targetAnchor,
        target = vnode.target,
        props = vnode.props;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        var shouldRemove = doRemove || !isTeleportDisabled(props);
        for (var _i14 = 0; _i14 < children.length; _i14++) {
          var child = children[_i14];
          unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, _ref22) {
    var insert = _ref22.o.insert,
      move = _ref22.m;
    var moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    var el = vnode.el,
      anchor = vnode.anchor,
      shapeFlag = vnode.shapeFlag,
      children = vnode.children,
      props = vnode.props;
    var isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (var _i15 = 0; _i15 < children.length; _i15++) {
          move(children[_i15], container, parentAnchor, 2);
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref23, hydrateChildren) {
    var _ref23$o = _ref23.o,
      nextSibling = _ref23$o.nextSibling,
      parentNode2 = _ref23$o.parentNode,
      querySelector = _ref23$o.querySelector,
      insert = _ref23$o.insert,
      createText = _ref23$o.createText;
    var target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
      var disabled = isTeleportDisabled(vnode.props);
      var targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode2(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetStart = targetNode;
          vnode.targetAnchor = targetNode && nextSibling(targetNode);
        } else {
          vnode.anchor = nextSibling(node);
          var targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target, vnode, createText, insert);
          }
          hydrateChildren(targetNode && nextSibling(targetNode), vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
      }
      updateCssVars(vnode, disabled);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  var Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled) {
    var ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      var node, anchor;
      if (isDisabled) {
        node = vnode.el;
        anchor = vnode.anchor;
      } else {
        node = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node && node !== anchor) {
        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  function prepareAnchor(target, vnode, createText, insert) {
    var targetStart = vnode.targetStart = createText("");
    var targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
      insert(targetStart, target);
      insert(targetAnchor, target);
    }
    return targetAnchor;
  }
  var leaveCbKey = Symbol("_leaveCb");
  var enterCbKey$1 = Symbol("_enterCb");
  function useTransitionState() {
    var state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */new Map()
    };
    onMounted(function () {
      state.isMounted = true;
    });
    onBeforeUnmount(function () {
      state.isUnmounting = true;
    });
    return state;
  }
  var TransitionHookValidator = [Function, Array];
  var BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  var recursiveGetSubtree = function (instance) {
    var subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  var BaseTransitionImpl = {
    name: "BaseTransition",
    props: BaseTransitionPropsValidators,
    setup: function (props, _ref24) {
      var slots = _ref24.slots;
      var instance = getCurrentInstance$1();
      var state = useTransitionState();
      return function () {
        var children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        var child = findNonCommentChild(children);
        var rawProps = toRaw(props);
        var mode = rawProps.mode;
        if (!!(process.env.NODE_ENV !== "production") && mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
          warn$1("invalid <transition> mode: " + mode);
        }
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        var innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance, function (hooks) {
          return enterHooks = hooks;
        });
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        var oldChild = instance.subTree;
        var oldInnerChild = oldChild && getInnerChild$1(oldChild);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = function () {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = function (el, earlyRemove, delayedLeave) {
              var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = function () {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    var child = children[0];
    if (children.length > 1) {
      var hasFound = false;
      for (var _iterator4 = _createForOfIteratorHelperLoose(children), _step5; !(_step5 = _iterator4()).done;) {
        var c = _step5.value;
        if (c.type !== Comment) {
          if (!!(process.env.NODE_ENV !== "production") && hasFound) {
            warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
            break;
          }
          child = c;
          hasFound = true;
          if (!!!(process.env.NODE_ENV !== "production")) break;
        }
      }
    }
    return child;
  }
  var BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    var leavingVNodes = state.leavingVNodes;
    var leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    var appear = props.appear,
      mode = props.mode,
      _props$persisted = props.persisted,
      persisted = _props$persisted === void 0 ? false : _props$persisted,
      onBeforeEnter = props.onBeforeEnter,
      onEnter = props.onEnter,
      onAfterEnter = props.onAfterEnter,
      onEnterCancelled = props.onEnterCancelled,
      onBeforeLeave = props.onBeforeLeave,
      onLeave = props.onLeave,
      onAfterLeave = props.onAfterLeave,
      onLeaveCancelled = props.onLeaveCancelled,
      onBeforeAppear = props.onBeforeAppear,
      onAppear = props.onAppear,
      onAfterAppear = props.onAfterAppear,
      onAppearCancelled = props.onAppearCancelled;
    var key = String(vnode.key);
    var leavingVNodesCache = getLeavingNodesForType(state, vnode);
    var callHook2 = function (hook, args) {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    var callAsyncHook = function (hook, args) {
      var done = args[1];
      callHook2(hook, args);
      if (isArray$1(hook)) {
        if (hook.every(function (hook2) {
          return hook2.length <= 1;
        })) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    var hooks = {
      mode: mode,
      persisted: persisted,
      beforeEnter: function (el) {
        var hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](true);
        }
        var leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter: function (el) {
        var hook = onEnter;
        var afterHook = onAfterEnter;
        var cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        var called = false;
        var done = el[enterCbKey$1] = function (cancelled) {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave: function (el, remove2) {
        var key2 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](true);
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        var called = false;
        var done = el[leaveCbKey] = function (cancelled) {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone: function (vnode2) {
        var hooks2 = resolveTransitionHooks(vnode2, props, state, instance, postClone);
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    if (!!(process.env.NODE_ENV !== "production") && vnode.component) {
      return vnode.component.subTree;
    }
    var shapeFlag = vnode.shapeFlag,
      children = vnode.children;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$1(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children) {
    var keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var parentKey = arguments.length > 2 ? arguments[2] : undefined;
    var ret = [];
    var keyedFragmentCount = 0;
    for (var _i16 = 0; _i16 < children.length; _i16++) {
      var child = children[_i16];
      var key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : _i16);
      if (child.type === Fragment$1) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, {
          key: key
        }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (var _i17 = 0; _i17 < ret.length; _i17++) {
        ret[_i17].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  function defineComponent$1(options, extraOptions) {
    return isFunction$1(options) ? /* @__PURE__ */function () {
      return extend({
        name: options.name
      }, extraOptions, {
        setup: options
      });
    }() : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  var knownTemplateRefs = /* @__PURE__ */new WeakSet();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
    var isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    if (isArray$1(rawRef)) {
      rawRef.forEach(function (r, i) {
        return setRef(r, oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
      });
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    var refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    var value = isUnmount ? null : refValue;
    var owner = rawRef.i,
      ref2 = rawRef.r;
    if (!!(process.env.NODE_ENV !== "production") && !owner) {
      warn$1("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
      return;
    }
    var oldRef = oldRawRef && oldRawRef.r;
    var refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    var setupState = owner.setupState;
    var rawSetupState = toRaw(setupState);
    var canSetSetupRef = setupState === EMPTY_OBJ ? function () {
      return false;
    } : function (key) {
      if (!!(process.env.NODE_ENV !== "production")) {
        if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {
          warn$1("Template ref \"" + key + "\" used on a non-ref value. It will not work in the production build.");
        }
        if (knownTemplateRefs.has(rawSetupState[key])) {
          return false;
        }
      }
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref2) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else {
      var _isString = isString(ref2);
      var _isRef = isRef(ref2);
      if (_isString || _isRef) {
        var doSet = function () {
          if (rawRef.f) {
            var existing = _isString ? canSetSetupRef(ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
            if (isUnmount) {
              isArray$1(existing) && remove(existing, refValue);
            } else {
              if (!isArray$1(existing)) {
                if (_isString) {
                  refs[ref2] = [refValue];
                  if (canSetSetupRef(ref2)) {
                    setupState[ref2] = refs[ref2];
                  }
                } else {
                  ref2.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref2.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref2] = value;
            if (canSetSetupRef(ref2)) {
              setupState[ref2] = value;
            }
          } else if (_isRef) {
            ref2.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else if (!!(process.env.NODE_ENV !== "production")) {
            warn$1("Invalid template ref type:", ref2, "(" + _typeof(ref2) + ")");
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else if (!!(process.env.NODE_ENV !== "production")) {
        warn$1("Invalid template ref type:", ref2, "(" + _typeof(ref2) + ")");
      }
    }
  }
  getGlobalThis().requestIdleCallback || function (cb) {
    return setTimeout(cb, 1);
  };
  getGlobalThis().cancelIdleCallback || function (id) {
    return clearTimeout(id);
  };
  var isAsyncWrapper = function (i) {
    return !!i.type.__asyncLoader;
  };
  var isKeepAlive = function (vnode) {
    return vnode.type.__isKeepAlive;
  };
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type) {
    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
    var wrappedHook = hook.__wdc || (hook.__wdc = function () {
      var current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      var current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    var injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(function () {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook) {
    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
    var prepend2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (target) {
      var hooks = target[type] || (target[type] = []);
      var wrappedHook = hook.__weh || (hook.__weh = function () {
        pauseTracking();
        var reset = setCurrentInstance(target);
        for (var _len16 = arguments.length, args = new Array(_len16), _key17 = 0; _key17 < _len16; _key17++) {
          args[_key17] = arguments[_key17];
        }
        var res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend2) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      var apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
      warn$1(apiName + " is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.");
    }
  }
  var createHook = function (lifecycle) {
    return function (hook) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, function () {
          return hook.apply(void 0, arguments);
        }, target);
      }
    };
  };
  var onBeforeMount = createHook("bm");
  var onMounted = createHook("m");
  var onBeforeUpdate = createHook("bu");
  var onUpdated = createHook("u");
  var onBeforeUnmount = createHook("bum");
  var onUnmounted = createHook("um");
  var onServerPrefetch = createHook("sp");
  var onRenderTriggered = createHook("rtg");
  var onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
    injectHook("ec", hook, target);
  }
  var COMPONENTS = "components";
  var DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name) {
    var warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var instance = currentRenderingInstance || currentInstance;
    if (instance) {
      var Component = instance.type;
      if (type === COMPONENTS) {
        var selfName = getComponentName(Component, false);
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      var res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (!!(process.env.NODE_ENV !== "production") && warnMissing && !res) {
        var extra = type === COMPONENTS ? "\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement." : "";
        warn$1("Failed to resolve " + type.slice(0, -1) + ": " + name + extra);
      }
      return res;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1("resolve" + capitalize(type.slice(0, -1)) + " can only be used in render() or setup().");
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function renderList(source, renderItem, cache, index) {
    var ret;
    var cached = cache && cache[index];
    var sourceIsArray = isArray$1(source);
    if (sourceIsArray || isString(source)) {
      var sourceIsReactiveArray = sourceIsArray && isReactive(source);
      var needsWrap = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (var _i18 = 0, l = source.length; _i18 < l; _i18++) {
        ret[_i18] = renderItem(needsWrap ? toReactive(source[_i18]) : source[_i18], _i18, void 0, cached && cached[_i18]);
      }
    } else if (typeof source === "number") {
      if (!!(process.env.NODE_ENV !== "production") && !Number.isInteger(source)) {
        warn$1("The v-for range expect an integer value but got " + source + ".");
      }
      ret = new Array(source);
      for (var _i19 = 0; _i19 < source; _i19++) {
        ret[_i19] = renderItem(_i19 + 1, _i19, void 0, cached && cached[_i19]);
      }
    } else if (isObject$1(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(source, function (item, i) {
          return renderItem(item, i, void 0, cached && cached[i]);
        });
      } else {
        var keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (var _i20 = 0, _l2 = keys2.length; _i20 < _l2; _i20++) {
          var key = keys2[_i20];
          ret[_i20] = renderItem(source[key], key, _i20, cached && cached[_i20]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index] = ret;
    }
    return ret;
  }
  var getPublicInstance = function (i) {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = /* @__PURE__ */extend( /* @__PURE__ */Object.create(null), {
    $: function (i) {
      return i;
    },
    $el: function (i) {
      return i.vnode.el;
    },
    $data: function (i) {
      return i.data;
    },
    $props: function (i) {
      return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.props) : i.props;
    },
    $attrs: function (i) {
      return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.attrs) : i.attrs;
    },
    $slots: function (i) {
      return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.slots) : i.slots;
    },
    $refs: function (i) {
      return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.refs) : i.refs;
    },
    $parent: function (i) {
      return getPublicInstance(i.parent);
    },
    $root: function (i) {
      return getPublicInstance(i.root);
    },
    $host: function (i) {
      return i.ce;
    },
    $emit: function (i) {
      return i.emit;
    },
    $options: function (i) {
      return resolveMergedOptions(i);
    },
    $forceUpdate: function (i) {
      return i.f || (i.f = function () {
        queueJob(i.update);
      });
    },
    $nextTick: function (i) {
      return i.n || (i.n = nextTick.bind(i.proxy));
    },
    $watch: function (i) {
      return instanceWatch.bind(i);
    }
  });
  var isReservedPrefix = function (key) {
    return key === "_" || key === "$";
  };
  var hasSetupBinding = function (state, key) {
    return state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  };
  var PublicInstanceProxyHandlers = {
    get: function (_ref25, key) {
      var instance = _ref25._;
      if (key === "__v_skip") {
        return true;
      }
      var ctx = instance.ctx,
        setupState = instance.setupState,
        data = instance.data,
        props = instance.props,
        accessCache = instance.accessCache,
        type = instance.type,
        appContext = instance.appContext;
      if (!!(process.env.NODE_ENV !== "production") && key === "__isVue") {
        return true;
      }
      var normalizedProps;
      if (key[0] !== "$") {
        var n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      var publicGetter = publicPropertiesMap[key];
      var cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          !!(process.env.NODE_ENV !== "production") && markAttrsAccessed();
        } else if (!!(process.env.NODE_ENV !== "production") && key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else if (!!(process.env.NODE_ENV !== "production") && currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1("Property " + JSON.stringify(key) + " must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.");
        } else if (instance === currentRenderingInstance) {
          warn$1("Property " + JSON.stringify(key) + " was accessed during render but is not defined on instance.");
        }
      }
    },
    set: function (_ref26, key, value) {
      var instance = _ref26._;
      var data = instance.data,
        setupState = instance.setupState,
        ctx = instance.ctx;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (!!(process.env.NODE_ENV !== "production") && setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1("Cannot mutate <script setup> binding \"" + key + "\" from Options API.");
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        !!(process.env.NODE_ENV !== "production") && warn$1("Attempting to mutate prop \"" + key + "\". Props are readonly.");
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        !!(process.env.NODE_ENV !== "production") && warn$1("Attempting to mutate public property \"" + key + "\". Properties starting with $ are reserved and readonly.");
        return false;
      } else {
        if (!!(process.env.NODE_ENV !== "production") && key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value: value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has: function (_ref27, key) {
      var _ref27$_ = _ref27._,
        data = _ref27$_.data,
        setupState = _ref27$_.setupState,
        accessCache = _ref27$_.accessCache,
        ctx = _ref27$_.ctx,
        appContext = _ref27$_.appContext,
        propsOptions = _ref27$_.propsOptions;
      var normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty: function (target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  if (!!(process.env.NODE_ENV !== "production") && true) {
    PublicInstanceProxyHandlers.ownKeys = function (target) {
      warn$1("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.");
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    var target = {};
    Object.defineProperty(target, "_", {
      configurable: true,
      enumerable: false,
      get: function () {
        return instance;
      }
    });
    Object.keys(publicPropertiesMap).forEach(function (key) {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: function () {
          return publicPropertiesMap[key](instance);
        },
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    var ctx = instance.ctx,
      _instance$propsOption = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption[0];
    if (propsOptions) {
      Object.keys(propsOptions).forEach(function (key) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: function () {
            return instance.props[key];
          },
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    var ctx = instance.ctx,
      setupState = instance.setupState;
    Object.keys(toRaw(setupState)).forEach(function (key) {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1("setup() return property " + JSON.stringify(key) + " should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.");
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: function () {
            return setupState[key];
          },
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props) {
    return isArray$1(props) ? props.reduce(function (normalized, p2) {
      return normalized[p2] = null, normalized;
    }, {}) : props;
  }
  function createDuplicateChecker() {
    var cache = /* @__PURE__ */Object.create(null);
    return function (type, key) {
      if (cache[key]) {
        warn$1(type + " property \"" + key + "\" is already defined in " + cache[key] + ".");
      } else {
        cache[key] = type;
      }
    };
  }
  var shouldCacheAccess = true;
  function applyOptions(instance) {
    var options = resolveMergedOptions(instance);
    var publicThis = instance.proxy;
    var ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    var dataOptions = options.data,
      computedOptions = options.computed,
      methods = options.methods,
      watchOptions = options.watch,
      provideOptions = options.provide,
      injectOptions = options.inject,
      created = options.created,
      beforeMount = options.beforeMount,
      mounted2 = options.mounted,
      beforeUpdate = options.beforeUpdate,
      updated2 = options.updated,
      activated = options.activated,
      deactivated = options.deactivated,
      beforeDestroy = options.beforeDestroy,
      beforeUnmount = options.beforeUnmount,
      destroyed = options.destroyed,
      unmounted2 = options.unmounted,
      render2 = options.render,
      renderTracked = options.renderTracked,
      renderTriggered = options.renderTriggered,
      errorCaptured = options.errorCaptured,
      serverPrefetch = options.serverPrefetch,
      expose = options.expose,
      inheritAttrs = options.inheritAttrs,
      components2 = options.components,
      directives2 = options.directives,
      filters = options.filters;
    var checkDuplicateProperties = !!(process.env.NODE_ENV !== "production") ? createDuplicateChecker() : null;
    if (!!(process.env.NODE_ENV !== "production")) {
      var _instance$propsOption2 = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption2[0];
      if (propsOptions) {
        for (var key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (var _key18 in methods) {
        var methodHandler = methods[_key18];
        if (isFunction$1(methodHandler)) {
          if (!!(process.env.NODE_ENV !== "production")) {
            Object.defineProperty(ctx, _key18, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx[_key18] = methodHandler.bind(publicThis);
          }
          if (!!(process.env.NODE_ENV !== "production")) {
            checkDuplicateProperties("Methods", _key18);
          }
        } else if (!!(process.env.NODE_ENV !== "production")) {
          warn$1("Method \"" + _key18 + "\" has type \"" + _typeof(methodHandler) + "\" in the component definition. Did you reference the function correctly?");
        }
      }
    }
    if (dataOptions) {
      if (!!(process.env.NODE_ENV !== "production") && !isFunction$1(dataOptions)) {
        warn$1("The data option must be a function. Plain object usage is no longer supported.");
      }
      var data = dataOptions.call(publicThis, publicThis);
      if (!!(process.env.NODE_ENV !== "production") && isPromise(data)) {
        warn$1("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.");
      }
      if (!isObject$1(data)) {
        !!(process.env.NODE_ENV !== "production") && warn$1("data() should return an object.");
      } else {
        instance.data = reactive(data);
        if (!!(process.env.NODE_ENV !== "production")) {
          var _loop2 = function (_key19) {
            checkDuplicateProperties("Data", _key19);
            if (!isReservedPrefix(_key19[0])) {
              Object.defineProperty(ctx, _key19, {
                configurable: true,
                enumerable: true,
                get: function () {
                  return data[_key19];
                },
                set: NOOP
              });
            }
          };
          for (var _key19 in data) {
            _loop2(_key19);
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      var _loop3 = function (_key20) {
        var opt = computedOptions[_key20];
        var get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (!!(process.env.NODE_ENV !== "production") && get2 === NOOP) {
          warn$1("Computed property \"" + _key20 + "\" has no getter.");
        }
        var set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : !!(process.env.NODE_ENV !== "production") ? function () {
          warn$1("Write operation failed: computed property \"" + _key20 + "\" is readonly.");
        } : NOOP;
        var c = computed({
          get: get2,
          set: set
        });
        Object.defineProperty(ctx, _key20, {
          enumerable: true,
          configurable: true,
          get: function () {
            return c.value;
          },
          set: function (v) {
            return c.value = v;
          }
        });
        if (!!(process.env.NODE_ENV !== "production")) {
          checkDuplicateProperties("Computed", _key20);
        }
      };
      for (var _key20 in computedOptions) {
        _loop3(_key20);
      }
    }
    if (watchOptions) {
      for (var _key21 in watchOptions) {
        createWatcher(watchOptions[_key21], ctx, publicThis, _key21);
      }
    }
    if (provideOptions) {
      var provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach(function (key) {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$1(hook)) {
        hook.forEach(function (_hook) {
          return register(_hook.bind(publicThis));
        });
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted2);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated2);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted2);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
      if (expose.length) {
        var exposed = instance.exposed || (instance.exposed = {});
        expose.forEach(function (key) {
          Object.defineProperty(exposed, key, {
            get: function () {
              return publicThis[key];
            },
            set: function (val) {
              return publicThis[key] = val;
            }
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components2) instance.components = components2;
    if (directives2) instance.directives = directives2;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx) {
    var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOOP;
    if (isArray$1(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    var _loop4 = function () {
      var opt = injectOptions[key];
      var injected;
      if (isObject$1(opt)) {
        if ("default" in opt) {
          injected = inject$1(opt.from || key, opt.default, true);
        } else {
          injected = inject$1(opt.from || key);
        }
      } else {
        injected = inject$1(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: function () {
            return injected.value;
          },
          set: function (v) {
            return injected.value = v;
          }
        });
      } else {
        ctx[key] = injected;
      }
      if (!!(process.env.NODE_ENV !== "production")) {
        checkDuplicateProperties("Inject", key);
      }
    };
    for (var key in injectOptions) {
      _loop4();
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(isArray$1(hook) ? hook.map(function (h2) {
      return h2.bind(instance.proxy);
    }) : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx, publicThis, key) {
    var getter = key.includes(".") ? createPathGetter(publicThis, key) : function () {
      return publicThis[key];
    };
    if (isString(raw)) {
      var handler = ctx[raw];
      if (isFunction$1(handler)) {
        {
          watch(getter, handler);
        }
      } else if (!!(process.env.NODE_ENV !== "production")) {
        warn$1("Invalid watch handler specified by key \"" + raw + "\"", handler);
      }
    } else if (isFunction$1(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject$1(raw)) {
      if (isArray$1(raw)) {
        raw.forEach(function (r) {
          return createWatcher(r, ctx, publicThis, key);
        });
      } else {
        var _handler2 = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$1(_handler2)) {
          watch(getter, _handler2, raw);
        } else if (!!(process.env.NODE_ENV !== "production")) {
          warn$1("Invalid watch handler specified by key \"" + raw.handler + "\"", _handler2);
        }
      }
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1("Invalid watch option: \"" + key + "\"", raw);
    }
  }
  function resolveMergedOptions(instance) {
    var base2 = instance.type;
    var mixins = base2.mixins,
      extendsOptions = base2.extends;
    var _instance$appContext = instance.appContext,
      globalMixins = _instance$appContext.mixins,
      cache = _instance$appContext.optionsCache,
      optionMergeStrategies = _instance$appContext.config.optionMergeStrategies;
    var cached = cache.get(base2);
    var resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base2;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(function (m3) {
          return mergeOptions$1(resolved, m3, optionMergeStrategies, true);
        });
      }
      mergeOptions$1(resolved, base2, optionMergeStrategies);
    }
    if (isObject$1(base2)) {
      cache.set(base2, resolved);
    }
    return resolved;
  }
  function mergeOptions$1(to, from2, strats) {
    var asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var mixins = from2.mixins,
      extendsOptions = from2.extends;
    if (extendsOptions) {
      mergeOptions$1(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(function (m3) {
        return mergeOptions$1(to, m3, strats, true);
      });
    }
    for (var key in from2) {
      if (asMixin && key === "expose") {
        !!(process.env.NODE_ENV !== "production") && warn$1("\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.");
      } else {
        var strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from2[key]) : from2[key];
      }
    }
    return to;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from2) {
    if (!from2) {
      return to;
    }
    if (!to) {
      return from2;
    }
    return function mergedDataFn() {
      return extend(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from2) ? from2.call(this, this) : from2);
    };
  }
  function mergeInject(to, from2) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
  }
  function normalizeInject(raw) {
    if (isArray$1(raw)) {
      var res = {};
      for (var _i21 = 0; _i21 < raw.length; _i21++) {
        res[raw[_i21]] = raw[_i21];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from2) {
    return to ? _toConsumableArray(new Set([].concat(to, from2))) : from2;
  }
  function mergeObjectOptions(to, from2) {
    return to ? extend( /* @__PURE__ */Object.create(null), to, from2) : from2;
  }
  function mergeEmitsOrPropsOptions(to, from2) {
    if (to) {
      if (isArray$1(to) && isArray$1(from2)) {
        return _toConsumableArray( /* @__PURE__ */new Set([].concat(_toConsumableArray(to), _toConsumableArray(from2))));
      }
      return extend( /* @__PURE__ */Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from2 != null ? from2 : {}));
    } else {
      return from2;
    }
  }
  function mergeWatchOptions(to, from2) {
    if (!to) return from2;
    if (!from2) return to;
    var merged = extend( /* @__PURE__ */Object.create(null), to);
    for (var key in from2) {
      merged[key] = mergeAsArray(to[key], from2[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */Object.create(null),
      optionsCache: /* @__PURE__ */new WeakMap(),
      propsCache: /* @__PURE__ */new WeakMap(),
      emitsCache: /* @__PURE__ */new WeakMap()
    };
  }
  var uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent) {
      var rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject$1(rootProps)) {
        !!(process.env.NODE_ENV !== "production") && warn$1("root props passed to app.mount() must be an object.");
        rootProps = null;
      }
      var context = createAppContext();
      var installedPlugins = /* @__PURE__ */new WeakSet();
      var pluginCleanupFns = [];
      var isMounted = false;
      var app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version: version$1,
        get config() {
          return context.config;
        },
        set config(v) {
          if (!!(process.env.NODE_ENV !== "production")) {
            warn$1("app.config cannot be replaced. Modify individual options instead.");
          }
        },
        use: function (plugin) {
          for (var _len17 = arguments.length, options = new Array(_len17 > 1 ? _len17 - 1 : 0), _key22 = 1; _key22 < _len17; _key22++) {
            options[_key22 - 1] = arguments[_key22];
          }
          if (installedPlugins.has(plugin)) {
            !!(process.env.NODE_ENV !== "production") && warn$1("Plugin has already been applied to target app.");
          } else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install.apply(plugin, [app].concat(options));
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin.apply(void 0, [app].concat(options));
          } else if (!!(process.env.NODE_ENV !== "production")) {
            warn$1("A plugin must either be a function or an object with an \"install\" function.");
          }
          return app;
        },
        mixin: function (mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (!!(process.env.NODE_ENV !== "production")) {
              warn$1("Mixin has already been applied to target app" + (mixin.name ? ": " + mixin.name : ""));
            }
          }
          return app;
        },
        component: function (name, component) {
          if (!!(process.env.NODE_ENV !== "production")) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (!!(process.env.NODE_ENV !== "production") && context.components[name]) {
            warn$1("Component \"" + name + "\" has already been registered in target app.");
          }
          context.components[name] = component;
          return app;
        },
        directive: function (name, directive2) {
          if (!!(process.env.NODE_ENV !== "production")) {
            validateDirectiveName(name);
          }
          if (!directive2) {
            return context.directives[name];
          }
          if (!!(process.env.NODE_ENV !== "production") && context.directives[name]) {
            warn$1("Directive \"" + name + "\" has already been registered in target app.");
          }
          context.directives[name] = directive2;
          return app;
        },
        mount: function (rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (!!(process.env.NODE_ENV !== "production") && rootContainer.__vue_app__) {
              warn$1("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
            }
            var vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (!!(process.env.NODE_ENV !== "production")) {
              context.reload = function () {
                render2(cloneVNode(vnode), rootContainer, namespace);
              };
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (!!(process.env.NODE_ENV !== "production") || false) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version$1);
            }
            return getComponentPublicInstance(vnode.component);
          } else if (!!(process.env.NODE_ENV !== "production")) {
            warn$1("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
          }
        },
        onUnmount: function (cleanupFn) {
          if (!!(process.env.NODE_ENV !== "production") && typeof cleanupFn !== "function") {
            warn$1("Expected function as first argument to app.onUnmount(), but got " + _typeof(cleanupFn));
          }
          pluginCleanupFns.push(cleanupFn);
        },
        unmount: function () {
          if (isMounted) {
            callWithAsyncErrorHandling(pluginCleanupFns, app._instance, 16);
            render2(null, app._container);
            if (!!(process.env.NODE_ENV !== "production") || false) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (!!(process.env.NODE_ENV !== "production")) {
            warn$1("Cannot unmount an app that is not mounted.");
          }
        },
        provide: function (key, value) {
          if (!!(process.env.NODE_ENV !== "production") && key in context.provides) {
            warn$1("App already provides property with key \"" + String(key) + "\". It will be overwritten with the new value.");
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext: function (fn) {
          var lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  var currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$1("provide() can only be used inside setup().");
      }
    } else {
      var provides = currentInstance.provides;
      var parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject$1(key, defaultValue) {
    var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      var provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else if (!!(process.env.NODE_ENV !== "production")) {
        warn$1("injection \"" + String(key) + "\" not found.");
      }
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1("inject() can only be used inside setup() or functional components.");
    }
  }
  var internalObjectProto = {};
  var createInternalObject = function () {
    return Object.create(internalObjectProto);
  };
  var isInternalObject = function (obj) {
    return Object.getPrototypeOf(obj) === internalObjectProto;
  };
  function initProps(instance, rawProps, isStateful) {
    var isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var props = {};
    var attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (var key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (!!(process.env.NODE_ENV !== "production")) {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId) return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    var props = instance.props,
      attrs = instance.attrs,
      patchFlag = instance.vnode.patchFlag;
    var rawCurrentProps = toRaw(props);
    var _instance$propsOption3 = _slicedToArray(instance.propsOptions, 1),
      options = _instance$propsOption3[0];
    var hasAttrsChanged = false;
    if (!(!!(process.env.NODE_ENV !== "production") && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        var propsToUpdate = instance.vnode.dynamicProps;
        for (var _i22 = 0; _i22 < propsToUpdate.length; _i22++) {
          var key = propsToUpdate[_i22];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          var value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              var camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      var kebabKey;
      for (var _key23 in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, _key23) && ((kebabKey = hyphenate(_key23)) === _key23 || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[_key23] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[_key23] = resolvePropValue(options, rawCurrentProps, _key23, void 0, instance, true);
            }
          } else {
            delete props[_key23];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (var _key24 in attrs) {
          if (!rawProps || !hasOwn(rawProps, _key24) && true) {
            delete attrs[_key24];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    if (!!(process.env.NODE_ENV !== "production")) {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    var _instance$propsOption4 = _slicedToArray(instance.propsOptions, 2),
      options = _instance$propsOption4[0],
      needCastKeys = _instance$propsOption4[1];
    var hasAttrsChanged = false;
    var rawCastValues;
    if (rawProps) {
      for (var key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        var value = rawProps[key];
        var camelKey = void 0;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      var rawCurrentProps = toRaw(props);
      var castValues = rawCastValues || EMPTY_OBJ;
      for (var _i23 = 0; _i23 < needCastKeys.length; _i23++) {
        var _key25 = needCastKeys[_i23];
        props[_key25] = resolvePropValue(options, rawCurrentProps, _key25, castValues[_key25], instance, !hasOwn(castValues, _key25));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    var opt = options[key];
    if (opt != null) {
      var hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        var defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          var propsDefaults = instance.propsDefaults;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            var reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(null, props);
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  var mixinPropsCache = /* @__PURE__ */new WeakMap();
  function normalizePropsOptions(comp, appContext) {
    var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var cache = asMixin ? mixinPropsCache : appContext.propsCache;
    var cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    var raw = comp.props;
    var normalized = {};
    var needCastKeys = [];
    var hasExtends = false;
    if (!isFunction$1(comp)) {
      var extendProps = function (raw2) {
        hasExtends = true;
        var _normalizePropsOption = normalizePropsOptions(raw2, appContext, true),
          _normalizePropsOption2 = _slicedToArray(_normalizePropsOption, 2),
          props = _normalizePropsOption2[0],
          keys2 = _normalizePropsOption2[1];
        extend(normalized, props);
        if (keys2) needCastKeys.push.apply(needCastKeys, _toConsumableArray(keys2));
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$1(raw)) {
      for (var _i24 = 0; _i24 < raw.length; _i24++) {
        if (!!(process.env.NODE_ENV !== "production") && !isString(raw[_i24])) {
          warn$1("props must be strings when using array syntax.", raw[_i24]);
        }
        var normalizedKey = camelize(raw[_i24]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!!(process.env.NODE_ENV !== "production") && !isObject$1(raw)) {
        warn$1("invalid props options", raw);
      }
      for (var key in raw) {
        var _normalizedKey = camelize(key);
        if (validatePropName(_normalizedKey)) {
          var opt = raw[key];
          var prop = normalized[_normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? {
            type: opt
          } : extend({}, opt);
          var propType = prop.type;
          var shouldCast = false;
          var shouldCastTrue = true;
          if (isArray$1(propType)) {
            for (var index = 0; index < propType.length; ++index) {
              var type = propType[index];
              var typeName = isFunction$1(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$1(propType) && propType.name === "Boolean";
          }
          prop[0] = shouldCast;
          prop[1] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(_normalizedKey);
          }
        }
      }
    }
    var res = [normalized, needCastKeys];
    if (isObject$1(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1("Invalid prop name: \"" + key + "\" is a reserved property.");
    }
    return false;
  }
  function getType$1(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (_typeof(ctor) === "object") {
      var name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function validateProps(rawProps, props, instance) {
    var resolvedValues = toRaw(props);
    var options = instance.propsOptions[0];
    var camelizePropsKey = Object.keys(rawProps).map(function (key) {
      return camelize(key);
    });
    for (var key in options) {
      var opt = options[key];
      if (opt == null) continue;
      validateProp(key, resolvedValues[key], opt, !!(process.env.NODE_ENV !== "production") ? shallowReadonly(resolvedValues) : resolvedValues, !camelizePropsKey.includes(key));
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    var type = prop.type,
      required = prop.required,
      validator = prop.validator,
      skipCheck = prop.skipCheck;
    if (required && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required) {
      return;
    }
    if (type != null && type !== true && !skipCheck) {
      var isValid2 = false;
      var types = isArray$1(type) ? type : [type];
      var expectedTypes = [];
      for (var _i25 = 0; _i25 < types.length && !isValid2; _i25++) {
        var _assertType = assertType(value, types[_i25]),
          valid = _assertType.valid,
          expectedType = _assertType.expectedType;
        expectedTypes.push(expectedType || "");
        isValid2 = valid;
      }
      if (!isValid2) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  var isSimpleType = /* @__PURE__ */makeMap("String,Number,Boolean,Function,Symbol,BigInt");
  function assertType(value, type) {
    var valid;
    var expectedType = getType$1(type);
    if (expectedType === "null") {
      valid = value === null;
    } else if (isSimpleType(expectedType)) {
      var t = _typeof(value);
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject$1(value);
    } else if (expectedType === "Array") {
      valid = isArray$1(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return "Prop type [] for prop \"" + name + "\" won't match anything. Did you mean to use type Array instead?";
    }
    var message = "Invalid prop: type check failed for prop \"" + name + "\". Expected " + expectedTypes.map(capitalize).join(" | ");
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += " with value " + expectedValue;
    }
    message += ", got " + receivedType + " ";
    if (isExplicable(receivedType)) {
      message += "with value " + receivedValue + ".";
    }
    return message;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return "\"" + value + "\"";
    } else if (type === "Number") {
      return "" + Number(value);
    } else {
      return "" + value;
    }
  }
  function isExplicable(type) {
    var explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some(function (elem) {
      return type.toLowerCase() === elem;
    });
  }
  function isBoolean() {
    for (var _len18 = arguments.length, args = new Array(_len18), _key26 = 0; _key26 < _len18; _key26++) {
      args[_key26] = arguments[_key26];
    }
    return args.some(function (elem) {
      return elem.toLowerCase() === "boolean";
    });
  }
  var isInternalKey = function (key) {
    return key[0] === "_" || key === "$stable";
  };
  var normalizeSlotValue = function (value) {
    return isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  };
  var normalizeSlot$1 = function (key, rawSlot, ctx) {
    if (rawSlot._n) {
      return rawSlot;
    }
    var normalized = withCtx(function () {
      if (!!(process.env.NODE_ENV !== "production") && currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1("Slot \"" + key + "\" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.");
      }
      return normalizeSlotValue(rawSlot.apply(void 0, arguments));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  var normalizeObjectSlots = function (rawSlots, slots, instance) {
    var ctx = rawSlots._ctx;
    var _loop5 = function () {
      if (isInternalKey(key)) return 1; // continue
      var value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot$1(key, value, ctx);
      } else if (value != null) {
        if (!!(process.env.NODE_ENV !== "production") && true) {
          warn$1("Non-function value encountered for slot \"" + key + "\". Prefer function slots for better performance.");
        }
        var normalized = normalizeSlotValue(value);
        slots[key] = function () {
          return normalized;
        };
      }
    };
    for (var key in rawSlots) {
      if (_loop5()) continue;
    }
  };
  var normalizeVNodeSlots = function (instance, children) {
    if (!!(process.env.NODE_ENV !== "production") && !isKeepAlive(instance.vnode) && true) {
      warn$1("Non-function value encountered for default slot. Prefer function slots for better performance.");
    }
    var normalized = normalizeSlotValue(children);
    instance.slots.default = function () {
      return normalized;
    };
  };
  var assignSlots = function (slots, children, optimized) {
    for (var key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  var initSlots = function (instance, children, optimized) {
    var slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      var type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  var updateSlots = function (instance, children, optimized) {
    var vnode = instance.vnode,
      slots = instance.slots;
    var needDeletionCheck = true;
    var deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      var type = children._;
      if (type) {
        if (!!(process.env.NODE_ENV !== "production") && isHmrUpdating) {
          assignSlots(slots, children, optimized);
          trigger(instance, "set", "$slots");
        } else if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = {
        "default": 1
      };
    }
    if (needDeletionCheck) {
      for (var key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  var supported$1;
  var perf$1;
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      perf$1.mark("vue-" + type + "-" + instance.uid);
    }
    if (!!(process.env.NODE_ENV !== "production") || false) {
      devtoolsPerfStart(instance, type, isSupported() ? perf$1.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      var startTag = "vue-" + type + "-" + instance.uid;
      var endTag = startTag + ":end";
      perf$1.mark(endTag);
      perf$1.measure("<" + formatComponentName(instance, instance.type) + "> " + type, startTag, endTag);
      perf$1.clearMarks(startTag);
      perf$1.clearMarks(endTag);
    }
    if (!!(process.env.NODE_ENV !== "production") || false) {
      devtoolsPerfEnd(instance, type, isSupported() ? perf$1.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported$1 !== void 0) {
      return supported$1;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported$1 = true;
      perf$1 = window.performance;
    } else {
      supported$1 = false;
    }
    return supported$1;
  }
  function initFeatureFlags() {
    var needWarn = [];
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
      !!(process.env.NODE_ENV !== "production") && needWarn.push("__VUE_PROD_HYDRATION_MISMATCH_DETAILS__");
      getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
    if (!!(process.env.NODE_ENV !== "production") && needWarn.length) {
      var multi = needWarn.length > 1;
      console.warn("Feature flag" + (multi ? "s" : "") + " " + needWarn.join(", ") + " " + (multi ? "are" : "is") + " not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.\n\nFor more details, see https://link.vuejs.org/feature-flags.");
    }
  }
  var queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    var target = getGlobalThis();
    target.__VUE__ = true;
    if (!!(process.env.NODE_ENV !== "production") || false) {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    var hostInsert = options.insert,
      hostRemove = options.remove,
      hostPatchProp = options.patchProp,
      hostCreateElement = options.createElement,
      hostCreateText = options.createText,
      hostCreateComment = options.createComment,
      hostSetText = options.setText,
      hostSetElementText = options.setElementText,
      hostParentNode = options.parentNode,
      hostNextSibling = options.nextSibling,
      _options$setScopeId = options.setScopeId,
      hostSetScopeId = _options$setScopeId === void 0 ? NOOP : _options$setScopeId,
      hostInsertStaticContent = options.insertStaticContent;
    var patch = function (n1, n2, container) {
      var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var namespace = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : void 0;
      var slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !!(process.env.NODE_ENV !== "production") && isHmrUpdating ? false : !!n2.dynamicChildren;
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      var type = n2.type,
        ref2 = n2.ref,
        shapeFlag = n2.shapeFlag;
      switch (type) {
        case Text$1:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else if (!!(process.env.NODE_ENV !== "production")) {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment$1:
          processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
          } else if (!!(process.env.NODE_ENV !== "production")) {
            warn$1("Invalid VNode type:", type, "(" + _typeof(type) + ")");
          }
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    var processText = function (n1, n2, container, anchor) {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
      } else {
        var el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    var processCommentNode = function (n1, n2, container, anchor) {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
      } else {
        n2.el = n1.el;
      }
    };
    var mountStaticNode = function (n2, container, anchor, namespace) {
      var _hostInsertStaticCont = hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor);
      var _hostInsertStaticCont2 = _slicedToArray(_hostInsertStaticCont, 2);
      n2.el = _hostInsertStaticCont2[0];
      n2.anchor = _hostInsertStaticCont2[1];
    };
    var patchStaticNode = function (n1, n2, container, namespace) {
      if (n2.children !== n1.children) {
        var anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        var _hostInsertStaticCont3 = hostInsertStaticContent(n2.children, container, anchor, namespace);
        var _hostInsertStaticCont4 = _slicedToArray(_hostInsertStaticCont3, 2);
        n2.el = _hostInsertStaticCont4[0];
        n2.anchor = _hostInsertStaticCont4[1];
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    var moveStaticNode = function (_ref28, container, nextSibling) {
      var el = _ref28.el,
        anchor = _ref28.anchor;
      var next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    var removeStaticNode = function (_ref29) {
      var el = _ref29.el,
        anchor = _ref29.anchor;
      var next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    var processElement = function (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
      } else {
        patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
      }
    };
    var mountElement = function (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      var el;
      var vnodeHook;
      var props = vnode.props,
        shapeFlag = vnode.shapeFlag,
        transition = vnode.transition,
        dirs = vnode.dirs;
      el = vnode.el = hostCreateElement(vnode.type, namespace, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (var key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (!!(process.env.NODE_ENV !== "production") || false) {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      var needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(function () {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    var setScopeId = function (el, vnode, scopeId, slotScopeIds, parentComponent) {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (var _i26 = 0; _i26 < slotScopeIds.length; _i26++) {
          hostSetScopeId(el, slotScopeIds[_i26]);
        }
      }
      if (parentComponent) {
        var subTree = parentComponent.subTree;
        if (!!(process.env.NODE_ENV !== "production") && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          var parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    var mountChildren = function (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      var start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      for (var _i27 = start; _i27 < children.length; _i27++) {
        var child = children[_i27] = optimized ? cloneIfMounted(children[_i27]) : normalizeVNode(children[_i27]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
      }
    };
    var patchElement = function (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      var el = n2.el = n1.el;
      if (!!(process.env.NODE_ENV !== "production") || false) {
        el.__vnode = n2;
      }
      var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        dirs = n2.dirs;
      patchFlag |= n1.patchFlag & 16;
      var oldProps = n1.props || EMPTY_OBJ;
      var newProps = n2.props || EMPTY_OBJ;
      var vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (!!(process.env.NODE_ENV !== "production") && isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds);
        if (!!(process.env.NODE_ENV !== "production")) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            var propsToUpdate = n2.dynamicProps;
            for (var _i28 = 0; _i28 < propsToUpdate.length; _i28++) {
              var key = propsToUpdate[_i28];
              var prev = oldProps[key];
              var next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(function () {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    var patchBlockChildren = function (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) {
      for (var _i29 = 0; _i29 < newChildren.length; _i29++) {
        var oldVNode = oldChildren[_i29];
        var newVNode = newChildren[_i29];
        var container = oldVNode.el && (oldVNode.type === Fragment$1 || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, true);
      }
    };
    var patchProps = function (el, oldProps, newProps, parentComponent, namespace) {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (var key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(el, key, oldProps[key], null, namespace, parentComponent);
            }
          }
        }
        for (var _key27 in newProps) {
          if (isReservedProp(_key27)) continue;
          var next = newProps[_key27];
          var prev = oldProps[_key27];
          if (next !== prev && _key27 !== "value") {
            hostPatchProp(el, _key27, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    var processFragment = function (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        fragmentSlotScopeIds = n2.slotScopeIds;
      if (!!(process.env.NODE_ENV !== "production") && (isHmrUpdating || patchFlag & 2048)) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds);
          if (!!(process.env.NODE_ENV !== "production")) {
            traverseStaticChildren(n1, n2);
          } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(n1, n2, true);
          }
        } else {
          patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        }
      }
    };
    var processComponent = function (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(n2, container, anchor, namespace, optimized);
        } else {
          mountComponent2(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized);
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    var mountComponent2 = function (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) {
      var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (!!(process.env.NODE_ENV !== "production") && instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (!!(process.env.NODE_ENV !== "production")) {
        pushWarningContext(initialVNode);
        startMeasure(instance, "mount");
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (!!(process.env.NODE_ENV !== "production")) {
          startMeasure(instance, "init");
        }
        setupComponent(instance, false, optimized);
        if (!!(process.env.NODE_ENV !== "production")) {
          endMeasure(instance, "init");
        }
      }
      if (instance.asyncDep) {
        if (!!(process.env.NODE_ENV !== "production") && isHmrUpdating) initialVNode.el = null;
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          var placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
      }
      if (!!(process.env.NODE_ENV !== "production")) {
        popWarningContext();
        endMeasure(instance, "mount");
      }
    };
    var updateComponent = function (n1, n2, optimized) {
      var instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (!!(process.env.NODE_ENV !== "production")) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (!!(process.env.NODE_ENV !== "production")) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    var setupRenderEffect = function (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) {
      var componentUpdateFn = function () {
        if (!instance.isMounted) {
          var vnodeHook;
          var _initialVNode = initialVNode,
            el = _initialVNode.el,
            props = _initialVNode.props;
          var bm = instance.bm,
            m3 = instance.m,
            parent = instance.parent,
            root = instance.root,
            type = instance.type;
          var isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            var hydrateSubTree = function () {
              if (!!(process.env.NODE_ENV !== "production")) {
                startMeasure(instance, "render");
              }
              instance.subTree = renderComponentRoot(instance);
              if (!!(process.env.NODE_ENV !== "production")) {
                endMeasure(instance, "render");
              }
              if (!!(process.env.NODE_ENV !== "production")) {
                startMeasure(instance, "hydrate");
              }
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              if (!!(process.env.NODE_ENV !== "production")) {
                endMeasure(instance, "hydrate");
              }
            };
            if (isAsyncWrapperVNode && type.__asyncHydrate) {
              type.__asyncHydrate(el, instance, hydrateSubTree);
            } else {
              hydrateSubTree();
            }
          } else {
            if (root.ce) {
              root.ce._injectChildStyle(type);
            }
            if (!!(process.env.NODE_ENV !== "production")) {
              startMeasure(instance, "render");
            }
            var subTree = instance.subTree = renderComponentRoot(instance);
            if (!!(process.env.NODE_ENV !== "production")) {
              endMeasure(instance, "render");
            }
            if (!!(process.env.NODE_ENV !== "production")) {
              startMeasure(instance, "patch");
            }
            patch(null, subTree, container, anchor, instance, parentSuspense, namespace);
            if (!!(process.env.NODE_ENV !== "production")) {
              endMeasure(instance, "patch");
            }
            initialVNode.el = subTree.el;
          }
          if (m3) {
            queuePostRenderEffect(m3, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            var scopedInitialVNode = initialVNode;
            queuePostRenderEffect(function () {
              return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
            }, parentSuspense);
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (!!(process.env.NODE_ENV !== "production") || false) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          var next = instance.next,
            bu = instance.bu,
            u = instance.u,
            _parent = instance.parent,
            vnode = instance.vnode;
          {
            var nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(function () {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          var originNext = next;
          var _vnodeHook;
          if (!!(process.env.NODE_ENV !== "production")) {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(_vnodeHook, _parent, next, vnode);
          }
          toggleRecurse(instance, true);
          if (!!(process.env.NODE_ENV !== "production")) {
            startMeasure(instance, "render");
          }
          var nextTree = renderComponentRoot(instance);
          if (!!(process.env.NODE_ENV !== "production")) {
            endMeasure(instance, "render");
          }
          var prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (!!(process.env.NODE_ENV !== "production")) {
            startMeasure(instance, "patch");
          }
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, namespace);
          if (!!(process.env.NODE_ENV !== "production")) {
            endMeasure(instance, "patch");
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (_vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(function () {
              return invokeVNodeHook(_vnodeHook, _parent, next, vnode);
            }, parentSuspense);
          }
          if (!!(process.env.NODE_ENV !== "production") || false) {
            devtoolsComponentUpdated(instance);
          }
          if (!!(process.env.NODE_ENV !== "production")) {
            popWarningContext();
          }
        }
      };
      instance.scope.on();
      var effect = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      var update = instance.update = effect.run.bind(effect);
      var job = instance.job = effect.runIfDirty.bind(effect);
      job.i = instance;
      job.id = instance.uid;
      effect.scheduler = function () {
        return queueJob(job);
      };
      toggleRecurse(instance, true);
      if (!!(process.env.NODE_ENV !== "production")) {
        effect.onTrack = instance.rtc ? function (e) {
          return invokeArrayFns(instance.rtc, e);
        } : void 0;
        effect.onTrigger = instance.rtg ? function (e) {
          return invokeArrayFns(instance.rtg, e);
        } : void 0;
      }
      update();
    };
    var updateComponentPreRender = function (instance, nextVNode, optimized) {
      nextVNode.component = instance;
      var prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    var patchChildren = function (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds) {
      var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
      var c1 = n1 && n1.children;
      var prevShapeFlag = n1 ? n1.shapeFlag : 0;
      var c2 = n2.children;
      var patchFlag = n2.patchFlag,
        shapeFlag = n2.shapeFlag;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          }
        }
      }
    };
    var patchUnkeyedChildren = function (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      var oldLength = c1.length;
      var newLength = c2.length;
      var commonLength = Math.min(oldLength, newLength);
      var i;
      for (i = 0; i < commonLength; i++) {
        var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);
      }
    };
    var patchKeyedChildren = function (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
      var i = 0;
      var l2 = c2.length;
      var e1 = c1.length - 1;
      var e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        var n1 = c1[i];
        var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        var _n = c1[e1];
        var _n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(_n, _n2)) {
          patch(_n, _n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          var nextPos = e2 + 1;
          var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        var s1 = i;
        var s2 = i;
        var keyToNewIndexMap = /* @__PURE__ */new Map();
        for (i = s2; i <= e2; i++) {
          var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (!!(process.env.NODE_ENV !== "production") && keyToNewIndexMap.has(nextChild.key)) {
              warn$1("Duplicate keys found during update:", JSON.stringify(nextChild.key), "Make sure keys are unique.");
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        var j;
        var patched = 0;
        var toBePatched = e2 - s2 + 1;
        var moved = false;
        var maxNewIndexSoFar = 0;
        var newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          var prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          var newIndex = void 0;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            patched++;
          }
        }
        var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          var nextIndex = s2 + i;
          var _nextChild = c2[nextIndex];
          var _anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(null, _nextChild, container, _anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(_nextChild, container, _anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    var move = function (vnode, container, anchor, moveType) {
      var parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var el = vnode.el,
        type = vnode.type,
        transition = vnode.transition,
        children = vnode.children,
        shapeFlag = vnode.shapeFlag;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment$1) {
        hostInsert(el, container, anchor);
        for (var _i30 = 0; _i30 < children.length; _i30++) {
          move(children[_i30], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      var needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(function () {
            return transition.enter(el);
          }, parentSuspense);
        } else {
          var leave = transition.leave,
            delayLeave = transition.delayLeave,
            afterLeave = transition.afterLeave;
          var remove22 = function () {
            return hostInsert(el, container, anchor);
          };
          var performLeave = function () {
            leave(el, function () {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    var unmount = function (vnode, parentComponent, parentSuspense) {
      var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var type = vnode.type,
        props = vnode.props,
        ref2 = vnode.ref,
        children = vnode.children,
        dynamicChildren = vnode.dynamicChildren,
        shapeFlag = vnode.shapeFlag,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs,
        cacheIndex = vnode.cacheIndex;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      var shouldInvokeDirs = shapeFlag & 1 && dirs;
      var shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      var vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, internals, doRemove);
        } else if (dynamicChildren && !dynamicChildren.hasOnce && (type !== Fragment$1 || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type === Fragment$1 && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(function () {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    var remove2 = function (vnode) {
      var type = vnode.type,
        el = vnode.el,
        anchor = vnode.anchor,
        transition = vnode.transition;
      if (type === Fragment$1) {
        if (!!(process.env.NODE_ENV !== "production") && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach(function (child) {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      var performRemove = function () {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        var leave = transition.leave,
          delayLeave = transition.delayLeave;
        var performLeave = function () {
          return leave(el, performRemove);
        };
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    var removeFragment = function (cur, end) {
      var next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    var unmountComponent = function (instance, parentSuspense, doRemove) {
      if (!!(process.env.NODE_ENV !== "production") && instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      var bum = instance.bum,
        scope = instance.scope,
        job = instance.job,
        subTree = instance.subTree,
        um = instance.um,
        m3 = instance.m,
        a = instance.a;
      invalidateMount(m3);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(function () {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (!!(process.env.NODE_ENV !== "production") || false) {
        devtoolsComponentRemoved(instance);
      }
    };
    var unmountChildren = function (children, parentComponent, parentSuspense) {
      var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      for (var _i31 = start; _i31 < children.length; _i31++) {
        unmount(children[_i31], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    var getNextHostNode = function (vnode) {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      var el = hostNextSibling(vnode.anchor || vnode.el);
      var teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    var isFlushing = false;
    var render2 = function (vnode, container, namespace) {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, namespace);
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    var internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent2,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    var hydrate;
    var hydrateNode;
    if (createHydrationFns) {
      var _createHydrationFns = createHydrationFns(internals);
      var _createHydrationFns2 = _slicedToArray(_createHydrationFns, 2);
      hydrate = _createHydrationFns2[0];
      hydrateNode = _createHydrationFns2[1];
    }
    return {
      render: render2,
      hydrate: hydrate,
      createApp: createAppAPI(render2, hydrate)
    };
  }
  function resolveChildrenNamespace(_ref30, currentNamespace) {
    var type = _ref30.type,
      props = _ref30.props;
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse(_ref31, allowed) {
    var effect = _ref31.effect,
      job = _ref31.job;
    if (allowed) {
      effect.flags |= 32;
      job.flags |= 4;
    } else {
      effect.flags &= ~32;
      job.flags &= ~4;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2) {
    var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var ch1 = n1.children;
    var ch2 = n2.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
      for (var _i32 = 0; _i32 < ch1.length; _i32++) {
        var c1 = ch1[_i32];
        var c2 = ch2[_i32];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[_i32] = cloneIfMounted(ch2[_i32]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text$1) {
          c2.el = c1.el;
        }
        if (!!(process.env.NODE_ENV !== "production") && c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    var p2 = arr.slice();
    var result = [0];
    var i, j, u, v, c;
    var len = arr.length;
    for (i = 0; i < len; i++) {
      var arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    var subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (var _i33 = 0; _i33 < hooks.length; _i33++) hooks[_i33].flags |= 8;
    }
  }
  var ssrContextKey = Symbol.for("v-scx");
  var useSSRContext = function () {
    {
      var ctx = inject$1(ssrContextKey);
      if (!ctx) {
        !!(process.env.NODE_ENV !== "production") && warn$1("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.");
      }
      return ctx;
    }
  };
  function watchEffect(effect, options) {
    return doWatch(effect, null, options);
  }
  function watch(source, cb, options) {
    if (!!(process.env.NODE_ENV !== "production") && !isFunction$1(cb)) {
      warn$1("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.");
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ;
    var immediate = options.immediate,
      deep = options.deep,
      flush = options.flush,
      once = options.once;
    if (!!(process.env.NODE_ENV !== "production") && !cb) {
      if (immediate !== void 0) {
        warn$1("watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.");
      }
      if (deep !== void 0) {
        warn$1("watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.");
      }
      if (once !== void 0) {
        warn$1("watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.");
      }
    }
    var baseWatchOptions = extend({}, options);
    if (!!(process.env.NODE_ENV !== "production")) baseWatchOptions.onWarn = warn$1;
    var runsImmediately = cb && immediate || !cb && flush !== "post";
    var ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        var ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        var watchStopHandle = function () {};
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    var instance = currentInstance;
    baseWatchOptions.call = function (fn, type, args) {
      return callWithAsyncErrorHandling(fn, instance, type, args);
    };
    var isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = function (job) {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = function (job, isFirstRun) {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = function (job) {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    var watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    var publicThis = this.proxy;
    var getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : function () {
      return publicThis[source];
    } : source.bind(publicThis, publicThis);
    var cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    var reset = setCurrentInstance(this);
    var res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    var segments = path.split(".");
    return function () {
      var cur = ctx;
      for (var _i34 = 0; _i34 < segments.length && cur; _i34++) {
        cur = cur[segments[_i34]];
      }
      return cur;
    };
  }
  var getModelModifiers = function (props, modelName) {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[modelName + "Modifiers"] || props[camelize(modelName) + "Modifiers"] || props[hyphenate(modelName) + "Modifiers"];
  };
  function emit(instance, event) {
    if (instance.isUnmounted) return;
    var props = instance.vnode.props || EMPTY_OBJ;
    for (var _len19 = arguments.length, rawArgs = new Array(_len19 > 2 ? _len19 - 2 : 0), _key28 = 2; _key28 < _len19; _key28++) {
      rawArgs[_key28 - 2] = arguments[_key28];
    }
    if (!!(process.env.NODE_ENV !== "production")) {
      var emitsOptions = instance.emitsOptions,
        _instance$propsOption5 = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption5[0];
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
            warn$1("Component emitted event \"" + event + "\" but it is neither declared in the emits option nor as an \"" + toHandlerKey(camelize(event)) + "\" prop.");
          }
        } else {
          var validator = emitsOptions[event];
          if (isFunction$1(validator)) {
            var isValid2 = validator.apply(void 0, rawArgs);
            if (!isValid2) {
              warn$1("Invalid event arguments: event validation failed for event \"" + event + "\".");
            }
          }
        }
      }
    }
    var args = rawArgs;
    var isModelListener2 = event.startsWith("update:");
    var modifiers2 = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers2) {
      if (modifiers2.trim) {
        args = rawArgs.map(function (a) {
          return isString(a) ? a.trim() : a;
        });
      }
      if (modifiers2.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    if (!!(process.env.NODE_ENV !== "production") || false) {
      devtoolsComponentEmit(instance, event, args);
    }
    if (!!(process.env.NODE_ENV !== "production")) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(instance, instance.type) + " but the handler is registered for \"" + event + "\". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var handlerName;
    var handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(handler, instance, 6, args);
    }
    var onceHandler = props[handlerName + "Once"];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext) {
    var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var cache = appContext.emitsCache;
    var cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    var raw = comp.emits;
    var normalized = {};
    var hasExtends = false;
    if (!isFunction$1(comp)) {
      var extendEmits = function (raw2) {
        var normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$1(raw)) {
      raw.forEach(function (key) {
        return normalized[key] = null;
      });
    } else {
      extend(normalized, raw);
    }
    if (isObject$1(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn$1(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  var accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    var Component = instance.type,
      vnode = instance.vnode,
      proxy = instance.proxy,
      withProxy = instance.withProxy,
      _instance$propsOption6 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption6[0],
      slots = instance.slots,
      attrs = instance.attrs,
      emit2 = instance.emit,
      render2 = instance.render,
      renderCache = instance.renderCache,
      props = instance.props,
      data = instance.data,
      setupState = instance.setupState,
      ctx = instance.ctx,
      inheritAttrs = instance.inheritAttrs;
    var prev = setCurrentRenderingInstance(instance);
    var result;
    var fallthroughAttrs;
    if (!!(process.env.NODE_ENV !== "production")) {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        var proxyToUse = withProxy || proxy;
        var thisProxy = !!(process.env.NODE_ENV !== "production") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get: function (target, key, receiver) {
            warn$1("Property '" + String(key) + "' was accessed via 'this'. Avoid using 'this' in templates.");
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(render2.call(thisProxy, proxyToUse, renderCache, !!(process.env.NODE_ENV !== "production") ? shallowReadonly(props) : props, setupState, data, ctx));
        fallthroughAttrs = attrs;
      } else {
        var render22 = Component;
        if (!!(process.env.NODE_ENV !== "production") && attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(render22.length > 1 ? render22(!!(process.env.NODE_ENV !== "production") ? shallowReadonly(props) : props, !!(process.env.NODE_ENV !== "production") ? {
          get attrs() {
            markAttrsAccessed();
            return shallowReadonly(attrs);
          },
          slots: slots,
          emit: emit2
        } : {
          attrs: attrs,
          slots: slots,
          emit: emit2
        }) : render22(!!(process.env.NODE_ENV !== "production") ? shallowReadonly(props) : props, null));
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    var root = result;
    var setRoot = void 0;
    if (!!(process.env.NODE_ENV !== "production") && result.patchFlag > 0 && result.patchFlag & 2048) {
      var _getChildRoot = getChildRoot(result);
      var _getChildRoot2 = _slicedToArray(_getChildRoot, 2);
      root = _getChildRoot2[0];
      setRoot = _getChildRoot2[1];
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      var keys2 = Object.keys(fallthroughAttrs);
      var _root = root,
        shapeFlag = _root.shapeFlag;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        } else if (!!(process.env.NODE_ENV !== "production") && !accessedAttrs && root.type !== Comment) {
          var allAttrs = Object.keys(attrs);
          var eventAttrs = [];
          var extraAttrs = [];
          for (var _i35 = 0, l = allAttrs.length; _i35 < l; _i35++) {
            var key = allAttrs[_i35];
            if (isOn$1(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1("Extraneous non-props attributes (" + extraAttrs.join(", ") + ") were passed to component but could not be automatically inherited because component renders fragment or text root nodes.");
          }
          if (eventAttrs.length) {
            warn$1("Extraneous non-emits event listeners (" + eventAttrs.join(", ") + ") were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option.");
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!!(process.env.NODE_ENV !== "production") && !isElementRoot(root)) {
        warn$1("Runtime directive used on component with non-element root node. The directives will not function as intended.");
      }
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!!(process.env.NODE_ENV !== "production") && !isElementRoot(root)) {
        warn$1("Component inside <Transition> renders non-element root node that cannot be animated.");
      }
      setTransitionHooks(root, vnode.transition);
    }
    if (!!(process.env.NODE_ENV !== "production") && setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  var getChildRoot = function (vnode) {
    var rawChildren = vnode.children;
    var dynamicChildren = vnode.dynamicChildren;
    var childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (!!(process.env.NODE_ENV !== "production") && childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    var index = rawChildren.indexOf(childRoot);
    var dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    var setRoot = function (updatedRoot) {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [].concat(_toConsumableArray(dynamicChildren), [updatedRoot]);
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children) {
    var recurse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var singleRoot;
    for (var _i36 = 0; _i36 < children.length; _i36++) {
      var child = children[_i36];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (!!(process.env.NODE_ENV !== "production") && recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  var getFunctionalFallthrough = function (attrs) {
    var res;
    for (var key in attrs) {
      if (key === "class" || key === "style" || isOn$1(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  var filterModelListeners = function (attrs, props) {
    var res = {};
    for (var key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  var isElementRoot = function (vnode) {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    var prevProps = prevVNode.props,
      prevChildren = prevVNode.children,
      component = prevVNode.component;
    var nextProps = nextVNode.props,
      nextChildren = nextVNode.children,
      patchFlag = nextVNode.patchFlag;
    var emits = component.emitsOptions;
    if (!!(process.env.NODE_ENV !== "production") && (prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        var dynamicProps = nextVNode.dynamicProps;
        for (var _i37 = 0; _i37 < dynamicProps.length; _i37++) {
          var key = dynamicProps[_i37];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    var nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (var _i38 = 0; _i38 < nextKeys.length; _i38++) {
      var key = nextKeys[_i38];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl(_ref32, el) {
    var vnode = _ref32.vnode,
      parent = _ref32.parent;
    while (parent) {
      var root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  var isSuspense = function (type) {
    return type.__isSuspense;
  };
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$1(fn)) {
        var _suspense$effects;
        (_suspense$effects = suspense.effects).push.apply(_suspense$effects, _toConsumableArray(fn));
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  var Fragment$1 = Symbol.for("v-fgt");
  var Text$1 = Symbol.for("v-txt");
  var Comment = Symbol.for("v-cmt");
  var Static = Symbol.for("v-stc");
  var blockStack = [];
  var currentBlock = null;
  function openBlock() {
    var disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (!!(process.env.NODE_ENV !== "production") && n2.shapeFlag & 6 && n1.component) {
      var dirtyInstances = hmrDirtyComponents.get(n2.type);
      if (dirtyInstances && dirtyInstances.has(n1.component)) {
        n1.shapeFlag &= ~256;
        n2.shapeFlag &= ~512;
        return false;
      }
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  var createVNodeWithArgsTransform = function () {
    return _createVNode.apply(void 0, arguments);
  };
  var normalizeKey = function (_ref33) {
    var key = _ref33.key;
    return key != null ? key : null;
  };
  var normalizeRef = function (_ref34) {
    var ref2 = _ref34.ref,
      ref_key = _ref34.ref_key,
      ref_for = _ref34.ref_for;
    if (typeof ref2 === "number") {
      ref2 = "" + ref2;
    }
    return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction$1(ref2) ? {
      i: currentRenderingInstance,
      r: ref2,
      k: ref_key,
      f: !!ref_for
    } : ref2 : null;
  };
  function createBaseVNode(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var shapeFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : type === Fragment$1 ? 0 : 1;
    var isBlockNode2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var needFullChildrenNormalization = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
    var vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type,
      props: props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children: children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: shapeFlag,
      patchFlag: patchFlag,
      dynamicProps: dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (!!(process.env.NODE_ENV !== "production") && vnode.key !== vnode.key) {
      warn$1("VNode created with invalid key (NaN). VNode type:", vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = !!(process.env.NODE_ENV !== "production") ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var isBlockNode2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!!(process.env.NODE_ENV !== "production") && !type) {
        warn$1("Invalid vnode type when creating vnode: " + type + ".");
      }
      type = Comment;
    }
    if (isVNode(type)) {
      var cloned = cloneVNode(type, props, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      var _props2 = props,
        klass = _props2.class,
        style2 = _props2.style;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$1(style2)) {
        if (isProxy(style2) && !isArray$1(style2)) {
          style2 = extend({}, style2);
        }
        props.style = normalizeStyle(style2);
      }
    }
    var shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
    if (!!(process.env.NODE_ENV !== "production") && shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn$1("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", "\nComponent that was made reactive: ", type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode2, true);
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps) {
    var mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var cloneTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var props = vnode.props,
      ref2 = vnode.ref,
      patchFlag = vnode.patchFlag,
      children = vnode.children,
      transition = vnode.transition;
    var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    var cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$1(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: !!(process.env.NODE_ENV !== "production") && patchFlag === -1 && isArray$1(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(cloned, transition.clone(cloned));
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    var cloned = cloneVNode(vnode);
    if (isArray$1(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : " ";
    var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return createVNode(Text$1, null, text, flag);
  }
  function createCommentVNode() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$1(child)) {
      return createVNode(Fragment$1, null, child.slice());
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text$1, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    var type = 0;
    var shapeFlag = vnode.shapeFlag;
    if (children == null) {
      children = null;
    } else if (isArray$1(children)) {
      type = 16;
    } else if (_typeof(children) === "object") {
      if (shapeFlag & (1 | 64)) {
        var slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        var slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = {
        "default": children,
        _ctx: currentRenderingInstance
      };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps() {
    var ret = {};
    for (var _i39 = 0; _i39 < arguments.length; _i39++) {
      var toMerge = _i39 < 0 || arguments.length <= _i39 ? undefined : arguments[_i39];
      for (var key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn$1(key)) {
          var existing = ret[key];
          var incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode) {
    var prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);
  }
  var emptyAppContext = createAppContext();
  var uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    var type = vnode.type;
    var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    var instance = {
      uid: uid++,
      vnode: vnode,
      type: type,
      parent: parent,
      appContext: appContext,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense: suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (!!(process.env.NODE_ENV !== "production")) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = {
        _: instance
      };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  var currentInstance = null;
  var getCurrentInstance$1 = function () {
    return currentInstance || currentRenderingInstance;
  };
  var internalSetCurrentInstance;
  var setInSSRSetupState;
  {
    var g2 = getGlobalThis();
    var registerGlobalSetter = function (key, setter) {
      var setters;
      if (!(setters = g2[key])) setters = g2[key] = [];
      setters.push(setter);
      return function (v) {
        if (setters.length > 1) setters.forEach(function (set) {
          return set(v);
        });else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter("__VUE_INSTANCE_SETTERS__", function (v) {
      return currentInstance = v;
    });
    setInSSRSetupState = registerGlobalSetter("__VUE_SSR_SETTERS__", function (v) {
      return isInSSRComponentSetup = v;
    });
  }
  var setCurrentInstance = function (instance) {
    var prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return function () {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  var unsetCurrentInstance = function () {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  var isBuiltInTag = /* @__PURE__ */makeMap("slot,component");
  function validateComponentName(name, _ref35) {
    var isNativeTag = _ref35.isNativeTag;
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1("Do not use built-in or reserved HTML elements as component id: " + name);
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  function setupComponent(instance) {
    var isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var optimized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    isSSR && setInSSRSetupState(isSSR);
    var _instance$vnode = instance.vnode,
      props = _instance$vnode.props,
      children = _instance$vnode.children;
    var isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a2;
    var Component = instance.type;
    if (!!(process.env.NODE_ENV !== "production")) {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        var names = Object.keys(Component.components);
        for (var _i40 = 0; _i40 < names.length; _i40++) {
          validateComponentName(names[_i40], instance.appContext.config);
        }
      }
      if (Component.directives) {
        var _names = Object.keys(Component.directives);
        for (var _i41 = 0; _i41 < _names.length; _i41++) {
          validateDirectiveName(_names[_i41]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1("\"compilerOptions\" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.");
      }
    }
    instance.accessCache = /* @__PURE__ */Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    if (!!(process.env.NODE_ENV !== "production")) {
      exposePropsOnRenderContext(instance);
    }
    var setup = Component.setup;
    if (setup) {
      pauseTracking();
      var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      var reset = setCurrentInstance(instance);
      var setupResult = callWithErrorHandling(setup, instance, 0, [!!(process.env.NODE_ENV !== "production") ? shallowReadonly(instance.props) : instance.props, setupContext]);
      var isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then(function (resolvedResult) {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch(function (e) {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!!(process.env.NODE_ENV !== "production") && !instance.suspense) {
            var name = (_a2 = Component.name) != null ? _a2 : "Anonymous";
            warn$1("Component <" + name + ">: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.");
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$1(setupResult)) {
      if (!!(process.env.NODE_ENV !== "production") && isVNode(setupResult)) {
        warn$1("setup() should not return VNodes directly - return a render function instead.");
      }
      if (!!(process.env.NODE_ENV !== "production") || false) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (!!(process.env.NODE_ENV !== "production")) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (!!(process.env.NODE_ENV !== "production") && setupResult !== void 0) {
      warn$1("setup() should return an object. Received: " + (setupResult === null ? "null" : _typeof(setupResult)));
    }
    finishComponentSetup(instance, isSSR);
  }
  var compile;
  var isRuntimeOnly = function () {
    return !compile;
  };
  function finishComponentSetup(instance, isSSR, skipOptions) {
    var Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component.render) {
        var template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          if (!!(process.env.NODE_ENV !== "production")) {
            startMeasure(instance, "compile");
          }
          var _instance$appContext$ = instance.appContext.config,
            isCustomElement = _instance$appContext$.isCustomElement,
            compilerOptions = _instance$appContext$.compilerOptions;
          var delimiters = Component.delimiters,
            componentCompilerOptions = Component.compilerOptions;
          var finalCompilerOptions = extend(extend({
            isCustomElement: isCustomElement,
            delimiters: delimiters
          }, compilerOptions), componentCompilerOptions);
          Component.render = compile(template, finalCompilerOptions);
          if (!!(process.env.NODE_ENV !== "production")) {
            endMeasure(instance, "compile");
          }
        }
      }
      instance.render = Component.render || NOOP;
    }
    {
      var reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!!(process.env.NODE_ENV !== "production") && !Component.render && instance.render === NOOP && !isSSR) {
      if (Component.template) {
        warn$1("Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".");
      } else {
        warn$1("Component is missing template or render function: ", Component);
      }
    }
  }
  var attrsProxyHandlers = !!(process.env.NODE_ENV !== "production") ? {
    get: function (target, key) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key];
    },
    set: function () {
      warn$1("setupContext.attrs is readonly.");
      return false;
    },
    deleteProperty: function () {
      warn$1("setupContext.attrs is readonly.");
      return false;
    }
  } : {
    get: function (target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
      get: function (target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    var expose = function (exposed) {
      if (!!(process.env.NODE_ENV !== "production")) {
        if (instance.exposed) {
          warn$1("expose() should be called only once per setup().");
        }
        if (exposed != null) {
          var exposedType = _typeof(exposed);
          if (exposedType === "object") {
            if (isArray$1(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1("expose() should be passed a plain object, received " + exposedType + ".");
          }
        }
      }
      instance.exposed = exposed || {};
    };
    if (!!(process.env.NODE_ENV !== "production")) {
      var attrsProxy;
      var slotsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return slotsProxy || (slotsProxy = getSlotsProxy(instance));
        },
        get emit() {
          return function (event) {
            for (var _len20 = arguments.length, args = new Array(_len20 > 1 ? _len20 - 1 : 0), _key29 = 1; _key29 < _len20; _key29++) {
              args[_key29 - 1] = arguments[_key29];
            }
            return instance.emit.apply(instance, [event].concat(args));
          };
        },
        expose: expose
      });
    } else {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose: expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get: function (target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has: function (target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, "");
  };
  function getComponentName(Component) {
    var includeInferred = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component) {
    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var name = getComponentName(Component);
    if (!name && Component.__file) {
      var match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      var inferFromRegistry = function (registry) {
        for (var key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? "App" : "Anonymous";
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  var computed = function (getterOrOptions, debugOptions) {
    var c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    if (!!(process.env.NODE_ENV !== "production")) {
      var _i42 = getCurrentInstance$1();
      if (_i42 && _i42.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function h(type, propsOrChildren, children) {
    var l = arguments.length;
    if (l === 2) {
      if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (!!!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
      return;
    }
    var vueStyle = {
      style: "color:#3ba776"
    };
    var numberStyle = {
      style: "color:#1677ff"
    };
    var stringStyle = {
      style: "color:#f5222d"
    };
    var keywordStyle = {
      style: "color:#eb2f96"
    };
    var formatter = {
      __vue_custom_formatter: true,
      header: function (obj) {
        if (!isObject$1(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, "VueInstance"];
        } else if (isRef(obj)) {
          return ["div", {}, ["span", vueStyle, genRefFlag(obj)], "<", formatValue("_value" in obj ? obj._value : obj), ">"];
        } else if (isReactive(obj)) {
          return ["div", {}, ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"], "<", formatValue(obj), ">" + (isReadonly(obj) ? " (readonly)" : "")];
        } else if (isReadonly(obj)) {
          return ["div", {}, ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"], "<", formatValue(obj), ">"];
        }
        return null;
      },
      hasBody: function (obj) {
        return obj && obj.__isVue;
      },
      body: function (obj) {
        if (obj && obj.__isVue) {
          return ["div", {}].concat(_toConsumableArray(formatInstance(obj.$)));
        }
      }
    };
    function formatInstance(instance) {
      var blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      var computed2 = extractKeys2(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      var injected = extractKeys2(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push(["div", {}, ["span", {
        style: keywordStyle.style + ";opacity:0.66"
      }, "$ (internal): "], ["object", {
        object: instance
      }]]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return ["div", {
        style: "line-height:1.25em;margin-bottom:0.6em"
      }, ["div", {
        style: "color:#476582"
      }, type], ["div", {
        style: "padding-left:1.25em"
      }].concat(_toConsumableArray(Object.keys(target).map(function (key) {
        return ["div", {}, ["span", keywordStyle, key + ": "], formatValue(target[key], false)];
      })))];
    }
    function formatValue(v) {
      var asRaw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject$1(v)) {
        return ["object", {
          object: asRaw ? toRaw(v) : v
        }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys2(instance, type) {
      var Comp = instance.type;
      if (isFunction$1(Comp)) {
        return;
      }
      var extracted = {};
      for (var key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      var opts = Comp[type];
      if (isArray$1(opts) && opts.includes(key) || isObject$1(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some(function (m3) {
        return isKeyOfType(m3, key, type);
      })) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return "ShallowRef";
      }
      if (v.effect) {
        return "ComputedRef";
      }
      return "Ref";
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  var version$1 = "3.5.12";
  var warn$2 = !!(process.env.NODE_ENV !== "production") ? warn$1 : NOOP;
  !!(process.env.NODE_ENV !== "production") || true ? devtools$1 : void 0;
  !!(process.env.NODE_ENV !== "production") || true ? setDevtoolsHook$1 : NOOP;
  /**
  * @vue/runtime-dom v3.5.12
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  var policy = void 0;
  var tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */tt.createPolicy("vue", {
        createHTML: function (val) {
          return val;
        }
      });
    } catch (e) {
      !!(process.env.NODE_ENV !== "production") && warn$2("Error creating trusted types policy: " + e);
    }
  }
  var unsafeToTrustedHTML = policy ? function (val) {
    return policy.createHTML(val);
  } : function (val) {
    return val;
  };
  var svgNS = "http://www.w3.org/2000/svg";
  var mathmlNS = "http://www.w3.org/1998/Math/MathML";
  var doc$2 = typeof document !== "undefined" ? document : null;
  var templateContainer = doc$2 && /* @__PURE__ */doc$2.createElement("template");
  var nodeOps = {
    insert: function (child, parent, anchor) {
      parent.insertBefore(child, anchor || null);
    },
    remove: function (child) {
      var parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: function (tag, namespace, is, props) {
      var el = namespace === "svg" ? doc$2.createElementNS(svgNS, tag) : namespace === "mathml" ? doc$2.createElementNS(mathmlNS, tag) : is ? doc$2.createElement(tag, {
        is: is
      }) : doc$2.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: function (text) {
      return doc$2.createTextNode(text);
    },
    createComment: function (text) {
      return doc$2.createComment(text);
    },
    setText: function (node, text) {
      node.nodeValue = text;
    },
    setElementText: function (el, text) {
      el.textContent = text;
    },
    parentNode: function (node) {
      return node.parentNode;
    },
    nextSibling: function (node) {
      return node.nextSibling;
    },
    querySelector: function (selector) {
      return doc$2.querySelector(selector);
    },
    setScopeId: function (el, id) {
      el.setAttribute(id, "");
    },
    insertStaticContent: function (content, parent, anchor, namespace, start, end) {
      var before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(namespace === "svg" ? "<svg>" + content + "</svg>" : namespace === "mathml" ? "<math>" + content + "</math>" : content);
        var template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          var wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [before ? before.nextSibling : parent.firstChild, anchor ? anchor.previousSibling : parent.lastChild];
    }
  };
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var vtcKey = Symbol("_vtc");
  var DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      "default": true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  var TransitionPropsValidators = /* @__PURE__ */extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
  var decorate$1 = function (t) {
    t.displayName = "Transition";
    t.props = TransitionPropsValidators;
    return t;
  };
  var Transition = /* @__PURE__ */decorate$1(function (props, _ref36) {
    var slots = _ref36.slots;
    return h(BaseTransition, resolveTransitionProps(props), slots);
  });
  var callHook = function (hook) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (isArray$1(hook)) {
      hook.forEach(function (h2) {
        return h2.apply(void 0, _toConsumableArray(args));
      });
    } else if (hook) {
      hook.apply(void 0, _toConsumableArray(args));
    }
  };
  var hasExplicitCallback = function (hook) {
    return hook ? isArray$1(hook) ? hook.some(function (h2) {
      return h2.length > 1;
    }) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    var baseProps = {};
    for (var key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    var _rawProps$name = rawProps.name,
      name = _rawProps$name === void 0 ? "v" : _rawProps$name,
      type = rawProps.type,
      duration = rawProps.duration,
      _rawProps$enterFromCl = rawProps.enterFromClass,
      enterFromClass = _rawProps$enterFromCl === void 0 ? name + "-enter-from" : _rawProps$enterFromCl,
      _rawProps$enterActive = rawProps.enterActiveClass,
      enterActiveClass = _rawProps$enterActive === void 0 ? name + "-enter-active" : _rawProps$enterActive,
      _rawProps$enterToClas = rawProps.enterToClass,
      enterToClass = _rawProps$enterToClas === void 0 ? name + "-enter-to" : _rawProps$enterToClas,
      _rawProps$appearFromC = rawProps.appearFromClass,
      appearFromClass = _rawProps$appearFromC === void 0 ? enterFromClass : _rawProps$appearFromC,
      _rawProps$appearActiv = rawProps.appearActiveClass,
      appearActiveClass = _rawProps$appearActiv === void 0 ? enterActiveClass : _rawProps$appearActiv,
      _rawProps$appearToCla = rawProps.appearToClass,
      appearToClass = _rawProps$appearToCla === void 0 ? enterToClass : _rawProps$appearToCla,
      _rawProps$leaveFromCl = rawProps.leaveFromClass,
      leaveFromClass = _rawProps$leaveFromCl === void 0 ? name + "-leave-from" : _rawProps$leaveFromCl,
      _rawProps$leaveActive = rawProps.leaveActiveClass,
      leaveActiveClass = _rawProps$leaveActive === void 0 ? name + "-leave-active" : _rawProps$leaveActive,
      _rawProps$leaveToClas = rawProps.leaveToClass,
      leaveToClass = _rawProps$leaveToClas === void 0 ? name + "-leave-to" : _rawProps$leaveToClas;
    var durations = normalizeDuration(duration);
    var enterDuration = durations && durations[0];
    var leaveDuration = durations && durations[1];
    var onBeforeEnter = baseProps.onBeforeEnter,
      onEnter = baseProps.onEnter,
      onEnterCancelled = baseProps.onEnterCancelled,
      onLeave = baseProps.onLeave,
      onLeaveCancelled = baseProps.onLeaveCancelled,
      _baseProps$onBeforeAp = baseProps.onBeforeAppear,
      onBeforeAppear = _baseProps$onBeforeAp === void 0 ? onBeforeEnter : _baseProps$onBeforeAp,
      _baseProps$onAppear = baseProps.onAppear,
      onAppear = _baseProps$onAppear === void 0 ? onEnter : _baseProps$onAppear,
      _baseProps$onAppearCa = baseProps.onAppearCancelled,
      onAppearCancelled = _baseProps$onAppearCa === void 0 ? onEnterCancelled : _baseProps$onAppearCa;
    var finishEnter = function (el, isAppear, done) {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    var finishLeave = function (el, done) {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    var makeEnterHook = function (isAppear) {
      return function (el, done) {
        var hook = isAppear ? onAppear : onEnter;
        var resolve2 = function () {
          return finishEnter(el, isAppear, done);
        };
        callHook(hook, [el, resolve2]);
        nextFrame(function () {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter: function (el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear: function (el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave: function (el, done) {
        el._isLeaving = true;
        var resolve2 = function () {
          return finishLeave(el, done);
        };
        addTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
        nextFrame(function () {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled: function (el) {
        finishEnter(el, false);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled: function (el) {
        finishEnter(el, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled: function (el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$1(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      var n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    var res = toNumber(val);
    if (!!(process.env.NODE_ENV !== "production")) {
      assertNumber(res, "<transition> explicit duration");
    }
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(function (c) {
      return c && el.classList.add(c);
    });
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(function (c) {
      return c && el.classList.remove(c);
    });
    var _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(function () {
      requestAnimationFrame(cb);
    });
  }
  var endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    var id = el._endId = ++endId;
    var resolveIfNotStale = function () {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    var _getTransitionInfo = getTransitionInfo(el, expectedType),
      type = _getTransitionInfo.type,
      timeout = _getTransitionInfo.timeout,
      propCount = _getTransitionInfo.propCount;
    if (!type) {
      return resolve2();
    }
    var endEvent = type + "end";
    var ended = 0;
    var end = function () {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    var onEnd = function (e) {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var getStyleProperties = function (key) {
      return (styles[key] || "").split(", ");
    };
    var transitionDelays = getStyleProperties(TRANSITION + "Delay");
    var transitionDurations = getStyleProperties(TRANSITION + "Duration");
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = getStyleProperties(ANIMATION + "Delay");
    var animationDurations = getStyleProperties(ANIMATION + "Duration");
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type = null;
    var timeout = 0;
    var propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(TRANSITION + "Property").toString());
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max.apply(Math, _toConsumableArray(durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    })));
  }
  function toMs(s) {
    if (s === "auto") return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    var transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value].concat(_toConsumableArray(transitionClasses)) : _toConsumableArray(transitionClasses)).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  var vShowOriginalDisplay = Symbol("_vod");
  var vShowHidden = Symbol("_vsh");
  var vShow = {
    beforeMount: function (el, _ref37, _ref38) {
      var value = _ref37.value;
      var transition = _ref38.transition;
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted: function (el, _ref39, _ref40) {
      var value = _ref39.value;
      var transition = _ref40.transition;
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated: function (el, _ref41, _ref42) {
      var value = _ref41.value,
        oldValue = _ref41.oldValue;
      var transition = _ref42.transition;
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, function () {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount: function (el, _ref43) {
      var value = _ref43.value;
      setDisplay(el, value);
    }
  };
  if (!!(process.env.NODE_ENV !== "production")) {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  var CSS_VAR_TEXT = Symbol(!!(process.env.NODE_ENV !== "production") ? "CSS_VAR_TEXT" : "");
  var displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    var style2 = el.style;
    var isCssString = isString(next);
    var hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (var key in prev) {
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        } else {
          for (var _iterator5 = _createForOfIteratorHelperLoose(prev.split(";")), _step6; !(_step6 = _iterator5()).done;) {
            var prevStyle = _step6.value;
            var _key30 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[_key30] == null) {
              setStyle(style2, _key30, "");
            }
          }
        }
      }
      for (var _key31 in next) {
        if (_key31 === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style2, _key31, next[_key31]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          var cssVarText = style2[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style2.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
      if (el[vShowHidden]) {
        style2.display = "none";
      }
    }
  }
  var semicolonRE = /[^\\];\s*$/;
  var importantRE = /\s*!important$/;
  function setStyle(style2, name, val) {
    if (isArray$1(val)) {
      val.forEach(function (v) {
        return setStyle(style2, name, v);
      });
    } else {
      if (val == null) val = "";
      if (!!(process.env.NODE_ENV !== "production")) {
        if (semicolonRE.test(val)) {
          warn$2("Unexpected semicolon at the end of '" + name + "' style value: '" + val + "'");
        }
      }
      if (name.startsWith("--")) {
        style2.setProperty(name, val);
      } else {
        var prefixed = autoPrefix(style2, name);
        if (importantRE.test(val)) {
          style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style2[prefixed] = val;
        }
      }
    }
  }
  var prefixes = ["Webkit", "Moz", "ms"];
  var prefixCache = {};
  function autoPrefix(style2, rawName) {
    var cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    var name = camelize(rawName);
    if (name !== "filter" && name in style2) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (var _i43 = 0; _i43 < prefixes.length; _i43++) {
      var prefixed = prefixes[_i43] + name;
      if (prefixed in style2) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  var xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    var isBoolean2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : isSpecialBooleanAttr(key);
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean2 ? "" : isSymbol(value) ? String(value) : value);
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    var tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
      var oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      var newValue = value == null ? el.type === "checkbox" ? "on" : "" : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    var needRemove = false;
    if (value === "" || value == null) {
      var type = _typeof(el[key]);
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!!(process.env.NODE_ENV !== "production") && !needRemove) {
        warn$2("Failed setting prop \"" + key + "\" on <" + tag.toLowerCase() + ">: value " + value + " is invalid.", e);
      }
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  var veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue) {
    var instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var invokers = el[veiKey] || (el[veiKey] = {});
    var existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = !!(process.env.NODE_ENV !== "production") ? sanitizeEventValue(nextValue, rawName) : nextValue;
    } else {
      var _parseName = parseName(rawName),
        _parseName2 = _slicedToArray(_parseName, 2),
        name = _parseName2[0],
        options = _parseName2[1];
      if (nextValue) {
        var invoker = invokers[rawName] = createInvoker(!!(process.env.NODE_ENV !== "production") ? sanitizeEventValue(nextValue, rawName) : nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  var optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    var options;
    if (optionsModifierRE.test(name)) {
      options = {};
      var m3;
      while (m3 = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m3[0].length);
        options[m3[0].toLowerCase()] = true;
      }
    }
    var event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  var cachedNow = 0;
  var p = /* @__PURE__ */Promise.resolve();
  var getNow = function () {
    return cachedNow || (p.then(function () {
      return cachedNow = 0;
    }), cachedNow = Date.now());
  };
  function createInvoker(initialValue, instance) {
    var invoker = function (e) {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction$1(value) || isArray$1(value)) {
      return value;
    }
    warn$2("Wrong type passed as event handler to " + propName + " - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type " + _typeof(value) + ".");
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$1(value)) {
      var originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = function () {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(function (fn) {
        return function (e2) {
          return !e2._stopped && fn && fn(e2);
        };
      });
    } else {
      return value;
    }
  }
  var isNativeOn = function (key) {
    return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  };
  var patchProp = function (el, key, prevValue, nextValue, namespace, parentComponent) {
    var isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn$1(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction$1(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      var tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  var positionMap = /* @__PURE__ */new WeakMap();
  var newPositionMap = /* @__PURE__ */new WeakMap();
  var moveCbKey = Symbol("_moveCb");
  var enterCbKey = Symbol("_enterCb");
  var decorate = function (t) {
    delete t.props.mode;
    return t;
  };
  var TransitionGroupImpl = /* @__PURE__ */decorate({
    name: "TransitionGroup",
    props: /* @__PURE__ */extend({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup: function (props, _ref44) {
      var slots = _ref44.slots;
      var instance = getCurrentInstance$1();
      var state = useTransitionState();
      var prevChildren;
      var children;
      onUpdated(function () {
        if (!prevChildren.length) {
          return;
        }
        var moveClass = props.moveClass || (props.name || "v") + "-move";
        if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        var movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach(function (c) {
          var el = c.el;
          var style2 = el.style;
          addTransitionClass(el, moveClass);
          style2.transform = style2.webkitTransform = style2.transitionDuration = "";
          var cb = el[moveCbKey] = function (e) {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return function () {
        var rawProps = toRaw(props);
        var cssTransitionProps = resolveTransitionProps(rawProps);
        var tag = rawProps.tag || Fragment$1;
        prevChildren = [];
        if (children) {
          for (var _i44 = 0; _i44 < children.length; _i44++) {
            var child = children[_i44];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (var _i45 = 0; _i45 < children.length; _i45++) {
          var _child = children[_i45];
          if (_child.key != null) {
            setTransitionHooks(_child, resolveTransitionHooks(_child, cssTransitionProps, state, instance));
          } else if (!!(process.env.NODE_ENV !== "production") && _child.type !== Text$1) {
            warn$2("<TransitionGroup> children must be keyed.");
          }
        }
        return createVNode(tag, null, children);
      };
    }
  });
  var TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c) {
    var el = c.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
    var oldPos = positionMap.get(c);
    var newPos = newPositionMap.get(c);
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      var s = c.el.style;
      s.transform = s.webkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = "0s";
      return c;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    var clone = el.cloneNode();
    var _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach(function (cls) {
        cls.split(/\s+/).forEach(function (c) {
          return c && clone.classList.remove(c);
        });
      });
    }
    moveClass.split(/\s+/).forEach(function (c) {
      return c && clone.classList.add(c);
    });
    clone.style.display = "none";
    var container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    var _getTransitionInfo2 = getTransitionInfo(clone),
      hasTransform = _getTransitionInfo2.hasTransform;
    container.removeChild(clone);
    return hasTransform;
  }
  var getModelAssigner = function (vnode) {
    var fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray$1(fn) ? function (value) {
      return invokeArrayFns(fn, value);
    } : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    var target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  var assignKey = Symbol("_assign");
  var vModelText = {
    created: function (el, _ref45, vnode) {
      var _ref45$modifiers = _ref45.modifiers,
        lazy = _ref45$modifiers.lazy,
        trim = _ref45$modifiers.trim,
        number = _ref45$modifiers.number;
      el[assignKey] = getModelAssigner(vnode);
      var castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", function (e) {
        if (e.target.composing) return;
        var domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el, "change", function () {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    mounted: function (el, _ref46) {
      var value = _ref46.value;
      el.value = value == null ? "" : value;
    },
    beforeUpdate: function (el, _ref47, vnode) {
      var value = _ref47.value,
        oldValue = _ref47.oldValue,
        _ref47$modifiers = _ref47.modifiers,
        lazy = _ref47$modifiers.lazy,
        trim = _ref47$modifiers.trim,
        number = _ref47$modifiers.number;
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) return;
      var elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      var newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  var systemModifiers = ["ctrl", "shift", "alt", "meta"];
  var modifierGuards = {
    stop: function (e) {
      return e.stopPropagation();
    },
    prevent: function (e) {
      return e.preventDefault();
    },
    self: function (e) {
      return e.target !== e.currentTarget;
    },
    ctrl: function (e) {
      return !e.ctrlKey;
    },
    shift: function (e) {
      return !e.shiftKey;
    },
    alt: function (e) {
      return !e.altKey;
    },
    meta: function (e) {
      return !e.metaKey;
    },
    left: function (e) {
      return "button" in e && e.button !== 0;
    },
    middle: function (e) {
      return "button" in e && e.button !== 1;
    },
    right: function (e) {
      return "button" in e && e.button !== 2;
    },
    exact: function (e, modifiers2) {
      return systemModifiers.some(function (m3) {
        return e[m3 + "Key"] && !modifiers2.includes(m3);
      });
    }
  };
  var withModifiers = function (fn, modifiers2) {
    var cache = fn._withMods || (fn._withMods = {});
    var cacheKey = modifiers2.join(".");
    return cache[cacheKey] || (cache[cacheKey] = function (event) {
      for (var _i46 = 0; _i46 < modifiers2.length; _i46++) {
        var guard = modifierGuards[modifiers2[_i46]];
        if (guard && guard(event, modifiers2)) return;
      }
      for (var _len21 = arguments.length, args = new Array(_len21 > 1 ? _len21 - 1 : 0), _key32 = 1; _key32 < _len21; _key32++) {
        args[_key32 - 1] = arguments[_key32];
      }
      return fn.apply(void 0, [event].concat(args));
    });
  };
  var rendererOptions = /* @__PURE__ */extend({
    patchProp: patchProp
  }, nodeOps);
  var renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  var render = function () {
    var _ensureRenderer;
    (_ensureRenderer = ensureRenderer()).render.apply(_ensureRenderer, arguments);
  };
  var createApp = function () {
    var _ensureRenderer2;
    var app = (_ensureRenderer2 = ensureRenderer()).createApp.apply(_ensureRenderer2, arguments);
    if (!!(process.env.NODE_ENV !== "production")) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    var mount = app.mount;
    app.mount = function (containerOrSelector) {
      var container = normalizeContainer(containerOrSelector);
      if (!container) return;
      var component = app._component;
      if (!isFunction$1(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      var proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: function (tag) {
        return isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag);
      },
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      var isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get: function () {
          return isCustomElement;
        },
        set: function () {
          warn$2("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
        }
      });
      var compilerOptions = app.config.compilerOptions;
      var msg = "The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka \"full build\"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader's `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc";
      Object.defineProperty(app.config, "compilerOptions", {
        get: function () {
          warn$2(msg);
          return compilerOptions;
        },
        set: function () {
          warn$2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      var res = document.querySelector(container);
      if (!!(process.env.NODE_ENV !== "production") && !res) {
        warn$2("Failed to mount app: mount target selector \"" + container + "\" returned null.");
      }
      return res;
    }
    if (!!(process.env.NODE_ENV !== "production") && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn$2("mounting on a ShadowRoot with `{mode: \"closed\"}` may lead to unpredictable bugs");
    }
    return container;
  }
  /**
  * vue v3.5.12
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  if (!!(process.env.NODE_ENV !== "production")) {
    initDev();
  }
  var g = typeof window !== "undefined" ? window : global;
  var m = g.Package["tracker"];
  var m2$1;
  var require$1 = Package.modules.meteorInstall({
    "__vite_stub1.js": function (require3, exports, module) {
      m2$1 = require3("meteor/tracker");
      validateStub(m2$1, {
        "requestId": "meteor/tracker",
        "packageName": "meteor/tracker",
        "exportKeys": ["Tracker", "Deps"],
        "warnOnly": true
      });
    }
  }, {
    "extensions": [".js"]
  });
  require$1("/__vite_stub1.js");
  var Tracker = m.Tracker;
  m.Deps;
  var config = {
    subscribe: Meteor.subscribe
  };
  function autorun(callback) {
    var result = ref();
    var stop = watchEffect(function (onInvalidate) {
      var computation = Tracker.autorun(function () {
        var value = callback();
        if (typeof (value == null ? void 0 : value.fetch) === "function") {
          value = value.fetch();
        }
        result.value = value && _typeof(value) === "object" ? markRaw(value) : value;
      });
      onInvalidate(function () {
        computation.stop();
      });
    });
    return {
      result: computed(function () {
        return result.value;
      }),
      stop: stop
    };
  }
  function subscribe(payload) {
    if (typeof payload === "string") {
      for (var _len22 = arguments.length, args = new Array(_len22 > 1 ? _len22 - 1 : 0), _key33 = 1; _key33 < _len22; _key33++) {
        args[_key33 - 1] = arguments[_key33];
      }
      return simpleSubscribe.apply(void 0, [payload].concat(args));
    } else {
      return watchSubscribe(payload);
    }
  }
  function simpleSubscribe(name) {
    for (var _len23 = arguments.length, args = new Array(_len23 > 1 ? _len23 - 1 : 0), _key34 = 1; _key34 < _len23; _key34++) {
      args[_key34 - 1] = arguments[_key34];
    }
    var sub = config.subscribe.apply(config, [name].concat(args));
    var ready = autorun(function () {
      return sub.ready();
    });
    function stop() {
      ready.stop();
      sub.stop();
    }
    getCurrentInstance$1() && onUnmounted(function () {
      stop();
    });
    return {
      stop: stop,
      ready: ready.result,
      sub: sub
    };
  }
  function watchSubscribe(callback) {
    var ready = ref(false);
    var sub = ref();
    var stop = watch(callback, function (value, oldValue, onInvalidate) {
      if (value !== false) {
        sub.value = markRaw(config.subscribe.apply(config, _toConsumableArray(value)));
        var computation = Tracker.autorun(function () {
          ready.value = sub.value.ready();
        });
        onInvalidate(function () {
          sub.value.stop();
          computation.stop();
        });
      }
    }, {
      immediate: true,
      deep: true
    });
    return {
      stop: stop,
      ready: computed(function () {
        return ready.value;
      }),
      get sub() {
        return sub.value;
      }
    };
  }
  function makeComposable(name, fn) {
    return function () {
      var _ref48;
      var effects = [];
      var _run = function () {
        var effect = fn.apply(void 0, arguments);
        effects.push(effect);
        return effect;
      };
      onUnmounted(function () {
        effects.forEach(function (effect) {
          return effect.stop();
        });
      });
      return _ref48 = {}, _ref48[name] = _run, _ref48;
    };
  }
  var useSubscribe = makeComposable("subscribe", subscribe);
  var VueMeteor = {
    install: function (app) {
      app.mixin({
        beforeCreate: function () {
          var _this2 = this;
          if (this.$options.meteor) {
            var subReady = reactive({});
            if (this.$options.meteor.$subscribe) {
              var _loop6 = function (key) {
                var value = _this2.$options.meteor.$subscribe[key];
                var _ref49 = typeof value === "function" ? subscribe(function () {
                    var result = value.call(_this2);
                    return [key].concat(_toConsumableArray(result));
                  }) : subscribe.apply(void 0, [key].concat(_toConsumableArray(value))),
                  ready = _ref49.ready;
                subReady[key] = ready;
              };
              for (var key in this.$options.meteor.$subscribe) {
                _loop6(key);
              }
            }
            this.$options.computed = this.$options.computed || {};
            this.$options.computed.$subReady = function () {
              return subReady;
            };
            var _useSubscribe = useSubscribe(),
              $subscribe = _useSubscribe.subscribe;
            this.$options.methods = this.$options.methods || {};
            this.$options.methods.$subscribe = $subscribe;
            var _loop7 = function () {
              if (_key35.startsWith("$")) return 1; // continue
              var fn = _this2.$options.meteor[_key35];
              var _autorun = autorun(fn.bind(_this2)),
                result = _autorun.result;
              _this2.$options.computed[_key35] = function () {
                return result.value;
              };
            };
            for (var _key35 in this.$options.meteor) {
              if (_loop7()) continue;
            }
          }
        }
      });
    }
  };
  function getDevtoolsGlobalHook() {
    return getTarget$2().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget$2() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
  }
  var isProxyAvailable = typeof Proxy === "function";
  var HOOK_SETUP = "devtools-plugin:setup";
  var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  var supported;
  var perf;
  function isPerformanceSupported() {
    var _a2;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
      supported = true;
      perf = globalThis.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  var ApiProxy = /*#__PURE__*/function () {
    function ApiProxy(plugin, hook) {
      var _this3 = this;
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      var defaultSettings = {};
      if (plugin.settings) {
        for (var id in plugin.settings) {
          var item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      var localSettingsSaveId = "__vue-devtools-plugin-settings__" + plugin.id;
      var currentSettings = Object.assign({}, defaultSettings);
      try {
        var raw = localStorage.getItem(localSettingsSaveId);
        var data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e) {}
      this.fallbacks = {
        getSettings: function () {
          return currentSettings;
        },
        setSettings: function (value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e) {}
          currentSettings = value;
        },
        now: function () {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, function (pluginId, value) {
          if (pluginId === _this3.plugin.id) {
            _this3.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: function (_target, prop) {
          if (_this3.target) {
            return _this3.target.on[prop];
          } else {
            return function () {
              for (var _len24 = arguments.length, args = new Array(_len24), _key36 = 0; _key36 < _len24; _key36++) {
                args[_key36] = arguments[_key36];
              }
              _this3.onQueue.push({
                method: prop,
                args: args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: function (_target, prop) {
          if (_this3.target) {
            return _this3.target[prop];
          } else if (prop === "on") {
            return _this3.proxiedOn;
          } else if (Object.keys(_this3.fallbacks).includes(prop)) {
            return function () {
              var _this3$fallbacks;
              for (var _len25 = arguments.length, args = new Array(_len25), _key37 = 0; _key37 < _len25; _key37++) {
                args[_key37] = arguments[_key37];
              }
              _this3.targetQueue.push({
                method: prop,
                args: args,
                resolve: function () {}
              });
              return (_this3$fallbacks = _this3.fallbacks)[prop].apply(_this3$fallbacks, args);
            };
          } else {
            return function () {
              for (var _len26 = arguments.length, args = new Array(_len26), _key38 = 0; _key38 < _len26; _key38++) {
                args[_key38] = arguments[_key38];
              }
              return new Promise(function (resolve2) {
                _this3.targetQueue.push({
                  method: prop,
                  args: args,
                  resolve: resolve2
                });
              });
            };
          }
        }
      });
    }
    var _proto8 = ApiProxy.prototype;
    _proto8.setRealTarget = function setRealTarget(target) {
      var _iterator6, _step7, _this$target$on, item, _iterator7, _step8, _this$target, _item;
      return _regeneratorRuntime.async(function setRealTarget$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            this.target = target;
            for (_iterator6 = _createForOfIteratorHelperLoose(this.onQueue); !(_step7 = _iterator6()).done;) {
              item = _step7.value;
              (_this$target$on = this.target.on)[item.method].apply(_this$target$on, _toConsumableArray(item.args));
            }
            _iterator7 = _createForOfIteratorHelperLoose(this.targetQueue);
          case 3:
            if ((_step8 = _iterator7()).done) {
              _context.next = 12;
              break;
            }
            _item = _step8.value;
            _context.t0 = _item;
            _context.next = 8;
            return _regeneratorRuntime.awrap((_this$target = this.target)[_item.method].apply(_this$target, _toConsumableArray(_item.args)));
          case 8:
            _context.t1 = _context.sent;
            _context.t0.resolve.call(_context.t0, _context.t1);
          case 10:
            _context.next = 3;
            break;
          case 12:
          case "end":
            return _context.stop();
        }
      }, null, this, null, Promise);
    };
    return ApiProxy;
  }();
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    var descriptor = pluginDescriptor;
    var target = getTarget$2();
    var hook = getDevtoolsGlobalHook();
    var enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      var proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      var list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn: setupFn,
        proxy: proxy
      });
      if (proxy) {
        setupFn(proxy.proxiedTarget);
      }
    }
  }
  /*!
    * vue-router v4.4.5
    * (c) 2024 Eduardo San Martin Morote
    * @license MIT
    */
  var isBrowser = typeof document !== "undefined";
  function isRouteComponent(component) {
    return _typeof(component) === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
  }
  function isESModule(obj) {
    return obj.__esModule || obj[Symbol.toStringTag] === "Module" || obj.default && isRouteComponent(obj.default);
  }
  var assign = Object.assign;
  function applyToParams(fn, params) {
    var newParams = {};
    for (var key in params) {
      var value = params[key];
      newParams[key] = isArray(value) ? value.map(fn) : fn(value);
    }
    return newParams;
  }
  var noop$1 = function () {};
  var isArray = Array.isArray;
  function warn(msg) {
    var args = Array.from(arguments).slice(1);
    console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
  }
  var HASH_RE = /#/g;
  var AMPERSAND_RE = /&/g;
  var SLASH_RE = /\//g;
  var EQUAL_RE = /=/g;
  var IM_RE = /\?/g;
  var PLUS_RE = /\+/g;
  var ENC_BRACKET_OPEN_RE = /%5B/g;
  var ENC_BRACKET_CLOSE_RE = /%5D/g;
  var ENC_CARET_RE = /%5E/g;
  var ENC_BACKTICK_RE = /%60/g;
  var ENC_CURLY_OPEN_RE = /%7B/g;
  var ENC_PIPE_RE = /%7C/g;
  var ENC_CURLY_CLOSE_RE = /%7D/g;
  var ENC_SPACE_RE = /%20/g;
  function commonEncode(text) {
    return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
  }
  function encodeHash(text) {
    return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryValue(text) {
    return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
  }
  function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
  }
  function encodeParam(text) {
    return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
  }
  function decode(text) {
    try {
      return decodeURIComponent("" + text);
    } catch (err) {
      process.env.NODE_ENV !== "production" && warn("Error decoding \"" + text + "\". Using original value");
    }
    return "" + text;
  }
  var TRAILING_SLASH_RE = /\/$/;
  var removeTrailingSlash = function (path) {
    return path.replace(TRAILING_SLASH_RE, "");
  };
  function parseURL(parseQuery2, location2) {
    var currentLocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "/";
    var path,
      query = {},
      searchString = "",
      hash = "";
    var hashPos = location2.indexOf("#");
    var searchPos = location2.indexOf("?");
    if (hashPos < searchPos && hashPos >= 0) {
      searchPos = -1;
    }
    if (searchPos > -1) {
      path = location2.slice(0, searchPos);
      searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
      query = parseQuery2(searchString);
    }
    if (hashPos > -1) {
      path = path || location2.slice(0, hashPos);
      hash = location2.slice(hashPos, location2.length);
    }
    path = resolveRelativePath(path != null ? path : location2, currentLocation);
    return {
      fullPath: path + (searchString && "?") + searchString + hash,
      path: path,
      query: query,
      hash: decode(hash)
    };
  }
  function stringifyURL(stringifyQuery2, location2) {
    var query = location2.query ? stringifyQuery2(location2.query) : "";
    return location2.path + (query && "?") + query + (location2.hash || "");
  }
  function stripBase(pathname, base2) {
    if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase())) return pathname;
    return pathname.slice(base2.length) || "/";
  }
  function isSameRouteLocation(stringifyQuery2, a, b) {
    var aLastIndex = a.matched.length - 1;
    var bLastIndex = b.matched.length - 1;
    return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
  }
  function isSameRouteRecord(a, b) {
    return (a.aliasOf || a) === (b.aliasOf || b);
  }
  function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length) return false;
    for (var key in a) {
      if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;
    }
    return true;
  }
  function isSameRouteLocationParamsValue(a, b) {
    return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
  }
  function isEquivalentArray(a, b) {
    return isArray(b) ? a.length === b.length && a.every(function (value, i) {
      return value === b[i];
    }) : a.length === 1 && a[0] === b;
  }
  function resolveRelativePath(to, from2) {
    if (to.startsWith("/")) return to;
    if (process.env.NODE_ENV !== "production" && !from2.startsWith("/")) {
      warn("Cannot resolve a relative location without an absolute path. Trying to resolve \"" + to + "\" from \"" + from2 + "\". It should look like \"/" + from2 + "\".");
      return to;
    }
    if (!to) return from2;
    var fromSegments = from2.split("/");
    var toSegments = to.split("/");
    var lastToSegment = toSegments[toSegments.length - 1];
    if (lastToSegment === ".." || lastToSegment === ".") {
      toSegments.push("");
    }
    var position = fromSegments.length - 1;
    var toPosition;
    var segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
      segment = toSegments[toPosition];
      if (segment === ".") continue;
      if (segment === "..") {
        if (position > 1) position--;
      } else break;
    }
    return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
  }
  var START_LOCATION_NORMALIZED = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  var NavigationType;
  (function (NavigationType2) {
    NavigationType2["pop"] = "pop";
    NavigationType2["push"] = "push";
  })(NavigationType || (NavigationType = {}));
  var NavigationDirection;
  (function (NavigationDirection2) {
    NavigationDirection2["back"] = "back";
    NavigationDirection2["forward"] = "forward";
    NavigationDirection2["unknown"] = "";
  })(NavigationDirection || (NavigationDirection = {}));
  function normalizeBase(base2) {
    if (!base2) {
      if (isBrowser) {
        var baseEl = document.querySelector("base");
        base2 = baseEl && baseEl.getAttribute("href") || "/";
        base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
      } else {
        base2 = "/";
      }
    }
    if (base2[0] !== "/" && base2[0] !== "#") base2 = "/" + base2;
    return removeTrailingSlash(base2);
  }
  var BEFORE_HASH_RE = /^[^#]+#/;
  function createHref(base2, location2) {
    return base2.replace(BEFORE_HASH_RE, "#") + location2;
  }
  function getElementPosition(el, offset) {
    var docRect = document.documentElement.getBoundingClientRect();
    var elRect = el.getBoundingClientRect();
    return {
      behavior: offset.behavior,
      left: elRect.left - docRect.left - (offset.left || 0),
      top: elRect.top - docRect.top - (offset.top || 0)
    };
  }
  var computeScrollPosition = function () {
    return {
      left: window.scrollX,
      top: window.scrollY
    };
  };
  function scrollToPosition(position) {
    var scrollToOptions;
    if ("el" in position) {
      var positionEl = position.el;
      var isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
      if (process.env.NODE_ENV !== "production" && typeof position.el === "string") {
        if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
          try {
            var foundEl = document.querySelector(position.el);
            if (isIdSelector && foundEl) {
              warn("The selector \"" + position.el + "\" should be passed as \"el: document.querySelector('" + position.el + "')\" because it starts with \"#\".");
              return;
            }
          } catch (err) {
            warn("The selector \"" + position.el + "\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).");
            return;
          }
        }
      }
      var el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
      if (!el) {
        process.env.NODE_ENV !== "production" && warn("Couldn't find element using selector \"" + position.el + "\" returned by scrollBehavior.");
        return;
      }
      scrollToOptions = getElementPosition(el, position);
    } else {
      scrollToOptions = position;
    }
    if ("scrollBehavior" in document.documentElement.style) window.scrollTo(scrollToOptions);else {
      window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
    }
  }
  function getScrollKey(path, delta2) {
    var position = history.state ? history.state.position - delta2 : -1;
    return position + path;
  }
  var scrollPositions = /* @__PURE__ */new Map();
  function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
  }
  function getSavedScrollPosition(key) {
    var scroll = scrollPositions.get(key);
    scrollPositions.delete(key);
    return scroll;
  }
  var createBaseLocation = function () {
    return location.protocol + "//" + location.host;
  };
  function createCurrentLocation(base2, location2) {
    var pathname = location2.pathname,
      search = location2.search,
      hash = location2.hash;
    var hashPos = base2.indexOf("#");
    if (hashPos > -1) {
      var slicePos = hash.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
      var pathFromHash = hash.slice(slicePos);
      if (pathFromHash[0] !== "/") pathFromHash = "/" + pathFromHash;
      return stripBase(pathFromHash, "");
    }
    var path = stripBase(pathname, base2);
    return path + search + hash;
  }
  function useHistoryListeners(base2, historyState, currentLocation, replace2) {
    var listeners = [];
    var teardowns = [];
    var pauseState = null;
    var popStateHandler = function (_ref50) {
      var state = _ref50.state;
      var to = createCurrentLocation(base2, location);
      var from2 = currentLocation.value;
      var fromState = historyState.value;
      var delta2 = 0;
      if (state) {
        currentLocation.value = to;
        historyState.value = state;
        if (pauseState && pauseState === from2) {
          pauseState = null;
          return;
        }
        delta2 = fromState ? state.position - fromState.position : 0;
      } else {
        replace2(to);
      }
      listeners.forEach(function (listener) {
        listener(currentLocation.value, from2, {
          delta: delta2,
          type: NavigationType.pop,
          direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
        });
      });
    };
    function pauseListeners() {
      pauseState = currentLocation.value;
    }
    function listen(callback) {
      listeners.push(callback);
      var teardown = function () {
        var index = listeners.indexOf(callback);
        if (index > -1) listeners.splice(index, 1);
      };
      teardowns.push(teardown);
      return teardown;
    }
    function beforeUnloadListener() {
      var _window = window,
        history2 = _window.history;
      if (!history2.state) return;
      history2.replaceState(assign({}, history2.state, {
        scroll: computeScrollPosition()
      }), "");
    }
    function destroy() {
      for (var _iterator8 = _createForOfIteratorHelperLoose(teardowns), _step9; !(_step9 = _iterator8()).done;) {
        var teardown = _step9.value;
        teardown();
      }
      teardowns = [];
      window.removeEventListener("popstate", popStateHandler);
      window.removeEventListener("beforeunload", beforeUnloadListener);
    }
    window.addEventListener("popstate", popStateHandler);
    window.addEventListener("beforeunload", beforeUnloadListener, {
      passive: true
    });
    return {
      pauseListeners: pauseListeners,
      listen: listen,
      destroy: destroy
    };
  }
  function buildState(back, current, forward) {
    var replaced = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var computeScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    return {
      back: back,
      current: current,
      forward: forward,
      replaced: replaced,
      position: window.history.length,
      scroll: computeScroll ? computeScrollPosition() : null
    };
  }
  function useHistoryStateNavigation(base2) {
    var _window2 = window,
      history2 = _window2.history,
      location2 = _window2.location;
    var currentLocation = {
      value: createCurrentLocation(base2, location2)
    };
    var historyState = {
      value: history2.state
    };
    if (!historyState.value) {
      changeLocation(currentLocation.value, {
        back: null,
        current: currentLocation.value,
        forward: null,
        position: history2.length - 1,
        replaced: true,
        scroll: null
      }, true);
    }
    function changeLocation(to, state, replace3) {
      var hashIndex = base2.indexOf("#");
      var url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
      try {
        history2[replace3 ? "replaceState" : "pushState"](state, "", url);
        historyState.value = state;
      } catch (err) {
        if (process.env.NODE_ENV !== "production") {
          warn("Error with push/replace State", err);
        } else {
          console.error(err);
        }
        location2[replace3 ? "replace" : "assign"](url);
      }
    }
    function replace2(to, data) {
      var state = assign({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, {
        position: historyState.value.position
      });
      changeLocation(to, state, true);
      currentLocation.value = to;
    }
    function push(to, data) {
      var currentState = assign({}, historyState.value, history2.state, {
        forward: to,
        scroll: computeScrollPosition()
      });
      if (process.env.NODE_ENV !== "production" && !history2.state) {
        warn("history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\nhistory.replaceState(history.state, '', url)\n\nYou can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state");
      }
      changeLocation(currentState.current, currentState, true);
      var state = assign({}, buildState(currentLocation.value, to, null), {
        position: currentState.position + 1
      }, data);
      changeLocation(to, state, false);
      currentLocation.value = to;
    }
    return {
      location: currentLocation,
      state: historyState,
      push: push,
      replace: replace2
    };
  }
  function createWebHistory(base2) {
    base2 = normalizeBase(base2);
    var historyNavigation = useHistoryStateNavigation(base2);
    var historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta2) {
      var triggerListeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!triggerListeners) historyListeners.pauseListeners();
      history.go(delta2);
    }
    var routerHistory = assign({
      location: "",
      base: base2,
      go: go,
      createHref: createHref.bind(null, base2)
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, "location", {
      enumerable: true,
      get: function () {
        return historyNavigation.location.value;
      }
    });
    Object.defineProperty(routerHistory, "state", {
      enumerable: true,
      get: function () {
        return historyNavigation.state.value;
      }
    });
    return routerHistory;
  }
  function isRouteLocation(route) {
    return typeof route === "string" || route && _typeof(route) === "object";
  }
  function isRouteName(name) {
    return typeof name === "string" || _typeof(name) === "symbol";
  }
  var NavigationFailureSymbol = Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
  var NavigationFailureType;
  (function (NavigationFailureType2) {
    NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
    NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
    NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
  })(NavigationFailureType || (NavigationFailureType = {}));
  var ErrorTypeMessages = (_ErrorTypeMessages = {}, _ErrorTypeMessages[1] = function (_ref51) {
    var location2 = _ref51.location,
      currentLocation = _ref51.currentLocation;
    return "No match for\n " + JSON.stringify(location2) + (currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : "");
  }, _ErrorTypeMessages[2] = function (_ref52) {
    var from2 = _ref52.from,
      to = _ref52.to;
    return "Redirected from \"" + from2.fullPath + "\" to \"" + stringifyRoute(to) + "\" via a navigation guard.";
  }, _ErrorTypeMessages[4] = function (_ref53) {
    var from2 = _ref53.from,
      to = _ref53.to;
    return "Navigation aborted from \"" + from2.fullPath + "\" to \"" + to.fullPath + "\" via a navigation guard.";
  }, _ErrorTypeMessages[8] = function (_ref54) {
    var from2 = _ref54.from,
      to = _ref54.to;
    return "Navigation cancelled from \"" + from2.fullPath + "\" to \"" + to.fullPath + "\" with a new navigation.";
  }, _ErrorTypeMessages[16] = function (_ref55) {
    var from2 = _ref55.from,
      to = _ref55.to;
    return "Avoided redundant navigation to current location: \"" + from2.fullPath + "\".";
  }, _ErrorTypeMessages);
  function createRouterError(type, params) {
    if (process.env.NODE_ENV !== "production" || false) {
      var _assign;
      return assign(new Error(ErrorTypeMessages[type](params)), (_assign = {
        type: type
      }, _assign[NavigationFailureSymbol] = true, _assign), params);
    } else {
      var _assign2;
      return assign(new Error(), (_assign2 = {
        type: type
      }, _assign2[NavigationFailureSymbol] = true, _assign2), params);
    }
  }
  function isNavigationFailure(error, type) {
    return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
  }
  var propertiesToLog = ["params", "query", "hash"];
  function stringifyRoute(to) {
    if (typeof to === "string") return to;
    if (to.path != null) return to.path;
    var location2 = {};
    for (var _iterator9 = _createForOfIteratorHelperLoose(propertiesToLog), _step10; !(_step10 = _iterator9()).done;) {
      var key = _step10.value;
      if (key in to) location2[key] = to[key];
    }
    return JSON.stringify(location2, null, 2);
  }
  var BASE_PARAM_PATTERN = "[^/]+?";
  var BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true
  };
  var REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
  function tokensToParser(segments, extraOptions) {
    var options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    var score = [];
    var pattern = options.start ? "^" : "";
    var keys2 = [];
    for (var _iterator10 = _createForOfIteratorHelperLoose(segments), _step11; !(_step11 = _iterator10()).done;) {
      var segment = _step11.value;
      var segmentScores = segment.length ? [] : [90];
      if (options.strict && !segment.length) pattern += "/";
      for (var tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
        var token = segment[tokenIndex];
        var subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
        if (token.type === 0) {
          if (!tokenIndex) pattern += "/";
          pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
          subSegmentScore += 40;
        } else if (token.type === 1) {
          var value = token.value,
            repeatable = token.repeatable,
            optional = token.optional,
            regexp = token.regexp;
          keys2.push({
            name: value,
            repeatable: repeatable,
            optional: optional
          });
          var re2 = regexp ? regexp : BASE_PARAM_PATTERN;
          if (re2 !== BASE_PARAM_PATTERN) {
            subSegmentScore += 10;
            try {
              new RegExp("(" + re2 + ")");
            } catch (err) {
              throw new Error("Invalid custom RegExp for param \"" + value + "\" (" + re2 + "): " + err.message);
            }
          }
          var subPattern = repeatable ? "((?:" + re2 + ")(?:/(?:" + re2 + "))*)" : "(" + re2 + ")";
          if (!tokenIndex) subPattern = optional && segment.length < 2 ? "(?:/" + subPattern + ")" : "/" + subPattern;
          if (optional) subPattern += "?";
          pattern += subPattern;
          subSegmentScore += 20;
          if (optional) subSegmentScore += -8;
          if (repeatable) subSegmentScore += -20;
          if (re2 === ".*") subSegmentScore += -50;
        }
        segmentScores.push(subSegmentScore);
      }
      score.push(segmentScores);
    }
    if (options.strict && options.end) {
      var _i47 = score.length - 1;
      score[_i47][score[_i47].length - 1] += 0.7000000000000001;
    }
    if (!options.strict) pattern += "/?";
    if (options.end) pattern += "$";else if (options.strict) pattern += "(?:/|$)";
    var re = new RegExp(pattern, options.sensitive ? "" : "i");
    function parse2(path) {
      var match = path.match(re);
      var params = {};
      if (!match) return null;
      for (var _i48 = 1; _i48 < match.length; _i48++) {
        var value = match[_i48] || "";
        var key = keys2[_i48 - 1];
        params[key.name] = value && key.repeatable ? value.split("/") : value;
      }
      return params;
    }
    function stringify(params) {
      var path = "";
      var avoidDuplicatedSlash = false;
      for (var _iterator11 = _createForOfIteratorHelperLoose(segments), _step12; !(_step12 = _iterator11()).done;) {
        var segment = _step12.value;
        if (!avoidDuplicatedSlash || !path.endsWith("/")) path += "/";
        avoidDuplicatedSlash = false;
        for (var _iterator12 = _createForOfIteratorHelperLoose(segment), _step13; !(_step13 = _iterator12()).done;) {
          var token = _step13.value;
          if (token.type === 0) {
            path += token.value;
          } else if (token.type === 1) {
            var value = token.value,
              repeatable = token.repeatable,
              optional = token.optional;
            var param = value in params ? params[value] : "";
            if (isArray(param) && !repeatable) {
              throw new Error("Provided param \"" + value + "\" is an array but it is not repeatable (* or + modifiers)");
            }
            var text = isArray(param) ? param.join("/") : param;
            if (!text) {
              if (optional) {
                if (segment.length < 2) {
                  if (path.endsWith("/")) path = path.slice(0, -1);else avoidDuplicatedSlash = true;
                }
              } else throw new Error("Missing required param \"" + value + "\"");
            }
            path += text;
          }
        }
      }
      return path || "/";
    }
    return {
      re: re,
      score: score,
      keys: keys2,
      parse: parse2,
      stringify: stringify
    };
  }
  function compareScoreArray(a, b) {
    var i = 0;
    while (i < a.length && i < b.length) {
      var diff = b[i] - a[i];
      if (diff) return diff;
      i++;
    }
    if (a.length < b.length) {
      return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
    } else if (a.length > b.length) {
      return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
    }
    return 0;
  }
  function comparePathParserScore(a, b) {
    var i = 0;
    var aScore = a.score;
    var bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
      var comp = compareScoreArray(aScore[i], bScore[i]);
      if (comp) return comp;
      i++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
      if (isLastScoreNegative(aScore)) return 1;
      if (isLastScoreNegative(bScore)) return -1;
    }
    return bScore.length - aScore.length;
  }
  function isLastScoreNegative(score) {
    var last = score[score.length - 1];
    return score.length > 0 && last[last.length - 1] < 0;
  }
  var ROOT_TOKEN = {
    type: 0,
    value: ""
  };
  var VALID_PARAM_RE = /[a-zA-Z0-9_]/;
  function tokenizePath(path) {
    if (!path) return [[]];
    if (path === "/") return [[ROOT_TOKEN]];
    if (!path.startsWith("/")) {
      throw new Error(process.env.NODE_ENV !== "production" ? "Route paths should start with a \"/\": \"" + path + "\" should be \"/" + path + "\"." : "Invalid path \"" + path + "\"");
    }
    function crash(message) {
      throw new Error("ERR (" + state + ")/\"" + buffer2 + "\": " + message);
    }
    var state = 0;
    var previousState = state;
    var tokens = [];
    var segment;
    function finalizeSegment() {
      if (segment) tokens.push(segment);
      segment = [];
    }
    var i = 0;
    var char;
    var buffer2 = "";
    var customRe = "";
    function consumeBuffer() {
      if (!buffer2) return;
      if (state === 0) {
        segment.push({
          type: 0,
          value: buffer2
        });
      } else if (state === 1 || state === 2 || state === 3) {
        if (segment.length > 1 && (char === "*" || char === "+")) crash("A repeatable param (" + buffer2 + ") must be alone in its segment. eg: '/:ids+.");
        segment.push({
          type: 1,
          value: buffer2,
          regexp: customRe,
          repeatable: char === "*" || char === "+",
          optional: char === "*" || char === "?"
        });
      } else {
        crash("Invalid state to consume buffer");
      }
      buffer2 = "";
    }
    function addCharToBuffer() {
      buffer2 += char;
    }
    while (i < path.length) {
      char = path[i++];
      if (char === "\\" && state !== 2) {
        previousState = state;
        state = 4;
        continue;
      }
      switch (state) {
        case 0:
          if (char === "/") {
            if (buffer2) {
              consumeBuffer();
            }
            finalizeSegment();
          } else if (char === ":") {
            consumeBuffer();
            state = 1;
          } else {
            addCharToBuffer();
          }
          break;
        case 4:
          addCharToBuffer();
          state = previousState;
          break;
        case 1:
          if (char === "(") {
            state = 2;
          } else if (VALID_PARAM_RE.test(char)) {
            addCharToBuffer();
          } else {
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+") i--;
          }
          break;
        case 2:
          if (char === ")") {
            if (customRe[customRe.length - 1] == "\\") customRe = customRe.slice(0, -1) + char;else state = 3;
          } else {
            customRe += char;
          }
          break;
        case 3:
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+") i--;
          customRe = "";
          break;
        default:
          crash("Unknown state");
          break;
      }
    }
    if (state === 2) crash("Unfinished custom RegExp for param \"" + buffer2 + "\"");
    consumeBuffer();
    finalizeSegment();
    return tokens;
  }
  function createRouteRecordMatcher(record, parent, options) {
    var parser = tokensToParser(tokenizePath(record.path), options);
    if (process.env.NODE_ENV !== "production") {
      var existingKeys = /* @__PURE__ */new Set();
      for (var _iterator13 = _createForOfIteratorHelperLoose(parser.keys), _step14; !(_step14 = _iterator13()).done;) {
        var key = _step14.value;
        if (existingKeys.has(key.name)) warn("Found duplicated params with name \"" + key.name + "\" for path \"" + record.path + "\". Only the last one will be available on \"$route.params\".");
        existingKeys.add(key.name);
      }
    }
    var matcher = assign(parser, {
      record: record,
      parent: parent,
      children: [],
      alias: []
    });
    if (parent) {
      if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);
    }
    return matcher;
  }
  function createRouterMatcher(routes, globalOptions) {
    var matchers = [];
    var matcherMap = /* @__PURE__ */new Map();
    globalOptions = mergeOptions({
      strict: false,
      end: true,
      sensitive: false
    }, globalOptions);
    function getRecordMatcher(name) {
      return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
      var isRootAdd = !originalRecord;
      var mainNormalizedRecord = normalizeRouteRecord(record);
      if (process.env.NODE_ENV !== "production") {
        checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);
      }
      mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
      var options = mergeOptions(globalOptions, record);
      var normalizedRecords = [mainNormalizedRecord];
      if ("alias" in record) {
        var aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
        for (var _iterator14 = _createForOfIteratorHelperLoose(aliases2), _step15; !(_step15 = _iterator14()).done;) {
          var alias = _step15.value;
          normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {
            components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
            path: alias,
            aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          })));
        }
      }
      var matcher;
      var originalMatcher;
      for (var _i49 = 0, _normalizedRecords = normalizedRecords; _i49 < _normalizedRecords.length; _i49++) {
        var normalizedRecord = _normalizedRecords[_i49];
        var path = normalizedRecord.path;
        if (parent && path[0] !== "/") {
          var parentPath = parent.record.path;
          var connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
          normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
        }
        if (process.env.NODE_ENV !== "production" && normalizedRecord.path === "*") {
          throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.');
        }
        matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
        if (process.env.NODE_ENV !== "production" && parent && path[0] === "/") checkMissingParamsInAbsolutePath(matcher, parent);
        if (originalRecord) {
          originalRecord.alias.push(matcher);
          if (process.env.NODE_ENV !== "production") {
            checkSameParams(originalRecord, matcher);
          }
        } else {
          originalMatcher = originalMatcher || matcher;
          if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);
          if (isRootAdd && record.name && !isAliasRecord(matcher)) removeRoute(record.name);
        }
        if (isMatchable(matcher)) {
          insertMatcher(matcher);
        }
        if (mainNormalizedRecord.children) {
          var children = mainNormalizedRecord.children;
          for (var _i50 = 0; _i50 < children.length; _i50++) {
            addRoute(children[_i50], matcher, originalRecord && originalRecord.children[_i50]);
          }
        }
        originalRecord = originalRecord || matcher;
      }
      return originalMatcher ? function () {
        removeRoute(originalMatcher);
      } : noop$1;
    }
    function removeRoute(matcherRef) {
      if (isRouteName(matcherRef)) {
        var matcher = matcherMap.get(matcherRef);
        if (matcher) {
          matcherMap.delete(matcherRef);
          matchers.splice(matchers.indexOf(matcher), 1);
          matcher.children.forEach(removeRoute);
          matcher.alias.forEach(removeRoute);
        }
      } else {
        var index = matchers.indexOf(matcherRef);
        if (index > -1) {
          matchers.splice(index, 1);
          if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
          matcherRef.children.forEach(removeRoute);
          matcherRef.alias.forEach(removeRoute);
        }
      }
    }
    function getRoutes() {
      return matchers;
    }
    function insertMatcher(matcher) {
      var index = findInsertionIndex(matcher, matchers);
      matchers.splice(index, 0, matcher);
      if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);
    }
    function resolve2(location2, currentLocation) {
      var matcher;
      var params = {};
      var path;
      var name;
      if ("name" in location2 && location2.name) {
        matcher = matcherMap.get(location2.name);
        if (!matcher) throw createRouterError(1, {
          location: location2
        });
        if (process.env.NODE_ENV !== "production") {
          var invalidParams = Object.keys(location2.params || {}).filter(function (paramName) {
            return !matcher.keys.find(function (k) {
              return k.name === paramName;
            });
          });
          if (invalidParams.length) {
            warn("Discarded invalid param(s) \"" + invalidParams.join('", "') + "\" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.");
          }
        }
        name = matcher.record.name;
        params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter(function (k) {
          return !k.optional;
        }).concat(matcher.parent ? matcher.parent.keys.filter(function (k) {
          return k.optional;
        }) : []).map(function (k) {
          return k.name;
        })), location2.params && paramsFromLocation(location2.params, matcher.keys.map(function (k) {
          return k.name;
        })));
        path = matcher.stringify(params);
      } else if (location2.path != null) {
        path = location2.path;
        if (process.env.NODE_ENV !== "production" && !path.startsWith("/")) {
          warn("The Matcher cannot resolve relative paths but received \"" + path + "\". Unless you directly called `matcher.resolve(\"" + path + "\")`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.");
        }
        matcher = matchers.find(function (m3) {
          return m3.re.test(path);
        });
        if (matcher) {
          params = matcher.parse(path);
          name = matcher.record.name;
        }
      } else {
        matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(function (m3) {
          return m3.re.test(currentLocation.path);
        });
        if (!matcher) throw createRouterError(1, {
          location: location2,
          currentLocation: currentLocation
        });
        name = matcher.record.name;
        params = assign({}, currentLocation.params, location2.params);
        path = matcher.stringify(params);
      }
      var matched = [];
      var parentMatcher = matcher;
      while (parentMatcher) {
        matched.unshift(parentMatcher.record);
        parentMatcher = parentMatcher.parent;
      }
      return {
        name: name,
        path: path,
        params: params,
        matched: matched,
        meta: mergeMetaFields(matched)
      };
    }
    routes.forEach(function (route) {
      return addRoute(route);
    });
    function clearRoutes() {
      matchers.length = 0;
      matcherMap.clear();
    }
    return {
      addRoute: addRoute,
      resolve: resolve2,
      removeRoute: removeRoute,
      clearRoutes: clearRoutes,
      getRoutes: getRoutes,
      getRecordMatcher: getRecordMatcher
    };
  }
  function paramsFromLocation(params, keys2) {
    var newParams = {};
    for (var _iterator15 = _createForOfIteratorHelperLoose(keys2), _step16; !(_step16 = _iterator15()).done;) {
      var key = _step16.value;
      if (key in params) newParams[key] = params[key];
    }
    return newParams;
  }
  function normalizeRouteRecord(record) {
    var normalized = {
      path: record.path,
      redirect: record.redirect,
      name: record.name,
      meta: record.meta || {},
      aliasOf: record.aliasOf,
      beforeEnter: record.beforeEnter,
      props: normalizeRecordProps(record),
      children: record.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */new Set(),
      updateGuards: /* @__PURE__ */new Set(),
      enterCallbacks: {},
      components: "components" in record ? record.components || null : record.component && {
        "default": record.component
      }
    };
    Object.defineProperty(normalized, "mods", {
      value: {}
    });
    return normalized;
  }
  function normalizeRecordProps(record) {
    var propsObject = {};
    var props = record.props || false;
    if ("component" in record) {
      propsObject.default = props;
    } else {
      for (var name in record.components) propsObject[name] = _typeof(props) === "object" ? props[name] : props;
    }
    return propsObject;
  }
  function isAliasRecord(record) {
    while (record) {
      if (record.record.aliasOf) return true;
      record = record.parent;
    }
    return false;
  }
  function mergeMetaFields(matched) {
    return matched.reduce(function (meta, record) {
      return assign(meta, record.meta);
    }, {});
  }
  function mergeOptions(defaults, partialOptions) {
    var options = {};
    for (var key in defaults) {
      options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
    }
    return options;
  }
  function isSameParam(a, b) {
    return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;
  }
  function checkSameParams(a, b) {
    for (var _iterator16 = _createForOfIteratorHelperLoose(a.keys), _step17; !(_step17 = _iterator16()).done;) {
      var key = _step17.value;
      if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn("Alias \"" + b.record.path + "\" and the original record: \"" + a.record.path + "\" must have the exact same param named \"" + key.name + "\"");
    }
    for (var _iterator17 = _createForOfIteratorHelperLoose(b.keys), _step18; !(_step18 = _iterator17()).done;) {
      var _key39 = _step18.value;
      if (!_key39.optional && !a.keys.find(isSameParam.bind(null, _key39))) return warn("Alias \"" + b.record.path + "\" and the original record: \"" + a.record.path + "\" must have the exact same param named \"" + _key39.name + "\"");
    }
  }
  function checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {
    if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {
      warn("The route named \"" + String(parent.record.name) + "\" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.");
    }
  }
  function checkMissingParamsInAbsolutePath(record, parent) {
    for (var _iterator18 = _createForOfIteratorHelperLoose(parent.keys), _step19; !(_step19 = _iterator18()).done;) {
      var key = _step19.value;
      if (!record.keys.find(isSameParam.bind(null, key))) return warn("Absolute path \"" + record.record.path + "\" must have the exact same param named \"" + key.name + "\" as its parent \"" + parent.record.path + "\".");
    }
  }
  function findInsertionIndex(matcher, matchers) {
    var lower = 0;
    var upper = matchers.length;
    while (lower !== upper) {
      var mid = lower + upper >> 1;
      var sortOrder = comparePathParserScore(matcher, matchers[mid]);
      if (sortOrder < 0) {
        upper = mid;
      } else {
        lower = mid + 1;
      }
    }
    var insertionAncestor = getInsertionAncestor(matcher);
    if (insertionAncestor) {
      upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
      if (process.env.NODE_ENV !== "production" && upper < 0) {
        warn("Finding ancestor route \"" + insertionAncestor.record.path + "\" failed for \"" + matcher.record.path + "\"");
      }
    }
    return upper;
  }
  function getInsertionAncestor(matcher) {
    var ancestor = matcher;
    while (ancestor = ancestor.parent) {
      if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
        return ancestor;
      }
    }
    return;
  }
  function isMatchable(_ref56) {
    var record = _ref56.record;
    return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
  }
  function parseQuery(search) {
    var query = {};
    if (search === "" || search === "?") return query;
    var hasLeadingIM = search[0] === "?";
    var searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
    for (var _i51 = 0; _i51 < searchParams.length; ++_i51) {
      var searchParam = searchParams[_i51].replace(PLUS_RE, " ");
      var eqPos = searchParam.indexOf("=");
      var key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
      var value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
      if (key in query) {
        var currentValue = query[key];
        if (!isArray(currentValue)) {
          currentValue = query[key] = [currentValue];
        }
        currentValue.push(value);
      } else {
        query[key] = value;
      }
    }
    return query;
  }
  function stringifyQuery(query) {
    var search = "";
    var _loop8 = function (key) {
      var value = query[key];
      key = encodeQueryKey(key);
      if (value == null) {
        if (value !== void 0) {
          search += (search.length ? "&" : "") + key;
        }
        return 1; // continue
      }
      var values = isArray(value) ? value.map(function (v) {
        return v && encodeQueryValue(v);
      }) : [value && encodeQueryValue(value)];
      values.forEach(function (value2) {
        if (value2 !== void 0) {
          search += (search.length ? "&" : "") + key;
          if (value2 != null) search += "=" + value2;
        }
      });
    };
    for (var key in query) {
      if (_loop8(key)) continue;
    }
    return search;
  }
  function normalizeQuery(query) {
    var normalizedQuery = {};
    for (var key in query) {
      var value = query[key];
      if (value !== void 0) {
        normalizedQuery[key] = isArray(value) ? value.map(function (v) {
          return v == null ? null : "" + v;
        }) : value == null ? value : "" + value;
      }
    }
    return normalizedQuery;
  }
  var matchedRouteKey = Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : "");
  var viewDepthKey = Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : "");
  var routerKey = Symbol(process.env.NODE_ENV !== "production" ? "router" : "");
  var routeLocationKey = Symbol(process.env.NODE_ENV !== "production" ? "route location" : "");
  var routerViewLocationKey = Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
  function useCallbacks() {
    var handlers2 = [];
    function add(handler) {
      handlers2.push(handler);
      return function () {
        var i = handlers2.indexOf(handler);
        if (i > -1) handlers2.splice(i, 1);
      };
    }
    function reset() {
      handlers2 = [];
    }
    return {
      add: add,
      list: function () {
        return handlers2.slice();
      },
      reset: reset
    };
  }
  function guardToPromiseFn(guard, to, from2, record, name) {
    var runWithContext = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (fn) {
      return fn();
    };
    var enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return function () {
      return new Promise(function (resolve2, reject) {
        var next = function (valid) {
          if (valid === false) {
            reject(createRouterError(4, {
              from: from2,
              to: to
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to,
              to: valid
            }));
          } else {
            if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve2();
          }
        };
        var guardReturn = runWithContext(function () {
          return guard.call(record && record.instances[name], to, from2, process.env.NODE_ENV !== "production" ? canOnlyBeCalledOnce(next, to, from2) : next);
        });
        var guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3) guardCall = guardCall.then(next);
        if (process.env.NODE_ENV !== "production" && guard.length > 2) {
          var message = "The \"next\" callback was never called inside of " + (guard.name ? '"' + guard.name + '"' : "") + ":\n" + guard.toString() + "\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.";
          if (_typeof(guardReturn) === "object" && "then" in guardReturn) {
            guardCall = guardCall.then(function (resolvedValue) {
              if (!next._called) {
                warn(message);
                return Promise.reject(new Error("Invalid navigation guard"));
              }
              return resolvedValue;
            });
          } else if (guardReturn !== void 0) {
            if (!next._called) {
              warn(message);
              reject(new Error("Invalid navigation guard"));
              return;
            }
          }
        }
        guardCall.catch(function (err) {
          return reject(err);
        });
      });
    };
  }
  function canOnlyBeCalledOnce(next, to, from2) {
    var called = 0;
    return function () {
      if (called++ === 1) warn("The \"next\" callback was called more than once in one navigation guard when going from \"" + from2.fullPath + "\" to \"" + to.fullPath + "\". It should be called exactly one time in each navigation guard. This will fail in production.");
      next._called = true;
      if (called === 1) next.apply(null, arguments);
    };
  }
  function extractComponentsGuards(matched, guardType, to, from2) {
    var runWithContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (fn) {
      return fn();
    };
    var guards = [];
    var _loop9 = function (record) {
      if (process.env.NODE_ENV !== "production" && !record.components && !record.children.length) {
        warn("Record with path \"" + record.path + "\" is either missing a \"component(s)\" or \"children\" property.");
      }
      var _loop10 = function (name) {
        var rawComponent = record.components[name];
        if (process.env.NODE_ENV !== "production") {
          if (!rawComponent || _typeof(rawComponent) !== "object" && typeof rawComponent !== "function") {
            warn("Component \"" + name + "\" in record with path \"" + record.path + "\" is not a valid component. Received \"" + String(rawComponent) + "\".");
            throw new Error("Invalid route component");
          } else if ("then" in rawComponent) {
            warn("Component \"" + name + "\" in record with path \"" + record.path + "\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\" ? This will break in production if not fixed.");
            var promise = rawComponent;
            rawComponent = function () {
              return promise;
            };
          } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {
            rawComponent.__warnedDefineAsync = true;
            warn("Component \"" + name + "\" in record with path \"" + record.path + "\" is defined using \"defineAsyncComponent()\". Write \"() => import('./MyPage.vue')\" instead of \"defineAsyncComponent(() => import('./MyPage.vue'))\".");
          }
        }
        if (guardType !== "beforeRouteEnter" && !record.instances[name]) return 1; // continue
        if (isRouteComponent(rawComponent)) {
          var options = rawComponent.__vccOpts || rawComponent;
          var guard = options[guardType];
          guard && guards.push(guardToPromiseFn(guard, to, from2, record, name, runWithContext));
        } else {
          var componentPromise = rawComponent();
          if (process.env.NODE_ENV !== "production" && !("catch" in componentPromise)) {
            warn("Component \"" + name + "\" in record with path \"" + record.path + "\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.");
            componentPromise = Promise.resolve(componentPromise);
          }
          guards.push(function () {
            return componentPromise.then(function (resolved) {
              if (!resolved) throw new Error("Couldn't resolve component \"" + name + "\" at \"" + record.path + "\"");
              var resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record.mods[name] = resolved;
              record.components[name] = resolvedComponent;
              var options = resolvedComponent.__vccOpts || resolvedComponent;
              var guard = options[guardType];
              return guard && guardToPromiseFn(guard, to, from2, record, name, runWithContext)();
            });
          });
        }
      };
      for (var name in record.components) {
        if (_loop10(name)) continue;
      }
    };
    for (var _iterator19 = _createForOfIteratorHelperLoose(matched), _step20; !(_step20 = _iterator19()).done;) {
      var record = _step20.value;
      _loop9(record);
    }
    return guards;
  }
  function useLink$1(props) {
    var router2 = inject$1(routerKey);
    var currentRoute = inject$1(routeLocationKey);
    var hasPrevious = false;
    var previousTo = null;
    var route = computed(function () {
      var to = unref(props.to);
      if (process.env.NODE_ENV !== "production" && (!hasPrevious || to !== previousTo)) {
        if (!isRouteLocation(to)) {
          if (hasPrevious) {
            warn("Invalid value for prop \"to\" in useLink()\n- to:", to, "\n- previous to:", previousTo, "\n- props:", props);
          } else {
            warn("Invalid value for prop \"to\" in useLink()\n- to:", to, "\n- props:", props);
          }
        }
        previousTo = to;
        hasPrevious = true;
      }
      return router2.resolve(to);
    });
    var activeRecordIndex = computed(function () {
      var matched = route.value.matched;
      var length = matched.length;
      var routeMatched = matched[length - 1];
      var currentMatched = currentRoute.matched;
      if (!routeMatched || !currentMatched.length) return -1;
      var index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
      if (index > -1) return index;
      var parentRecordPath = getOriginalPath(matched[length - 2]);
      return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
    });
    var isActive2 = computed(function () {
      return activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params);
    });
    var isExactActive = computed(function () {
      return activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params);
    });
    function navigate() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (guardEvent(e)) {
        return router2[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop$1);
      }
      return Promise.resolve();
    }
    if ((process.env.NODE_ENV !== "production" || false) && isBrowser) {
      var instance = getCurrentInstance$1();
      if (instance) {
        var linkContextDevtools = {
          route: route.value,
          isActive: isActive2.value,
          isExactActive: isExactActive.value,
          error: null
        };
        instance.__vrl_devtools = instance.__vrl_devtools || [];
        instance.__vrl_devtools.push(linkContextDevtools);
        watchEffect(function () {
          linkContextDevtools.route = route.value;
          linkContextDevtools.isActive = isActive2.value;
          linkContextDevtools.isExactActive = isExactActive.value;
          linkContextDevtools.error = isRouteLocation(unref(props.to)) ? null : 'Invalid "to" value';
        }, {
          flush: "post"
        });
      }
    }
    return {
      route: route,
      href: computed(function () {
        return route.value.href;
      }),
      isActive: isActive2,
      isExactActive: isExactActive,
      navigate: navigate
    };
  }
  var RouterLinkImpl = /* @__PURE__ */defineComponent$1({
    name: "RouterLink",
    compatConfig: {
      MODE: 3
    },
    props: {
      to: {
        type: [String, Object],
        required: true
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        "default": "page"
      }
    },
    useLink: useLink$1,
    setup: function (props, _ref57) {
      var slots = _ref57.slots;
      var link = reactive(useLink$1(props));
      var _inject$ = inject$1(routerKey),
        options = _inject$.options;
      var elClass = computed(function () {
        var _ref58;
        return _ref58 = {}, _ref58[getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")] = link.isActive, _ref58[getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")] = link.isExactActive, _ref58;
      });
      return function () {
        var children = slots.default && slots.default(link);
        return props.custom ? children : h("a", {
          "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
          href: link.href,
          onClick: link.navigate,
          "class": elClass.value
        }, children);
      };
    }
  });
  var RouterLink = RouterLinkImpl;
  function guardEvent(e) {
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;
    if (e.button !== void 0 && e.button !== 0) return;
    if (e.currentTarget && e.currentTarget.getAttribute) {
      var target = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(target)) return;
    }
    if (e.preventDefault) e.preventDefault();
    return true;
  }
  function includesParams(outer, inner) {
    var _loop11 = function () {
        var innerValue = inner[key];
        var outerValue = outer[key];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue) return {
            v: false
          };
        } else {
          if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some(function (value, i) {
            return value !== outerValue[i];
          })) return {
            v: false
          };
        }
      },
      _ret;
    for (var key in inner) {
      _ret = _loop11();
      if (_ret) return _ret.v;
    }
    return true;
  }
  function getOriginalPath(record) {
    return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
  }
  var getLinkClass = function (propClass, globalClass, defaultClass) {
    return propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
  };
  var RouterViewImpl = /* @__PURE__ */defineComponent$1({
    name: "RouterView",
    inheritAttrs: false,
    props: {
      name: {
        type: String,
        "default": "default"
      },
      route: Object
    },
    compatConfig: {
      MODE: 3
    },
    setup: function (props, _ref59) {
      var attrs = _ref59.attrs,
        slots = _ref59.slots;
      process.env.NODE_ENV !== "production" && warnDeprecatedUsage();
      var injectedRoute = inject$1(routerViewLocationKey);
      var routeToDisplay = computed(function () {
        return props.route || injectedRoute.value;
      });
      var injectedDepth = inject$1(viewDepthKey, 0);
      var depth = computed(function () {
        var initialDepth = unref(injectedDepth);
        var matched = routeToDisplay.value.matched;
        var matchedRoute;
        while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
          initialDepth++;
        }
        return initialDepth;
      });
      var matchedRouteRef = computed(function () {
        return routeToDisplay.value.matched[depth.value];
      });
      provide(viewDepthKey, computed(function () {
        return depth.value + 1;
      }));
      provide(matchedRouteKey, matchedRouteRef);
      provide(routerViewLocationKey, routeToDisplay);
      var viewRef = ref();
      watch(function () {
        return [viewRef.value, matchedRouteRef.value, props.name];
      }, function (_ref60, _ref61) {
        var _ref62 = _slicedToArray(_ref60, 3),
          instance = _ref62[0],
          to = _ref62[1],
          name = _ref62[2];
        var _ref63 = _slicedToArray(_ref61, 3),
          oldInstance = _ref63[0],
          from2 = _ref63[1],
          oldName = _ref63[2];
        if (to) {
          to.instances[name] = instance;
          if (from2 && from2 !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from2.leaveGuards;
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from2.updateGuards;
            }
          }
        }
        if (instance && to && (!from2 || !isSameRouteRecord(to, from2) || !oldInstance)) {
          (to.enterCallbacks[name] || []).forEach(function (callback) {
            return callback(instance);
          });
        }
      }, {
        flush: "post"
      });
      return function () {
        var route = routeToDisplay.value;
        var currentName = props.name;
        var matchedRoute = matchedRouteRef.value;
        var ViewComponent = matchedRoute && matchedRoute.components[currentName];
        if (!ViewComponent) {
          return normalizeSlot(slots.default, {
            Component: ViewComponent,
            route: route
          });
        }
        var routePropsOption = matchedRoute.props[currentName];
        var routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
        var onVnodeUnmounted = function (vnode) {
          if (vnode.component.isUnmounted) {
            matchedRoute.instances[currentName] = null;
          }
        };
        var component = h(ViewComponent, assign({}, routeProps, attrs, {
          onVnodeUnmounted: onVnodeUnmounted,
          ref: viewRef
        }));
        if ((process.env.NODE_ENV !== "production" || false) && isBrowser && component.ref) {
          var info = {
            depth: depth.value,
            name: matchedRoute.name,
            path: matchedRoute.path,
            meta: matchedRoute.meta
          };
          var internalInstances = isArray(component.ref) ? component.ref.map(function (r) {
            return r.i;
          }) : [component.ref.i];
          internalInstances.forEach(function (instance) {
            instance.__vrv_devtools = info;
          });
        }
        return normalizeSlot(slots.default, {
          Component: component,
          route: route
        }) || component;
      };
    }
  });
  function normalizeSlot(slot, data) {
    if (!slot) return null;
    var slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
  }
  var RouterView = RouterViewImpl;
  function warnDeprecatedUsage() {
    var instance = getCurrentInstance$1();
    var parentName = instance.parent && instance.parent.type.name;
    var parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;
    if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition")) && _typeof(parentSubTreeType) === "object" && parentSubTreeType.name === "RouterView") {
      var comp = parentName === "KeepAlive" ? "keep-alive" : "transition";
      warn("<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot=\"{ Component }\">\n  <" + comp + ">\n    <component :is=\"Component\" />\n  </" + comp + ">\n</router-view>");
    }
  }
  function formatRouteLocation(routeLocation, tooltip) {
    var copy2 = assign({}, routeLocation, {
      matched: routeLocation.matched.map(function (matched) {
        return omit$1(matched, ["instances", "children", "aliasOf"]);
      })
    });
    return {
      _custom: {
        type: null,
        readOnly: true,
        display: routeLocation.fullPath,
        tooltip: tooltip,
        value: copy2
      }
    };
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display: display
      }
    };
  }
  var routerId = 0;
  function addDevtools(app, router2, matcher) {
    if (router2.__hasDevtools) return;
    router2.__hasDevtools = true;
    var id = routerId++;
    setupDevtoolsPlugin({
      id: "org.vuejs.router" + (id ? "." + id : ""),
      label: "Vue Router",
      packageName: "vue-router",
      homepage: "https://router.vuejs.org",
      logo: "https://router.vuejs.org/logo.png",
      componentStateTypes: ["Routing"],
      app: app
    }, function (api) {
      if (typeof api.now !== "function") {
        console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api.on.inspectComponent(function (payload, ctx) {
        if (payload.instanceData) {
          payload.instanceData.state.push({
            type: "Routing",
            key: "$route",
            editable: false,
            value: formatRouteLocation(router2.currentRoute.value, "Current Route")
          });
        }
      });
      api.on.visitComponentTree(function (_ref64) {
        var node = _ref64.treeNode,
          componentInstance = _ref64.componentInstance;
        if (componentInstance.__vrv_devtools) {
          var info = componentInstance.__vrv_devtools;
          node.tags.push({
            label: (info.name ? info.name.toString() + ": " : "") + info.path,
            textColor: 0,
            tooltip: "This component is rendered by &lt;router-view&gt;",
            backgroundColor: PINK_500
          });
        }
        if (isArray(componentInstance.__vrl_devtools)) {
          componentInstance.__devtoolsApi = api;
          componentInstance.__vrl_devtools.forEach(function (devtoolsData) {
            var label = devtoolsData.route.path;
            var backgroundColor = ORANGE_400;
            var tooltip = "";
            var textColor = 0;
            if (devtoolsData.error) {
              label = devtoolsData.error;
              backgroundColor = RED_100;
              textColor = RED_700;
            } else if (devtoolsData.isExactActive) {
              backgroundColor = LIME_500;
              tooltip = "This is exactly active";
            } else if (devtoolsData.isActive) {
              backgroundColor = BLUE_600;
              tooltip = "This link is active";
            }
            node.tags.push({
              label: label,
              textColor: textColor,
              tooltip: tooltip,
              backgroundColor: backgroundColor
            });
          });
        }
      });
      watch(router2.currentRoute, function () {
        refreshRoutesView();
        api.notifyComponentUpdate();
        api.sendInspectorTree(routerInspectorId);
        api.sendInspectorState(routerInspectorId);
      });
      var navigationsLayerId = "router:navigations:" + id;
      api.addTimelineLayer({
        id: navigationsLayerId,
        label: "Router" + (id ? " " + id : "") + " Navigations",
        color: 4237508
      });
      router2.onError(function (error, to) {
        api.addTimelineEvent({
          layerId: navigationsLayerId,
          event: {
            title: "Error during Navigation",
            subtitle: to.fullPath,
            logType: "error",
            time: api.now(),
            data: {
              error: error
            },
            groupId: to.meta.__navigationId
          }
        });
      });
      var navigationId = 0;
      router2.beforeEach(function (to, from2) {
        var data = {
          guard: formatDisplay("beforeEach"),
          from: formatRouteLocation(from2, "Current Location during this navigation"),
          to: formatRouteLocation(to, "Target location")
        };
        Object.defineProperty(to.meta, "__navigationId", {
          value: navigationId++
        });
        api.addTimelineEvent({
          layerId: navigationsLayerId,
          event: {
            time: api.now(),
            title: "Start of navigation",
            subtitle: to.fullPath,
            data: data,
            groupId: to.meta.__navigationId
          }
        });
      });
      router2.afterEach(function (to, from2, failure) {
        var data = {
          guard: formatDisplay("afterEach")
        };
        if (failure) {
          data.failure = {
            _custom: {
              type: Error,
              readOnly: true,
              display: failure ? failure.message : "",
              tooltip: "Navigation Failure",
              value: failure
            }
          };
          data.status = formatDisplay("\u274C");
        } else {
          data.status = formatDisplay("\u2705");
        }
        data.from = formatRouteLocation(from2, "Current Location during this navigation");
        data.to = formatRouteLocation(to, "Target location");
        api.addTimelineEvent({
          layerId: navigationsLayerId,
          event: {
            title: "End of navigation",
            subtitle: to.fullPath,
            time: api.now(),
            data: data,
            logType: failure ? "warning" : "default",
            groupId: to.meta.__navigationId
          }
        });
      });
      var routerInspectorId = "router-inspector:" + id;
      api.addInspector({
        id: routerInspectorId,
        label: "Routes" + (id ? " " + id : ""),
        icon: "book",
        treeFilterPlaceholder: "Search routes"
      });
      function refreshRoutesView() {
        if (!activeRoutesPayload) return;
        var payload = activeRoutesPayload;
        var routes = matcher.getRoutes().filter(function (route) {
          return !route.parent || !route.parent.record.components;
        });
        routes.forEach(resetMatchStateOnRouteRecord);
        if (payload.filter) {
          routes = routes.filter(function (route) {
            return isRouteMatching(route, payload.filter.toLowerCase());
          });
        }
        routes.forEach(function (route) {
          return markRouteRecordActive(route, router2.currentRoute.value);
        });
        payload.rootNodes = routes.map(formatRouteRecordForInspector);
      }
      var activeRoutesPayload;
      api.on.getInspectorTree(function (payload) {
        activeRoutesPayload = payload;
        if (payload.app === app && payload.inspectorId === routerInspectorId) {
          refreshRoutesView();
        }
      });
      api.on.getInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === routerInspectorId) {
          var routes = matcher.getRoutes();
          var route = routes.find(function (route2) {
            return route2.record.__vd_id === payload.nodeId;
          });
          if (route) {
            payload.state = {
              options: formatRouteRecordMatcherForStateInspector(route)
            };
          }
        }
      });
      api.sendInspectorTree(routerInspectorId);
      api.sendInspectorState(routerInspectorId);
    });
  }
  function modifierForKey(key) {
    if (key.optional) {
      return key.repeatable ? "*" : "?";
    } else {
      return key.repeatable ? "+" : "";
    }
  }
  function formatRouteRecordMatcherForStateInspector(route) {
    var record = route.record;
    var fields = [{
      editable: false,
      key: "path",
      value: record.path
    }];
    if (record.name != null) {
      fields.push({
        editable: false,
        key: "name",
        value: record.name
      });
    }
    fields.push({
      editable: false,
      key: "regexp",
      value: route.re
    });
    if (route.keys.length) {
      fields.push({
        editable: false,
        key: "keys",
        value: {
          _custom: {
            type: null,
            readOnly: true,
            display: route.keys.map(function (key) {
              return "" + key.name + modifierForKey(key);
            }).join(" "),
            tooltip: "Param keys",
            value: route.keys
          }
        }
      });
    }
    if (record.redirect != null) {
      fields.push({
        editable: false,
        key: "redirect",
        value: record.redirect
      });
    }
    if (route.alias.length) {
      fields.push({
        editable: false,
        key: "aliases",
        value: route.alias.map(function (alias) {
          return alias.record.path;
        })
      });
    }
    if (Object.keys(route.record.meta).length) {
      fields.push({
        editable: false,
        key: "meta",
        value: route.record.meta
      });
    }
    fields.push({
      key: "score",
      editable: false,
      value: {
        _custom: {
          type: null,
          readOnly: true,
          display: route.score.map(function (score) {
            return score.join(", ");
          }).join(" | "),
          tooltip: "Score used to sort routes",
          value: route.score
        }
      }
    });
    return fields;
  }
  var PINK_500 = 15485081;
  var BLUE_600 = 2450411;
  var LIME_500 = 8702998;
  var CYAN_400 = 2282478;
  var ORANGE_400 = 16486972;
  var DARK = 6710886;
  var RED_100 = 16704226;
  var RED_700 = 12131356;
  function formatRouteRecordForInspector(route) {
    var tags = [];
    var record = route.record;
    if (record.name != null) {
      tags.push({
        label: String(record.name),
        textColor: 0,
        backgroundColor: CYAN_400
      });
    }
    if (record.aliasOf) {
      tags.push({
        label: "alias",
        textColor: 0,
        backgroundColor: ORANGE_400
      });
    }
    if (route.__vd_match) {
      tags.push({
        label: "matches",
        textColor: 0,
        backgroundColor: PINK_500
      });
    }
    if (route.__vd_exactActive) {
      tags.push({
        label: "exact",
        textColor: 0,
        backgroundColor: LIME_500
      });
    }
    if (route.__vd_active) {
      tags.push({
        label: "active",
        textColor: 0,
        backgroundColor: BLUE_600
      });
    }
    if (record.redirect) {
      tags.push({
        label: typeof record.redirect === "string" ? "redirect: " + record.redirect : "redirects",
        textColor: 16777215,
        backgroundColor: DARK
      });
    }
    var id = record.__vd_id;
    if (id == null) {
      id = String(routeRecordId++);
      record.__vd_id = id;
    }
    return {
      id: id,
      label: record.path,
      tags: tags,
      children: route.children.map(formatRouteRecordForInspector)
    };
  }
  var routeRecordId = 0;
  var EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
  function markRouteRecordActive(route, currentRoute) {
    var isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
    route.__vd_exactActive = route.__vd_active = isExactActive;
    if (!isExactActive) {
      route.__vd_active = currentRoute.matched.some(function (match) {
        return isSameRouteRecord(match, route.record);
      });
    }
    route.children.forEach(function (childRoute) {
      return markRouteRecordActive(childRoute, currentRoute);
    });
  }
  function resetMatchStateOnRouteRecord(route) {
    route.__vd_match = false;
    route.children.forEach(resetMatchStateOnRouteRecord);
  }
  function isRouteMatching(route, filter) {
    var found2 = String(route.re).match(EXTRACT_REGEXP_RE);
    route.__vd_match = false;
    if (!found2 || found2.length < 3) {
      return false;
    }
    var nonEndingRE = new RegExp(found2[1].replace(/\$$/, ""), found2[2]);
    if (nonEndingRE.test(filter)) {
      route.children.forEach(function (child) {
        return isRouteMatching(child, filter);
      });
      if (route.record.path !== "/" || filter === "/") {
        route.__vd_match = route.re.test(filter);
        return true;
      }
      return false;
    }
    var path = route.record.path.toLowerCase();
    var decodedPath = decode(path);
    if (!filter.startsWith("/") && (decodedPath.includes(filter) || path.includes(filter))) return true;
    if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;
    if (route.record.name && String(route.record.name).includes(filter)) return true;
    return route.children.some(function (child) {
      return isRouteMatching(child, filter);
    });
  }
  function omit$1(obj, keys2) {
    var ret = {};
    for (var key in obj) {
      if (!keys2.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  function createRouter(options) {
    var matcher = createRouterMatcher(options.routes, options);
    var parseQuery$1 = options.parseQuery || parseQuery;
    var stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    var routerHistory = options.history;
    if (process.env.NODE_ENV !== "production" && !routerHistory) throw new Error('Provide the "history" option when calling "createRouter()": https://router.vuejs.org/api/interfaces/RouterOptions.html#history');
    var beforeGuards = useCallbacks();
    var beforeResolveGuards = useCallbacks();
    var afterGuards = useCallbacks();
    var currentRoute = shallowRef(START_LOCATION_NORMALIZED);
    var pendingLocation = START_LOCATION_NORMALIZED;
    if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    var normalizeParams = applyToParams.bind(null, function (paramValue) {
      return "" + paramValue;
    });
    var encodeParams = applyToParams.bind(null, encodeParam);
    var decodeParams = applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
      var parent;
      var record;
      if (isRouteName(parentOrRoute)) {
        parent = matcher.getRecordMatcher(parentOrRoute);
        if (process.env.NODE_ENV !== "production" && !parent) {
          warn("Parent route \"" + String(parentOrRoute) + "\" not found when adding child route", route);
        }
        record = route;
      } else {
        record = parentOrRoute;
      }
      return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
      var recordMatcher = matcher.getRecordMatcher(name);
      if (recordMatcher) {
        matcher.removeRoute(recordMatcher);
      } else if (process.env.NODE_ENV !== "production") {
        warn("Cannot remove non-existent route \"" + String(name) + "\"");
      }
    }
    function getRoutes() {
      return matcher.getRoutes().map(function (routeMatcher) {
        return routeMatcher.record;
      });
    }
    function hasRoute(name) {
      return !!matcher.getRecordMatcher(name);
    }
    function resolve2(rawLocation, currentLocation) {
      currentLocation = assign({}, currentLocation || currentRoute.value);
      if (typeof rawLocation === "string") {
        var locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
        var matchedRoute2 = matcher.resolve({
          path: locationNormalized.path
        }, currentLocation);
        var href2 = routerHistory.createHref(locationNormalized.fullPath);
        if (process.env.NODE_ENV !== "production") {
          if (href2.startsWith("//")) warn("Location \"" + rawLocation + "\" resolved to \"" + href2 + "\". A resolved location cannot start with multiple slashes.");else if (!matchedRoute2.matched.length) {
            warn("No match found for location with path \"" + rawLocation + "\"");
          }
        }
        return assign(locationNormalized, matchedRoute2, {
          params: decodeParams(matchedRoute2.params),
          hash: decode(locationNormalized.hash),
          redirectedFrom: void 0,
          href: href2
        });
      }
      if (process.env.NODE_ENV !== "production" && !isRouteLocation(rawLocation)) {
        warn("router.resolve() was passed an invalid location. This will fail in production.\n- Location:", rawLocation);
        return resolve2({});
      }
      var matcherLocation;
      if (rawLocation.path != null) {
        if (process.env.NODE_ENV !== "production" && "params" in rawLocation && !("name" in rawLocation) && Object.keys(rawLocation.params).length) {
          warn("Path \"" + rawLocation.path + "\" was passed with params but they will be ignored. Use a named route alongside params instead.");
        }
        matcherLocation = assign({}, rawLocation, {
          path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
        });
      } else {
        var targetParams = assign({}, rawLocation.params);
        for (var key in targetParams) {
          if (targetParams[key] == null) {
            delete targetParams[key];
          }
        }
        matcherLocation = assign({}, rawLocation, {
          params: encodeParams(targetParams)
        });
        currentLocation.params = encodeParams(currentLocation.params);
      }
      var matchedRoute = matcher.resolve(matcherLocation, currentLocation);
      var hash = rawLocation.hash || "";
      if (process.env.NODE_ENV !== "production" && hash && !hash.startsWith("#")) {
        warn("A `hash` should always start with the character \"#\". Replace \"" + hash + "\" with \"#" + hash + "\".");
      }
      matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
      var fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
        hash: encodeHash(hash),
        path: matchedRoute.path
      }));
      var href = routerHistory.createHref(fullPath);
      if (process.env.NODE_ENV !== "production") {
        if (href.startsWith("//")) {
          warn("Location \"" + rawLocation + "\" resolved to \"" + href + "\". A resolved location cannot start with multiple slashes.");
        } else if (!matchedRoute.matched.length) {
          warn("No match found for location with path \"" + (rawLocation.path != null ? rawLocation.path : rawLocation) + "\"");
        }
      }
      return assign({
        fullPath: fullPath,
        hash: hash,
        query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      }, matchedRoute, {
        redirectedFrom: void 0,
        href: href
      });
    }
    function locationAsObject(to) {
      return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
    }
    function checkCanceledNavigation(to, from2) {
      if (pendingLocation !== to) {
        return createRouterError(8, {
          from: from2,
          to: to
        });
      }
    }
    function push(to) {
      return pushWithRedirect(to);
    }
    function replace2(to) {
      return push(assign(locationAsObject(to), {
        replace: true
      }));
    }
    function handleRedirectRecord(to) {
      var lastMatched = to.matched[to.matched.length - 1];
      if (lastMatched && lastMatched.redirect) {
        var redirect = lastMatched.redirect;
        var newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
        if (typeof newTargetLocation === "string") {
          newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : {
            path: newTargetLocation
          };
          newTargetLocation.params = {};
        }
        if (process.env.NODE_ENV !== "production" && newTargetLocation.path == null && !("name" in newTargetLocation)) {
          warn("Invalid redirect found:\n" + JSON.stringify(newTargetLocation, null, 2) + "\n when navigating to \"" + to.fullPath + "\". A redirect must contain a name or path. This will break in production.");
          throw new Error("Invalid redirect");
        }
        return assign({
          query: to.query,
          hash: to.hash,
          params: newTargetLocation.path != null ? {} : to.params
        }, newTargetLocation);
      }
    }
    function pushWithRedirect(to, redirectedFrom) {
      var targetLocation = pendingLocation = resolve2(to);
      var from2 = currentRoute.value;
      var data = to.state;
      var force = to.force;
      var replace3 = to.replace === true;
      var shouldRedirect = handleRedirectRecord(targetLocation);
      if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
        state: _typeof(shouldRedirect) === "object" ? assign({}, data, shouldRedirect.state) : data,
        force: force,
        replace: replace3
      }), redirectedFrom || targetLocation);
      var toLocation = targetLocation;
      toLocation.redirectedFrom = redirectedFrom;
      var failure;
      if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
        failure = createRouterError(16, {
          to: toLocation,
          from: from2
        });
        handleScroll(from2, from2, true, false);
      }
      return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch(function (error) {
        return isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from2);
      }).then(function (failure2) {
        if (failure2) {
          if (isNavigationFailure(failure2, 2)) {
            if (process.env.NODE_ENV !== "production" && isSameRouteLocation(stringifyQuery$1, resolve2(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 30) {
              warn("Detected a possibly infinite redirection in a navigation guard when going from \"" + from2.fullPath + "\" to \"" + toLocation.fullPath + "\". Aborting to avoid a Stack Overflow.\n Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.");
              return Promise.reject(new Error("Infinite redirect in navigation guard"));
            }
            return pushWithRedirect(assign({
              replace: replace3
            }, locationAsObject(failure2.to), {
              state: _typeof(failure2.to) === "object" ? assign({}, data, failure2.to.state) : data,
              force: force
            }), redirectedFrom || toLocation);
          }
        } else {
          failure2 = finalizeNavigation(toLocation, from2, true, replace3, data);
        }
        triggerAfterEach(toLocation, from2, failure2);
        return failure2;
      });
    }
    function checkCanceledNavigationAndReject(to, from2) {
      var error = checkCanceledNavigation(to, from2);
      return error ? Promise.reject(error) : Promise.resolve();
    }
    function runWithContext(fn) {
      var app = installedApps.values().next().value;
      return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
    }
    function navigate(to, from2) {
      var guards;
      var _extractChangingRecor = extractChangingRecords(to, from2),
        _extractChangingRecor2 = _slicedToArray(_extractChangingRecor, 3),
        leavingRecords = _extractChangingRecor2[0],
        updatingRecords = _extractChangingRecor2[1],
        enteringRecords = _extractChangingRecor2[2];
      guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from2);
      for (var _iterator20 = _createForOfIteratorHelperLoose(leavingRecords), _step21; !(_step21 = _iterator20()).done;) {
        var record = _step21.value;
        record.leaveGuards.forEach(function (guard) {
          guards.push(guardToPromiseFn(guard, to, from2));
        });
      }
      var canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from2);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards).then(function () {
        guards = [];
        for (var _iterator21 = _createForOfIteratorHelperLoose(beforeGuards.list()), _step22; !(_step22 = _iterator21()).done;) {
          var guard = _step22.value;
          guards.push(guardToPromiseFn(guard, to, from2));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(function () {
        guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from2);
        for (var _iterator22 = _createForOfIteratorHelperLoose(updatingRecords), _step23; !(_step23 = _iterator22()).done;) {
          var record = _step23.value;
          record.updateGuards.forEach(function (guard) {
            guards.push(guardToPromiseFn(guard, to, from2));
          });
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(function () {
        guards = [];
        for (var _iterator23 = _createForOfIteratorHelperLoose(enteringRecords), _step24; !(_step24 = _iterator23()).done;) {
          var record = _step24.value;
          if (record.beforeEnter) {
            if (isArray(record.beforeEnter)) {
              for (var _iterator24 = _createForOfIteratorHelperLoose(record.beforeEnter), _step25; !(_step25 = _iterator24()).done;) {
                var beforeEnter = _step25.value;
                guards.push(guardToPromiseFn(beforeEnter, to, from2));
              }
            } else {
              guards.push(guardToPromiseFn(record.beforeEnter, to, from2));
            }
          }
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(function () {
        to.matched.forEach(function (record) {
          return record.enterCallbacks = {};
        });
        guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from2, runWithContext);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(function () {
        guards = [];
        for (var _iterator25 = _createForOfIteratorHelperLoose(beforeResolveGuards.list()), _step26; !(_step26 = _iterator25()).done;) {
          var guard = _step26.value;
          guards.push(guardToPromiseFn(guard, to, from2));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).catch(function (err) {
        return isNavigationFailure(err, 8) ? err : Promise.reject(err);
      });
    }
    function triggerAfterEach(to, from2, failure) {
      afterGuards.list().forEach(function (guard) {
        return runWithContext(function () {
          return guard(to, from2, failure);
        });
      });
    }
    function finalizeNavigation(toLocation, from2, isPush, replace3, data) {
      var error = checkCanceledNavigation(toLocation, from2);
      if (error) return error;
      var isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
      var state = !isBrowser ? {} : history.state;
      if (isPush) {
        if (replace3 || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));else routerHistory.push(toLocation.fullPath, data);
      }
      currentRoute.value = toLocation;
      handleScroll(toLocation, from2, isPush, isFirstNavigation);
      markAsReady();
    }
    var removeHistoryListener;
    function setupListeners() {
      if (removeHistoryListener) return;
      removeHistoryListener = routerHistory.listen(function (to, _from, info) {
        if (!router2.listening) return;
        var toLocation = resolve2(to);
        var shouldRedirect = handleRedirectRecord(toLocation);
        if (shouldRedirect) {
          pushWithRedirect(assign(shouldRedirect, {
            replace: true
          }), toLocation).catch(noop$1);
          return;
        }
        pendingLocation = toLocation;
        var from2 = currentRoute.value;
        if (isBrowser) {
          saveScrollPosition(getScrollKey(from2.fullPath, info.delta), computeScrollPosition());
        }
        navigate(toLocation, from2).catch(function (error) {
          if (isNavigationFailure(error, 4 | 8)) {
            return error;
          }
          if (isNavigationFailure(error, 2)) {
            pushWithRedirect(error.to, toLocation).then(function (failure) {
              if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                routerHistory.go(-1, false);
              }
            }).catch(noop$1);
            return Promise.reject();
          }
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          }
          return triggerError(error, toLocation, from2);
        }).then(function (failure) {
          failure = failure || finalizeNavigation(toLocation, from2, false);
          if (failure) {
            if (info.delta && !isNavigationFailure(failure, 8)) {
              routerHistory.go(-info.delta, false);
            } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
              routerHistory.go(-1, false);
            }
          }
          triggerAfterEach(toLocation, from2, failure);
        }).catch(noop$1);
      });
    }
    var readyHandlers = useCallbacks();
    var errorListeners = useCallbacks();
    var ready;
    function triggerError(error, to, from2) {
      markAsReady(error);
      var list = errorListeners.list();
      if (list.length) {
        list.forEach(function (handler) {
          return handler(error, to, from2);
        });
      } else {
        if (process.env.NODE_ENV !== "production") {
          warn("uncaught error during route navigation:");
        }
        console.error(error);
      }
      return Promise.reject(error);
    }
    function isReady() {
      if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();
      return new Promise(function (resolve3, reject) {
        readyHandlers.add([resolve3, reject]);
      });
    }
    function markAsReady(err) {
      if (!ready) {
        ready = !err;
        setupListeners();
        readyHandlers.list().forEach(function (_ref65) {
          var _ref66 = _slicedToArray(_ref65, 2),
            resolve3 = _ref66[0],
            reject = _ref66[1];
          return err ? reject(err) : resolve3();
        });
        readyHandlers.reset();
      }
      return err;
    }
    function handleScroll(to, from2, isPush, isFirstNavigation) {
      var scrollBehavior = options.scrollBehavior;
      if (!isBrowser || !scrollBehavior) return Promise.resolve();
      var scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
      return nextTick().then(function () {
        return scrollBehavior(to, from2, scrollPosition);
      }).then(function (position) {
        return position && scrollToPosition(position);
      }).catch(function (err) {
        return triggerError(err, to, from2);
      });
    }
    var go = function (delta2) {
      return routerHistory.go(delta2);
    };
    var started;
    var installedApps = /* @__PURE__ */new Set();
    var router2 = {
      currentRoute: currentRoute,
      listening: true,
      addRoute: addRoute,
      removeRoute: removeRoute,
      clearRoutes: matcher.clearRoutes,
      hasRoute: hasRoute,
      getRoutes: getRoutes,
      resolve: resolve2,
      options: options,
      push: push,
      replace: replace2,
      go: go,
      back: function () {
        return go(-1);
      },
      forward: function () {
        return go(1);
      },
      beforeEach: beforeGuards.add,
      beforeResolve: beforeResolveGuards.add,
      afterEach: afterGuards.add,
      onError: errorListeners.add,
      isReady: isReady,
      install: function (app) {
        var router3 = this;
        app.component("RouterLink", RouterLink);
        app.component("RouterView", RouterView);
        app.config.globalProperties.$router = router3;
        Object.defineProperty(app.config.globalProperties, "$route", {
          enumerable: true,
          get: function () {
            return unref(currentRoute);
          }
        });
        if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
          started = true;
          push(routerHistory.location).catch(function (err) {
            if (process.env.NODE_ENV !== "production") warn("Unexpected error when starting the router:", err);
          });
        }
        var reactiveRoute = {};
        var _loop12 = function (key) {
          Object.defineProperty(reactiveRoute, key, {
            get: function () {
              return currentRoute.value[key];
            },
            enumerable: true
          });
        };
        for (var key in START_LOCATION_NORMALIZED) {
          _loop12(key);
        }
        app.provide(routerKey, router3);
        app.provide(routeLocationKey, shallowReactive(reactiveRoute));
        app.provide(routerViewLocationKey, currentRoute);
        var unmountApp = app.unmount;
        installedApps.add(app);
        app.unmount = function () {
          installedApps.delete(app);
          if (installedApps.size < 1) {
            pendingLocation = START_LOCATION_NORMALIZED;
            removeHistoryListener && removeHistoryListener();
            removeHistoryListener = null;
            currentRoute.value = START_LOCATION_NORMALIZED;
            started = false;
            ready = false;
          }
          unmountApp();
        };
        if ((process.env.NODE_ENV !== "production" || false) && isBrowser) {
          addDevtools(app, router3, matcher);
        }
      }
    };
    function runGuardQueue(guards) {
      return guards.reduce(function (promise, guard) {
        return promise.then(function () {
          return runWithContext(guard);
        });
      }, Promise.resolve());
    }
    return router2;
  }
  function extractChangingRecords(to, from2) {
    var leavingRecords = [];
    var updatingRecords = [];
    var enteringRecords = [];
    var len = Math.max(from2.matched.length, to.matched.length);
    var _loop13 = function () {
      var recordFrom = from2.matched[_i52];
      if (recordFrom) {
        if (to.matched.find(function (record) {
          return isSameRouteRecord(record, recordFrom);
        })) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);
      }
      var recordTo = to.matched[_i52];
      if (recordTo) {
        if (!from2.matched.find(function (record) {
          return isSameRouteRecord(record, recordTo);
        })) {
          enteringRecords.push(recordTo);
        }
      }
    };
    for (var _i52 = 0; _i52 < len; _i52++) {
      _loop13();
    }
    return [leavingRecords, updatingRecords, enteringRecords];
  }
  function useRouter$1() {
    return inject$1(routerKey);
  }
  function useRoute$1(_name) {
    return inject$1(routeLocationKey);
  }
  var _sfc_main$6 = {
    __name: "App",
    setup: function (__props) {
      return function (_ctx, _cache) {
        return openBlock(), createBlock(unref(RouterView));
      };
    }
  };
  var _hoisted_1$2 = {
    "class": "text-red text-h4 text-center my-2 font-weight-bold"
  };
  var _hoisted_2$2 = ["innerHTML"];
  var _sfc_main$5 = {
    __name: "Home",
    setup: function (__props) {
      var dataGet = ref([]);
      function getData() {
        Meteor.call("productJoinCategory", function (err, result) {
          if (result) {
            dataGet.value = result;
            console.log("data", dataGet.value);
          } else {
            console.log(err);
          }
        });
      }
      onMounted(function () {
        getData();
      });
      return function (_ctx, _cache) {
        var _component_v_card_title = resolveComponent("v-card-title");
        var _component_v_img = resolveComponent("v-img");
        var _component_v_col = resolveComponent("v-col");
        var _component_v_row = resolveComponent("v-row");
        var _component_v_card_text = resolveComponent("v-card-text");
        var _component_v_card = resolveComponent("v-card");
        return openBlock(true), createElementBlock(Fragment$1, null, renderList(dataGet.value, function (cat, catidx) {
          return openBlock(), createBlock(_component_v_card, {
            "class": "w-75 mx-auto mt-5 pa-4",
            key: catidx,
            elevation: "3"
          }, {
            "default": withCtx(function () {
              return [createVNode(_component_v_card_title, {
                "class": "text-red text-h5 font-weight-bold"
              }, {
                "default": withCtx(function () {
                  return [createTextVNode(toDisplayString(cat._id), 1)];
                }),
                _: 2
              }, 1024), createVNode(_component_v_card_text, {
                "class": "mt-5"
              }, {
                "default": withCtx(function () {
                  return [createVNode(_component_v_row, null, {
                    "default": withCtx(function () {
                      return [(openBlock(true), createElementBlock(Fragment$1, null, renderList(cat.products, function (i, idx) {
                        return openBlock(), createBlock(_component_v_col, {
                          cols: "12",
                          md: "3",
                          "class": "border border-secondary",
                          key: idx
                        }, {
                          "default": withCtx(function () {
                            return [i.photo_path ? (openBlock(), createBlock(_component_v_img, {
                              key: 0,
                              "class": "mx-auto",
                              width: 180,
                              src: i.photo_path
                            }, null, 8, ["src"])) : (openBlock(), createBlock(_component_v_img, {
                              key: 1,
                              "class": "mx-auto",
                              width: 180,
                              src: "https://media.istockphoto.com/id/1055079680/id/vektor/kamera-foto-linear-hitam-tidak-seperti-gambar-yang-tersedia.jpg?s=612x612&w=0&k=20&c=JwsOavJ9ghdrwbjvJTUsAUEODcVv5-SXQdxhjEsJ_V4="
                            })), createVNode(_component_v_img, {
                              "class": "mx-auto",
                              width: 180,
                              src: "https://cccomputerkh.com/ori.gif"
                            }), createBaseVNode("p", _hoisted_1$2, toDisplayString(i.price) + "$ ", 1), createBaseVNode("div", {
                              innerHTML: i.data,
                              "class": "tiptap mt-3"
                            }, null, 8, _hoisted_2$2)];
                          }),
                          _: 2
                        }, 1024);
                      }), 128))];
                    }),
                    _: 2
                  }, 1024)];
                }),
                _: 2
              }, 1024)];
            }),
            _: 2
          }, 1024);
        }), 128);
      };
    }
  };
  function OrderedMap(content) {
    this.content = content;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function (key) {
      for (var i = 0; i < this.content.length; i += 2) if (this.content[i] === key) return i;
      return -1;
    },
    get: function (key) {
      var found2 = this.find(key);
      return found2 == -1 ? void 0 : this.content[found2 + 1];
    },
    update: function (key, value, newKey) {
      var self2 = newKey && newKey != key ? this.remove(newKey) : this;
      var found2 = self2.find(key),
        content = self2.content.slice();
      if (found2 == -1) {
        content.push(newKey || key, value);
      } else {
        content[found2 + 1] = value;
        if (newKey) content[found2] = newKey;
      }
      return new OrderedMap(content);
    },
    remove: function (key) {
      var found2 = this.find(key);
      if (found2 == -1) return this;
      var content = this.content.slice();
      content.splice(found2, 2);
      return new OrderedMap(content);
    },
    addToStart: function (key, value) {
      return new OrderedMap([key, value].concat(this.remove(key).content));
    },
    addToEnd: function (key, value) {
      var content = this.remove(key).content.slice();
      content.push(key, value);
      return new OrderedMap(content);
    },
    addBefore: function (place, key, value) {
      var without = this.remove(key),
        content = without.content.slice();
      var found2 = without.find(place);
      content.splice(found2 == -1 ? content.length : found2, 0, key, value);
      return new OrderedMap(content);
    },
    forEach: function (f) {
      for (var i = 0; i < this.content.length; i += 2) f(this.content[i], this.content[i + 1]);
    },
    prepend: function (map3) {
      map3 = OrderedMap.from(map3);
      if (!map3.size) return this;
      return new OrderedMap(map3.content.concat(this.subtract(map3).content));
    },
    append: function (map3) {
      map3 = OrderedMap.from(map3);
      if (!map3.size) return this;
      return new OrderedMap(this.subtract(map3).content.concat(map3.content));
    },
    subtract: function (map3) {
      var result = this;
      map3 = OrderedMap.from(map3);
      for (var i = 0; i < map3.content.length; i += 2) result = result.remove(map3.content[i]);
      return result;
    },
    toObject: function () {
      var result = {};
      this.forEach(function (key, value) {
        result[key] = value;
      });
      return result;
    },
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function (value) {
    if (value instanceof OrderedMap) return value;
    var content = [];
    if (value) for (var prop in value) content.push(prop, value[prop]);
    return new OrderedMap(content);
  };
  function _findDiffStart(a, b, pos) {
    for (var _i53 = 0;; _i53++) {
      if (_i53 == a.childCount || _i53 == b.childCount) return a.childCount == b.childCount ? null : pos;
      var childA = a.child(_i53),
        childB = b.child(_i53);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB)) return pos;
      if (childA.isText && childA.text != childB.text) {
        for (var j = 0; childA.text[j] == childB.text[j]; j++) pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        var inner = _findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null) return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function _findDiffEnd(a, b, posA, posB) {
    for (var iA = a.childCount, iB = b.childCount;;) {
      if (iA == 0 || iB == 0) return iA == iB ? null : {
        a: posA,
        b: posB
      };
      var childA = a.child(--iA),
        childB = b.child(--iB),
        size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB)) return {
        a: posA,
        b: posB
      };
      if (childA.isText && childA.text != childB.text) {
        var same = 0,
          minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return {
          a: posA,
          b: posB
        };
      }
      if (childA.content.size || childB.content.size) {
        var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner) return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment = /*#__PURE__*/function () {
    function Fragment(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null) for (var _i54 = 0; _i54 < content.length; _i54++) this.size += content[_i54].nodeSize;
    }
    var _proto9 = Fragment.prototype;
    _proto9.nodesBetween = function nodesBetween(from2, to, f) {
      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parent = arguments.length > 4 ? arguments[4] : undefined;
      for (var _i55 = 0, pos = 0; pos < to; _i55++) {
        var child = this.content[_i55],
          end = pos + child.nodeSize;
        if (end > from2 && f(child, nodeStart + pos, parent || null, _i55) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }
        pos = end;
      }
    };
    _proto9.descendants = function descendants(f) {
      this.nodesBetween(0, this.size, f);
    };
    _proto9.textBetween = function textBetween(from2, to, blockSeparator, leafText) {
      var text = "",
        first2 = true;
      this.nodesBetween(from2, to, function (node, pos) {
        var nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
          if (first2) first2 = false;else text += blockSeparator;
        }
        text += nodeText;
      }, 0);
      return text;
    };
    _proto9.append = function append(other) {
      if (!other.size) return this;
      if (!this.size) return other;
      var last = this.lastChild,
        first2 = other.firstChild,
        content = this.content.slice(),
        i = 0;
      if (last.isText && last.sameMarkup(first2)) {
        content[content.length - 1] = last.withText(last.text + first2.text);
        i = 1;
      }
      for (; i < other.content.length; i++) content.push(other.content[i]);
      return new Fragment(content, this.size + other.size);
    };
    _proto9.cut = function cut(from2) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      if (from2 == 0 && to == this.size) return this;
      var result = [],
        size = 0;
      if (to > from2) for (var _i56 = 0, pos = 0; pos < to; _i56++) {
        var child = this.content[_i56],
          end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText) child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
      return new Fragment(result, size);
    };
    _proto9.cutByIndex = function cutByIndex(from2, to) {
      if (from2 == to) return Fragment.empty;
      if (from2 == 0 && to == this.content.length) return this;
      return new Fragment(this.content.slice(from2, to));
    };
    _proto9.replaceChild = function replaceChild(index, node) {
      var current = this.content[index];
      if (current == node) return this;
      var copy2 = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new Fragment(copy2, size);
    };
    _proto9.addToStart = function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    };
    _proto9.addToEnd = function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    };
    _proto9.eq = function eq(other) {
      if (this.content.length != other.content.length) return false;
      for (var _i57 = 0; _i57 < this.content.length; _i57++) if (!this.content[_i57].eq(other.content[_i57])) return false;
      return true;
    };
    _proto9.child = function child(index) {
      var found2 = this.content[index];
      if (!found2) throw new RangeError("Index " + index + " out of range for " + this);
      return found2;
    };
    _proto9.maybeChild = function maybeChild(index) {
      return this.content[index] || null;
    };
    _proto9.forEach = function forEach(f) {
      for (var _i58 = 0, p2 = 0; _i58 < this.content.length; _i58++) {
        var child = this.content[_i58];
        f(child, p2, _i58);
        p2 += child.nodeSize;
      }
    };
    _proto9.findDiffStart = function findDiffStart(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return _findDiffStart(this, other, pos);
    };
    _proto9.findDiffEnd = function findDiffEnd(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;
      return _findDiffEnd(this, other, pos, otherPos);
    };
    _proto9.findIndex = function findIndex(pos) {
      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      if (pos == 0) return retIndex(0, pos);
      if (pos == this.size) return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0) throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
      for (var _i59 = 0, curPos = 0;; _i59++) {
        var cur = this.child(_i59),
          end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0) return retIndex(_i59 + 1, end);
          return retIndex(_i59, curPos);
        }
        curPos = end;
      }
    };
    _proto9.toString = function toString() {
      return "<" + this.toStringInner() + ">";
    };
    _proto9.toStringInner = function toStringInner() {
      return this.content.join(", ");
    };
    _proto9.toJSON = function toJSON() {
      return this.content.length ? this.content.map(function (n) {
        return n.toJSON();
      }) : null;
    };
    Fragment.fromJSON = function fromJSON(schema, value) {
      if (!value) return Fragment.empty;
      if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema.nodeFromJSON));
    };
    Fragment.fromArray = function fromArray(array) {
      if (!array.length) return Fragment.empty;
      var joined,
        size = 0;
      for (var _i60 = 0; _i60 < array.length; _i60++) {
        var node = array[_i60];
        size += node.nodeSize;
        if (_i60 && node.isText && array[_i60 - 1].sameMarkup(node)) {
          if (!joined) joined = array.slice(0, _i60);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new Fragment(joined || array, size);
    };
    Fragment.from = function from(nodes) {
      if (!nodes) return Fragment.empty;
      if (nodes instanceof Fragment) return nodes;
      if (Array.isArray(nodes)) return this.fromArray(nodes);
      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    };
    return _createClass(Fragment, [{
      key: "firstChild",
      get: function () {
        return this.content.length ? this.content[0] : null;
      }
    }, {
      key: "lastChild",
      get: function () {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
    }, {
      key: "childCount",
      get: function () {
        return this.content.length;
      }
    }]);
  }();
  Fragment.empty = new Fragment([], 0);
  var found = {
    index: 0,
    offset: 0
  };
  function retIndex(index, offset) {
    found.index = index;
    found.offset = offset;
    return found;
  }
  function compareDeep(a, b) {
    if (a === b) return true;
    if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object")) return false;
    var array = Array.isArray(a);
    if (Array.isArray(b) != array) return false;
    if (array) {
      if (a.length != b.length) return false;
      for (var _i61 = 0; _i61 < a.length; _i61++) if (!compareDeep(a[_i61], b[_i61])) return false;
    } else {
      for (var p2 in a) if (!(p2 in b) || !compareDeep(a[p2], b[p2])) return false;
      for (var _p2 in b) if (!(_p2 in a)) return false;
    }
    return true;
  }
  var Mark$1 = /*#__PURE__*/function () {
    function Mark$1(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    var _proto10 = Mark$1.prototype;
    _proto10.addToSet = function addToSet(set) {
      var copy2,
        placed = false;
      for (var _i62 = 0; _i62 < set.length; _i62++) {
        var _other = set[_i62];
        if (this.eq(_other)) return set;
        if (this.type.excludes(_other.type)) {
          if (!copy2) copy2 = set.slice(0, _i62);
        } else if (_other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && _other.type.rank > this.type.rank) {
            if (!copy2) copy2 = set.slice(0, _i62);
            copy2.push(this);
            placed = true;
          }
          if (copy2) copy2.push(_other);
        }
      }
      if (!copy2) copy2 = set.slice();
      if (!placed) copy2.push(this);
      return copy2;
    };
    _proto10.removeFromSet = function removeFromSet(set) {
      for (var _i63 = 0; _i63 < set.length; _i63++) if (this.eq(set[_i63])) return set.slice(0, _i63).concat(set.slice(_i63 + 1));
      return set;
    };
    _proto10.isInSet = function isInSet(set) {
      for (var _i64 = 0; _i64 < set.length; _i64++) if (this.eq(set[_i64])) return true;
      return false;
    };
    _proto10.eq = function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    };
    _proto10.toJSON = function toJSON() {
      var obj = {
        type: this.type.name
      };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    };
    Mark$1.fromJSON = function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
      var type = schema.marks[json.type];
      if (!type) throw new RangeError("There is no mark type " + json.type + " in this schema");
      var mark = type.create(json.attrs);
      type.checkAttrs(mark.attrs);
      return mark;
    };
    Mark$1.sameSet = function sameSet(a, b) {
      if (a == b) return true;
      if (a.length != b.length) return false;
      for (var _i65 = 0; _i65 < a.length; _i65++) if (!a[_i65].eq(b[_i65])) return false;
      return true;
    };
    Mark$1.setFrom = function setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark$1.none;
      if (marks instanceof Mark$1) return [marks];
      var copy2 = marks.slice();
      copy2.sort(function (a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy2;
    };
    return Mark$1;
  }();
  Mark$1.none = [];
  var ReplaceError = /*#__PURE__*/function (_Error2) {
    function ReplaceError() {
      return _Error2.apply(this, arguments) || this;
    }
    _inheritsLoose(ReplaceError, _Error2);
    return ReplaceError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var Slice = /*#__PURE__*/function () {
    function Slice(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    var _proto11 = Slice.prototype;
    _proto11.insertAt = function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new Slice(content, this.openStart, this.openEnd);
    };
    _proto11.removeBetween = function removeBetween(from2, to) {
      return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    };
    _proto11.eq = function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    };
    _proto11.toString = function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    };
    _proto11.toJSON = function toJSON() {
      if (!this.content.size) return null;
      var json = {
        content: this.content.toJSON()
      };
      if (this.openStart > 0) json.openStart = this.openStart;
      if (this.openEnd > 0) json.openEnd = this.openEnd;
      return json;
    };
    Slice.fromJSON = function fromJSON(schema, json) {
      if (!json) return Slice.empty;
      var openStart = json.openStart || 0,
        openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    };
    Slice.maxOpen = function maxOpen(fragment) {
      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var openStart = 0,
        openEnd = 0;
      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;
      for (var _n3 = fragment.lastChild; _n3 && !_n3.isLeaf && (openIsolating || !_n3.type.spec.isolating); _n3 = _n3.lastChild) openEnd++;
      return new Slice(fragment, openStart, openEnd);
    };
    return _createClass(Slice, [{
      key: "size",
      get: function () {
        return this.content.size - this.openStart - this.openEnd;
      }
    }]);
  }();
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content, from2, to) {
    var _content$findIndex = content.findIndex(from2),
      index = _content$findIndex.index,
      offset = _content$findIndex.offset,
      child = content.maybeChild(index);
    var _content$findIndex2 = content.findIndex(to),
      indexTo = _content$findIndex2.index,
      offsetTo = _content$findIndex2.offset;
    if (offset == from2 || child.isText) {
      if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range");
      return content.cut(0, from2).append(content.cut(to));
    }
    if (index != indexTo) throw new RangeError("Removing non-flat range");
    return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset - 1, to - offset - 1)));
  }
  function insertInto(content, dist, insert, parent) {
    var _content$findIndex3 = content.findIndex(dist),
      index = _content$findIndex3.index,
      offset = _content$findIndex3.offset,
      child = content.maybeChild(index);
    if (offset == dist || child.isText) {
      if (parent && !parent.canReplace(index, index, insert)) return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    var inner = insertInto(child.content, dist - offset - 1, insert);
    return inner && content.replaceChild(index, child.copy(inner));
  }
  function replace$1($from, $to, slice2) {
    if (slice2.openStart > $from.depth) throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd) throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice2, 0);
  }
  function replaceOuter($from, $to, slice2, depth) {
    var index = $from.index(depth),
      node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
      var inner = replaceOuter($from, $to, slice2, depth + 1);
      return node.copy(node.content.replaceChild(index, inner));
    } else if (!slice2.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
      var parent = $from.parent,
        content = parent.content;
      return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
    } else {
      var _prepareSliceForRepla = prepareSliceForReplace(slice2, $from),
        start = _prepareSliceForRepla.start,
        end = _prepareSliceForRepla.end;
      return close(node, replaceThreeWay($from, start, end, $to, depth));
    }
  }
  function checkJoin(main2, sub) {
    if (!sub.type.compatibleContent(main2.type)) throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
  function joinable$1($before, $after, depth) {
    var node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    var last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);
  }
  function addRange($start, $end, depth, target) {
    var node = ($end || $start).node(depth);
    var startIndex = 0,
      endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (var _i66 = startIndex; _i66 < endIndex; _i66++) addNode(node.child(_i66), target);
    if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    var openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
    var openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
    var content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    } else {
      if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
      addRange($start, $end, depth, content);
      if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    var content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      var type = joinable$1($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice2, $along) {
    var extra = $along.depth - slice2.openStart,
      parent = $along.node(extra);
    var node = parent.copy(slice2.content);
    for (var _i67 = extra - 1; _i67 >= 0; _i67--) node = $along.node(_i67).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice2.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
    };
  }
  var ResolvedPos = /*#__PURE__*/function () {
    function ResolvedPos(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.parentOffset = parentOffset;
      this.depth = path.length / 3 - 1;
    }
    var _proto12 = ResolvedPos.prototype;
    _proto12.resolveDepth = function resolveDepth(val) {
      if (val == null) return this.depth;
      if (val < 0) return this.depth + val;
      return val;
    };
    _proto12.node = function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    };
    _proto12.index = function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    };
    _proto12.indexAfter = function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    };
    _proto12.start = function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    };
    _proto12.end = function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    };
    _proto12.before = function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    };
    _proto12.after = function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    };
    _proto12.posAtIndex = function posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3],
        pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (var _i68 = 0; _i68 < index; _i68++) pos += node.child(_i68).nodeSize;
      return pos;
    };
    _proto12.marks = function marks() {
      var parent = this.parent,
        index = this.index();
      if (parent.content.size == 0) return Mark$1.none;
      if (this.textOffset) return parent.child(index).marks;
      var main2 = parent.maybeChild(index - 1),
        other = parent.maybeChild(index);
      if (!main2) {
        var tmp = main2;
        main2 = other;
        other = tmp;
      }
      var marks = main2.marks;
      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);
      return marks;
    };
    _proto12.marksAcross = function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) return null;
      var marks = after.marks,
        next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);
      return marks;
    };
    _proto12.sharedDepth = function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
      return 0;
    };
    _proto12.blockRange = function blockRange() {
      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
      var pred = arguments.length > 1 ? arguments[1] : undefined;
      if (other.pos < this.pos) return other.blockRange(this);
      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);
      return null;
    };
    _proto12.sameParent = function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    };
    _proto12.max = function max(other) {
      return other.pos > this.pos ? other : this;
    };
    _proto12.min = function min(other) {
      return other.pos < this.pos ? other : this;
    };
    _proto12.toString = function toString() {
      var str = "";
      for (var _i69 = 1; _i69 <= this.depth; _i69++) str += (str ? "/" : "") + this.node(_i69).type.name + "_" + this.index(_i69 - 1);
      return str + ":" + this.parentOffset;
    };
    ResolvedPos.resolve = function resolve(doc2, pos) {
      if (!(pos >= 0 && pos <= doc2.content.size)) throw new RangeError("Position " + pos + " out of range");
      var path = [];
      var start = 0,
        parentOffset = pos;
      for (var node = doc2;;) {
        var _node$content$findInd = node.content.findIndex(parentOffset),
          index = _node$content$findInd.index,
          offset = _node$content$findInd.offset;
        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) break;
        node = node.child(index);
        if (node.isText) break;
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new ResolvedPos(pos, path, parentOffset);
    };
    ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
      var cache = resolveCache.get(doc2);
      if (cache) {
        for (var _i70 = 0; _i70 < cache.elts.length; _i70++) {
          var elt = cache.elts[_i70];
          if (elt.pos == pos) return elt;
        }
      } else {
        resolveCache.set(doc2, cache = new ResolveCache());
      }
      var result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
      cache.i = (cache.i + 1) % resolveCacheSize;
      return result;
    };
    return _createClass(ResolvedPos, [{
      key: "parent",
      get: function () {
        return this.node(this.depth);
      }
    }, {
      key: "doc",
      get: function () {
        return this.node(0);
      }
    }, {
      key: "textOffset",
      get: function () {
        return this.pos - this.path[this.path.length - 1];
      }
    }, {
      key: "nodeAfter",
      get: function () {
        var parent = this.parent,
          index = this.index(this.depth);
        if (index == parent.childCount) return null;
        var dOff = this.pos - this.path[this.path.length - 1],
          child = parent.child(index);
        return dOff ? parent.child(index).cut(dOff) : child;
      }
    }, {
      key: "nodeBefore",
      get: function () {
        var index = this.index(this.depth);
        var dOff = this.pos - this.path[this.path.length - 1];
        if (dOff) return this.parent.child(index).cut(0, dOff);
        return index == 0 ? null : this.parent.child(index - 1);
      }
    }]);
  }();
  var ResolveCache = function ResolveCache() {
    this.elts = [];
    this.i = 0;
  };
  var resolveCacheSize = 12,
    resolveCache = /* @__PURE__ */new WeakMap();
  var NodeRange = /*#__PURE__*/function () {
    function NodeRange($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    return _createClass(NodeRange, [{
      key: "start",
      get: function () {
        return this.$from.before(this.depth + 1);
      }
    }, {
      key: "end",
      get: function () {
        return this.$to.after(this.depth + 1);
      }
    }, {
      key: "parent",
      get: function () {
        return this.$from.node(this.depth);
      }
    }, {
      key: "startIndex",
      get: function () {
        return this.$from.index(this.depth);
      }
    }, {
      key: "endIndex",
      get: function () {
        return this.$to.indexAfter(this.depth);
      }
    }]);
  }();
  var emptyAttrs = /* @__PURE__ */Object.create(null);
  var Node$2 = /*#__PURE__*/function () {
    function Node$2(type, attrs, content) {
      var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark$1.none;
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content || Fragment.empty;
    }
    var _proto13 = Node$2.prototype;
    _proto13.child = function child(index) {
      return this.content.child(index);
    };
    _proto13.maybeChild = function maybeChild(index) {
      return this.content.maybeChild(index);
    };
    _proto13.forEach = function forEach(f) {
      this.content.forEach(f);
    };
    _proto13.nodesBetween = function nodesBetween(from2, to, f) {
      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.content.nodesBetween(from2, to, f, startPos, this);
    };
    _proto13.descendants = function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    };
    _proto13.textBetween = function textBetween(from2, to, blockSeparator, leafText) {
      return this.content.textBetween(from2, to, blockSeparator, leafText);
    };
    _proto13.eq = function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    };
    _proto13.sameMarkup = function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    };
    _proto13.hasMarkup = function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
    };
    _proto13.copy = function copy() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (content == this.content) return this;
      return new Node$2(this.type, this.attrs, content, this.marks);
    };
    _proto13.mark = function mark(marks) {
      return marks == this.marks ? this : new Node$2(this.type, this.attrs, this.content, marks);
    };
    _proto13.cut = function cut(from2) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      if (from2 == 0 && to == this.content.size) return this;
      return this.copy(this.content.cut(from2, to));
    };
    _proto13.slice = function slice(from2) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (from2 == to) return Slice.empty;
      var $from = this.resolve(from2),
        $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth),
        node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    };
    _proto13.replace = function replace(from2, to, slice2) {
      return replace$1(this.resolve(from2), this.resolve(to), slice2);
    };
    _proto13.nodeAt = function nodeAt(pos) {
      for (var node = this;;) {
        var _node$content$findInd2 = node.content.findIndex(pos),
          index = _node$content$findInd2.index,
          offset = _node$content$findInd2.offset;
        node = node.maybeChild(index);
        if (!node) return null;
        if (offset == pos || node.isText) return node;
        pos -= offset + 1;
      }
    };
    _proto13.childAfter = function childAfter(pos) {
      var _this$content$findInd = this.content.findIndex(pos),
        index = _this$content$findInd.index,
        offset = _this$content$findInd.offset;
      return {
        node: this.content.maybeChild(index),
        index: index,
        offset: offset
      };
    };
    _proto13.childBefore = function childBefore(pos) {
      if (pos == 0) return {
        node: null,
        index: 0,
        offset: 0
      };
      var _this$content$findInd2 = this.content.findIndex(pos),
        index = _this$content$findInd2.index,
        offset = _this$content$findInd2.offset;
      if (offset < pos) return {
        node: this.content.child(index),
        index: index,
        offset: offset
      };
      var node = this.content.child(index - 1);
      return {
        node: node,
        index: index - 1,
        offset: offset - node.nodeSize
      };
    };
    _proto13.resolve = function resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    };
    _proto13.resolveNoCache = function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    };
    _proto13.rangeHasMark = function rangeHasMark(from2, to, type) {
      var found2 = false;
      if (to > from2) this.nodesBetween(from2, to, function (node) {
        if (type.isInSet(node.marks)) found2 = true;
        return !found2;
      });
      return found2;
    };
    _proto13.toString = function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      var name = this.type.name;
      if (this.content.size) name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    };
    _proto13.contentMatchAt = function contentMatchAt(index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    };
    _proto13.canReplace = function canReplace(from2, to) {
      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;
      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;
      var one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) return false;
      for (var _i71 = start; _i71 < end; _i71++) if (!this.type.allowsMarks(replacement.child(_i71).marks)) return false;
      return true;
    };
    _proto13.canReplaceWith = function canReplaceWith(from2, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) return false;
      var start = this.contentMatchAt(from2).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    };
    _proto13.canAppend = function canAppend(other) {
      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);
    };
    _proto13.check = function check() {
      this.type.checkContent(this.content);
      this.type.checkAttrs(this.attrs);
      var copy2 = Mark$1.none;
      for (var _i72 = 0; _i72 < this.marks.length; _i72++) {
        var mark = this.marks[_i72];
        mark.type.checkAttrs(mark.attrs);
        copy2 = mark.addToSet(copy2);
      }
      if (!Mark$1.sameSet(copy2, this.marks)) throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function (m3) {
        return m3.type.name;
      }));
      this.content.forEach(function (node) {
        return node.check();
      });
    };
    _proto13.toJSON = function toJSON() {
      var obj = {
        type: this.type.name
      };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size) obj.content = this.content.toJSON();
      if (this.marks.length) obj.marks = this.marks.map(function (n) {
        return n.toJSON();
      });
      return obj;
    };
    Node$2.fromJSON = function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Node.fromJSON");
      var marks = void 0;
      if (json.marks) {
        if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      var content = Fragment.fromJSON(schema, json.content);
      var node = schema.nodeType(json.type).create(json.attrs, content, marks);
      node.type.checkAttrs(node.attrs);
      return node;
    };
    return _createClass(Node$2, [{
      key: "nodeSize",
      get: function () {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
    }, {
      key: "childCount",
      get: function () {
        return this.content.childCount;
      }
    }, {
      key: "textContent",
      get: function () {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
    }, {
      key: "firstChild",
      get: function () {
        return this.content.firstChild;
      }
    }, {
      key: "lastChild",
      get: function () {
        return this.content.lastChild;
      }
    }, {
      key: "isBlock",
      get: function () {
        return this.type.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function () {
        return this.type.isTextblock;
      }
    }, {
      key: "inlineContent",
      get: function () {
        return this.type.inlineContent;
      }
    }, {
      key: "isInline",
      get: function () {
        return this.type.isInline;
      }
    }, {
      key: "isText",
      get: function () {
        return this.type.isText;
      }
    }, {
      key: "isLeaf",
      get: function () {
        return this.type.isLeaf;
      }
    }, {
      key: "isAtom",
      get: function () {
        return this.type.isAtom;
      }
    }]);
  }();
  Node$2.prototype.text = void 0;
  var TextNode = /*#__PURE__*/function (_Node$) {
    function TextNode(type, attrs, content, marks) {
      var _this4;
      _this4 = _Node$.call(this, type, attrs, null, marks) || this;
      if (!content) throw new RangeError("Empty text nodes are not allowed");
      _this4.text = content;
      return _this4;
    }
    _inheritsLoose(TextNode, _Node$);
    var _proto14 = TextNode.prototype;
    _proto14.toString = function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    };
    _proto14.textBetween = function textBetween(from2, to) {
      return this.text.slice(from2, to);
    };
    _proto14.mark = function mark(marks) {
      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    };
    _proto14.withText = function withText(text) {
      if (text == this.text) return this;
      return new TextNode(this.type, this.attrs, text, this.marks);
    };
    _proto14.cut = function cut() {
      var from2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;
      if (from2 == 0 && to == this.text.length) return this;
      return this.withText(this.text.slice(from2, to));
    };
    _proto14.eq = function eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    };
    _proto14.toJSON = function toJSON() {
      var base2 = _Node$.prototype.toJSON.call(this);
      base2.text = this.text;
      return base2;
    };
    return _createClass(TextNode, [{
      key: "textContent",
      get: function () {
        return this.text;
      }
    }, {
      key: "nodeSize",
      get: function () {
        return this.text.length;
      }
    }]);
  }(Node$2);
  function wrapMarks(marks, str) {
    for (var _i73 = marks.length - 1; _i73 >= 0; _i73--) str = marks[_i73].type.name + "(" + str + ")";
    return str;
  }
  var ContentMatch = /*#__PURE__*/function () {
    function ContentMatch(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    ContentMatch.parse = function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) return ContentMatch.empty;
      var expr = parseExpr(stream);
      if (stream.next) stream.err("Unexpected trailing text");
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    };
    var _proto15 = ContentMatch.prototype;
    _proto15.matchType = function matchType(type) {
      for (var _i74 = 0; _i74 < this.next.length; _i74++) if (this.next[_i74].type == type) return this.next[_i74].next;
      return null;
    };
    _proto15.matchFragment = function matchFragment(frag) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;
      var cur = this;
      for (var _i75 = start; cur && _i75 < end; _i75++) cur = cur.matchType(frag.child(_i75).type);
      return cur;
    };
    _proto15.compatible = function compatible(other) {
      for (var _i76 = 0; _i76 < this.next.length; _i76++) for (var j = 0; j < other.next.length; j++) if (this.next[_i76].type == other.next[j].type) return true;
      return false;
    };
    _proto15.fillBefore = function fillBefore(after) {
      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seen = [this];
      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {
          return tp.createAndFill();
        }));
        for (var _i77 = 0; _i77 < match.next.length; _i77++) {
          var _match$next$_i = match.next[_i77],
            type = _match$next$_i.type,
            next = _match$next$_i.next;
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            var found2 = search(next, types.concat(type));
            if (found2) return found2;
          }
        }
        return null;
      }
      return search(this, []);
    };
    _proto15.findWrapping = function findWrapping(target) {
      for (var _i78 = 0; _i78 < this.wrapCache.length; _i78 += 2) if (this.wrapCache[_i78] == target) return this.wrapCache[_i78 + 1];
      var computed2 = this.computeWrapping(target);
      this.wrapCache.push(target, computed2);
      return computed2;
    };
    _proto15.computeWrapping = function computeWrapping(target) {
      var seen = /* @__PURE__ */Object.create(null),
        active = [{
          match: this,
          type: null,
          via: null
        }];
      while (active.length) {
        var current = active.shift(),
          match = current.match;
        if (match.matchType(target)) {
          var result = [];
          for (var obj = current; obj.type; obj = obj.via) result.push(obj.type);
          return result.reverse();
        }
        for (var _i79 = 0; _i79 < match.next.length; _i79++) {
          var _match$next$_i2 = match.next[_i79],
            type = _match$next$_i2.type,
            next = _match$next$_i2.next;
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({
              match: type.contentMatch,
              type: type,
              via: current
            });
            seen[type.name] = true;
          }
        }
      }
      return null;
    };
    _proto15.edge = function edge(n) {
      if (n >= this.next.length) throw new RangeError("There's no " + n + "th edge in this content match");
      return this.next[n];
    };
    _proto15.toString = function toString() {
      var seen = [];
      function scan(m3) {
        seen.push(m3);
        for (var _i80 = 0; _i80 < m3.next.length; _i80++) if (seen.indexOf(m3.next[_i80].next) == -1) scan(m3.next[_i80].next);
      }
      scan(this);
      return seen.map(function (m3, i) {
        var out = i + (m3.validEnd ? "*" : " ") + " ";
        for (var i2 = 0; i2 < m3.next.length; i2++) out += (i2 ? ", " : "") + m3.next[i2].type.name + "->" + seen.indexOf(m3.next[i2].next);
        return out;
      }).join("\n");
    };
    return _createClass(ContentMatch, [{
      key: "inlineContent",
      get: function () {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
    }, {
      key: "defaultType",
      get: function () {
        for (var _i81 = 0; _i81 < this.next.length; _i81++) {
          var type = this.next[_i81].type;
          if (!(type.isText || type.hasRequiredAttrs())) return type;
        }
        return null;
      }
    }, {
      key: "edgeCount",
      get: function () {
        return this.next.length;
      }
    }]);
  }();
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = /*#__PURE__*/function () {
    function TokenStream(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
      if (this.tokens[0] == "") this.tokens.shift();
    }
    var _proto16 = TokenStream.prototype;
    _proto16.eat = function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    };
    _proto16.err = function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    };
    return _createClass(TokenStream, [{
      key: "next",
      get: function () {
        return this.tokens[this.pos];
      }
    }]);
  }();
  function parseExpr(stream) {
    var exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : {
      type: "choice",
      exprs: exprs
    };
  }
  function parseExprSeq(stream) {
    var exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : {
      type: "seq",
      exprs: exprs
    };
  }
  function parseExprSubscript(stream) {
    var expr = parseExprAtom(stream);
    for (;;) {
      if (stream.eat("+")) expr = {
        type: "plus",
        expr: expr
      };else if (stream.eat("*")) expr = {
        type: "star",
        expr: expr
      };else if (stream.eat("?")) expr = {
        type: "opt",
        expr: expr
      };else if (stream.eat("{")) expr = parseExprRange(stream, expr);else break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
    var result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    var min = parseNum(stream),
      max = min;
    if (stream.eat(",")) {
      if (stream.next != "}") max = parseNum(stream);else max = -1;
    }
    if (!stream.eat("}")) stream.err("Unclosed braced range");
    return {
      type: "range",
      min: min,
      max: max,
      expr: expr
    };
  }
  function resolveName(stream, name) {
    var types = stream.nodeTypes,
      type = types[name];
    if (type) return [type];
    var result = [];
    for (var typeName in types) {
      var type2 = types[typeName];
      if (type2.isInGroup(name)) result.push(type2);
    }
    if (result.length == 0) stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      var expr = parseExpr(stream);
      if (!stream.eat(")")) stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      var exprs = resolveName(stream, stream.next).map(function (type) {
        if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err("Mixing inline and block content");
        return {
          type: "name",
          value: type
        };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : {
        type: "choice",
        exprs: exprs
      };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    var nfa2 = [[]];
    connect(compile2(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from2, to, term) {
      var edge2 = {
        term: term,
        to: to
      };
      nfa2[from2].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach(function (edge2) {
        return edge2.to = to;
      });
    }
    function compile2(expr2, from2) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce(function (out, expr3) {
          return out.concat(compile2(expr3, from2));
        }, []);
      } else if (expr2.type == "seq") {
        for (var _i82 = 0;; _i82++) {
          var next = compile2(expr2.exprs[_i82], from2);
          if (_i82 == expr2.exprs.length - 1) return next;
          connect(next, from2 = node());
        }
      } else if (expr2.type == "star") {
        var loop = node();
        edge(from2, loop);
        connect(compile2(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        var _loop14 = node();
        connect(compile2(expr2.expr, from2), _loop14);
        connect(compile2(expr2.expr, _loop14), _loop14);
        return [edge(_loop14)];
      } else if (expr2.type == "opt") {
        return [edge(from2)].concat(compile2(expr2.expr, from2));
      } else if (expr2.type == "range") {
        var cur = from2;
        for (var _i83 = 0; _i83 < expr2.min; _i83++) {
          var _next2 = node();
          connect(compile2(expr2.expr, cur), _next2);
          cur = _next2;
        }
        if (expr2.max == -1) {
          connect(compile2(expr2.expr, cur), cur);
        } else {
          for (var _i84 = expr2.min; _i84 < expr2.max; _i84++) {
            var _next3 = node();
            edge(cur, _next3);
            connect(compile2(expr2.expr, cur), _next3);
            cur = _next3;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from2, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa2, node) {
    var result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      var edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
      result.push(node2);
      for (var _i85 = 0; _i85 < edges.length; _i85++) {
        var _edges$_i = edges[_i85],
          term = _edges$_i.term,
          to = _edges$_i.to;
        if (!term && result.indexOf(to) == -1) scan(to);
      }
    }
  }
  function dfa(nfa2) {
    var labeled = /* @__PURE__ */Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      var out = [];
      states.forEach(function (node) {
        nfa2[node].forEach(function (_ref67) {
          var term = _ref67.term,
            to = _ref67.to;
          if (!term) return;
          var set;
          for (var _i86 = 0; _i86 < out.length; _i86++) if (out[_i86][0] == term) set = out[_i86][1];
          nullFrom(nfa2, to).forEach(function (node2) {
            if (!set) out.push([term, set = []]);
            if (set.indexOf(node2) == -1) set.push(node2);
          });
        });
      });
      var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (var _i87 = 0; _i87 < out.length; _i87++) {
        var states2 = out[_i87][1].sort(cmp);
        state.next.push({
          type: out[_i87][0],
          next: labeled[states2.join(",")] || explore(states2)
        });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (var _i88 = 0, work = [match]; _i88 < work.length; _i88++) {
      var state = work[_i88],
        dead = !state.validEnd,
        nodes = [];
      for (var j = 0; j < state.next.length; j++) {
        var _state$next$j = state.next[j],
          type = _state$next$j.type,
          next = _state$next$j.next;
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;
        if (work.indexOf(next) == -1) work.push(next);
      }
      if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    var defaults = /* @__PURE__ */Object.create(null);
    for (var attrName in attrs) {
      var attr = attrs[attrName];
      if (!attr.hasDefault) return null;
      defaults[attrName] = attr.default;
    }
    return defaults;
  }
  function _computeAttrs(attrs, value) {
    var built = /* @__PURE__ */Object.create(null);
    for (var name in attrs) {
      var given = value && value[name];
      if (given === void 0) {
        var attr = attrs[name];
        if (attr.hasDefault) given = attr.default;else throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function _checkAttrs(attrs, values, type, name) {
    for (var name2 in values) if (!(name2 in attrs)) throw new RangeError("Unsupported attribute " + name2 + " for " + type + " of type " + name2);
    for (var _name2 in attrs) {
      var attr = attrs[_name2];
      if (attr.validate) attr.validate(values[_name2]);
    }
  }
  function initAttrs(typeName, attrs) {
    var result = /* @__PURE__ */Object.create(null);
    if (attrs) for (var name in attrs) result[name] = new Attribute(typeName, name, attrs[name]);
    return result;
  }
  var NodeType$1 = /*#__PURE__*/function () {
    function NodeType$1(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.markSet = null;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(name, spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    }
    var _proto17 = NodeType$1.prototype;
    _proto17.isInGroup = function isInGroup(group) {
      return this.groups.indexOf(group) > -1;
    };
    _proto17.hasRequiredAttrs = function hasRequiredAttrs() {
      for (var n in this.attrs) if (this.attrs[n].isRequired) return true;
      return false;
    };
    _proto17.compatibleContent = function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    };
    _proto17.computeAttrs = function computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);
    };
    _proto17.create = function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      if (this.isText) throw new Error("NodeType.create can't construct text nodes");
      return new Node$2(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
    };
    _proto17.createChecked = function createChecked() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      content = Fragment.from(content);
      this.checkContent(content);
      return new Node$2(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
    };
    _proto17.createAndFill = function createAndFill() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) return null;
        content = before.append(content);
      }
      var matched = this.contentMatch.matchFragment(content);
      var after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after) return null;
      return new Node$2(this, attrs, content.append(after), Mark$1.setFrom(marks));
    };
    _proto17.validContent = function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) return false;
      for (var _i89 = 0; _i89 < content.childCount; _i89++) if (!this.allowsMarks(content.child(_i89).marks)) return false;
      return true;
    };
    _proto17.checkContent = function checkContent(content) {
      if (!this.validContent(content)) throw new RangeError("Invalid content for node " + this.name + ": " + content.toString().slice(0, 50));
    };
    _proto17.checkAttrs = function checkAttrs(attrs) {
      _checkAttrs(this.attrs, attrs, "node", this.name);
    };
    _proto17.allowsMarkType = function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    };
    _proto17.allowsMarks = function allowsMarks(marks) {
      if (this.markSet == null) return true;
      for (var _i90 = 0; _i90 < marks.length; _i90++) if (!this.allowsMarkType(marks[_i90].type)) return false;
      return true;
    };
    _proto17.allowedMarks = function allowedMarks(marks) {
      if (this.markSet == null) return marks;
      var copy2;
      for (var _i91 = 0; _i91 < marks.length; _i91++) {
        if (!this.allowsMarkType(marks[_i91].type)) {
          if (!copy2) copy2 = marks.slice(0, _i91);
        } else if (copy2) {
          copy2.push(marks[_i91]);
        }
      }
      return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
    };
    NodeType$1.compile = function compile(nodes, schema) {
      var result = /* @__PURE__ */Object.create(null);
      nodes.forEach(function (name, spec) {
        return result[name] = new NodeType$1(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text) throw new RangeError("Every schema needs a 'text' type");
      for (var _ in result.text.attrs) throw new RangeError("The text node type should not have attributes");
      return result;
    };
    return _createClass(NodeType$1, [{
      key: "isInline",
      get: function () {
        return !this.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function () {
        return this.isBlock && this.inlineContent;
      }
    }, {
      key: "isLeaf",
      get: function () {
        return this.contentMatch == ContentMatch.empty;
      }
    }, {
      key: "isAtom",
      get: function () {
        return this.isLeaf || !!this.spec.atom;
      }
    }, {
      key: "whitespace",
      get: function () {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
    }]);
  }();
  function validateType(typeName, attrName, type) {
    var types = type.split("|");
    return function (value) {
      var name = value === null ? "null" : _typeof(value);
      if (types.indexOf(name) < 0) throw new RangeError("Expected value of type " + types + " for attribute " + attrName + " on type " + typeName + ", got " + name);
    };
  }
  var Attribute = /*#__PURE__*/function () {
    function Attribute(typeName, attrName, options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
      this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
    }
    return _createClass(Attribute, [{
      key: "isRequired",
      get: function () {
        return !this.hasDefault;
      }
    }]);
  }();
  var MarkType = /*#__PURE__*/function () {
    function MarkType(name, rank, schema, spec) {
      this.name = name;
      this.rank = rank;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(name, spec.attrs);
      this.excluded = null;
      var defaults = defaultAttrs(this.attrs);
      this.instance = defaults ? new Mark$1(this, defaults) : null;
    }
    var _proto18 = MarkType.prototype;
    _proto18.create = function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (!attrs && this.instance) return this.instance;
      return new Mark$1(this, _computeAttrs(this.attrs, attrs));
    };
    MarkType.compile = function compile(marks, schema) {
      var result = /* @__PURE__ */Object.create(null),
        rank = 0;
      marks.forEach(function (name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    };
    _proto18.removeFromSet = function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
      return set;
    };
    _proto18.isInSet = function isInSet(set) {
      for (var _i92 = 0; _i92 < set.length; _i92++) if (set[_i92].type == this) return set[_i92];
    };
    _proto18.checkAttrs = function checkAttrs(attrs) {
      _checkAttrs(this.attrs, attrs, "mark", this.name);
    };
    _proto18.excludes = function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    };
    return MarkType;
  }();
  var Schema = /*#__PURE__*/function () {
    function Schema(spec) {
      this.linebreakReplacement = null;
      this.cached = /* @__PURE__ */Object.create(null);
      var instanceSpec = this.spec = {};
      for (var prop in spec) instanceSpec[prop] = spec[prop];
      instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      var contentExprCache = /* @__PURE__ */Object.create(null);
      for (var _prop in this.nodes) {
        if (_prop in this.marks) throw new RangeError(_prop + " can not be both a node and a mark");
        var type = this.nodes[_prop],
          contentExpr = type.spec.content || "",
          markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        if (type.spec.linebreakReplacement) {
          if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined");
          if (!type.isInline || !type.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
          this.linebreakReplacement = type;
        }
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (var _prop2 in this.marks) {
        var _type = this.marks[_prop2],
          excl = _type.spec.excludes;
        _type.excluded = excl == null ? [_type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached.wrappings = /* @__PURE__ */Object.create(null);
    }
    var _proto19 = Schema.prototype;
    _proto19.node = function node(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      if (typeof type == "string") type = this.nodeType(type);else if (!(type instanceof NodeType$1)) throw new RangeError("Invalid node type: " + type);else if (type.schema != this) throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    };
    _proto19.text = function text(_text, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, _text, Mark$1.setFrom(marks));
    };
    _proto19.mark = function mark(type, attrs) {
      if (typeof type == "string") type = this.marks[type];
      return type.create(attrs);
    };
    _proto19.nodeFromJSON = function nodeFromJSON(json) {
      return Node$2.fromJSON(this, json);
    };
    _proto19.markFromJSON = function markFromJSON(json) {
      return Mark$1.fromJSON(this, json);
    };
    _proto19.nodeType = function nodeType(name) {
      var found2 = this.nodes[name];
      if (!found2) throw new RangeError("Unknown node type: " + name);
      return found2;
    };
    return Schema;
  }();
  function gatherMarks(schema, marks) {
    var found2 = [];
    for (var _i93 = 0; _i93 < marks.length; _i93++) {
      var name = marks[_i93],
        mark = schema.marks[name],
        ok = mark;
      if (mark) {
        found2.push(mark);
      } else {
        for (var prop in schema.marks) {
          var mark2 = schema.marks[prop];
          if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1) found2.push(ok = mark2);
        }
      }
      if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[_i93] + "'");
    }
    return found2;
  }
  function isTagRule(rule) {
    return rule.tag != null;
  }
  function isStyleRule(rule) {
    return rule.style != null;
  }
  var DOMParser = /*#__PURE__*/function () {
    function DOMParser(schema, rules) {
      var _this5 = this;
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      var matchedStyles = this.matchedStyles = [];
      rules.forEach(function (rule) {
        if (isTagRule(rule)) {
          _this5.tags.push(rule);
        } else if (isStyleRule(rule)) {
          var prop = /[^=]*/.exec(rule.style)[0];
          if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);
          _this5.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some(function (r) {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
        var node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    }
    var _proto20 = DOMParser.prototype;
    _proto20.parse = function parse(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, Mark$1.none, options.from, options.to);
      return context.finish();
    };
    _proto20.parseSlice = function parseSlice(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, Mark$1.none, options.from, options.to);
      return Slice.maxOpen(context.finish());
    };
    _proto20.matchTag = function matchTag(dom, context, after) {
      for (var _i94 = after ? this.tags.indexOf(after) + 1 : 0; _i94 < this.tags.length; _i94++) {
        var rule = this.tags[_i94];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    };
    _proto20.matchStyle = function matchStyle(prop, value, context, after) {
      for (var _i95 = after ? this.styles.indexOf(after) + 1 : 0; _i95 < this.styles.length; _i95++) {
        var rule = this.styles[_i95],
          style2 = rule.style;
        if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value)) continue;
        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    };
    DOMParser.schemaRules = function schemaRules(schema) {
      var result = [];
      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority,
          i = 0;
        for (; i < result.length; i++) {
          var next = result[i],
            nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) break;
        }
        result.splice(i, 0, rule);
      }
      var _loop15 = function (name) {
        var rules = schema.marks[name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;
        });
      };
      for (var name in schema.marks) {
        _loop15(name);
      }
      var _loop16 = function (_name3) {
        var rules = schema.nodes[_name3].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name3;
        });
      };
      for (var _name3 in schema.nodes) {
        _loop16(_name3);
      }
      return result;
    };
    DOMParser.fromSchema = function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    };
    return DOMParser;
  }();
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags = {
    ol: true,
    ul: true
  };
  var OPT_PRESERVE_WS = 1,
    OPT_PRESERVE_WS_FULL = 2,
    OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  var NodeContext = /*#__PURE__*/function () {
    function NodeContext(type, attrs, marks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark$1.none;
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    var _proto21 = NodeContext.prototype;
    _proto21.findWrapping = function findWrapping(node) {
      if (!this.match) {
        if (!this.type) return [];
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch,
            wrap2;
          if (wrap2 = start.findWrapping(node.type)) {
            this.match = start;
            return wrap2;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    };
    _proto21.finish = function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last = this.content[this.content.length - 1],
          m3;
        if (last && last.isText && (m3 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          var text = last;
          if (last.text.length == m3[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m3[0].length));
        }
      }
      var content = Fragment.from(this.content);
      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    };
    _proto21.inlineContext = function inlineContext(node) {
      if (this.type) return this.type.inlineContent;
      if (this.content.length) return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    };
    return NodeContext;
  }();
  var ParseContext = /*#__PURE__*/function () {
    function ParseContext(parser, options, isOpen) {
      this.parser = parser;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      var topNode = options.topNode,
        topContext;
      var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark$1.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    var _proto22 = ParseContext.prototype;
    _proto22.addDOM = function addDOM(dom, marks) {
      if (dom.nodeType == 3) this.addTextNode(dom, marks);else if (dom.nodeType == 1) this.addElement(dom, marks);
    };
    _proto22.addTextNode = function addTextNode(dom, marks) {
      var value = dom.nodeValue;
      var top = this.top;
      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value) this.insertNode(this.parser.schema.text(value), marks);
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    };
    _proto22.addElement = function addElement(dom, marks, matchAfter) {
      var name = dom.nodeName.toLowerCase(),
        ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;
        var sync,
          top = this.top,
          oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type) this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks);
          return;
        }
        var innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
        if (innerMarks) this.addAll(dom, innerMarks);
        if (sync) this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        var _innerMarks = this.readStyles(dom, marks);
        if (_innerMarks) this.addElementByRule(dom, rule, _innerMarks, rule.consuming === false ? ruleID : void 0);
      }
    };
    _proto22.leafFallback = function leafFallback(dom, marks) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
    };
    _proto22.ignoreFallback = function ignoreFallback(dom, marks) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text("-"), marks);
    };
    _proto22.readStyles = function readStyles(dom, marks) {
      var _this6 = this;
      var styles = dom.style;
      if (styles && styles.length) for (var _i96 = 0; _i96 < this.parser.matchedStyles.length; _i96++) {
        var name = this.parser.matchedStyles[_i96],
          value = styles.getPropertyValue(name);
        if (value) {
          var _loop17 = function (_after) {
              var rule = _this6.parser.matchStyle(name, value, _this6, _after);
              if (!rule) {
                after = _after;
                return 0;
              } // break
              if (rule.ignore) return {
                v: null
              };
              if (rule.clearMark) marks = marks.filter(function (m3) {
                return !rule.clearMark(m3);
              });else marks = marks.concat(_this6.parser.schema.marks[rule.mark].create(rule.attrs));
              if (rule.consuming === false) _after = rule;else {
                after = _after;
                return 0;
              } // break
              after = _after;
            },
            _ret2;
          for (var after = void 0;;) {
            _ret2 = _loop17(after);
            if (_ret2 === 0) break;
            if (_ret2) return _ret2.v;
          }
        }
      }
      return marks;
    };
    _proto22.addElementByRule = function addElementByRule(dom, rule, marks, continueAfter) {
      var _this7 = this;
      var sync, nodeType;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          var inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
          if (inner) {
            sync = true;
            marks = inner;
          }
        } else if (!this.insertNode(nodeType.create(rule.attrs), marks)) {
          this.leafFallback(dom, marks);
        }
      } else {
        var markType = this.parser.schema.marks[rule.mark];
        marks = marks.concat(markType.create(rule.attrs));
      }
      var startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, marks, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function (node) {
          return _this7.insertNode(node, marks);
        });
      } else {
        var contentDOM = dom;
        if (typeof rule.contentElement == "string") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == "function") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, marks);
        this.findAround(dom, contentDOM, false);
      }
      if (sync && this.sync(startIn)) this.open--;
    };
    _proto22.addAll = function addAll(parent, marks, startIndex, endIndex) {
      var index = startIndex || 0;
      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom, marks);
      }
      this.findAtPoint(parent, index);
    };
    _proto22.findPlace = function findPlace(node, marks) {
      var route, sync;
      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];
        var found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync = cx;
          if (!found2.length) break;
        }
        if (cx.solid) break;
      }
      if (!route) return null;
      this.sync(sync);
      for (var _i97 = 0; _i97 < route.length; _i97++) marks = this.enterInner(route[_i97], null, marks, false);
      return marks;
    };
    _proto22.insertNode = function insertNode(node, marks) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block2 = this.textblockFromContext();
        if (block2) marks = this.enterInner(block2, null, marks);
      }
      var innerMarks = this.findPlace(node, marks);
      if (innerMarks) {
        this.closeExtra();
        var top = this.top;
        if (top.match) top.match = top.match.matchType(node.type);
        var nodeMarks = Mark$1.none;
        for (var _iterator26 = _createForOfIteratorHelperLoose(innerMarks.concat(node.marks)), _step27; !(_step27 = _iterator26()).done;) {
          var m3 = _step27.value;
          if (top.type ? top.type.allowsMarkType(m3.type) : markMayApply(m3.type, node.type)) nodeMarks = m3.addToSet(nodeMarks);
        }
        top.content.push(node.mark(nodeMarks));
        return true;
      }
      return false;
    };
    _proto22.enter = function enter(type, attrs, marks, preserveWS) {
      var innerMarks = this.findPlace(type.create(attrs), marks);
      if (innerMarks) innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
      return innerMarks;
    };
    _proto22.enterInner = function enterInner(type, attrs, marks) {
      var solid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var preserveWS = arguments.length > 4 ? arguments[4] : undefined;
      this.closeExtra();
      var top = this.top;
      top.match = top.match && top.match.matchType(type);
      var options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;
      var applyMarks = Mark$1.none;
      marks = marks.filter(function (m3) {
        if (top.type ? top.type.allowsMarkType(m3.type) : markMayApply(m3.type, type)) {
          applyMarks = m3.addToSet(applyMarks);
          return false;
        }
        return true;
      });
      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
      this.open++;
      return marks;
    };
    _proto22.closeExtra = function closeExtra() {
      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    };
    _proto22.finish = function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    };
    _proto22.sync = function sync(to) {
      for (var _i98 = this.open; _i98 >= 0; _i98--) if (this.nodes[_i98] == to) {
        this.open = _i98;
        return true;
      }
      return false;
    };
    _proto22.findAtPoint = function findAtPoint(parent, offset) {
      if (this.find) for (var _i99 = 0; _i99 < this.find.length; _i99++) {
        if (this.find[_i99].node == parent && this.find[_i99].offset == offset) this.find[_i99].pos = this.currentPos;
      }
    };
    _proto22.findInside = function findInside(parent) {
      if (this.find) for (var _i100 = 0; _i100 < this.find.length; _i100++) {
        if (this.find[_i100].pos == null && parent.nodeType == 1 && parent.contains(this.find[_i100].node)) this.find[_i100].pos = this.currentPos;
      }
    };
    _proto22.findAround = function findAround(parent, content, before) {
      if (parent != content && this.find) for (var _i101 = 0; _i101 < this.find.length; _i101++) {
        if (this.find[_i101].pos == null && parent.nodeType == 1 && parent.contains(this.find[_i101].node)) {
          var pos = content.compareDocumentPosition(this.find[_i101].node);
          if (pos & (before ? 2 : 4)) this.find[_i101].pos = this.currentPos;
        }
      }
    };
    _proto22.findInText = function findInText(textNode) {
      if (this.find) for (var _i102 = 0; _i102 < this.find.length; _i102++) {
        if (this.find[_i102].node == textNode) this.find[_i102].pos = this.currentPos - (textNode.nodeValue.length - this.find[_i102].offset);
      }
    };
    _proto22.matchesContext = function matchesContext(context) {
      var _this8 = this;
      if (context.indexOf("|") > -1) return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      var match = function (i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0) continue;
            for (; depth >= minDepth; depth--) if (match(i - 1, depth)) return true;
            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? _this8.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && !next.isInGroup(part)) return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    };
    _proto22.textblockFromContext = function textblockFromContext() {
      var $context = this.options.context;
      if ($context) for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
      }
      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) return type;
      }
    };
    return _createClass(ParseContext, [{
      key: "top",
      get: function () {
        return this.nodes[this.open];
      }
    }, {
      key: "currentPos",
      get: function () {
        this.closeExtra();
        var pos = 0;
        for (var _i103 = this.open; _i103 >= 0; _i103--) {
          var content = this.nodes[_i103].content;
          for (var j = content.length - 1; j >= 0; j--) pos += content[j].nodeSize;
          if (_i103) pos++;
        }
        return pos;
      }
    }]);
  }();
  function normalizeList(dom) {
    for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function copy(obj) {
    var copy2 = {};
    for (var prop in obj) copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    var nodes = nodeType.schema.nodes;
    var _loop18 = function () {
        var parent = nodes[name];
        if (!parent.allowsMarkType(markType)) return 0; // continue
        var seen = [],
          scan = function (match) {
            seen.push(match);
            for (var _i104 = 0; _i104 < match.edgeCount; _i104++) {
              var _match$edge = match.edge(_i104),
                type = _match$edge.type,
                next = _match$edge.next;
              if (type == nodeType) return true;
              if (seen.indexOf(next) < 0 && scan(next)) return true;
            }
          };
        if (scan(parent.contentMatch)) return {
          v: true
        };
      },
      _ret3;
    for (var name in nodes) {
      _ret3 = _loop18();
      if (_ret3 === 0) continue;
      if (_ret3) return _ret3.v;
    }
  }
  var DOMSerializer = /*#__PURE__*/function () {
    function DOMSerializer(nodes, marks) {
      this.nodes = nodes;
      this.marks = marks;
    }
    var _proto23 = DOMSerializer.prototype;
    _proto23.serializeFragment = function serializeFragment(fragment) {
      var _this9 = this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = arguments.length > 2 ? arguments[2] : undefined;
      if (!target) target = doc$1(options).createDocumentFragment();
      var top = target,
        active = [];
      fragment.forEach(function (node) {
        if (active.length || node.marks.length) {
          var keep = 0,
            rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];
            if (!_this9.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;
            keep++;
            rendered++;
          }
          while (keep < active.length) top = active.pop()[1];
          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];
            var markDOM = _this9.serializeMark(add, node.isInline, options);
            if (markDOM) {
              active.push([add, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(_this9.serializeNodeInner(node, options));
      });
      return target;
    };
    _proto23.serializeNodeInner = function serializeNodeInner(node, options) {
      var _renderSpec2 = _renderSpec(doc$1(options), this.nodes[node.type.name](node), null, node.attrs),
        dom = _renderSpec2.dom,
        contentDOM = _renderSpec2.contentDOM;
      if (contentDOM) {
        if (node.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }
      return dom;
    };
    _proto23.serializeNode = function serializeNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var dom = this.serializeNodeInner(node, options);
      for (var _i105 = node.marks.length - 1; _i105 >= 0; _i105--) {
        var wrap2 = this.serializeMark(node.marks[_i105], node.isInline, options);
        if (wrap2) {
          (wrap2.contentDOM || wrap2.dom).appendChild(dom);
          dom = wrap2.dom;
        }
      }
      return dom;
    };
    _proto23.serializeMark = function serializeMark(mark, inline2) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && _renderSpec(doc$1(options), toDOM(mark, inline2), null, mark.attrs);
    };
    DOMSerializer.renderSpec = function renderSpec(doc2, structure) {
      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var blockArraysIn = arguments.length > 3 ? arguments[3] : undefined;
      return _renderSpec(doc2, structure, xmlNS, blockArraysIn);
    };
    DOMSerializer.fromSchema = function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    };
    DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) result.text = function (node) {
        return node.text;
      };
      return result;
    };
    DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    };
    return DOMSerializer;
  }();
  function gatherToDOM(obj) {
    var result = {};
    for (var name in obj) {
      var toDOM = obj[name].spec.toDOM;
      if (toDOM) result[name] = toDOM;
    }
    return result;
  }
  function doc$1(options) {
    return options.document || window.document;
  }
  var suspiciousAttributeCache = /* @__PURE__ */new WeakMap();
  function suspiciousAttributes(attrs) {
    var value = suspiciousAttributeCache.get(attrs);
    if (value === void 0) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
    return value;
  }
  function suspiciousAttributesInner(attrs) {
    var result = null;
    function scan(value) {
      if (value && _typeof(value) == "object") {
        if (Array.isArray(value)) {
          if (typeof value[0] == "string") {
            if (!result) result = [];
            result.push(value);
          } else {
            for (var _i106 = 0; _i106 < value.length; _i106++) scan(value[_i106]);
          }
        } else {
          for (var prop in value) scan(value[prop]);
        }
      }
    }
    scan(attrs);
    return result;
  }
  function _renderSpec(doc2, structure, xmlNS, blockArraysIn) {
    if (typeof structure == "string") return {
      dom: doc2.createTextNode(structure)
    };
    if (structure.nodeType != null) return {
      dom: structure
    };
    if (structure.dom && structure.dom.nodeType != null) return structure;
    var tagName = structure[0],
      suspicious;
    if (typeof tagName != "string") throw new RangeError("Invalid array passed to renderSpec");
    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    var space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    var contentDOM;
    var dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    var attrs = structure[1],
      start = 1;
    if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start = 2;
      for (var name in attrs) if (attrs[name] != null) {
        var space2 = name.indexOf(" ");
        if (space2 > 0) dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);
      }
    }
    for (var _i107 = start; _i107 < structure.length; _i107++) {
      var child = structure[_i107];
      if (child === 0) {
        if (_i107 < structure.length - 1 || _i107 > start) throw new RangeError("Content hole must be the only child of its parent node");
        return {
          dom: dom,
          contentDOM: dom
        };
      } else {
        var _renderSpec3 = _renderSpec(doc2, child, xmlNS, blockArraysIn),
          inner = _renderSpec3.dom,
          innerContent = _renderSpec3.contentDOM;
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM) throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return {
      dom: dom,
      contentDOM: contentDOM
    };
  }
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index, offset) {
    return index + offset * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var DEL_BEFORE = 1,
    DEL_AFTER = 2,
    DEL_ACROSS = 4,
    DEL_SIDE = 8;
  var MapResult = /*#__PURE__*/function () {
    function MapResult(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    return _createClass(MapResult, [{
      key: "deleted",
      get: function () {
        return (this.delInfo & DEL_SIDE) > 0;
      }
    }, {
      key: "deletedBefore",
      get: function () {
        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
      }
    }, {
      key: "deletedAfter",
      get: function () {
        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
      }
    }, {
      key: "deletedAcross",
      get: function () {
        return (this.delInfo & DEL_ACROSS) > 0;
      }
    }]);
  }();
  var StepMap = /*#__PURE__*/function () {
    function StepMap(ranges) {
      var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && StepMap.empty) return StepMap.empty;
    }
    var _proto24 = StepMap.prototype;
    _proto24.recover = function recover(value) {
      var diff = 0,
        index = recoverIndex(value);
      if (!this.inverted) for (var _i108 = 0; _i108 < index; _i108++) diff += this.ranges[_i108 * 3 + 2] - this.ranges[_i108 * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    };
    _proto24.mapResult = function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    };
    _proto24.map = function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, true);
    };
    _proto24._map = function _map(pos, assoc, simple) {
      var diff = 0,
        oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (var _i109 = 0; _i109 < this.ranges.length; _i109 += 3) {
        var start = this.ranges[_i109] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[_i109 + oldIndex],
          newSize = this.ranges[_i109 + newIndex],
          end = start + oldSize;
        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) return result;
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(_i109 / 3, pos - start);
          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;
          return new MapResult(result, del, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    };
    _proto24.touches = function touches(pos, recover) {
      var diff = 0,
        index = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (var _i110 = 0; _i110 < this.ranges.length; _i110 += 3) {
        var start = this.ranges[_i110] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[_i110 + oldIndex],
          end = start + oldSize;
        if (pos <= end && _i110 == index * 3) return true;
        diff += this.ranges[_i110 + newIndex] - oldSize;
      }
      return false;
    };
    _proto24.forEach = function forEach(f) {
      var oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (var _i111 = 0, diff = 0; _i111 < this.ranges.length; _i111 += 3) {
        var start = this.ranges[_i111],
          oldStart = start - (this.inverted ? diff : 0),
          newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[_i111 + oldIndex],
          newSize = this.ranges[_i111 + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    };
    _proto24.invert = function invert() {
      return new StepMap(this.ranges, !this.inverted);
    };
    _proto24.toString = function toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    };
    StepMap.offset = function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    };
    return StepMap;
  }();
  StepMap.empty = new StepMap([]);
  var Mapping = /*#__PURE__*/function () {
    function Mapping() {
      var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var mirror = arguments.length > 1 ? arguments[1] : undefined;
      var from2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;
      this.maps = maps;
      this.mirror = mirror;
      this.from = from2;
      this.to = to;
    }
    var _proto25 = Mapping.prototype;
    _proto25.slice = function slice() {
      var from2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;
      return new Mapping(this.maps, this.mirror, from2, to);
    };
    _proto25.copy = function copy() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    };
    _proto25.appendMap = function appendMap(map3, mirrors) {
      this.to = this.maps.push(map3);
      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);
    };
    _proto25.appendMapping = function appendMapping(mapping) {
      for (var _i112 = 0, startSize = this.maps.length; _i112 < mapping.maps.length; _i112++) {
        var mirr = mapping.getMirror(_i112);
        this.appendMap(mapping.maps[_i112], mirr != null && mirr < _i112 ? startSize + mirr : void 0);
      }
    };
    _proto25.getMirror = function getMirror(n) {
      if (this.mirror) {
        for (var _i113 = 0; _i113 < this.mirror.length; _i113++) if (this.mirror[_i113] == n) return this.mirror[_i113 + (_i113 % 2 ? -1 : 1)];
      }
    };
    _proto25.setMirror = function setMirror(n, m3) {
      if (!this.mirror) this.mirror = [];
      this.mirror.push(n, m3);
    };
    _proto25.appendMappingInverted = function appendMappingInverted(mapping) {
      for (var _i114 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; _i114 >= 0; _i114--) {
        var mirr = mapping.getMirror(_i114);
        this.appendMap(mapping.maps[_i114].invert(), mirr != null && mirr > _i114 ? totalSize - mirr - 1 : void 0);
      }
    };
    _proto25.invert = function invert() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    };
    _proto25.map = function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (this.mirror) return this._map(pos, assoc, true);
      for (var _i115 = this.from; _i115 < this.to; _i115++) pos = this.maps[_i115].map(pos, assoc);
      return pos;
    };
    _proto25.mapResult = function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    };
    _proto25._map = function _map(pos, assoc, simple) {
      var delInfo = 0;
      for (var _i116 = this.from; _i116 < this.to; _i116++) {
        var map3 = this.maps[_i116],
          result = map3.mapResult(pos, assoc);
        if (result.recover != null) {
          var corr = this.getMirror(_i116);
          if (corr != null && corr > _i116 && corr < this.to) {
            _i116 = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    };
    return Mapping;
  }();
  var stepsByID = /* @__PURE__ */Object.create(null);
  var Step = /*#__PURE__*/function () {
    function Step() {}
    var _proto26 = Step.prototype;
    _proto26.getMap = function getMap() {
      return StepMap.empty;
    };
    _proto26.merge = function merge(other) {
      return null;
    };
    Step.fromJSON = function fromJSON(schema, json) {
      if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON");
      var type = stepsByID[json.stepType];
      if (!type) throw new RangeError("No step type " + json.stepType + " defined");
      return type.fromJSON(schema, json);
    };
    Step.jsonID = function jsonID(id, stepClass) {
      if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    };
    return Step;
  }();
  var StepResult = /*#__PURE__*/function () {
    function StepResult(doc2, failed) {
      this.doc = doc2;
      this.failed = failed;
    }
    StepResult.ok = function ok(doc2) {
      return new StepResult(doc2, null);
    };
    StepResult.fail = function fail(message) {
      return new StepResult(null, message);
    };
    StepResult.fromReplace = function fromReplace(doc2, from2, to, slice2) {
      try {
        return StepResult.ok(doc2.replace(from2, to, slice2));
      } catch (e) {
        if (e instanceof ReplaceError) return StepResult.fail(e.message);
        throw e;
      }
    };
    return StepResult;
  }();
  function mapFragment(fragment, f, parent) {
    var mapped = [];
    for (var _i117 = 0; _i117 < fragment.childCount; _i117++) {
      var child = fragment.child(_i117);
      if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline) child = f(child, parent, _i117);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = /*#__PURE__*/function (_Step) {
    function AddMarkStep(from2, to, mark) {
      var _this10;
      _this10 = _Step.call(this) || this;
      _this10.from = from2;
      _this10.to = to;
      _this10.mark = mark;
      return _this10;
    }
    _inheritsLoose(AddMarkStep, _Step);
    var _proto27 = AddMarkStep.prototype;
    _proto27.apply = function apply(doc2) {
      var _this11 = this;
      var oldSlice = doc2.slice(this.from, this.to),
        $from = doc2.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice2 = new Slice(mapFragment(oldSlice.content, function (node, parent2) {
        if (!node.isAtom || !parent2.type.allowsMarkType(_this11.mark.type)) return node;
        return node.mark(_this11.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice2);
    };
    _proto27.invert = function invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    };
    _proto27.map = function map(mapping) {
      var from2 = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos) return null;
      return new AddMarkStep(from2.pos, to.pos, this.mark);
    };
    _proto27.merge = function merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    };
    _proto27.toJSON = function toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    };
    AddMarkStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    };
    return AddMarkStep;
  }(Step);
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = /*#__PURE__*/function (_Step2) {
    function RemoveMarkStep(from2, to, mark) {
      var _this12;
      _this12 = _Step2.call(this) || this;
      _this12.from = from2;
      _this12.to = to;
      _this12.mark = mark;
      return _this12;
    }
    _inheritsLoose(RemoveMarkStep, _Step2);
    var _proto28 = RemoveMarkStep.prototype;
    _proto28.apply = function apply(doc2) {
      var _this13 = this;
      var oldSlice = doc2.slice(this.from, this.to);
      var slice2 = new Slice(mapFragment(oldSlice.content, function (node) {
        return node.mark(_this13.mark.removeFromSet(node.marks));
      }, doc2), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc2, this.from, this.to, slice2);
    };
    _proto28.invert = function invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    };
    _proto28.map = function map(mapping) {
      var from2 = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos) return null;
      return new RemoveMarkStep(from2.pos, to.pos, this.mark);
    };
    _proto28.merge = function merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    };
    _proto28.toJSON = function toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    };
    RemoveMarkStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    };
    return RemoveMarkStep;
  }(Step);
  Step.jsonID("removeMark", RemoveMarkStep);
  var AddNodeMarkStep = /*#__PURE__*/function (_Step3) {
    function AddNodeMarkStep(pos, mark) {
      var _this14;
      _this14 = _Step3.call(this) || this;
      _this14.pos = pos;
      _this14.mark = mark;
      return _this14;
    }
    _inheritsLoose(AddNodeMarkStep, _Step3);
    var _proto29 = AddNodeMarkStep.prototype;
    _proto29.apply = function apply(doc2) {
      var node = doc2.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      var updated2 = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated2), 0, node.isLeaf ? 0 : 1));
    };
    _proto29.invert = function invert(doc2) {
      var node = doc2.nodeAt(this.pos);
      if (node) {
        var newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (var _i118 = 0; _i118 < node.marks.length; _i118++) if (!node.marks[_i118].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[_i118]);
          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    };
    _proto29.map = function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
    };
    _proto29.toJSON = function toJSON() {
      return {
        stepType: "addNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    };
    AddNodeMarkStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    };
    return AddNodeMarkStep;
  }(Step);
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  var RemoveNodeMarkStep = /*#__PURE__*/function (_Step4) {
    function RemoveNodeMarkStep(pos, mark) {
      var _this15;
      _this15 = _Step4.call(this) || this;
      _this15.pos = pos;
      _this15.mark = mark;
      return _this15;
    }
    _inheritsLoose(RemoveNodeMarkStep, _Step4);
    var _proto30 = RemoveNodeMarkStep.prototype;
    _proto30.apply = function apply(doc2) {
      var node = doc2.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      var updated2 = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated2), 0, node.isLeaf ? 0 : 1));
    };
    _proto30.invert = function invert(doc2) {
      var node = doc2.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks)) return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    };
    _proto30.map = function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
    };
    _proto30.toJSON = function toJSON() {
      return {
        stepType: "removeNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    };
    RemoveNodeMarkStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    };
    return RemoveNodeMarkStep;
  }(Step);
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  var ReplaceStep = /*#__PURE__*/function (_Step5) {
    function ReplaceStep(from2, to, slice2) {
      var _this16;
      var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      _this16 = _Step5.call(this) || this;
      _this16.from = from2;
      _this16.to = to;
      _this16.slice = slice2;
      _this16.structure = structure;
      return _this16;
    }
    _inheritsLoose(ReplaceStep, _Step5);
    var _proto31 = ReplaceStep.prototype;
    _proto31.apply = function apply(doc2) {
      if (this.structure && contentBetween(doc2, this.from, this.to)) return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
    };
    _proto31.getMap = function getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    };
    _proto31.invert = function invert(doc2) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
    };
    _proto31.map = function map(mapping) {
      var from2 = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from2.deletedAcross && to.deletedAcross) return null;
      return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
    };
    _proto31.merge = function merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var _slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new ReplaceStep(other.from, this.to, _slice, this.structure);
      } else {
        return null;
      }
    };
    _proto31.toJSON = function toJSON() {
      var json = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    };
    ReplaceStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    };
    return ReplaceStep;
  }(Step);
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = /*#__PURE__*/function (_Step6) {
    function ReplaceAroundStep(from2, to, gapFrom, gapTo, slice2, insert) {
      var _this17;
      var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      _this17 = _Step6.call(this) || this;
      _this17.from = from2;
      _this17.to = to;
      _this17.gapFrom = gapFrom;
      _this17.gapTo = gapTo;
      _this17.slice = slice2;
      _this17.insert = insert;
      _this17.structure = structure;
      return _this17;
    }
    _inheritsLoose(ReplaceAroundStep, _Step6);
    var _proto32 = ReplaceAroundStep.prototype;
    _proto32.apply = function apply(doc2) {
      if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) return StepResult.fail("Structure gap-replace would overwrite content");
      var gap = doc2.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) return StepResult.fail("Gap is not a flat range");
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc2, this.from, this.to, inserted);
    };
    _proto32.getMap = function getMap() {
      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    };
    _proto32.invert = function invert(doc2) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    };
    _proto32.map = function map(mapping) {
      var from2 = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      var gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
      var gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
      if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos) return null;
      return new ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    };
    _proto32.toJSON = function toJSON() {
      var json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    };
    ReplaceAroundStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    };
    return ReplaceAroundStep;
  }(Step);
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc2, from2, to) {
    var $from = doc2.resolve(from2),
      dist = to - from2,
      depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      var next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf) return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function _addMark(tr, from2, to, mark) {
    var removed = [],
      added = [];
    var removing, adding;
    tr.doc.nodesBetween(from2, to, function (node, pos, parent) {
      if (!node.isInline) return;
      var marks = node.marks;
      if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
        var start = Math.max(pos, from2),
          end = Math.min(pos + node.nodeSize, to);
        var newSet = mark.addToSet(marks);
        for (var _i119 = 0; _i119 < marks.length; _i119++) {
          if (!marks[_i119].isInSet(newSet)) {
            if (removing && removing.to == start && removing.mark.eq(marks[_i119])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[_i119]));
          }
        }
        if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));
      }
    });
    removed.forEach(function (s) {
      return tr.step(s);
    });
    added.forEach(function (s) {
      return tr.step(s);
    });
  }
  function _removeMark(tr, from2, to, mark) {
    var matched = [],
      step = 0;
    tr.doc.nodesBetween(from2, to, function (node, pos) {
      if (!node.isInline) return;
      step++;
      var toRemove = null;
      if (mark instanceof MarkType) {
        var set = node.marks,
          found2;
        while (found2 = mark.isInSet(set)) {
          (toRemove || (toRemove = [])).push(found2);
          set = found2.removeFromSet(set);
        }
      } else if (mark) {
        if (mark.isInSet(node.marks)) toRemove = [mark];
      } else {
        toRemove = node.marks;
      }
      if (toRemove && toRemove.length) {
        var end = Math.min(pos + node.nodeSize, to);
        for (var _i120 = 0; _i120 < toRemove.length; _i120++) {
          var style2 = toRemove[_i120],
            _found = void 0;
          for (var j = 0; j < matched.length; j++) {
            var m3 = matched[j];
            if (m3.step == step - 1 && style2.eq(matched[j].style)) _found = m3;
          }
          if (_found) {
            _found.to = end;
            _found.step = step;
          } else {
            matched.push({
              style: style2,
              from: Math.max(pos, from2),
              to: end,
              step: step
            });
          }
        }
      }
    });
    matched.forEach(function (m3) {
      return tr.step(new RemoveMarkStep(m3.from, m3.to, m3.style));
    });
  }
  function _clearIncompatible(tr, pos, parentType) {
    var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;
    var clearNewlines = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var node = tr.doc.nodeAt(pos);
    var replSteps = [],
      cur = pos + 1;
    for (var _i121 = 0; _i121 < node.childCount; _i121++) {
      var child = node.child(_i121),
        end = cur + child.nodeSize;
      var allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end, Slice.empty));
      } else {
        match = allowed;
        for (var j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
        if (clearNewlines && child.isText && parentType.whitespace != "pre") {
          var m3 = void 0,
            newline = /\r?\n|\r/g,
            slice2 = void 0;
          while (m3 = newline.exec(child.text)) {
            if (!slice2) slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m3.index, cur + m3.index + m3[0].length, slice2));
          }
        }
      }
      cur = end;
    }
    if (!match.validEnd) {
      var fill = match.fillBefore(Fragment.empty, true);
      tr.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (var _i122 = replSteps.length - 1; _i122 >= 0; _i122--) tr.step(replSteps[_i122]);
  }
  function canCut(node, start, end) {
    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
  }
  function liftTarget(range) {
    var parent = range.parent;
    var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (var depth = range.depth;; --depth) {
      var node = range.$from.node(depth);
      var index = range.$from.index(depth),
        endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;
      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;
    }
    return null;
  }
  function lift$2(tr, range, target) {
    var $from = range.$from,
      $to = range.$to,
      depth = range.depth;
    var gapStart = $from.before(depth + 1),
      gapEnd = $to.after(depth + 1);
    var start = gapStart,
      end = gapEnd;
    var before = Fragment.empty,
      openStart = 0;
    for (var d = depth, splitting = false; d > target; d--) if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
    var after = Fragment.empty,
      openEnd = 0;
    for (var _d3 = depth, _splitting = false; _d3 > target; _d3--) if (_splitting || $to.after(_d3 + 1) < $to.end(_d3)) {
      _splitting = true;
      after = Fragment.from($to.node(_d3).copy(after));
      openEnd++;
    } else {
      end++;
    }
    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;
    var around = findWrappingOutside(range, nodeType);
    var inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner) return null;
    return around.map(withAttrs).concat({
      type: nodeType,
      attrs: attrs
    }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return {
      type: type,
      attrs: null
    };
  }
  function findWrappingOutside(range, type) {
    var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
    var around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around) return null;
    var outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
    var inner = parent.child(startIndex);
    var inside = type.contentMatch.findWrapping(inner.type);
    if (!inside) return null;
    var lastType = inside.length ? inside[inside.length - 1] : type;
    var innerMatch = lastType.contentMatch;
    for (var _i123 = startIndex; innerMatch && _i123 < endIndex; _i123++) innerMatch = innerMatch.matchType(parent.child(_i123).type);
    if (!innerMatch || !innerMatch.validEnd) return null;
    return inside;
  }
  function _wrap(tr, range, wrappers) {
    var content = Fragment.empty;
    for (var _i124 = wrappers.length - 1; _i124 >= 0; _i124--) {
      if (content.size) {
        var match = wrappers[_i124].type.contentMatch.matchFragment(content);
        if (!match || !match.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content = Fragment.from(wrappers[_i124].type.create(wrappers[_i124].attrs, content));
    }
    var start = range.start,
      end = range.end;
    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
  }
  function setBlockType$1(tr, from2, to, type, attrs) {
    if (!type.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
    var mapFrom = tr.steps.length;
    tr.doc.nodesBetween(from2, to, function (node, pos) {
      var attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
      if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
        var convertNewlines = null;
        if (type.schema.linebreakReplacement) {
          var pre = type.whitespace == "pre",
            supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
          if (pre && !supportLinebreak) convertNewlines = false;else if (!pre && supportLinebreak) convertNewlines = true;
        }
        if (convertNewlines === false) replaceLinebreaks(tr, node, pos, mapFrom);
        _clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
        var mapping = tr.mapping.slice(mapFrom);
        var startM = mapping.map(pos, 1),
          endM = mapping.map(pos + node.nodeSize, 1);
        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
        if (convertNewlines === true) replaceNewlines(tr, node, pos, mapFrom);
        return false;
      }
    });
  }
  function replaceNewlines(tr, node, pos, mapFrom) {
    node.forEach(function (child, offset) {
      if (child.isText) {
        var m3,
          newline = /\r?\n|\r/g;
        while (m3 = newline.exec(child.text)) {
          var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m3.index);
          tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function replaceLinebreaks(tr, node, pos, mapFrom) {
    node.forEach(function (child, offset) {
      if (child.type == child.type.schema.linebreakReplacement) {
        var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
        tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
      }
    });
  }
  function canChangeType(doc2, pos, type) {
    var $pos = doc2.resolve(pos),
      index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
  }
  function _setNodeMarkup(tr, pos, type, attrs, marks) {
    var node = tr.doc.nodeAt(pos);
    if (!node) throw new RangeError("No node at given position");
    if (!type) type = node.type;
    var newNode = type.create(attrs, null, marks || node.marks);
    if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);
    if (!type.validContent(node.content)) throw new RangeError("Invalid content for node type " + type.name);
    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  }
  function canSplit(doc2, pos) {
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
    var $pos = doc2.resolve(pos),
      base2 = $pos.depth - depth;
    var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;
    for (var d = $pos.depth - 1, _i125 = depth - 2; d > base2; d--, _i125--) {
      var node = $pos.node(d),
        index2 = $pos.index(d);
      if (node.type.spec.isolating) return false;
      var rest = node.content.cutByIndex(index2, node.childCount);
      var overrideChild = typesAfter && typesAfter[_i125 + 1];
      if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      var after = typesAfter && typesAfter[_i125] || node;
      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest)) return false;
    }
    var index = $pos.indexAfter(base2);
    var baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  function _split(tr, pos) {
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
    var $pos = tr.doc.resolve(pos),
      before = Fragment.empty,
      after = Fragment.empty;
    for (var d = $pos.depth, e = $pos.depth - depth, _i126 = depth - 1; d > e; d--, _i126--) {
      before = Fragment.from($pos.node(d).copy(before));
      var typeAfter = typesAfter && typesAfter[_i126];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc2, pos) {
    var $pos = doc2.resolve(pos),
      index = $pos.index();
    return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
  }
  function canAppendWithSubstitutedLinebreaks(a, b) {
    if (!b.content.size) a.type.compatibleContent(b.type);
    var match = a.contentMatchAt(a.childCount);
    var linebreakReplacement = a.type.schema.linebreakReplacement;
    for (var _i127 = 0; _i127 < b.childCount; _i127++) {
      var child = b.child(_i127);
      var type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
      match = match.matchType(type);
      if (!match) return false;
      if (!a.type.allowsMarks(child.marks)) return false;
    }
    return match.validEnd;
  }
  function joinable(a, b) {
    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
  }
  function joinPoint(doc2, pos) {
    var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    var $pos = doc2.resolve(pos);
    for (var d = $pos.depth;; d--) {
      var before = void 0,
        after = void 0,
        index = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index++;
        after = $pos.node(d).maybeChild(index);
      } else {
        before = $pos.node(d).maybeChild(index - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;
      if (d == 0) break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function _join(tr, pos, depth) {
    var convertNewlines = null;
    var linebreakReplacement = tr.doc.type.schema.linebreakReplacement;
    var $before = tr.doc.resolve(pos - depth),
      beforeType = $before.node().type;
    if (linebreakReplacement && beforeType.inlineContent) {
      var pre = beforeType.whitespace == "pre";
      var supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
      if (pre && !supportLinebreak) convertNewlines = false;else if (!pre && supportLinebreak) convertNewlines = true;
    }
    var mapFrom = tr.steps.length;
    if (convertNewlines === false) {
      var $after = tr.doc.resolve(pos + depth);
      replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
    }
    if (beforeType.inlineContent) _clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
    var mapping = tr.mapping.slice(mapFrom),
      start = mapping.map(pos - depth);
    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
    if (convertNewlines === true) {
      var $full = tr.doc.resolve(start);
      replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
    }
    return tr;
  }
  function insertPoint(doc2, pos, nodeType) {
    var $pos = doc2.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;
    if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);
      if (index > 0) return null;
    }
    if ($pos.parentOffset == $pos.parent.content.size) for (var _d4 = $pos.depth - 1; _d4 >= 0; _d4--) {
      var _index = $pos.indexAfter(_d4);
      if ($pos.node(_d4).canReplaceWith(_index, _index, nodeType)) return $pos.after(_d4 + 1);
      if (_index < $pos.node(_d4).childCount) return null;
    }
    return null;
  }
  function dropPoint(doc2, pos, slice2) {
    var $pos = doc2.resolve(pos);
    if (!slice2.content.size) return pos;
    var content = slice2.content;
    for (var _i128 = 0; _i128 < slice2.openStart; _i128++) content = content.firstChild.content;
    for (var pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
      for (var d = $pos.depth; d >= 0; d--) {
        var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        var parent = $pos.node(d),
          fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content);
        } else {
          var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc2, from2) {
    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from2;
    var slice2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Slice.empty;
    if (from2 == to && !slice2.size) return null;
    var $from = doc2.resolve(from2),
      $to = doc2.resolve(to);
    if (fitsTrivially($from, $to, slice2)) return new ReplaceStep(from2, to, slice2);
    return new Fitter($from, $to, slice2).fit();
  }
  function fitsTrivially($from, $to, slice2) {
    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
  }
  var Fitter = /*#__PURE__*/function () {
    function Fitter($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (var _i129 = 0; _i129 <= $from.depth; _i129++) {
        var node = $from.node(_i129);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(_i129))
        });
      }
      for (var _i130 = $from.depth; _i130 > 0; _i130--) this.placed = Fragment.from($from.node(_i130).copy(this.placed));
    }
    var _proto33 = Fitter.prototype;
    _proto33.fit = function fit() {
      while (this.unplaced.size) {
        var fit = this.findFittable();
        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();
      }
      var moveInline = this.mustMoveInline(),
        placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from,
        $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) return null;
      var content = this.placed,
        openStart = $from.depth,
        openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      var slice2 = new Slice(content, openStart, openEnd);
      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
      if (slice2.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice2);
      return null;
    };
    _proto33.findFittable = function findFittable() {
      var startDepth = this.unplaced.openStart;
      for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        var node = cur.firstChild;
        if (cur.childCount > 1) openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0,
            parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          var first2 = fragment.firstChild;
          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var _this$frontier$fronti = this.frontier[frontierDepth],
              type = _this$frontier$fronti.type,
              match = _this$frontier$fronti.match,
              wrap2 = void 0,
              inject2 = null;
            if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject2 = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              inject: inject2
            };else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              wrap: wrap2
            };
            if (parent && match.matchType(parent.type)) break;
          }
        }
      }
    };
    _proto33.openMore = function openMore() {
      var _this$unplaced = this.unplaced,
        content = _this$unplaced.content,
        openStart = _this$unplaced.openStart,
        openEnd = _this$unplaced.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) return false;
      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    };
    _proto33.dropNode = function dropNode() {
      var _this$unplaced2 = this.unplaced,
        content = _this$unplaced2.content,
        openStart = _this$unplaced2.openStart,
        openEnd = _this$unplaced2.openEnd;
      var inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    };
    _proto33.placeNodes = function placeNodes(_ref68) {
      var sliceDepth = _ref68.sliceDepth,
        frontierDepth = _ref68.frontierDepth,
        parent = _ref68.parent,
        inject2 = _ref68.inject,
        wrap2 = _ref68.wrap;
      while (this.depth > frontierDepth) this.closeFrontierNode();
      if (wrap2) for (var _i131 = 0; _i131 < wrap2.length; _i131++) this.openFrontierNode(wrap2[_i131]);
      var slice2 = this.unplaced,
        fragment = parent ? parent.content : slice2.content;
      var openStart = slice2.openStart - sliceDepth;
      var taken = 0,
        add = [];
      var _this$frontier$fronti2 = this.frontier[frontierDepth],
        match = _this$frontier$fronti2.match,
        type = _this$frontier$fronti2.type;
      if (inject2) {
        for (var _i132 = 0; _i132 < inject2.childCount; _i132++) add.push(inject2.child(_i132));
        match = match.matchFragment(inject2);
      }
      var openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
      while (taken < fragment.childCount) {
        var next = fragment.child(taken),
          matches2 = match.matchType(next.type);
        if (!matches2) break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      var toEnd = taken == fragment.childCount;
      if (!toEnd) openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();
      for (var _i133 = 0, cur = fragment; _i133 < openEndCount; _i133++) {
        var node = cur.lastChild;
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt(node.childCount)
        });
        cur = node.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
    };
    _proto33.mustMoveInline = function mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      var top = this.frontier[this.depth],
        level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;
      var depth = this.$to.depth,
        after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth)) ++after;
      return after;
    };
    _proto33.findCloseLevel = function findCloseLevel($to) {
      scan: for (var _i134 = Math.min(this.depth, $to.depth); _i134 >= 0; _i134--) {
        var _this$frontier$_i = this.frontier[_i134],
          match = _this$frontier$_i.match,
          type = _this$frontier$_i.type;
        var dropInner = _i134 < $to.depth && $to.end(_i134 + 1) == $to.pos + ($to.depth - (_i134 + 1));
        var fit = contentAfterFits($to, _i134, type, match, dropInner);
        if (!fit) continue;
        for (var d = _i134 - 1; d >= 0; d--) {
          var _this$frontier$d = this.frontier[d],
            match2 = _this$frontier$d.match,
            type2 = _this$frontier$d.type;
          var matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount) continue scan;
        }
        return {
          depth: _i134,
          fit: fit,
          move: dropInner ? $to.doc.resolve($to.after(_i134 + 1)) : $to
        };
      }
    };
    _proto33.close = function close($to) {
      var close2 = this.findCloseLevel($to);
      if (!close2) return null;
      while (this.depth > close2.depth) this.closeFrontierNode();
      if (close2.fit.childCount) this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (var d = close2.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d),
          add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to;
    };
    _proto33.openFrontierNode = function openFrontierNode(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
      this.frontier.push({
        type: type,
        match: type.contentMatch
      });
    };
    _proto33.closeFrontierNode = function closeFrontierNode() {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(Fragment.empty, true);
      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);
    };
    return _createClass(Fitter, [{
      key: "depth",
      get: function () {
        return this.frontier.length - 1;
      }
    }]);
  }();
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0) return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
  }
  function contentAt(fragment, depth) {
    for (var _i135 = 0; _i135 < depth; _i135++) fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0) return node;
    var frag = node.content;
    if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    var node = $to.node(depth),
      index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type)) return null;
    var fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
  }
  function invalidMarks(type, fragment, start) {
    for (var _i136 = start; _i136 < fragment.childCount; _i136++) if (!type.allowsMarks(fragment.child(_i136).marks)) return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function _replaceRange(tr, from2, to, slice2) {
    if (!slice2.size) return tr.deleteRange(from2, to);
    var $from = tr.doc.resolve(from2),
      $to = tr.doc.resolve(to);
    if (fitsTrivially($from, $to, slice2)) return tr.step(new ReplaceStep(from2, to, slice2));
    var targetDepths = coveredDepths($from, tr.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
    var preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      var spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating) break;
      if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
    }
    var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    var leftNodes = [],
      preferredDepth = slice2.openStart;
    for (var content = slice2.content, _i137 = 0;; _i137++) {
      var node = content.firstChild;
      leftNodes.push(node);
      if (_i137 == slice2.openStart) break;
      content = node.content;
    }
    for (var _d5 = preferredDepth - 1; _d5 >= 0; _d5--) {
      var leftNode = leftNodes[_d5],
        def2 = definesContent(leftNode.type);
      if (def2 && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = _d5;else if (def2 || !leftNode.type.isTextblock) break;
    }
    for (var j = slice2.openStart; j >= 0; j--) {
      var openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
      var insert = leftNodes[openDepth];
      if (!insert) continue;
      for (var _i138 = 0; _i138 < targetDepths.length; _i138++) {
        var targetDepth = targetDepths[(_i138 + preferredTargetIndex) % targetDepths.length],
          expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        var parent = $from.node(targetDepth - 1),
          index = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
      }
    }
    var startSteps = tr.steps.length;
    for (var _i139 = targetDepths.length - 1; _i139 >= 0; _i139--) {
      tr.replace(from2, to, slice2);
      if (tr.steps.length > startSteps) break;
      var depth = targetDepths[_i139];
      if (depth < 0) continue;
      from2 = $from.before(depth);
      to = $to.after(depth);
    }
  }
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      var first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      var match = parent.contentMatchAt(0);
      var start = match.fillBefore(fragment).append(fragment);
      fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  function _replaceRangeWith(tr, from2, to, node) {
    if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
      var point = insertPoint(tr.doc, from2, node.type);
      if (point != null) from2 = to = point;
    }
    tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
  }
  function deleteRange$1(tr, from2, to) {
    var $from = tr.doc.resolve(from2),
      $to = tr.doc.resolve(to);
    var covered = coveredDepths($from, $to);
    for (var _i140 = 0; _i140 < covered.length; _i140++) {
      var depth = covered[_i140],
        last = _i140 == covered.length - 1;
      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr.delete($from.before(depth), $to.after(depth));
    }
    for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1))) return tr.delete($from.before(d), to);
    }
    tr.delete(from2, to);
  }
  function coveredDepths($from, $to) {
    var result = [],
      minDepth = Math.min($from.depth, $to.depth);
    for (var d = minDepth; d >= 0; d--) {
      var start = $from.start(d);
      if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;
      if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);
    }
    return result;
  }
  var AttrStep = /*#__PURE__*/function (_Step7) {
    function AttrStep(pos, attr, value) {
      var _this18;
      _this18 = _Step7.call(this) || this;
      _this18.pos = pos;
      _this18.attr = attr;
      _this18.value = value;
      return _this18;
    }
    _inheritsLoose(AttrStep, _Step7);
    var _proto34 = AttrStep.prototype;
    _proto34.apply = function apply(doc2) {
      var node = doc2.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at attribute step's position");
      var attrs = /* @__PURE__ */Object.create(null);
      for (var name in node.attrs) attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      var updated2 = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated2), 0, node.isLeaf ? 0 : 1));
    };
    _proto34.getMap = function getMap() {
      return StepMap.empty;
    };
    _proto34.invert = function invert(doc2) {
      return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
    };
    _proto34.map = function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
    };
    _proto34.toJSON = function toJSON() {
      return {
        stepType: "attr",
        pos: this.pos,
        attr: this.attr,
        value: this.value
      };
    };
    AttrStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new AttrStep(json.pos, json.attr, json.value);
    };
    return AttrStep;
  }(Step);
  Step.jsonID("attr", AttrStep);
  var DocAttrStep = /*#__PURE__*/function (_Step8) {
    function DocAttrStep(attr, value) {
      var _this19;
      _this19 = _Step8.call(this) || this;
      _this19.attr = attr;
      _this19.value = value;
      return _this19;
    }
    _inheritsLoose(DocAttrStep, _Step8);
    var _proto35 = DocAttrStep.prototype;
    _proto35.apply = function apply(doc2) {
      var attrs = /* @__PURE__ */Object.create(null);
      for (var name in doc2.attrs) attrs[name] = doc2.attrs[name];
      attrs[this.attr] = this.value;
      var updated2 = doc2.type.create(attrs, doc2.content, doc2.marks);
      return StepResult.ok(updated2);
    };
    _proto35.getMap = function getMap() {
      return StepMap.empty;
    };
    _proto35.invert = function invert(doc2) {
      return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
    };
    _proto35.map = function map(mapping) {
      return this;
    };
    _proto35.toJSON = function toJSON() {
      return {
        stepType: "docAttr",
        attr: this.attr,
        value: this.value
      };
    };
    DocAttrStep.fromJSON = function fromJSON(schema, json) {
      if (typeof json.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new DocAttrStep(json.attr, json.value);
    };
    return DocAttrStep;
  }(Step);
  Step.jsonID("docAttr", DocAttrStep);
  var TransformError = /*#__PURE__*/function (_Error3) {
    function TransformError() {
      return _Error3.apply(this, arguments) || this;
    }
    _inheritsLoose(TransformError, _Error3);
    return TransformError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  TransformError = function TransformError2(message) {
    var err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  var Transform = /*#__PURE__*/function () {
    function Transform(doc2) {
      this.doc = doc2;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    }
    var _proto36 = Transform.prototype;
    _proto36.step = function step(_step28) {
      var result = this.maybeStep(_step28);
      if (result.failed) throw new TransformError(result.failed);
      return this;
    };
    _proto36.maybeStep = function maybeStep(step) {
      var result = step.apply(this.doc);
      if (!result.failed) this.addStep(step, result.doc);
      return result;
    };
    _proto36.addStep = function addStep(step, doc2) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc2;
    };
    _proto36.replace = function replace(from2) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from2;
      var slice2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Slice.empty;
      var step = replaceStep(this.doc, from2, to, slice2);
      if (step) this.step(step);
      return this;
    };
    _proto36.replaceWith = function replaceWith(from2, to, content) {
      return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
    };
    _proto36.delete = function _delete(from2, to) {
      return this.replace(from2, to, Slice.empty);
    };
    _proto36.insert = function insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    };
    _proto36.replaceRange = function replaceRange(from2, to, slice2) {
      _replaceRange(this, from2, to, slice2);
      return this;
    };
    _proto36.replaceRangeWith = function replaceRangeWith(from2, to, node) {
      _replaceRangeWith(this, from2, to, node);
      return this;
    };
    _proto36.deleteRange = function deleteRange(from2, to) {
      deleteRange$1(this, from2, to);
      return this;
    };
    _proto36.lift = function lift(range, target) {
      lift$2(this, range, target);
      return this;
    };
    _proto36.join = function join(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      _join(this, pos, depth);
      return this;
    };
    _proto36.wrap = function wrap(range, wrappers) {
      _wrap(this, range, wrappers);
      return this;
    };
    _proto36.setBlockType = function setBlockType(from2) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from2;
      var type = arguments.length > 2 ? arguments[2] : undefined;
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      setBlockType$1(this, from2, to, type, attrs);
      return this;
    };
    _proto36.setNodeMarkup = function setNodeMarkup(pos, type) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      _setNodeMarkup(this, pos, type, attrs, marks);
      return this;
    };
    _proto36.setNodeAttribute = function setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    };
    _proto36.setDocAttribute = function setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    };
    _proto36.addNodeMark = function addNodeMark(pos, mark) {
      this.step(new AddNodeMarkStep(pos, mark));
      return this;
    };
    _proto36.removeNodeMark = function removeNodeMark(pos, mark) {
      if (!(mark instanceof Mark$1)) {
        var node = this.doc.nodeAt(pos);
        if (!node) throw new RangeError("No node at position " + pos);
        mark = mark.isInSet(node.marks);
        if (!mark) return this;
      }
      this.step(new RemoveNodeMarkStep(pos, mark));
      return this;
    };
    _proto36.split = function split(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;
      _split(this, pos, depth, typesAfter);
      return this;
    };
    _proto36.addMark = function addMark(from2, to, mark) {
      _addMark(this, from2, to, mark);
      return this;
    };
    _proto36.removeMark = function removeMark(from2, to, mark) {
      _removeMark(this, from2, to, mark);
      return this;
    };
    _proto36.clearIncompatible = function clearIncompatible(pos, parentType, match) {
      _clearIncompatible(this, pos, parentType, match);
      return this;
    };
    return _createClass(Transform, [{
      key: "before",
      get: function () {
        return this.docs.length ? this.docs[0] : this.doc;
      }
    }, {
      key: "docChanged",
      get: function () {
        return this.steps.length > 0;
      }
    }]);
  }();
  var classesById = /* @__PURE__ */Object.create(null);
  var Selection = /*#__PURE__*/function () {
    function Selection($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    var _proto37 = Selection.prototype;
    _proto37.content = function content() {
      return this.$from.doc.slice(this.from, this.to, true);
    };
    _proto37.replace = function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;
      var lastNode = content.content.lastChild,
        lastParent = null;
      for (var _i141 = 0; _i141 < content.openEnd; _i141++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      var mapFrom = tr.steps.length,
        ranges = this.ranges;
      for (var _i142 = 0; _i142 < ranges.length; _i142++) {
        var _ranges$_i = ranges[_i142],
          $from = _ranges$_i.$from,
          $to = _ranges$_i.$to,
          mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i142 ? Slice.empty : content);
        if (_i142 == 0) selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    };
    _proto37.replaceWith = function replaceWith(tr, node) {
      var mapFrom = tr.steps.length,
        ranges = this.ranges;
      for (var _i143 = 0; _i143 < ranges.length; _i143++) {
        var _ranges$_i2 = ranges[_i143],
          $from = _ranges$_i2.$from,
          $to = _ranges$_i2.$to,
          mapping = tr.mapping.slice(mapFrom);
        var _from2 = mapping.map($from.pos),
          to = mapping.map($to.pos);
        if (_i143) {
          tr.deleteRange(_from2, to);
        } else {
          tr.replaceRangeWith(_from2, to, node);
          selectionToInsertionEnd$1(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    };
    Selection.findFrom = function findFrom($pos, dir) {
      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) return inner;
      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2) return found2;
      }
      return null;
    };
    Selection.near = function near($pos) {
      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    };
    Selection.atStart = function atStart(doc2) {
      return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
    };
    Selection.atEnd = function atEnd(doc2) {
      return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
    };
    Selection.fromJSON = function fromJSON(doc2, json) {
      if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON");
      var cls = classesById[json.type];
      if (!cls) throw new RangeError("No selection type " + json.type + " defined");
      return cls.fromJSON(doc2, json);
    };
    Selection.jsonID = function jsonID(id, selectionClass) {
      if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    };
    _proto37.getBookmark = function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    };
    return _createClass(Selection, [{
      key: "anchor",
      get: function () {
        return this.$anchor.pos;
      }
    }, {
      key: "head",
      get: function () {
        return this.$head.pos;
      }
    }, {
      key: "from",
      get: function () {
        return this.$from.pos;
      }
    }, {
      key: "to",
      get: function () {
        return this.$to.pos;
      }
    }, {
      key: "$from",
      get: function () {
        return this.ranges[0].$from;
      }
    }, {
      key: "$to",
      get: function () {
        return this.ranges[0].$to;
      }
    }, {
      key: "empty",
      get: function () {
        var ranges = this.ranges;
        for (var _i144 = 0; _i144 < ranges.length; _i144++) if (ranges[_i144].$from.pos != ranges[_i144].$to.pos) return false;
        return true;
      }
    }]);
  }();
  Selection.prototype.visible = true;
  var SelectionRange = function SelectionRange($from, $to) {
    this.$from = $from;
    this.$to = $to;
  };
  var warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  var TextSelection = /*#__PURE__*/function (_Selection) {
    function TextSelection($anchor) {
      var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;
      checkTextSelection($anchor);
      checkTextSelection($head);
      return _Selection.call(this, $anchor, $head) || this;
    }
    _inheritsLoose(TextSelection, _Selection);
    var _proto38 = TextSelection.prototype;
    _proto38.map = function map(doc2, mapping) {
      var $head = doc2.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) return Selection.near($head);
      var $anchor = doc2.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    };
    _proto38.replace = function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;
      _Selection.prototype.replace.call(this, tr, content);
      if (content == Slice.empty) {
        var marks = this.$from.marksAcross(this.$to);
        if (marks) tr.ensureMarks(marks);
      }
    };
    _proto38.eq = function eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    };
    _proto38.getBookmark = function getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    };
    _proto38.toJSON = function toJSON() {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    };
    TextSelection.fromJSON = function fromJSON(doc2, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
    };
    TextSelection.create = function create(doc2, anchor) {
      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;
      var $anchor = doc2.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
    };
    TextSelection.between = function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        var found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2) $head = found2.$head;else return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
        }
      }
      return new TextSelection($anchor, $head);
    };
    return _createClass(TextSelection, [{
      key: "$cursor",
      get: function () {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
    }]);
  }(Selection);
  Selection.jsonID("text", TextSelection);
  var TextBookmark = /*#__PURE__*/function () {
    function TextBookmark(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    }
    var _proto39 = TextBookmark.prototype;
    _proto39.map = function map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    };
    _proto39.resolve = function resolve(doc2) {
      return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
    };
    return TextBookmark;
  }();
  var NodeSelection = /*#__PURE__*/function (_Selection2) {
    function NodeSelection($pos) {
      var _this20;
      var node = $pos.nodeAfter;
      var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
      _this20 = _Selection2.call(this, $pos, $end) || this;
      _this20.node = node;
      return _this20;
    }
    _inheritsLoose(NodeSelection, _Selection2);
    var _proto40 = NodeSelection.prototype;
    _proto40.map = function map(doc2, mapping) {
      var _mapping$mapResult = mapping.mapResult(this.anchor),
        deleted = _mapping$mapResult.deleted,
        pos = _mapping$mapResult.pos;
      var $pos = doc2.resolve(pos);
      if (deleted) return Selection.near($pos);
      return new NodeSelection($pos);
    };
    _proto40.content = function content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    };
    _proto40.eq = function eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    };
    _proto40.toJSON = function toJSON() {
      return {
        type: "node",
        anchor: this.anchor
      };
    };
    _proto40.getBookmark = function getBookmark() {
      return new NodeBookmark(this.anchor);
    };
    NodeSelection.fromJSON = function fromJSON(doc2, json) {
      if (typeof json.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc2.resolve(json.anchor));
    };
    NodeSelection.create = function create(doc2, from2) {
      return new NodeSelection(doc2.resolve(from2));
    };
    NodeSelection.isSelectable = function isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    };
    return NodeSelection;
  }(Selection);
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = /*#__PURE__*/function () {
    function NodeBookmark(anchor) {
      this.anchor = anchor;
    }
    var _proto41 = NodeBookmark.prototype;
    _proto41.map = function map(mapping) {
      var _mapping$mapResult2 = mapping.mapResult(this.anchor),
        deleted = _mapping$mapResult2.deleted,
        pos = _mapping$mapResult2.pos;
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    };
    _proto41.resolve = function resolve(doc2) {
      var $pos = doc2.resolve(this.anchor),
        node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);
      return Selection.near($pos);
    };
    return NodeBookmark;
  }();
  var AllSelection = /*#__PURE__*/function (_Selection3) {
    function AllSelection(doc2) {
      return _Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size)) || this;
    }
    _inheritsLoose(AllSelection, _Selection3);
    var _proto42 = AllSelection.prototype;
    _proto42.replace = function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;
      if (content == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        var sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection)) tr.setSelection(sel);
      } else {
        _Selection3.prototype.replace.call(this, tr, content);
      }
    };
    _proto42.toJSON = function toJSON() {
      return {
        type: "all"
      };
    };
    AllSelection.fromJSON = function fromJSON(doc2) {
      return new AllSelection(doc2);
    };
    _proto42.map = function map(doc2) {
      return new AllSelection(doc2);
    };
    _proto42.eq = function eq(other) {
      return other instanceof AllSelection;
    };
    _proto42.getBookmark = function getBookmark() {
      return AllBookmark;
    };
    return AllSelection;
  }(Selection);
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map: function () {
      return this;
    },
    resolve: function (doc2) {
      return new AllSelection(doc2);
    }
  };
  function findSelectionIn(doc2, node, pos, index, dir) {
    var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    if (node.inlineContent) return TextSelection.create(doc2, pos);
    for (var _i145 = index - (dir > 0 ? 0 : 1); dir > 0 ? _i145 < node.childCount : _i145 >= 0; _i145 += dir) {
      var child = node.child(_i145);
      if (!child.isAtom) {
        var inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
        if (inner) return inner;
      } else if (!text && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd$1(tr, startLen, bias) {
    var last = tr.steps.length - 1;
    if (last < startLen) return;
    var step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return;
    var map3 = tr.mapping.maps[last],
      end;
    map3.forEach(function (_from, _to, _newFrom, newTo) {
      if (end == null) end = newTo;
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  var UPDATED_SEL = 1,
    UPDATED_MARKS = 2,
    UPDATED_SCROLL = 4;
  var Transaction = /*#__PURE__*/function (_Transform) {
    function Transaction(state) {
      var _this21;
      _this21 = _Transform.call(this, state.doc) || this;
      _this21.curSelectionFor = 0;
      _this21.updated = 0;
      _this21.meta = /* @__PURE__ */Object.create(null);
      _this21.time = Date.now();
      _this21.curSelection = state.selection;
      _this21.storedMarks = state.storedMarks;
      return _this21;
    }
    _inheritsLoose(Transaction, _Transform);
    var _proto43 = Transaction.prototype;
    _proto43.setSelection = function setSelection(selection) {
      if (selection.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    };
    _proto43.setStoredMarks = function setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    };
    _proto43.ensureMarks = function ensureMarks(marks) {
      if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);
      return this;
    };
    _proto43.addStoredMark = function addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    };
    _proto43.removeStoredMark = function removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    };
    _proto43.addStep = function addStep(step, doc2) {
      _Transform.prototype.addStep.call(this, step, doc2);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    };
    _proto43.setTime = function setTime(time) {
      this.time = time;
      return this;
    };
    _proto43.replaceSelection = function replaceSelection(slice2) {
      this.selection.replace(this, slice2);
      return this;
    };
    _proto43.replaceSelectionWith = function replaceSelectionWith(node) {
      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var selection = this.selection;
      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
      selection.replaceWith(this, node);
      return this;
    };
    _proto43.deleteSelection = function deleteSelection() {
      this.selection.replace(this);
      return this;
    };
    _proto43.insertText = function insertText(text, from2, to) {
      var schema = this.doc.type.schema;
      if (from2 == null) {
        if (!text) return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null) to = from2;
        to = to == null ? from2 : to;
        if (!text) return this.deleteRange(from2, to);
        var marks = this.storedMarks;
        if (!marks) {
          var $from = this.doc.resolve(from2);
          marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from2, to, schema.text(text, marks));
        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    };
    _proto43.setMeta = function setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    };
    _proto43.getMeta = function getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    };
    _proto43.scrollIntoView = function scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    };
    return _createClass(Transaction, [{
      key: "selection",
      get: function () {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
      }
    }, {
      key: "selectionSet",
      get: function () {
        return (this.updated & UPDATED_SEL) > 0;
      }
    }, {
      key: "storedMarksSet",
      get: function () {
        return (this.updated & UPDATED_MARKS) > 0;
      }
    }, {
      key: "isGeneric",
      get: function () {
        for (var _ in this.meta) return false;
        return true;
      }
    }, {
      key: "scrolledIntoView",
      get: function () {
        return (this.updated & UPDATED_SCROLL) > 0;
      }
    }]);
  }(Transform);
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  var FieldDesc = function FieldDesc(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  };
  var baseFields = [new FieldDesc("doc", {
    init: function (config2) {
      return config2.doc || config2.schema.topNodeType.createAndFill();
    },
    apply: function (tr) {
      return tr.doc;
    }
  }), new FieldDesc("selection", {
    init: function (config2, instance) {
      return config2.selection || Selection.atStart(instance.doc);
    },
    apply: function (tr) {
      return tr.selection;
    }
  }), new FieldDesc("storedMarks", {
    init: function (config2) {
      return config2.storedMarks || null;
    },
    apply: function (tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }), new FieldDesc("scrollToSelection", {
    init: function () {
      return 0;
    },
    apply: function (tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })];
  var Configuration = function Configuration(schema, plugins) {
    var _this22 = this;
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */Object.create(null);
    this.fields = baseFields.slice();
    if (plugins) plugins.forEach(function (plugin) {
      if (_this22.pluginsByKey[plugin.key]) throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
      _this22.plugins.push(plugin);
      _this22.pluginsByKey[plugin.key] = plugin;
      if (plugin.spec.state) _this22.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
    });
  };
  var EditorState = /*#__PURE__*/function () {
    function EditorState(config2) {
      this.config = config2;
    }
    var _proto44 = EditorState.prototype;
    _proto44.apply = function apply(tr) {
      return this.applyTransaction(tr).state;
    };
    _proto44.filterTransaction = function filterTransaction(tr) {
      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      for (var _i146 = 0; _i146 < this.config.plugins.length; _i146++) if (_i146 != ignore) {
        var plugin = this.config.plugins[_i146];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;
      }
      return true;
    };
    _proto44.applyTransaction = function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) return {
        state: this,
        transactions: []
      };
      var trs = [rootTr],
        newState = this.applyInner(rootTr),
        seen = null;
      for (;;) {
        var haveNew = false;
        for (var _i147 = 0; _i147 < this.config.plugins.length; _i147++) {
          var plugin = this.config.plugins[_i147];
          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[_i147].n : 0,
              oldState = seen ? seen[_i147].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, _i147)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (var j = 0; j < this.config.plugins.length; j++) seen.push(j < _i147 ? {
                  state: newState,
                  n: trs.length
                } : {
                  state: this,
                  n: 0
                });
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen) seen[_i147] = {
              state: newState,
              n: trs.length
            };
          }
        }
        if (!haveNew) return {
          state: newState,
          transactions: trs
        };
      }
    };
    _proto44.applyInner = function applyInner(tr) {
      if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
      var newInstance = new EditorState(this.config),
        fields = this.config.fields;
      for (var _i148 = 0; _i148 < fields.length; _i148++) {
        var field = fields[_i148];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      return newInstance;
    };
    EditorState.create = function create(config2) {
      var $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
      var instance = new EditorState($config);
      for (var _i149 = 0; _i149 < $config.fields.length; _i149++) instance[$config.fields[_i149].name] = $config.fields[_i149].init(config2, instance);
      return instance;
    };
    _proto44.reconfigure = function reconfigure(config2) {
      var $config = new Configuration(this.schema, config2.plugins);
      var fields = $config.fields,
        instance = new EditorState($config);
      for (var _i150 = 0; _i150 < fields.length; _i150++) {
        var name = fields[_i150].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[_i150].init(config2, instance);
      }
      return instance;
    };
    _proto44.toJSON = function toJSON(pluginFields) {
      var result = {
        doc: this.doc.toJSON(),
        selection: this.selection.toJSON()
      };
      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m3) {
        return m3.toJSON();
      });
      if (pluginFields && _typeof(pluginFields) == "object") for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        var plugin = pluginFields[prop],
          state = plugin.spec.state;
        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
      return result;
    };
    EditorState.fromJSON = function fromJSON(config2, json, pluginFields) {
      if (!json) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config2.schema) throw new RangeError("Required config field 'schema' missing");
      var $config = new Configuration(config2.schema, config2.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function (field) {
        if (field.name == "doc") {
          instance.doc = Node$2.fromJSON(config2.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
        } else {
          if (pluginFields) for (var prop in pluginFields) {
            var plugin = pluginFields[prop],
              state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config2, json[prop], instance);
              return;
            }
          }
          instance[field.name] = field.init(config2, instance);
        }
      });
      return instance;
    };
    return _createClass(EditorState, [{
      key: "schema",
      get: function () {
        return this.config.schema;
      }
    }, {
      key: "plugins",
      get: function () {
        return this.config.plugins;
      }
    }, {
      key: "tr",
      get: function () {
        return new Transaction(this);
      }
    }]);
  }();
  function bindProps$1(obj, self2, target) {
    for (var prop in obj) {
      var val = obj[prop];
      if (val instanceof Function) val = val.bind(self2);else if (prop == "handleDOMEvents") val = bindProps$1(val, self2, {});
      target[prop] = val;
    }
    return target;
  }
  var Plugin = /*#__PURE__*/function () {
    function Plugin(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props) bindProps$1(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    var _proto45 = Plugin.prototype;
    _proto45.getState = function getState(state) {
      return state[this.key];
    };
    return Plugin;
  }();
  var keys$1 = /* @__PURE__ */Object.create(null);
  function createKey(name) {
    if (name in keys$1) return name + "$" + ++keys$1[name];
    keys$1[name] = 0;
    return name + "$";
  }
  var PluginKey = /*#__PURE__*/function () {
    function PluginKey() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "key";
      this.key = createKey(name);
    }
    var _proto46 = PluginKey.prototype;
    _proto46.get = function get(state) {
      return state.config.pluginsByKey[this.key];
    };
    _proto46.getState = function getState(state) {
      return state[this.key];
    };
    return PluginKey;
  }();
  var domIndex = function (node) {
    for (var index = 0;; index++) {
      node = node.previousSibling;
      if (!node) return index;
    }
  };
  var parentNode = function (node) {
    var parent = node.assignedSlot || node.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  var reusedRange = null;
  var textRange = function (node, from2, to) {
    var range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node, to == null ? node.nodeValue.length : to);
    range.setStart(node, from2 || 0);
    return range;
  };
  var clearReusedRange = function () {
    reusedRange = null;
  };
  var isEquivalentPosition = function (node, off, targetNode, targetOff) {
    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
  };
  var atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
      if (node == targetNode && off == targetOff) return true;
      if (off == (dir < 0 ? 0 : nodeSize(node))) {
        var parent = node.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.contentEditable == "false") return false;
        off = dir < 0 ? nodeSize(node) : 0;
      } else {
        return false;
      }
    }
  }
  function nodeSize(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function textNodeBefore$1(node, offset) {
    for (;;) {
      if (node.nodeType == 3 && offset) return node;
      if (node.nodeType == 1 && offset > 0) {
        if (node.contentEditable == "false") return null;
        node = node.childNodes[offset - 1];
        offset = nodeSize(node);
      } else if (node.parentNode && !hasBlockDesc(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter$1(node, offset) {
    for (;;) {
      if (node.nodeType == 3 && offset < node.nodeValue.length) return node;
      if (node.nodeType == 1 && offset < node.childNodes.length) {
        if (node.contentEditable == "false") return null;
        node = node.childNodes[offset];
        offset = 0;
      } else if (node.parentNode && !hasBlockDesc(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function isOnEdge(node, offset, parent) {
    for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
      if (node == parent) return true;
      var index = domIndex(node);
      node = node.parentNode;
      if (!node) return false;
      atStart = atStart && index == 0;
      atEnd = atEnd && index == nodeSize(node);
    }
  }
  function hasBlockDesc(dom) {
    var desc;
    for (var cur = dom; cur; cur = cur.parentNode) if (desc = cur.pmViewDesc) break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  var selectionCollapsed = function (domSel) {
    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
  };
  function keyEvent(keyCode, key) {
    var event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key;
    return event;
  }
  function deepActiveElement(doc2) {
    var elt = doc2.activeElement;
    while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc2, x, y) {
    if (doc2.caretPositionFromPoint) {
      try {
        var pos = doc2.caretPositionFromPoint(x, y);
        if (pos) return {
          node: pos.offsetNode,
          offset: Math.min(nodeSize(pos.offsetNode), pos.offset)
        };
      } catch (_) {}
    }
    if (doc2.caretRangeFromPoint) {
      var range = doc2.caretRangeFromPoint(x, y);
      if (range) return {
        node: range.startContainer,
        offset: Math.min(nodeSize(range.startContainer), range.startOffset)
      };
    }
  }
  var nav = typeof navigator != "undefined" ? navigator : null;
  var doc = typeof document != "undefined" ? document : null;
  var agent = nav && nav.userAgent || "";
  var ie_edge = /Edge\/(\d+)/.exec(agent);
  var ie_upto10 = /MSIE \d/.exec(agent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
  var ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
  var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
  var gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
  gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
  var _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
  var chrome = !!_chrome;
  var chrome_version = _chrome ? +_chrome[1] : 0;
  var safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
  var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
  var mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
  var windows = nav ? /Win/.test(nav.platform) : false;
  var android = /Android \d/.test(agent);
  var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
  var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function windowRect(doc2) {
    var vp = doc2.defaultView && doc2.defaultView.visualViewport;
    if (vp) return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
    return {
      left: 0,
      right: doc2.documentElement.clientWidth,
      top: 0,
      bottom: doc2.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node) {
    var rect = node.getBoundingClientRect();
    var scaleX = rect.width / node.offsetWidth || 1;
    var scaleY = rect.height / node.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    var scrollThreshold = view.someProp("scrollThreshold") || 0,
      scrollMargin = view.someProp("scrollMargin") || 5;
    var doc2 = view.dom.ownerDocument;
    for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
      if (!parent) break;
      if (parent.nodeType != 1) continue;
      var elt = parent;
      var atTop = elt == doc2.body;
      var bounding = atTop ? windowRect(doc2) : clientRect(elt);
      var moveX = 0,
        moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc2.defaultView.scrollBy(moveX, moveY);
        } else {
          var startX = elt.scrollLeft,
            startY = elt.scrollTop;
          if (moveY) elt.scrollTop += moveY;
          if (moveX) elt.scrollLeft += moveX;
          var dX = elt.scrollLeft - startX,
            dY = elt.scrollTop - startY;
          rect = {
            left: rect.left - dX,
            top: rect.top - dY,
            right: rect.right - dX,
            bottom: rect.bottom - dY
          };
        }
      }
      if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position)) break;
    }
  }
  function storeScrollPos(view) {
    var rect = view.dom.getBoundingClientRect(),
      startY = Math.max(0, rect.top);
    var refDOM, refTop;
    for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      var dom = view.root.elementFromPoint(x, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;
      var localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return {
      refDOM: refDOM,
      refTop: refTop,
      stack: scrollStack(view.dom)
    };
  }
  function scrollStack(dom) {
    var stack2 = [],
      doc2 = dom.ownerDocument;
    for (var cur = dom; cur; cur = parentNode(cur)) {
      stack2.push({
        dom: cur,
        top: cur.scrollTop,
        left: cur.scrollLeft
      });
      if (dom == doc2) break;
    }
    return stack2;
  }
  function resetScrollPos(_ref69) {
    var refDOM = _ref69.refDOM,
      refTop = _ref69.refTop,
      stack2 = _ref69.stack;
    var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack2, dTop) {
    for (var _i151 = 0; _i151 < stack2.length; _i151++) {
      var _stack2$_i = stack2[_i151],
        dom = _stack2$_i.dom,
        top = _stack2$_i.top,
        left = _stack2$_i.left;
      if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
      if (dom.scrollLeft != left) dom.scrollLeft = left;
    }
  }
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive) return dom.setActive();
    if (preventScrollSupported) return dom.focus(preventScrollSupported);
    var stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = {
          preventScroll: true
        };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node, coords) {
    var closest,
      dxClosest = 2e8,
      coordsClosest,
      offset = 0;
    var rowBot = coords.top,
      rowTop = coords.top;
    var firstBelow, coordsBelow;
    for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      var rects = void 0;
      if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;
      for (var _i152 = 0; _i152 < rects.length; _i152++) {
        var rect = rects[_i152];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = {
            left: Math.max(rect.left, Math.min(rect.right, coords.left)),
            top: rect.top
          };
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;
      }
    }
    if (!closest && firstBelow) {
      closest = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
    if (!closest || dxClosest && closest.nodeType == 1) return {
      node: node,
      offset: offset
    };
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node, coords) {
    var len = node.nodeValue.length;
    var range = document.createRange();
    for (var _i153 = 0; _i153 < len; _i153++) {
      range.setEnd(node, _i153 + 1);
      range.setStart(node, _i153);
      var rect = singleRect(range, 1);
      if (rect.top == rect.bottom) continue;
      if (inRect(coords, rect)) return {
        node: node,
        offset: _i153 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
      };
    }
    return {
      node: node,
      offset: 0
    };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    var parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    var _findOffsetInNode = findOffsetInNode(elt, coords),
      node = _findOffsetInNode.node,
      offset = _findOffsetInNode.offset,
      bias = -1;
    if (node.nodeType == 1 && !node.firstChild) {
      var rect = node.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node, offset, bias);
  }
  function posFromCaret(view, node, offset, coords) {
    var outsideBlock = -1;
    for (var cur = node, sawBlock = false;;) {
      if (cur == view.dom) break;
      var desc = view.docView.nearestDesc(cur, true);
      if (!desc) return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM)) {
        var rect = desc.dom.getBoundingClientRect();
        if (desc.node.isBlock && desc.parent) {
          if (!sawBlock && rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;
          sawBlock = true;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          var before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
  }
  function elementFromPoint(element, coords, box) {
    var len = element.childNodes.length;
    if (len && box.top < box.bottom) {
      for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), _i154 = startI;;) {
        var child = element.childNodes[_i154];
        if (child.nodeType == 1) {
          var rects = child.getClientRects();
          for (var j = 0; j < rects.length; j++) {
            var rect = rects[j];
            if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);
          }
        }
        if ((_i154 = (_i154 + 1) % len) == startI) break;
      }
    }
    return element;
  }
  function _posAtCoords(view, coords) {
    var doc2 = view.dom.ownerDocument,
      node,
      offset = 0;
    var caret = caretFromPoint(doc2, coords.left, coords.top);
    if (caret) {
      node = caret.node;
      offset = caret.offset;
    }
    var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
    var pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      var box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box)) return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt) return null;
    }
    if (safari) {
      for (var p2 = elt; node && p2; p2 = parentNode(p2)) if (p2.draggable) node = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node) {
      if (gecko && node.nodeType == 1) {
        offset = Math.min(offset, node.childNodes.length);
        if (offset < node.childNodes.length) {
          var next = node.childNodes[offset],
            _box;
          if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;
        }
      }
      var prev;
      if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top) offset--;
      if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") pos = posFromCaret(view, node, offset, coords);
    }
    if (pos == null) pos = posFromElement(view, elt, coords);
    var desc = view.docView.nearestDesc(elt, true);
    return {
      pos: pos,
      inside: desc ? desc.posAtStart - desc.border : -1
    };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    var rects = target.getClientRects();
    if (rects.length) {
      var first2 = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first2)) return first2;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function _coordsAtPos(view, pos, side) {
    var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1),
      node = _view$docView$domFrom.node,
      offset = _view$docView$domFrom.offset,
      atom = _view$docView$domFrom.atom;
    var supportEmptyRange = webkit || gecko;
    if (node.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
        var rect = singleRect(textRange(node, offset, offset), side);
        if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
          var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
          if (rectBefore.top == rect.top) {
            var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
            if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        var _from3 = offset,
          to = offset,
          takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset) {
          to++;
          takeSide = -1;
        } else if (side >= 0 && offset == node.nodeValue.length) {
          _from3--;
          takeSide = 1;
        } else if (side < 0) {
          _from3--;
        } else {
          to++;
        }
        return flattenV(singleRect(textRange(node, _from3, to), takeSide), takeSide < 0);
      }
    }
    var $dom = view.state.doc.resolve(pos - (atom || 0));
    if (!$dom.parent.inlineContent) {
      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
        var before = node.childNodes[offset - 1];
        if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom == null && offset < nodeSize(node)) {
        var after = node.childNodes[offset];
        if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node.getBoundingClientRect(), side >= 0);
    }
    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
      var _before = node.childNodes[offset - 1];
      var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
      if (target) return flattenV(singleRect(target, 1), false);
    }
    if (atom == null && offset < nodeSize(node)) {
      var _after2 = node.childNodes[offset];
      while (_after2.pmViewDesc && _after2.pmViewDesc.ignoreForCoords) _after2 = _after2.nextSibling;
      var _target2 = !_after2 ? null : _after2.nodeType == 3 ? textRange(_after2, 0, supportEmptyRange ? 0 : 1) : _after2.nodeType == 1 ? _after2 : null;
      if (_target2) return flattenV(singleRect(_target2, -1), true);
    }
    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
  }
  function flattenV(rect, left) {
    if (rect.width == 0) return rect;
    var x = left ? rect.left : rect.right;
    return {
      top: rect.top,
      bottom: rect.bottom,
      left: x,
      right: x
    };
  }
  function flattenH(rect, top) {
    if (rect.height == 0) return rect;
    var y = top ? rect.top : rect.bottom;
    return {
      top: y,
      bottom: y,
      left: rect.left,
      right: rect.right
    };
  }
  function withFlushedState(view, state, f) {
    var viewState = view.state,
      active = view.root.activeElement;
    if (viewState != state) view.updateState(state);
    if (active != view.dom) view.focus();
    try {
      return f();
    } finally {
      if (viewState != state) view.updateState(viewState);
      if (active != view.dom && active) active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    var sel = state.selection;
    var $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, function () {
      var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1),
        dom = _view$docView$domFrom2.node;
      for (;;) {
        var nearest = view.docView.nearestDesc(dom, true);
        if (!nearest) break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      var coords = _coordsAtPos(view, $pos.pos, 1);
      for (var child = dom.firstChild; child; child = child.nextSibling) {
        var boxes = void 0;
        if (child.nodeType == 1) boxes = child.getClientRects();else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();else continue;
        for (var _i155 = 0; _i155 < boxes.length; _i155++) {
          var box = boxes[_i155];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;
        }
      }
      return true;
    });
  }
  var maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    var $head = state.selection.$head;
    if (!$head.parent.isTextblock) return false;
    var offset = $head.parentOffset,
      atStart = !offset,
      atEnd = offset == $head.parent.content.size;
    var sel = view.domSelection();
    if (!sel) return $head.pos == $head.start() || $head.pos == $head.end();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, function () {
      var _view$domSelectionRan = view.domSelectionRange(),
        oldNode = _view$domSelectionRan.focusNode,
        oldOff = _view$domSelectionRan.focusOffset,
        anchorNode = _view$domSelectionRan.anchorNode,
        anchorOffset = _view$domSelectionRan.anchorOffset;
      var oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      var _view$domSelectionRan2 = view.domSelectionRange(),
        newNode = _view$domSelectionRan2.focusNode,
        newOff = _view$domSelectionRan2.focusOffset;
      var result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);
      } catch (_) {}
      if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  var cachedState = null;
  var cachedDir = null;
  var cachedResult = false;
  function _endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir) return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  var NOT_DIRTY = 0,
    CHILD_DIRTY = 1,
    CONTENT_DIRTY = 2,
    NODE_DIRTY = 3;
  var ViewDesc = /*#__PURE__*/function () {
    function ViewDesc(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
      dom.pmViewDesc = this;
    }
    var _proto47 = ViewDesc.prototype;
    _proto47.matchesWidget = function matchesWidget(widget) {
      return false;
    };
    _proto47.matchesMark = function matchesMark(mark) {
      return false;
    };
    _proto47.matchesNode = function matchesNode(node, outerDeco, innerDeco) {
      return false;
    };
    _proto47.matchesHack = function matchesHack(nodeName) {
      return false;
    };
    _proto47.parseRule = function parseRule() {
      return null;
    };
    _proto47.stopEvent = function stopEvent(event) {
      return false;
    };
    _proto47.destroy = function destroy() {
      this.parent = void 0;
      if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = void 0;
      for (var _i156 = 0; _i156 < this.children.length; _i156++) this.children[_i156].destroy();
    };
    _proto47.posBeforeChild = function posBeforeChild(child) {
      for (var _i157 = 0, pos = this.posAtStart;; _i157++) {
        var cur = this.children[_i157];
        if (cur == child) return pos;
        pos += cur.size;
      }
    };
    _proto47.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, _desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
        }
      }
      var atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) for (var search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling) break;
        }
        if (atEnd == null && offset == dom.childNodes.length) for (var _search2 = dom;; _search2 = _search2.parentNode) {
          if (_search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (_search2.nextSibling) break;
        }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    };
    _proto47.nearestDesc = function nearestDesc(dom) {
      var onlyNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      for (var first2 = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur),
          nodeDOM = void 0;
        if (desc && (!onlyNodes || desc.node)) {
          if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first2 = false;else return desc;
        }
      }
    };
    _proto47.getDesc = function getDesc(dom) {
      var desc = dom.pmViewDesc;
      for (var cur = desc; cur; cur = cur.parent) if (cur == this) return desc;
    };
    _proto47.posFromDOM = function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) return desc.localPosFromDOM(dom, offset, bias);
      }
      return -1;
    };
    _proto47.descAt = function descAt(pos) {
      for (var _i158 = 0, offset = 0; _i158 < this.children.length; _i158++) {
        var child = this.children[_i158],
          end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) child = child.children[0];
          return child;
        }
        if (pos < end) return child.descAt(pos - offset - child.border);
        offset = end;
      }
    };
    _proto47.domFromPos = function domFromPos(pos, side) {
      if (!this.contentDOM) return {
        node: this.dom,
        offset: 0,
        atom: pos + 1
      };
      var i = 0,
        offset = 0;
      for (var curPos = 0; i < this.children.length; i++) {
        var child = this.children[i],
          end = curPos + child.size;
        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }
        curPos = end;
      }
      if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);
      for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}
      if (side <= 0) {
        var _prev,
          enter2 = true;
        for (;; i--, enter2 = false) {
          _prev = i ? this.children[i - 1] : null;
          if (!_prev || _prev.dom.parentNode == this.contentDOM) break;
        }
        if (_prev && side && enter2 && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);
        return {
          node: this.contentDOM,
          offset: _prev ? domIndex(_prev.dom) + 1 : 0
        };
      } else {
        var next,
          _enter = true;
        for (;; i++, _enter = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM) break;
        }
        if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);
        return {
          node: this.contentDOM,
          offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
        };
      }
    };
    _proto47.parseRange = function parseRange(from2, to) {
      var base2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (this.children.length == 0) return {
        node: this.contentDOM,
        from: from2,
        to: to,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      };
      var fromOffset = -1,
        toOffset = -1;
      for (var offset = base2, _i159 = 0;; _i159++) {
        var child = this.children[_i159],
          end = offset + child.size;
        if (fromOffset == -1 && from2 <= end) {
          var childBase = offset + child.border;
          if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from2, to, childBase);
          from2 = offset;
          for (var j = _i159; j > 0; j--) {
            var prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from2 -= prev.size;
          }
          if (fromOffset == -1) fromOffset = 0;
        }
        if (fromOffset > -1 && (end > to || _i159 == this.children.length - 1)) {
          to = end;
          for (var _j2 = _i159 + 1; _j2 < this.children.length; _j2++) {
            var next = this.children[_j2];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset = end;
      }
      return {
        node: this.contentDOM,
        from: from2,
        to: to,
        fromOffset: fromOffset,
        toOffset: toOffset
      };
    };
    _proto47.emptyChildAt = function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) return false;
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    };
    _proto47.domAfterPos = function domAfterPos(pos) {
      var _this$domFromPos = this.domFromPos(pos, 0),
        node = _this$domFromPos.node,
        offset = _this$domFromPos.offset;
      if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset];
    };
    _proto47.setSelection = function setSelection(anchor, head, root) {
      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var from2 = Math.min(anchor, head),
        to = Math.max(anchor, head);
      for (var _i160 = 0, offset = 0; _i160 < this.children.length; _i160++) {
        var child = this.children[_i160],
          end = offset + child.size;
        if (from2 > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        offset = end;
      }
      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;
      if ((gecko || safari) && anchor == head) {
        var _anchorDOM = anchorDOM,
          node = _anchorDOM.node,
          _offset = _anchorDOM.offset;
        if (node.nodeType == 3) {
          brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");
          if (brKludge && _offset == node.nodeValue.length) {
            for (var scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR") anchorDOM = headDOM = {
                  node: after.parentNode,
                  offset: domIndex(after) + 1
                };
                break;
              }
              var desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock) break;
            }
          }
        } else {
          var prev = node.childNodes[_offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var _after3 = domSel.focusNode.childNodes[domSel.focusOffset];
        if (_after3 && _after3.contentEditable == "false") force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;
      var domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_) {}
      }
      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    };
    _proto47.ignoreMutation = function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    };
    _proto47.markDirty = function markDirty(from2, to) {
      for (var offset = 0, _i161 = 0; _i161 < this.children.length; _i161++) {
        var child = this.children[_i161],
          end = offset + child.size;
        if (offset == end ? from2 <= end && to >= offset : from2 < end && to > offset) {
          var startInside = offset + child.border,
            endInside = end - child.border;
          if (from2 >= startInside && to <= endInside) {
            this.dirty = from2 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;else child.markDirty(from2 - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    };
    _proto47.markParentsDirty = function markParentsDirty() {
      var level = 1;
      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) node.dirty = dirty;
      }
    };
    _proto47.isText = function isText(text) {
      return false;
    };
    return _createClass(ViewDesc, [{
      key: "size",
      get: function () {
        var size = 0;
        for (var _i162 = 0; _i162 < this.children.length; _i162++) size += this.children[_i162].size;
        return size;
      }
    }, {
      key: "border",
      get: function () {
        return 0;
      }
    }, {
      key: "posBefore",
      get: function () {
        return this.parent.posBeforeChild(this);
      }
    }, {
      key: "posAtStart",
      get: function () {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
    }, {
      key: "posAfter",
      get: function () {
        return this.posBefore + this.size;
      }
    }, {
      key: "posAtEnd",
      get: function () {
        return this.posAtStart + this.size - 2 * this.border;
      }
    }, {
      key: "contentLost",
      get: function () {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
    }, {
      key: "domAtom",
      get: function () {
        return false;
      }
    }, {
      key: "ignoreForCoords",
      get: function () {
        return false;
      }
    }]);
  }();
  var WidgetViewDesc = /*#__PURE__*/function (_ViewDesc) {
    function WidgetViewDesc(parent, widget, view, pos) {
      var _this23;
      var self2,
        dom = widget.type.toDOM;
      if (typeof dom == "function") dom = dom(view, function () {
        if (!self2) return pos;
        if (self2.parent) return self2.parent.posBeforeChild(self2);
      });
      if (!widget.type.spec.raw) {
        if (dom.nodeType != 1) {
          var wrap2 = document.createElement("span");
          wrap2.appendChild(dom);
          dom = wrap2;
        }
        dom.contentEditable = "false";
        dom.classList.add("ProseMirror-widget");
      }
      _this23 = _ViewDesc.call(this, parent, [], dom, null) || this;
      _this23.widget = widget;
      _this23.widget = widget;
      self2 = _this23;
      return _this23;
    }
    _inheritsLoose(WidgetViewDesc, _ViewDesc);
    var _proto48 = WidgetViewDesc.prototype;
    _proto48.matchesWidget = function matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    };
    _proto48.parseRule = function parseRule() {
      return {
        ignore: true
      };
    };
    _proto48.stopEvent = function stopEvent(event) {
      var stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    };
    _proto48.ignoreMutation = function ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    };
    _proto48.destroy = function destroy() {
      this.widget.type.destroy(this.dom);
      _ViewDesc.prototype.destroy.call(this);
    };
    return _createClass(WidgetViewDesc, [{
      key: "domAtom",
      get: function () {
        return true;
      }
    }, {
      key: "side",
      get: function () {
        return this.widget.type.side;
      }
    }]);
  }(ViewDesc);
  var CompositionViewDesc = /*#__PURE__*/function (_ViewDesc2) {
    function CompositionViewDesc(parent, dom, textDOM, text) {
      var _this24;
      _this24 = _ViewDesc2.call(this, parent, [], dom, null) || this;
      _this24.textDOM = textDOM;
      _this24.text = text;
      return _this24;
    }
    _inheritsLoose(CompositionViewDesc, _ViewDesc2);
    var _proto49 = CompositionViewDesc.prototype;
    _proto49.localPosFromDOM = function localPosFromDOM(dom, offset) {
      if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    };
    _proto49.domFromPos = function domFromPos(pos) {
      return {
        node: this.textDOM,
        offset: pos
      };
    };
    _proto49.ignoreMutation = function ignoreMutation(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    };
    return _createClass(CompositionViewDesc, [{
      key: "size",
      get: function () {
        return this.text.length;
      }
    }]);
  }(ViewDesc);
  var MarkViewDesc = /*#__PURE__*/function (_ViewDesc3) {
    function MarkViewDesc(parent, mark, dom, contentDOM) {
      var _this25;
      _this25 = _ViewDesc3.call(this, parent, [], dom, contentDOM) || this;
      _this25.mark = mark;
      return _this25;
    }
    _inheritsLoose(MarkViewDesc, _ViewDesc3);
    MarkViewDesc.create = function create(parent, mark, inline2, view) {
      var custom = view.nodeViews[mark.type.name];
      var spec = custom && custom(mark, view, inline2);
      if (!spec || !spec.dom) spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline2), null, mark.attrs);
      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    };
    var _proto50 = MarkViewDesc.prototype;
    _proto50.parseRule = function parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;
      return {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM
      };
    };
    _proto50.matchesMark = function matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    };
    _proto50.markDirty = function markDirty(from2, to) {
      _ViewDesc3.prototype.markDirty.call(this, from2, to);
      if (this.dirty != NOT_DIRTY) {
        var parent = this.parent;
        while (!parent.node) parent = parent.parent;
        if (parent.dirty < this.dirty) parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    };
    _proto50.slice = function slice(from2, to, view) {
      var copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
      var nodes = this.children,
        size = this.size;
      if (to < size) nodes = replaceNodes(nodes, to, size, view);
      if (from2 > 0) nodes = replaceNodes(nodes, 0, from2, view);
      for (var _i163 = 0; _i163 < nodes.length; _i163++) nodes[_i163].parent = copy2;
      copy2.children = nodes;
      return copy2;
    };
    return MarkViewDesc;
  }(ViewDesc);
  var NodeViewDesc = /*#__PURE__*/function (_ViewDesc4) {
    function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
      var _this26;
      _this26 = _ViewDesc4.call(this, parent, [], dom, contentDOM) || this;
      _this26.node = node;
      _this26.outerDeco = outerDeco;
      _this26.innerDeco = innerDeco;
      _this26.nodeDOM = nodeDOM;
      return _this26;
    }
    _inheritsLoose(NodeViewDesc, _ViewDesc4);
    NodeViewDesc.create = function create(parent, node, outerDeco, innerDeco, view, pos) {
      var custom = view.nodeViews[node.type.name],
        descObj;
      var spec = custom && custom(node, view, function () {
        if (!descObj) return pos;
        if (descObj.parent) return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      var dom = spec && spec.dom,
        contentDOM = spec && spec.contentDOM;
      if (node.isText) {
        if (!dom) dom = document.createTextNode(node.text);else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        var spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
        dom = spec2.dom;
        contentDOM = spec2.contentDOM;
      }
      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable")) dom.contentEditable = "false";
        if (node.type.spec.draggable) dom.draggable = true;
      }
      var nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    };
    var _proto51 = NodeViewDesc.prototype;
    _proto51.parseRule = function parseRule() {
      var _this27 = this;
      if (this.node.type.spec.reparseInView) return null;
      var rule = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      if (this.node.type.whitespace == "pre") rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = function () {
          return _this27.node.content;
        };
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (var _i164 = this.children.length - 1; _i164 >= 0; _i164--) {
          var child = this.children[_i164];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement) rule.getContent = function () {
          return Fragment.empty;
        };
      }
      return rule;
    };
    _proto51.matchesNode = function matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    };
    _proto51.updateChildren = function updateChildren(view, pos) {
      var _this28 = this;
      var inline2 = this.node.inlineContent,
        off = pos;
      var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      var localComposition = composition && composition.pos > -1 ? composition : null;
      var compositionInChild = composition && composition.pos < 0;
      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
        if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline2, view);else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this28.node.childCount ? Mark$1.none : _this28.node.child(i).marks, inline2, view);
        updater.placeWidget(widget, view, off);
      }, function (child, outerDeco, innerDeco, i) {
        updater.syncToMarks(child.marks, inline2, view);
        var compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline2, view);
      if (this.node.isTextblock) updater.addTextblockHacks();
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition) this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios) iosHacks(this.dom);
      }
    };
    _proto51.localCompositionInfo = function localCompositionInfo(view, pos) {
      var _view$state$selection = view.state.selection,
        from2 = _view$state$selection.from,
        to = _view$state$selection.to;
      if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size) return null;
      var textNode = view.input.compositionNode;
      if (!textNode || !this.dom.contains(textNode.parentNode)) return null;
      if (this.node.inlineContent) {
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
        return textPos < 0 ? null : {
          node: textNode,
          pos: textPos,
          text: text
        };
      } else {
        return {
          node: textNode,
          pos: -1,
          text: ""
        };
      }
    };
    _proto51.protectLocalComposition = function protectLocalComposition(view, _ref70) {
      var node = _ref70.node,
        pos = _ref70.pos,
        text = _ref70.text;
      if (this.getDesc(node)) return;
      var topNode = node;
      for (;; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM) break;
        while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc) topNode.pmViewDesc = void 0;
      }
      var desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    };
    _proto51.update = function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    };
    _proto51.updateInner = function updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM) this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    };
    _proto51.updateOuterDeco = function updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco)) return;
      var needsWrap = this.nodeDOM.nodeType != 1;
      var oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = void 0;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    };
    _proto51.selectNode = function selectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;
    };
    _proto51.deselectNode = function deselectNode() {
      if (this.nodeDOM.nodeType == 1) {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute("draggable");
      }
    };
    return _createClass(NodeViewDesc, [{
      key: "size",
      get: function () {
        return this.node.nodeSize;
      }
    }, {
      key: "border",
      get: function () {
        return this.node.isLeaf ? 0 : 1;
      }
    }, {
      key: "domAtom",
      get: function () {
        return this.node.isAtom;
      }
    }]);
  }(ViewDesc);
  function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc2);
    var docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM) docView.updateChildren(view, 0);
    return docView;
  }
  var TextViewDesc = /*#__PURE__*/function (_NodeViewDesc) {
    function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
      return _NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0) || this;
    }
    _inheritsLoose(TextViewDesc, _NodeViewDesc);
    var _proto52 = TextViewDesc.prototype;
    _proto52.parseRule = function parseRule() {
      var skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco) skip = skip.parentNode;
      return {
        skip: skip || true
      };
    };
    _proto52.update = function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM) view.trackWrites = null;
      }
      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    };
    _proto52.inParent = function inParent() {
      var parentDOM = this.parent.contentDOM;
      for (var n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true;
      return false;
    };
    _proto52.domFromPos = function domFromPos(pos) {
      return {
        node: this.nodeDOM,
        offset: pos
      };
    };
    _proto52.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);
      return _NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias);
    };
    _proto52.ignoreMutation = function ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    };
    _proto52.slice = function slice(from2, to, view) {
      var node = this.node.cut(from2, to),
        dom = document.createTextNode(node.text);
      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    };
    _proto52.markDirty = function markDirty(from2, to) {
      _NodeViewDesc.prototype.markDirty.call(this, from2, to);
      if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;
    };
    _proto52.isText = function isText(text) {
      return this.node.text == text;
    };
    return _createClass(TextViewDesc, [{
      key: "domAtom",
      get: function () {
        return false;
      }
    }]);
  }(NodeViewDesc);
  var TrailingHackViewDesc = /*#__PURE__*/function (_ViewDesc5) {
    function TrailingHackViewDesc() {
      return _ViewDesc5.apply(this, arguments) || this;
    }
    _inheritsLoose(TrailingHackViewDesc, _ViewDesc5);
    var _proto53 = TrailingHackViewDesc.prototype;
    _proto53.parseRule = function parseRule() {
      return {
        ignore: true
      };
    };
    _proto53.matchesHack = function matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    };
    return _createClass(TrailingHackViewDesc, [{
      key: "domAtom",
      get: function () {
        return true;
      }
    }, {
      key: "ignoreForCoords",
      get: function () {
        return this.dom.nodeName == "IMG";
      }
    }]);
  }(ViewDesc);
  var CustomNodeViewDesc = /*#__PURE__*/function (_NodeViewDesc2) {
    function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
      var _this29;
      _this29 = _NodeViewDesc2.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) || this;
      _this29.spec = spec;
      return _this29;
    }
    _inheritsLoose(CustomNodeViewDesc, _NodeViewDesc2);
    var _proto54 = CustomNodeViewDesc.prototype;
    _proto54.update = function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY) return false;
      if (this.spec.update) {
        var result = this.spec.update(node, outerDeco, innerDeco);
        if (result) this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return _NodeViewDesc2.prototype.update.call(this, node, outerDeco, innerDeco, view);
      }
    };
    _proto54.selectNode = function selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : _NodeViewDesc2.prototype.selectNode.call(this);
    };
    _proto54.deselectNode = function deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : _NodeViewDesc2.prototype.deselectNode.call(this);
    };
    _proto54.setSelection = function setSelection(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
    };
    _proto54.destroy = function destroy() {
      if (this.spec.destroy) this.spec.destroy();
      _NodeViewDesc2.prototype.destroy.call(this);
    };
    _proto54.stopEvent = function stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    };
    _proto54.ignoreMutation = function ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
    };
    return CustomNodeViewDesc;
  }(NodeViewDesc);
  function renderDescs(parentDOM, descs, view) {
    var dom = parentDOM.firstChild,
      written = false;
    for (var _i165 = 0; _i165 < descs.length; _i165++) {
      var desc = descs[_i165],
        childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        var pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM) view.trackWrites = null;
  }
  var OuterDecoLevel = function (nodeName) {
    if (nodeName) this.nodeName = nodeName;
  };
  OuterDecoLevel.prototype = /* @__PURE__ */Object.create(null);
  var noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node, needsWrap) {
    if (outerDeco.length == 0) return noDeco;
    var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),
      result = [top];
    for (var _i166 = 0; _i166 < outerDeco.length; _i166++) {
      var attrs = outerDeco[_i166].type.attrs;
      if (!attrs) continue;
      if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));
      for (var name in attrs) {
        var val = attrs[name];
        if (val == null) continue;
        if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
        if (name == "class") top.class = (top.class ? top.class + " " : "") + val;else if (name == "style") top.style = (top.style ? top.style + ";" : "") + val;else if (name != "nodeName") top[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;
    var curDOM = nodeDOM;
    for (var _i167 = 0; _i167 < curComputed.length; _i167++) {
      var deco = curComputed[_i167],
        prev = prevComputed[_i167];
      if (_i167) {
        var parent = void 0;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (var name in prev) if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) dom.removeAttribute(name);
    for (var _name4 in cur) if (_name4 != "class" && _name4 != "style" && _name4 != "nodeName" && cur[_name4] != prev[_name4]) dom.setAttribute(_name4, cur[_name4]);
    if (prev.class != cur.class) {
      var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      var curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (var _i168 = 0; _i168 < prevList.length; _i168++) if (curList.indexOf(prevList[_i168]) == -1) dom.classList.remove(prevList[_i168]);
      for (var _i169 = 0; _i169 < curList.length; _i169++) if (prevList.indexOf(curList[_i169]) == -1) dom.classList.add(curList[_i169]);
      if (dom.classList.length == 0) dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
          m3;
        while (m3 = prop.exec(prev.style)) dom.style.removeProperty(m3[1]);
      }
      if (cur.style) dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
  }
  function sameOuterDeco(a, b) {
    if (a.length != b.length) return false;
    for (var _i170 = 0; _i170 < a.length; _i170++) if (!a[_i170].type.eq(b[_i170].type)) return false;
    return true;
  }
  function rm(dom) {
    var next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ViewTreeUpdater = /*#__PURE__*/function () {
    function ViewTreeUpdater(top, lock, view) {
      this.lock = lock;
      this.view = view;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.top = top;
      this.preMatch = preMatch(top.node.content, top);
    }
    var _proto55 = ViewTreeUpdater.prototype;
    _proto55.destroyBetween = function destroyBetween(start, end) {
      if (start == end) return;
      for (var _i171 = start; _i171 < end; _i171++) this.top.children[_i171].destroy();
      this.top.children.splice(start, end - start);
      this.changed = true;
    };
    _proto55.destroyRest = function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    };
    _proto55.syncToMarks = function syncToMarks(marks, inline2, view) {
      var keep = 0,
        depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found2 = -1;
        for (var _i172 = this.index; _i172 < Math.min(this.index + 3, this.top.children.length); _i172++) {
          var next = this.top.children[_i172];
          if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
            found2 = _i172;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline2, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    };
    _proto55.findNodeMatch = function findNodeMatch(node, outerDeco, innerDeco, index) {
      var found2 = -1,
        targetDesc;
      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found2 = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (var _i173 = this.index, e = Math.min(this.top.children.length, _i173 + 5); _i173 < e; _i173++) {
          var child = this.top.children[_i173];
          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found2 = _i173;
            break;
          }
        }
      }
      if (found2 < 0) return false;
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    };
    _proto55.updateNodeAt = function updateNodeAt(node, outerDeco, innerDeco, index, view) {
      var child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view)) return false;
      this.destroyBetween(this.index, index);
      this.index++;
      return true;
    };
    _proto55.findIndexWithChild = function findIndexWithChild(domNode) {
      for (;;) {
        var parent = domNode.parentNode;
        if (!parent) return -1;
        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) for (var _i174 = this.index; _i174 < this.top.children.length; _i174++) {
            if (this.top.children[_i174] == desc) return _i174;
          }
          return -1;
        }
        domNode = parent;
      }
    };
    _proto55.updateNextNode = function updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
      for (var _i175 = this.index; _i175 < this.top.children.length; _i175++) {
        var next = this.top.children[_i175];
        if (next instanceof NodeViewDesc) {
          var preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index) return false;
          var nextDOM = next.dom,
            updated2 = void 0;
          var locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, _i175);
            if (next.dom != nextDOM) this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated2 = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
            this.destroyBetween(this.index, _i175);
            this.top.children[this.index] = updated2;
            if (updated2.contentDOM) {
              updated2.dirty = CONTENT_DIRTY;
              updated2.updateChildren(view, pos + 1);
              updated2.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    };
    _proto55.recreateWrapper = function recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco)) return null;
      var wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next.children;
        next.children = [];
        for (var _iterator27 = _createForOfIteratorHelperLoose(wrapper.children), _step29; !(_step29 = _iterator27()).done;) {
          var ch = _step29.value;
          ch.parent = wrapper;
        }
      }
      next.destroy();
      return wrapper;
    };
    _proto55.addNode = function addNode(node, outerDeco, innerDeco, view, pos) {
      var desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM) desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    };
    _proto55.placeWidget = function placeWidget(widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    };
    _proto55.addTextblockHacks = function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1],
        parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false") this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    };
    _proto55.addHackNode = function addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR") dom.className = "ProseMirror-trailingBreak";
        var hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top) parent.children.push(hack);else parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    };
    _proto55.isLocked = function isLocked(node) {
      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
    };
    return ViewTreeUpdater;
  }();
  function preMatch(frag, parentDesc) {
    var curDesc = parentDesc,
      descI = curDesc.children.length;
    var fI = frag.childCount,
      matched = /* @__PURE__ */new Map(),
      matches2 = [];
    outer: while (fI > 0) {
      var desc = void 0;
      for (;;) {
        if (descI) {
          var next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      var node = desc.node;
      if (!node) continue;
      if (node != frag.child(fI - 1)) break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
    return {
      index: fI,
      matched: matched,
      matches: matches2.reverse()
    };
  }
  function compareSide(a, b) {
    return a.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    var locals = deco.locals(parent),
      offset = 0;
    if (locals.length == 0) {
      for (var _i176 = 0; _i176 < parent.childCount; _i176++) {
        var child = parent.child(_i176);
        onNode(child, locals, deco.forChild(offset, child), _i176);
        offset += child.nodeSize;
      }
      return;
    }
    var decoIndex = 0,
      active = [],
      restNode = null;
    for (var parentIndex = 0;;) {
      var widget = void 0,
        widgets = void 0;
      while (decoIndex < locals.length && locals[decoIndex].to == offset) {
        var next = locals[decoIndex++];
        if (next.widget) {
          if (!widget) widget = next;else (widgets || (widgets = [widget])).push(next);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (var _i177 = 0; _i177 < widgets.length; _i177++) onWidget(widgets[_i177], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      var _child2 = void 0,
        index = void 0;
      if (restNode) {
        index = -1;
        _child2 = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index = parentIndex;
        _child2 = parent.child(parentIndex++);
      } else {
        break;
      }
      for (var _i178 = 0; _i178 < active.length; _i178++) if (active[_i178].to <= offset) active.splice(_i178--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) active.push(locals[decoIndex++]);
      var end = offset + _child2.nodeSize;
      if (_child2.isText) {
        var cutAt = end;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;
        for (var _i179 = 0; _i179 < active.length; _i179++) if (active[_i179].to < cutAt) cutAt = active[_i179].to;
        if (cutAt < end) {
          restNode = _child2.cut(cutAt - offset);
          _child2 = _child2.cut(0, cutAt - offset);
          end = cutAt;
          index = -1;
        }
      } else {
        while (decoIndex < locals.length && locals[decoIndex].to < end) decoIndex++;
      }
      var outerDeco = _child2.isInline && !_child2.isLeaf ? active.filter(function (d) {
        return !d.inline;
      }) : active.slice();
      onNode(_child2, outerDeco, deco.forChild(offset, _child2), index);
      offset = end;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      var oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function findTextInFragment(frag, text, from2, to) {
    for (var _i180 = 0, pos = 0; _i180 < frag.childCount && pos <= to;) {
      var child = frag.child(_i180++),
        childStart = pos;
      pos += child.nodeSize;
      if (!child.isText) continue;
      var str = child.text;
      while (_i180 < frag.childCount) {
        var next = frag.child(_i180++);
        pos += next.nodeSize;
        if (!next.isText) break;
        str += next.text;
      }
      if (pos >= from2) {
        if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;
        var found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text.length + childStart >= from2) return childStart + found2;
        if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from2, to, view, replacement) {
    var result = [];
    for (var _i181 = 0, off = 0; _i181 < nodes.length; _i181++) {
      var child = nodes[_i181],
        start = off,
        end = off += child.size;
      if (start >= to || end <= from2) {
        result.push(child);
      } else {
        if (start < from2) result.push(child.slice(0, from2 - start, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end > to) result.push(child.slice(to - start, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view) {
    var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var domSel = view.domSelectionRange(),
      doc2 = view.state.doc;
    if (!domSel.focusNode) return null;
    var nearestDesc = view.docView.nearestDesc(domSel.focusNode),
      inWidget = nearestDesc && nearestDesc.size == 0;
    var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head < 0) return null;
    var $head = doc2.resolve(head),
      anchor,
      selection;
    if (selectionCollapsed(domSel)) {
      anchor = head;
      while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent;
      var nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        var pos = nearestDesc.posBefore;
        selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
      }
    } else {
      if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
        var min = head,
          max = head;
        for (var _i182 = 0; _i182 < domSel.rangeCount; _i182++) {
          var range = domSel.getRangeAt(_i182);
          min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
          max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
        }
        if (min < 0) return null;
        var _ref71 = max == view.state.selection.anchor ? [max, min] : [min, max];
        var _ref72 = _slicedToArray(_ref71, 2);
        anchor = _ref72[0];
        head = _ref72[1];
        $head = doc2.resolve(head);
      } else {
        anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      }
      if (anchor < 0) return null;
    }
    var $anchor = doc2.resolve(anchor);
    if (!selection) {
      var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view) {
    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view)) return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      var domSel = view.domSelectionRange(),
        curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      var _anchor2 = sel.anchor,
        head = sel.head,
        resetEditableFrom,
        resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(_anchor2, head, view.root, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom) resetEditable(resetEditableFrom);
        if (resetEditableTo) resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document) removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0),
      node = _view$docView$domFrom3.node,
      offset = _view$docView$domFrom3.offset;
    var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
    var before = offset ? node.childNodes[offset - 1] : null;
    if (safari && after && after.contentEditable == "false") return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after) return setEditable(after);else if (before) return setEditable(before);
    }
  }
  function setEditable(element) {
    element.contentEditable = "true";
    if (safari && element.draggable) {
      element.draggable = false;
      element.wasDraggable = true;
    }
    return element;
  }
  function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
      element.draggable = true;
      element.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    var doc2 = view.dom.ownerDocument;
    doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    var domSel = view.domSelectionRange();
    var node = domSel.anchorNode,
      offset = domSel.anchorOffset;
    doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = function () {
      if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
        doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(function () {
          if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    var domSel = view.domSelection(),
      range = document.createRange();
    if (!domSel) return;
    var node = view.cursorWrapper.dom,
      img = node.nodeName == "IMG";
    if (img) range.setStart(node.parentNode, domIndex(node) + 1);else range.setStart(node, 0);
    range.collapse(true);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
      node.disabled = true;
      node.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      var desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc) desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", function (f) {
      return f(view, $anchor, $head);
    }) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus()) return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    var sel = view.domSelectionRange();
    if (!sel.anchorNode) return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    var domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    var _state$selection = state.selection,
      $anchor = _state$selection.$anchor,
      $head = _state$selection.$head;
    var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    var sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (mods.indexOf("s") > -1) {
        var $head = sel.$head,
          node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
        if (!node || node.isText || !node.isLeaf) return false;
        var $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
        return apply(view, new TextSelection(sel.$anchor, $newHead));
      } else if (!sel.empty) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        var next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection) return apply(view, next);
        return false;
      } else if (!(mac$2 && mods.indexOf("m") > -1)) {
        var _$head = sel.$head,
          _node = _$head.textOffset ? null : dir < 0 ? _$head.nodeBefore : _$head.nodeAfter,
          desc;
        if (!_node || _node.isText) return false;
        var nodePos = dir < 0 ? _$head.pos - _node.nodeSize : _$head.pos;
        if (!(_node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;
        if (NodeSelection.isSelectable(_node)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve(_$head.pos - _node.nodeSize) : _$head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + _node.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      var _next4 = moveSelectionBlock(view.state, dir);
      if (_next4) return apply(view, _next4);
      return false;
    }
  }
  function nodeLen(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    var desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    var sel = view.domSelectionRange();
    var node = sel.focusNode,
      offset = sel.focusOffset;
    if (!node) return;
    var moveNode,
      moveOffset,
      force = false;
    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;
    for (;;) {
      if (offset > 0) {
        if (node.nodeType != 1) {
          break;
        } else {
          var before = node.childNodes[offset - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node;
            moveOffset = --offset;
          } else if (before.nodeType == 3) {
            node = before;
            offset = node.nodeValue.length;
          } else break;
        }
      } else if (isBlockNode(node)) {
        break;
      } else {
        var prev = node.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node = node.parentNode;
          if (node == view.dom) break;
          offset = 0;
        } else {
          node = prev;
          offset = nodeLen(node);
        }
      }
    }
    if (force) setSelFocus(view, node, offset);else if (moveNode) setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    var sel = view.domSelectionRange();
    var node = sel.focusNode,
      offset = sel.focusOffset;
    if (!node) return;
    var len = nodeLen(node);
    var moveNode, moveOffset;
    for (;;) {
      if (offset < len) {
        if (node.nodeType != 1) break;
        var after = node.childNodes[offset];
        if (isIgnorable(after, 1)) {
          moveNode = node;
          moveOffset = ++offset;
        } else break;
      } else if (isBlockNode(node)) {
        break;
      } else {
        var next = node.nextSibling;
        while (next && isIgnorable(next, 1)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node = node.parentNode;
          if (node == view.dom) break;
          offset = len = 0;
        } else {
          node = next;
          offset = 0;
          len = nodeLen(node);
        }
      }
    }
    if (moveNode) setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    var desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node, offset) {
    while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    }
    while (node && offset < node.childNodes.length) {
      var next = node.childNodes[offset];
      if (next.nodeType == 3) return next;
      if (next.nodeType == 1 && next.contentEditable == "false") break;
      node = next;
      offset = 0;
    }
  }
  function textNodeBefore(node, offset) {
    while (node && !offset && !hasBlockDesc(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    }
    while (node && offset) {
      var next = node.childNodes[offset - 1];
      if (next.nodeType == 3) return next;
      if (next.nodeType == 1 && next.contentEditable == "false") break;
      node = next;
      offset = node.childNodes.length;
    }
  }
  function setSelFocus(view, node, offset) {
    if (node.nodeType != 3) {
      var before, after;
      if (after = textNodeAfter(node, offset)) {
        node = after;
        offset = 0;
      } else if (before = textNodeBefore(node, offset)) {
        node = before;
        offset = before.nodeValue.length;
      }
    }
    var sel = view.domSelection();
    if (!sel) return;
    if (selectionCollapsed(sel)) {
      var range = document.createRange();
      range.setEnd(node, offset);
      range.setStart(node, offset);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node, offset);
    }
    view.domObserver.setCurSelection();
    var state = view.state;
    setTimeout(function () {
      if (view.state == state) selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    var $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows) && $pos.parent.inlineContent) {
      var coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        var before = view.coordsAtPos(pos - 1);
        var mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        var after = view.coordsAtPos(pos + 1);
        var _mid = (after.top + after.bottom) / 2;
        if (_mid > coords.top && _mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    var computed2 = getComputedStyle(view.dom).direction;
    return computed2 == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    var sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) return false;
    if (mac$2 && mods.indexOf("m") > -1) return false;
    var $from = sel.$from,
      $to = sel.$to;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection) return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
      var side = dir < 0 ? $from : $to;
      var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection)) return true;
    var _view$state$selection2 = view.state.selection,
      $head = _view$state$selection2.$head,
      $anchor = _view$state$selection2.$anchor,
      empty2 = _view$state$selection2.empty;
    if (!$head.sameParent($anchor)) return true;
    if (!empty2) return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true;
    var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      var tr = view.state.tr;
      if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);else tr.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr);
      return true;
    }
    return false;
  }
  function switchEditable(view, node, state) {
    view.domObserver.stop();
    node.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0) return false;
    var _view$domSelectionRan3 = view.domSelectionRange(),
      focusNode = _view$domSelectionRan3.focusNode,
      focusOffset = _view$domSelectionRan3.focusOffset;
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      var child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(function () {
        return switchEditable(view, child, "false");
      }, 20);
    }
    return false;
  }
  function getMods(event) {
    var result = "";
    if (event.ctrlKey) result += "c";
    if (event.metaKey) result += "m";
    if (event.altKey) result += "a";
    if (event.shiftKey) result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    var code = event.keyCode,
      mods = getMods(event);
    if (code == 8 || mac$2 && code == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code == 46 && !event.shiftKey || mac$2 && code == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code == 13 || code == 27) {
      return true;
    } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
      var dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
      var _dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, _dir, mods) || skipIgnoredNodes(view, _dir);
    } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice2) {
    view.someProp("transformCopied", function (f) {
      slice2 = f(slice2, view);
    });
    var context = [],
      _slice2 = slice2,
      content = _slice2.content,
      openStart = _slice2.openStart,
      openEnd = _slice2.openEnd;
    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      var node = content.firstChild;
      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
      content = node.content;
    }
    var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    var doc2 = detachedDoc(),
      wrap2 = doc2.createElement("div");
    wrap2.appendChild(serializer.serializeFragment(content, {
      document: doc2
    }));
    var firstChild = wrap2.firstChild,
      needsWrap,
      wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (var _i183 = needsWrap.length - 1; _i183 >= 0; _i183--) {
        var wrapper = doc2.createElement(needsWrap[_i183]);
        while (wrap2.firstChild) wrapper.appendChild(wrap2.firstChild);
        wrap2.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap2.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + (wrappers ? " -" + wrappers : "") + " " + JSON.stringify(context));
    var text = view.someProp("clipboardTextSerializer", function (f) {
      return f(slice2, view);
    }) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
    return {
      dom: wrap2,
      text: text,
      slice: slice2
    };
  }
  function parseFromClipboard(view, text, html, plainText, $context) {
    var inCode = $context.parent.type.spec.code;
    var dom, slice2;
    if (!html && !text) return null;
    var asText = text && (plainText || inCode || !html);
    if (asText) {
      view.someProp("transformPastedText", function (f) {
        text = f(text, inCode || plainText, view);
      });
      if (inCode) return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      var parsed = view.someProp("clipboardTextParser", function (f) {
        return f(text, $context, plainText, view);
      });
      if (parsed) {
        slice2 = parsed;
      } else {
        var marks = $context.marks();
        var schema = view.state.schema,
          serializer = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text.split(/(?:\r\n?|\n)+/).forEach(function (block2) {
          var p2 = dom.appendChild(document.createElement("p"));
          if (block2) p2.appendChild(serializer.serializeNode(schema.text(block2, marks)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", function (f) {
        html = f(html, view);
      });
      dom = readHTML(html);
      if (webkit) restoreReplacedSpaces(dom);
    }
    var contextNode = dom && dom.querySelector("[data-pm-slice]");
    var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3]) for (var _i184 = +sliceData[3]; _i184 > 0; _i184--) {
      var child = dom.firstChild;
      while (child && child.nodeType != 1) child = child.nextSibling;
      if (!child) break;
      dom = child;
    }
    if (!slice2) {
      var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
      slice2 = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode: function (dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName)) return {
            ignore: true
          };
          return null;
        }
      });
    }
    if (sliceData) {
      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
      if (slice2.openStart || slice2.openEnd) {
        var openStart = 0,
          openEnd = 0;
        for (var node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}
        for (var _node2 = slice2.content.lastChild; openEnd < slice2.openEnd && !_node2.type.spec.isolating; openEnd++, _node2 = _node2.lastChild) {}
        slice2 = closeSlice(slice2, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", function (f) {
      slice2 = f(slice2, view);
    });
    return slice2;
  }
  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2) return fragment;
    var _loop19 = function () {
        var parent = $context.node(d);
        var match = parent.contentMatchAt($context.index(d));
        var lastWrap,
          result = [];
        fragment.forEach(function (node) {
          if (!result) return;
          var wrap2 = match.findWrapping(node.type),
            inLast;
          if (!wrap2) return result = null;
          if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
            result[result.length - 1] = inLast;
          } else {
            if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
            var wrapped = withWrappers(node, wrap2);
            result.push(wrapped);
            match = match.matchType(wrapped.type);
            lastWrap = wrap2;
          }
        });
        if (result) return {
          v: Fragment.from(result)
        };
      },
      _ret4;
    for (var d = $context.depth; d >= 0; d--) {
      _ret4 = _loop19();
      if (_ret4) return _ret4.v;
    }
    return fragment;
  }
  function withWrappers(node, wrap2) {
    var from2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    for (var _i185 = wrap2.length - 1; _i185 >= from2; _i185--) node = wrap2[_i185].create(null, Fragment.from(node));
    return node;
  }
  function addToSibling(wrap2, lastWrap, node, sibling, depth) {
    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
      var inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
      if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      var match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1])) return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
    }
  }
  function closeRight(node, depth) {
    if (depth == 0) return node;
    var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
    var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
    return node.copy(fragment.append(fill));
  }
  function closeRange(fragment, side, from2, to, depth, openEnd) {
    var node = side < 0 ? fragment.firstChild : fragment.lastChild,
      inner = node.content;
    if (fragment.childCount > 1) openEnd = 0;
    if (depth < to - 1) inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
    if (depth >= from2) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
  }
  function closeSlice(slice2, openStart, openEnd) {
    if (openStart < slice2.openStart) slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
    if (openEnd < slice2.openEnd) slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
    return slice2;
  }
  var wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  var _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  function maybeWrapTrusted(html) {
    var trustedTypes = window.trustedTypes;
    if (!trustedTypes) return html;
    return trustedTypes.createPolicy("detachedDocument", {
      createHTML: function (s) {
        return s;
      }
    }).createHTML(html);
  }
  function readHTML(html) {
    var metas = /^(\s*<meta [^>]*>)*/.exec(html);
    if (metas) html = html.slice(metas[0].length);
    var elt = detachedDoc().createElement("div");
    var firstTag = /<([a-z][^>\s]+)/i.exec(html),
      wrap2;
    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap2.map(function (n) {
      return "<" + n + ">";
    }).join("") + html + wrap2.map(function (n) {
      return "</" + n + ">";
    }).reverse().join("");
    elt.innerHTML = maybeWrapTrusted(html);
    if (wrap2) for (var _i186 = 0; _i186 < wrap2.length; _i186++) elt = elt.querySelector(wrap2[_i186]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (var _i187 = 0; _i187 < nodes.length; _i187++) {
      var node = nodes[_i187];
      if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
    }
  }
  function addContext(slice2, context) {
    if (!slice2.size) return slice2;
    var schema = slice2.content.firstChild.type.schema,
      array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice2;
    }
    var content = slice2.content,
      openStart = slice2.openStart,
      openEnd = slice2.openEnd;
    for (var _i188 = array.length - 2; _i188 >= 0; _i188 -= 2) {
      var type = schema.nodes[array[_i188]];
      if (!type || type.hasRequiredAttrs()) break;
      content = Fragment.from(type.create(array[_i188 + 1], content));
      openStart++;
      openEnd++;
    }
    return new Slice(content, openStart, openEnd);
  }
  var handlers$1 = {};
  var editHandlers = {};
  var passiveHandlers = {
    touchstart: true,
    touchmove: true
  };
  var InputState = function InputState() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = {
      time: 0,
      x: 0,
      y: 0,
      type: ""
    };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */Object.create(null);
    this.hideSelectionGuard = null;
  };
  function initInput(view) {
    var _loop20 = function () {
      var handler = handlers$1[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = function (event2) {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers))) handler(view, event2);
      }, passiveHandlers[event] ? {
        passive: true
      } : void 0);
    };
    for (var event in handlers$1) {
      _loop20();
    }
    if (safari) view.dom.addEventListener("input", function () {
      return null;
    });
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (var type in view.input.eventHandlers) view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", function (currentHandlers) {
      for (var type in currentHandlers) if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = function (event) {
        return runCustomHandler(view, event);
      });
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", function (handlers2) {
      var handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles) return true;
    if (event.defaultPrevented) return false;
    for (var node = event.target; node != view.dom; node = node.parentNode) if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;
    return true;
  }
  function _dispatchEvent(view, event) {
    if (!runCustomHandler(view, event) && handlers$1[event.type] && (view.editable || !(event.type in editHandlers))) handlers$1[event.type](view, event);
  }
  editHandlers.keydown = function (view, _event) {
    var event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event)) return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    if (android && chrome && event.keyCode == 13) return;
    if (view.domObserver.selectionChanged(view.domSelectionRange())) view.domObserver.flush();else if (event.keyCode != 229) view.domObserver.forceFlush();
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      var now2 = Date.now();
      view.input.lastIOSEnter = now2;
      view.input.lastIOSEnterFallbackTimeout = setTimeout(function () {
        if (view.input.lastIOSEnter == now2) {
          view.someProp("handleKeyDown", function (f) {
            return f(view, keyEvent(13, "Enter"));
          });
          view.input.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", function (f) {
      return f(view, event);
    }) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = function (view, event) {
    if (event.keyCode == 16) view.input.shiftKey = false;
  };
  editHandlers.keypress = function (view, _event) {
    var event = _event;
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey) return;
    if (view.someProp("handleKeyPress", function (f) {
      return f(view, event);
    })) {
      event.preventDefault();
      return;
    }
    var sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      var text = String.fromCharCode(event.charCode);
      if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", function (f) {
        return f(view, sel.$from.pos, sel.$to.pos, text);
      })) view.dispatch(view.state.tr.insertText(text).scrollIntoView());
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return {
      left: event.clientX,
      top: event.clientY
    };
  }
  function isNear(event, click) {
    var dx = click.x - event.clientX,
      dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1) return false;
    var $pos = view.state.doc.resolve(inside);
    var _loop21 = function (_i189) {
        if (view.someProp(propName, function (f) {
          return _i189 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(_i189), event, true) : f(view, pos, $pos.node(_i189), $pos.before(_i189), event, false);
        })) return {
          v: true
        };
      },
      _ret5;
    for (var _i189 = $pos.depth + 1; _i189 > 0; _i189--) {
      _ret5 = _loop21(_i189);
      if (_ret5) return _ret5.v;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused) view.focus();
    if (view.state.selection.eq(selection)) return;
    var tr = view.state.tr.setSelection(selection);
    if (origin == "pointer") tr.setMeta("pointer", true);
    view.dispatch(tr);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1) return false;
    var $pos = view.state.doc.resolve(inside),
      node = $pos.nodeAfter;
    if (node && node.isAtom && NodeSelection.isSelectable(node)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1) return false;
    var sel = view.state.selection,
      selectedNode,
      selectAt;
    if (sel instanceof NodeSelection) selectedNode = sel.node;
    var $pos = view.state.doc.resolve(inside);
    for (var _i190 = $pos.depth + 1; _i190 > 0; _i190--) {
      var node = _i190 > $pos.depth ? $pos.nodeAfter : $pos.node(_i190);
      if (NodeSelection.isSelectable(node)) {
        if (selectedNode && sel.$from.depth > 0 && _i190 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);else selectAt = $pos.before(_i190);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function (f) {
      return f(view, pos, event);
    }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function (f) {
      return f(view, pos, event);
    });
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function (f) {
      return f(view, pos, event);
    }) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0) return false;
    var doc2 = view.state.doc;
    if (inside == -1) {
      if (doc2.inlineContent) {
        updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
        return true;
      }
      return false;
    }
    var $pos = doc2.resolve(inside);
    for (var _i191 = $pos.depth + 1; _i191 > 0; _i191--) {
      var node = _i191 > $pos.depth ? $pos.nodeAfter : $pos.node(_i191);
      var nodePos = $pos.before(_i191);
      if (node.inlineContent) updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size), "pointer");else if (NodeSelection.isSelectable(node)) updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");else continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  var selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
  handlers$1.mousedown = function (view, _event) {
    var event = _event;
    view.input.shiftKey = event.shiftKey;
    var flushed = forceDOMFlush(view);
    var now2 = Date.now(),
      type = "singleClick";
    if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
      if (view.input.lastClick.type == "singleClick") type = "doubleClick";else if (view.input.lastClick.type == "doubleClick") type = "tripleClick";
    }
    view.input.lastClick = {
      time: now2,
      x: event.clientX,
      y: event.clientY,
      type: type
    };
    var pos = view.posAtCoords(eventCoords(event));
    if (!pos) return;
    if (type == "singleClick") {
      if (view.input.mouseDown) view.input.mouseDown.done();
      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  var MouseDown = /*#__PURE__*/function () {
    function MouseDown(view, pos, event, flushed) {
      var _this30 = this;
      this.view = view;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.delayedSelectionSync = false;
      this.mightDrag = null;
      this.startDoc = view.state.doc;
      this.selectNode = !!event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      var targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        var $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      var target = flushed ? null : event.target;
      var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
      var selection = view.state.selection;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) this.target.draggable = true;
        if (this.mightDrag.setUneditable) setTimeout(function () {
          if (_this30.view.input.mouseDown == _this30) _this30.target.setAttribute("contentEditable", "false");
        }, 20);
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    }
    var _proto56 = MouseDown.prototype;
    _proto56.done = function done() {
      var _this31 = this;
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync) setTimeout(function () {
        return selectionToDOM(_this31.view);
      });
      this.view.input.mouseDown = null;
    };
    _proto56.up = function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target)) return;
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    };
    _proto56.move = function move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) this.done();
    };
    _proto56.updateAllowDefault = function updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;
    };
    return MouseDown;
  }();
  handlers$1.touchstart = function (view) {
    view.input.lastTouch = Date.now();
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers$1.touchmove = function (view) {
    view.input.lastTouch = Date.now();
    setSelectionOrigin(view, "pointer");
  };
  handlers$1.contextmenu = function (view) {
    return forceDOMFlush(view);
  };
  function inOrNearComposition(view, event) {
    if (view.composing) return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  var timeoutComposition = android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
    if (!view.composing) {
      view.domObserver.flush();
      var state = view.state,
        $pos = state.selection.$to;
      if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m3) {
        return m3.type.spec.inclusive === false;
      }))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view, !state.selection.empty);
        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          var sel = view.domSelectionRange();
          for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
            var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
            if (!before) break;
            if (before.nodeType == 3) {
              var sel2 = view.domSelection();
              if (sel2) sel2.collapse(before, before.nodeValue.length);
              break;
            } else {
              node = before;
              offset = -1;
            }
          }
        }
      }
      view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = function (view, event) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = event.timeStamp;
      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
      view.input.compositionNode = null;
      if (view.input.compositionPendingChanges) Promise.resolve().then(function () {
        return view.domObserver.flush();
      });
      view.input.compositionID++;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1) view.input.composingTimeout = setTimeout(function () {
      return endComposition(view);
    }, delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0) view.input.compositionNodes.pop().markParentsDirty();
  }
  function findCompositionNode(view) {
    var sel = view.domSelectionRange();
    if (!sel.focusNode) return null;
    var textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
    var textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
    if (textBefore && textAfter && textBefore != textAfter) {
      var descAfter = textAfter.pmViewDesc,
        lastChanged = view.domObserver.lastChangedTextNode;
      if (textBefore == lastChanged || textAfter == lastChanged) return lastChanged;
      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
        return textAfter;
      } else if (view.input.compositionNode == textAfter) {
        var descBefore = textBefore.pmViewDesc;
        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue))) return textAfter;
      }
    }
    return textBefore || textAfter;
  }
  function timestampFromCustomEvent() {
    var event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view) {
    var restarting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (android && view.domObserver.flushingSoon >= 0) return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (restarting || view.docView && view.docView.dirty) {
      var sel = selectionFromDOM(view);
      if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));else if ((view.markCursor || restarting) && !view.state.selection.empty) view.dispatch(view.state.tr.deleteSelection());else view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode) return;
    var wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap2.appendChild(dom);
    wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
    var sel = getSelection(),
      range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(function () {
      if (wrap2.parentNode) wrap2.parentNode.removeChild(wrap2);
      view.focus();
    }, 50);
  }
  var brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
  handlers$1.copy = editHandlers.cut = function (view, _event) {
    var event = _event;
    var sel = view.state.selection,
      cut2 = event.type == "cut";
    if (sel.empty) return;
    var data = brokenClipboardAPI ? null : event.clipboardData;
    var slice2 = sel.content(),
      _serializeForClipboar = serializeForClipboard(view, slice2),
      dom = _serializeForClipboar.dom,
      text = _serializeForClipboar.text;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text);
    } else {
      captureCopy(view, dom);
    }
    if (cut2) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function sliceSingleNode(slice2) {
    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode) return;
    var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText) target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(function () {
      view.focus();
      if (target.parentNode) target.parentNode.removeChild(target);
      if (plainText) doPaste(view, target.value, null, plain, event);else doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text, html, preferPlain, event) {
    var slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", function (f) {
      return f(view, event, slice2 || Slice.empty);
    })) return true;
    if (!slice2) return false;
    var singleNode = sliceSingleNode(slice2);
    var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  function getText$1(clipboardData) {
    var text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
    if (text) return text;
    var uris = clipboardData.getData("text/uri-list");
    return uris ? uris.replace(/\r?\n/g, " ") : "";
  }
  editHandlers.paste = function (view, _event) {
    var event = _event;
    if (view.composing && !android) return;
    var data = brokenClipboardAPI ? null : event.clipboardData;
    var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    if (data && doPaste(view, getText$1(data), data.getData("text/html"), plain, event)) event.preventDefault();else capturePaste(view, event);
  };
  var Dragging = function Dragging(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  };
  var dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
  handlers$1.dragstart = function (view, _event) {
    var event = _event;
    var mouseDown = view.input.mouseDown;
    if (mouseDown) mouseDown.done();
    if (!event.dataTransfer) return;
    var sel = view.state.selection;
    var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    var node;
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;else if (mouseDown && mouseDown.mightDrag) {
      node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
    } else if (event.target && event.target.nodeType == 1) {
      var desc = view.docView.nearestDesc(event.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView) node = NodeSelection.create(view.state.doc, desc.posBefore);
    }
    var draggedSlice = (node || view.state.selection).content();
    var _serializeForClipboar2 = serializeForClipboard(view, draggedSlice),
      dom = _serializeForClipboar2.dom,
      text = _serializeForClipboar2.text,
      slice2 = _serializeForClipboar2.slice;
    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120) event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
    view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
  };
  handlers$1.dragend = function (view) {
    var dragging = view.dragging;
    window.setTimeout(function () {
      if (view.dragging == dragging) view.dragging = null;
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = function (_, e) {
    return e.preventDefault();
  };
  editHandlers.drop = function (view, _event) {
    var event = _event;
    var dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer) return;
    var eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos) return;
    var $mouse = view.state.doc.resolve(eventPos.pos);
    var slice2 = dragging && dragging.slice;
    if (slice2) {
      view.someProp("transformPasted", function (f) {
        slice2 = f(slice2, view);
      });
    } else {
      slice2 = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    var move = !!(dragging && !event[dragCopyModifier]);
    if (view.someProp("handleDrop", function (f) {
      return f(view, event, slice2 || Slice.empty, move);
    })) {
      event.preventDefault();
      return;
    }
    if (!slice2) return;
    event.preventDefault();
    var insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
    if (insertPos == null) insertPos = $mouse.pos;
    var tr = view.state.tr;
    if (move) {
      var node = dragging.node;
      if (node) node.replace(tr);else tr.deleteSelection();
    }
    var pos = tr.mapping.map(insertPos);
    var isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
    var beforeInsert = tr.doc;
    if (isNode) tr.replaceRangeWith(pos, pos, slice2.content.firstChild);else tr.replaceRange(pos, pos, slice2);
    if (tr.doc.eq(beforeInsert)) return;
    var $pos = tr.doc.resolve(pos);
    if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
      tr.setSelection(new NodeSelection($pos));
    } else {
      var end = tr.mapping.map(insertPos);
      tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) {
        return end = newTo;
      });
      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
    }
    view.focus();
    view.dispatch(tr.setMeta("uiEvent", "drop"));
  };
  handlers$1.focus = function (view) {
    view.input.lastFocus = Date.now();
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(function () {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);
      }, 20);
    }
  };
  handlers$1.blur = function (view, _event) {
    var event = _event;
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();
      view.focused = false;
    }
  };
  handlers$1.beforeinput = function (view, _event) {
    var event = _event;
    if (chrome && android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      var domChangeCount = view.input.domChangeCount;
      setTimeout(function () {
        if (view.input.domChangeCount != domChangeCount) return;
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(8, "Backspace"));
        })) return;
        var $cursor = view.state.selection.$cursor;
        if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }, 50);
    }
  };
  for (var prop in editHandlers) handlers$1[prop] = editHandlers[prop];
  function compareObjs(a, b) {
    if (a == b) return true;
    for (var p2 in a) if (a[p2] !== b[p2]) return false;
    for (var _p3 in b) if (!(_p3 in a)) return false;
    return true;
  }
  var WidgetType = /*#__PURE__*/function () {
    function WidgetType(toDOM, spec) {
      this.toDOM = toDOM;
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
    }
    var _proto57 = WidgetType.prototype;
    _proto57.map = function map(mapping, span, offset, oldOffset) {
      var _mapping$mapResult3 = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1),
        pos = _mapping$mapResult3.pos,
        deleted = _mapping$mapResult3.deleted;
      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    };
    _proto57.valid = function valid() {
      return true;
    };
    _proto57.eq = function eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    };
    _proto57.destroy = function destroy(node) {
      if (this.spec.destroy) this.spec.destroy(node);
    };
    return WidgetType;
  }();
  var InlineType = /*#__PURE__*/function () {
    function InlineType(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    var _proto58 = InlineType.prototype;
    _proto58.map = function map(mapping, span, offset, oldOffset) {
      var from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from2 >= to ? null : new Decoration(from2, to, this);
    };
    _proto58.valid = function valid(_, span) {
      return span.from < span.to;
    };
    _proto58.eq = function eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    InlineType.is = function is(span) {
      return span.type instanceof InlineType;
    };
    _proto58.destroy = function destroy() {};
    return InlineType;
  }();
  var NodeType = /*#__PURE__*/function () {
    function NodeType(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    var _proto59 = NodeType.prototype;
    _proto59.map = function map(mapping, span, offset, oldOffset) {
      var from2 = mapping.mapResult(span.from + oldOffset, 1);
      if (from2.deleted) return null;
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from2.pos) return null;
      return new Decoration(from2.pos - offset, to.pos - offset, this);
    };
    _proto59.valid = function valid(node, span) {
      var _node$content$findInd3 = node.content.findIndex(span.from),
        index = _node$content$findInd3.index,
        offset = _node$content$findInd3.offset,
        child;
      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
    };
    _proto59.eq = function eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    _proto59.destroy = function destroy() {};
    return NodeType;
  }();
  var Decoration = /*#__PURE__*/function () {
    function Decoration(from2, to, type) {
      this.from = from2;
      this.to = to;
      this.type = type;
    }
    var _proto60 = Decoration.prototype;
    _proto60.copy = function copy(from2, to) {
      return new Decoration(from2, to, this.type);
    };
    _proto60.eq = function eq(other) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    };
    _proto60.map = function map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    };
    Decoration.widget = function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    };
    Decoration.inline = function inline(from2, to, attrs, spec) {
      return new Decoration(from2, to, new InlineType(attrs, spec));
    };
    Decoration.node = function node(from2, to, attrs, spec) {
      return new Decoration(from2, to, new NodeType(attrs, spec));
    };
    return _createClass(Decoration, [{
      key: "spec",
      get: function () {
        return this.type.spec;
      }
    }, {
      key: "inline",
      get: function () {
        return this.type instanceof InlineType;
      }
    }, {
      key: "widget",
      get: function () {
        return this.type instanceof WidgetType;
      }
    }]);
  }();
  var none = [],
    noSpec = {};
  var DecorationSet = /*#__PURE__*/function () {
    function DecorationSet(local, children) {
      this.local = local.length ? local : none;
      this.children = children.length ? children : none;
    }
    DecorationSet.create = function create(doc2, decorations) {
      return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
    };
    var _proto61 = DecorationSet.prototype;
    _proto61.find = function find(start, end, predicate) {
      var result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    };
    _proto61.findInner = function findInner(start, end, result, offset, predicate) {
      for (var _i192 = 0; _i192 < this.local.length; _i192++) {
        var span = this.local[_i192];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));
      }
      for (var _i193 = 0; _i193 < this.children.length; _i193 += 3) {
        if (this.children[_i193] < end && this.children[_i193 + 1] > start) {
          var childOff = this.children[_i193] + 1;
          this.children[_i193 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    };
    _proto61.map = function map(mapping, doc2, options) {
      if (this == empty || mapping.maps.length == 0) return this;
      return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
    };
    _proto61.mapInner = function mapInner(mapping, node, offset, oldOffset, options) {
      var newLocal;
      for (var _i194 = 0; _i194 < this.local.length; _i194++) {
        var mapped = this.local[_i194].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);else if (options.onRemove) options.onRemove(this.local[_i194].spec);
      }
      if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    };
    _proto61.add = function add(doc2, decorations) {
      if (!decorations.length) return this;
      if (this == empty) return DecorationSet.create(doc2, decorations);
      return this.addInner(doc2, decorations, 0);
    };
    _proto61.addInner = function addInner(doc2, decorations, offset) {
      var _this32 = this;
      var children,
        childIndex = 0;
      doc2.forEach(function (childNode, childOffset) {
        var baseOffset = childOffset + offset,
          found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset))) return;
        if (!children) children = _this32.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3;
        if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (var _i195 = 0; _i195 < local.length; _i195++) if (!local[_i195].type.valid(doc2, local[_i195])) local.splice(_i195--, 1);
      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    };
    _proto61.remove = function remove(decorations) {
      if (decorations.length == 0 || this == empty) return this;
      return this.removeInner(decorations, 0);
    };
    _proto61.removeInner = function removeInner(decorations, offset) {
      var children = this.children,
        local = this.local;
      for (var _i196 = 0; _i196 < children.length; _i196 += 3) {
        var found2 = void 0;
        var _from4 = children[_i196] + offset,
          to = children[_i196 + 1] + offset;
        for (var j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {
          if (span.from > _from4 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
        if (!found2) continue;
        if (children == this.children) children = this.children.slice();
        var removed = children[_i196 + 2].removeInner(found2, _from4 + 1);
        if (removed != empty) {
          children[_i196 + 2] = removed;
        } else {
          children.splice(_i196, 3);
          _i196 -= 3;
        }
      }
      if (local.length) {
        for (var _i197 = 0, _span; _i197 < decorations.length; _i197++) if (_span = decorations[_i197]) {
          for (var _j3 = 0; _j3 < local.length; _j3++) if (local[_j3].eq(_span, offset)) {
            if (local == this.local) local = this.local.slice();
            local.splice(_j3--, 1);
          }
        }
      }
      if (children == this.children && local == this.local) return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    };
    _proto61.forChild = function forChild(offset, node) {
      if (this == empty) return this;
      if (node.isLeaf) return DecorationSet.empty;
      var child, local;
      for (var _i198 = 0; _i198 < this.children.length; _i198 += 3) if (this.children[_i198] >= offset) {
        if (this.children[_i198] == offset) child = this.children[_i198 + 2];
        break;
      }
      var start = offset + 1,
        end = start + node.content.size;
      for (var _i199 = 0; _i199 < this.local.length; _i199++) {
        var dec = this.local[_i199];
        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          var _from5 = Math.max(start, dec.from) - start,
            to = Math.min(end, dec.to) - start;
          if (_from5 < to) (local || (local = [])).push(dec.copy(_from5, to));
        }
      }
      if (local) {
        var localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    };
    _proto61.eq = function eq(other) {
      if (this == other) return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;
      for (var _i200 = 0; _i200 < this.local.length; _i200++) if (!this.local[_i200].eq(other.local[_i200])) return false;
      for (var _i201 = 0; _i201 < this.children.length; _i201 += 3) if (this.children[_i201] != other.children[_i201] || this.children[_i201 + 1] != other.children[_i201 + 1] || !this.children[_i201 + 2].eq(other.children[_i201 + 2])) return false;
      return true;
    };
    _proto61.locals = function locals(node) {
      return removeOverlap(this.localsInner(node));
    };
    _proto61.localsInner = function localsInner(node) {
      if (this == empty) return none;
      if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;
      var result = [];
      for (var _i202 = 0; _i202 < this.local.length; _i202++) {
        if (!(this.local[_i202].type instanceof InlineType)) result.push(this.local[_i202]);
      }
      return result;
    };
    _proto61.forEachSet = function forEachSet(f) {
      f(this);
    };
    return DecorationSet;
  }();
  DecorationSet.empty = new DecorationSet([], []);
  DecorationSet.removeOverlap = removeOverlap;
  var empty = DecorationSet.empty;
  var DecorationGroup = /*#__PURE__*/function () {
    function DecorationGroup(members) {
      this.members = members;
    }
    var _proto62 = DecorationGroup.prototype;
    _proto62.map = function map(mapping, doc2) {
      var mappedDecos = this.members.map(function (member) {
        return member.map(mapping, doc2, noSpec);
      });
      return DecorationGroup.from(mappedDecos);
    };
    _proto62.forChild = function forChild(offset, child) {
      if (child.isLeaf) return DecorationSet.empty;
      var found2 = [];
      for (var _i203 = 0; _i203 < this.members.length; _i203++) {
        var result = this.members[_i203].forChild(offset, child);
        if (result == empty) continue;
        if (result instanceof DecorationGroup) found2 = found2.concat(result.members);else found2.push(result);
      }
      return DecorationGroup.from(found2);
    };
    _proto62.eq = function eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;
      for (var _i204 = 0; _i204 < this.members.length; _i204++) if (!this.members[_i204].eq(other.members[_i204])) return false;
      return true;
    };
    _proto62.locals = function locals(node) {
      var result,
        sorted = true;
      for (var _i205 = 0; _i205 < this.members.length; _i205++) {
        var locals = this.members[_i205].localsInner(node);
        if (!locals.length) continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (var j = 0; j < locals.length; j++) result.push(locals[j]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    };
    DecorationGroup.from = function from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members.every(function (m3) {
            return m3 instanceof DecorationSet;
          }) ? members : members.reduce(function (r, m3) {
            return r.concat(m3 instanceof DecorationSet ? m3 : m3.members);
          }, []));
      }
    };
    _proto62.forEachSet = function forEachSet(f) {
      for (var _i206 = 0; _i206 < this.members.length; _i206++) this.members[_i206].forEachSet(f);
    };
    return DecorationGroup;
  }();
  function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
    var children = oldChildren.slice();
    var _loop22 = function (_baseOffset) {
      var moved = 0;
      mapping.maps[_i207].forEach(function (oldStart, oldEnd, newStart, newEnd) {
        var dSize = newEnd - newStart - (oldEnd - oldStart);
        for (var i2 = 0; i2 < children.length; i2 += 3) {
          var end = children[i2 + 1];
          if (end < 0 || oldStart > end + _baseOffset - moved) continue;
          var start = children[i2] + _baseOffset - moved;
          if (oldEnd >= start) {
            children[i2 + 1] = oldStart <= start ? -2 : -1;
          } else if (oldStart >= _baseOffset && dSize) {
            children[i2] += dSize;
            children[i2 + 1] += dSize;
          }
        }
        moved += dSize;
      });
      _baseOffset = mapping.maps[_i207].map(_baseOffset, -1);
      baseOffset = _baseOffset;
    };
    for (var _i207 = 0, baseOffset = oldOffset; _i207 < mapping.maps.length; _i207++) {
      _loop22(baseOffset);
    }
    var mustRebuild = false;
    for (var _i208 = 0; _i208 < children.length; _i208 += 3) if (children[_i208 + 1] < 0) {
      if (children[_i208 + 1] == -2) {
        mustRebuild = true;
        children[_i208 + 1] = -1;
        continue;
      }
      var _from6 = mapping.map(oldChildren[_i208] + oldOffset),
        fromLocal = _from6 - offset;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[_i208 + 1] + oldOffset, -1),
        toLocal = to - offset;
      var _node$content$findInd4 = node.content.findIndex(fromLocal),
        index = _node$content$findInd4.index,
        childOffset = _node$content$findInd4.offset;
      var childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[_i208 + 2].mapInner(mapping, childNode, _from6 + 1, oldChildren[_i208] + oldOffset + 1, options);
        if (mapped != empty) {
          children[_i208] = fromLocal;
          children[_i208 + 1] = toLocal;
          children[_i208 + 2] = mapped;
        } else {
          children[_i208 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
    if (mustRebuild) {
      var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
      var built = buildTree(decorations, node, 0, options);
      newLocal = built.local;
      for (var _i209 = 0; _i209 < children.length; _i209 += 3) if (children[_i209 + 1] < 0) {
        children.splice(_i209, 3);
        _i209 -= 3;
      }
      for (var _i210 = 0, j = 0; _i210 < built.children.length; _i210 += 3) {
        var _from7 = built.children[_i210];
        while (j < children.length && children[j] < _from7) j += 3;
        children.splice(j, 0, built.children[_i210], built.children[_i210 + 1], built.children[_i210 + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset) {
    if (!offset || !spans.length) return spans;
    var result = [];
    for (var _i211 = 0; _i211 < spans.length; _i211++) {
      var span = spans[_i211];
      result.push(new Decoration(span.from + offset, span.to + offset, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
    function gather(set, oldOffset2) {
      for (var _i212 = 0; _i212 < set.local.length; _i212++) {
        var mapped = set.local[_i212].map(mapping, offset, oldOffset2);
        if (mapped) decorations.push(mapped);else if (options.onRemove) options.onRemove(set.local[_i212].spec);
      }
      for (var _i213 = 0; _i213 < set.children.length; _i213 += 3) gather(set.children[_i213 + 2], set.children[_i213] + oldOffset2 + 1);
    }
    for (var _i214 = 0; _i214 < children.length; _i214 += 3) if (children[_i214 + 1] == -1) gather(children[_i214 + 2], oldChildren[_i214] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node, offset) {
    if (node.isLeaf) return null;
    var end = offset + node.nodeSize,
      found2 = null;
    for (var _i215 = 0, span; _i215 < spans.length; _i215++) {
      if ((span = spans[_i215]) && span.from > offset && span.to < end) {
        (found2 || (found2 = [])).push(span);
        spans[_i215] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    var result = [];
    for (var _i216 = 0; _i216 < array.length; _i216++) if (array[_i216] != null) result.push(array[_i216]);
    return result;
  }
  function buildTree(spans, node, offset, options) {
    var children = [],
      hasNulls = false;
    node.forEach(function (childNode, localStart) {
      var found2 = takeSpansForNode(spans, childNode, localStart + offset);
      if (found2) {
        hasNulls = true;
        var subtree = buildTree(found2, childNode, offset + localStart + 1, options);
        if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
    for (var _i217 = 0; _i217 < locals.length; _i217++) if (!locals[_i217].type.valid(node, locals[_i217])) {
      if (options.onRemove) options.onRemove(locals[_i217].spec);
      locals.splice(_i217--, 1);
    }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
  }
  function byPos(a, b) {
    return a.from - b.from || a.to - b.to;
  }
  function removeOverlap(spans) {
    var working = spans;
    for (var _i218 = 0; _i218 < working.length - 1; _i218++) {
      var span = working[_i218];
      if (span.from != span.to) for (var j = _i218 + 1; j < working.length; j++) {
        var next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) working = spans.slice();
            working[_i218] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
    return working;
  }
  function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0) i++;
    array.splice(i, 0, deco);
  }
  function viewDecorations(view) {
    var found2 = [];
    view.someProp("decorations", function (f) {
      var result = f(view.state);
      if (result && result != empty) found2.push(result);
    });
    if (view.cursorWrapper) found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  var useCharData = ie$1 && ie_version <= 11;
  var SelectionState = /*#__PURE__*/function () {
    function SelectionState() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    var _proto63 = SelectionState.prototype;
    _proto63.set = function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    };
    _proto63.clear = function clear() {
      this.anchorNode = this.focusNode = null;
    };
    _proto63.eq = function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    };
    return SelectionState;
  }();
  var DOMObserver = /*#__PURE__*/function () {
    function DOMObserver(view, handleDOMChange) {
      var _this33 = this;
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = null;
      this.currentSelection = new SelectionState();
      this.onCharData = null;
      this.suppressingSelectionUpdates = false;
      this.lastChangedTextNode = null;
      this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {
        for (var _i219 = 0; _i219 < mutations.length; _i219++) _this33.queue.push(mutations[_i219]);
        if (ie$1 && ie_version <= 11 && mutations.some(function (m3) {
          return m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length;
        })) _this33.flushSoon();else _this33.flush();
      });
      if (useCharData) {
        this.onCharData = function (e) {
          _this33.queue.push({
            target: e.target,
            type: "characterData",
            oldValue: e.prevValue
          });
          _this33.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    var _proto64 = DOMObserver.prototype;
    _proto64.flushSoon = function flushSoon() {
      var _this34 = this;
      if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function () {
        _this34.flushingSoon = -1;
        _this34.flush();
      }, 20);
    };
    _proto64.forceFlush = function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    };
    _proto64.start = function start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData) this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    };
    _proto64.stop = function stop() {
      var _this35 = this;
      if (this.observer) {
        var take = this.observer.takeRecords();
        if (take.length) {
          for (var _i220 = 0; _i220 < take.length; _i220++) this.queue.push(take[_i220]);
          window.setTimeout(function () {
            return _this35.flush();
          }, 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    };
    _proto64.connectSelection = function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    };
    _proto64.disconnectSelection = function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    };
    _proto64.suppressSelectionUpdates = function suppressSelectionUpdates() {
      var _this36 = this;
      this.suppressingSelectionUpdates = true;
      setTimeout(function () {
        return _this36.suppressingSelectionUpdates = false;
      }, 50);
    };
    _proto64.onSelectionChange = function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) return;
      if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);
      if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();
      }
      this.flush();
    };
    _proto64.setCurSelection = function setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    };
    _proto64.ignoreSelectionChange = function ignoreSelectionChange(sel) {
      if (!sel.focusNode) return true;
      var ancestors = /* @__PURE__ */new Set(),
        container;
      for (var scan = sel.focusNode; scan; scan = parentNode(scan)) ancestors.add(scan);
      for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan)) if (ancestors.has(_scan)) {
        container = _scan;
        break;
      }
      var desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    };
    _proto64.pendingRecords = function pendingRecords() {
      if (this.observer) {
        for (var _iterator28 = _createForOfIteratorHelperLoose(this.observer.takeRecords()), _step30; !(_step30 = _iterator28()).done;) {
          var mut = _step30.value;
          this.queue.push(mut);
        }
      }
      return this.queue;
    };
    _proto64.selectionChanged = function selectionChanged(sel) {
      return !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(this.view) && !this.ignoreSelectionChange(sel);
    };
    _proto64.flush = function flush() {
      var view = this.view;
      if (!view.docView || this.flushingSoon > -1) return;
      var mutations = this.pendingRecords();
      if (mutations.length) this.queue = [];
      var sel = view.domSelectionRange(),
        newSel = this.selectionChanged(sel);
      var from2 = -1,
        to = -1,
        typeOver = false,
        added = [];
      if (view.editable) {
        for (var _i221 = 0; _i221 < mutations.length; _i221++) {
          var result = this.registerMutation(mutations[_i221], added);
          if (result) {
            from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver) typeOver = true;
          }
        }
      }
      if (gecko && added.length) {
        var brs = added.filter(function (n) {
          return n.nodeName == "BR";
        });
        if (brs.length == 2) {
          var _brs = _slicedToArray(brs, 2),
            a = _brs[0],
            b = _brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();else a.remove();
        } else {
          var focusNode = this.currentSelection.focusNode;
          for (var _iterator29 = _createForOfIteratorHelperLoose(brs), _step31; !(_step31 = _iterator29()).done;) {
            var br = _step31.value;
            var parent = br.parentNode;
            if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent)) br.remove();
          }
        }
      }
      var readSel = null;
      if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from2 > -1 || newSel) {
        if (from2 > -1) {
          view.docView.markDirty(from2, to);
          checkCSS(view);
        }
        this.handleDOMChange(from2, to, typeOver, added);
        if (view.docView && view.docView.dirty) view.updateState(view.state);else if (!this.currentSelection.eq(sel)) selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    };
    _proto64.registerMutation = function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) return null;
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) return null;
      if (!desc || desc.ignoreMutation(mut)) return null;
      if (mut.type == "childList") {
        for (var _i222 = 0; _i222 < mut.addedNodes.length; _i222++) {
          var node = mut.addedNodes[_i222];
          added.push(node);
          if (node.nodeType == 3) this.lastChangedTextNode = node;
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {
          from: desc.posBefore,
          to: desc.posAfter
        };
        var prev = mut.previousSibling,
          next = mut.nextSibling;
        if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
          for (var _i223 = 0; _i223 < mut.addedNodes.length; _i223++) {
            var _mut$addedNodes$_i = mut.addedNodes[_i223],
              previousSibling = _mut$addedNodes$_i.previousSibling,
              nextSibling = _mut$addedNodes$_i.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;
          }
        }
        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var _from8 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return {
          from: _from8,
          to: to
        };
      } else if (mut.type == "attributes") {
        return {
          from: desc.posAtStart - desc.border,
          to: desc.posAtEnd + desc.border
        };
      } else {
        this.lastChangedTextNode = mut.target;
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    };
    return DOMObserver;
  }();
  var cssChecked = /* @__PURE__ */new WeakMap();
  var cssCheckWarned = false;
  function checkCSS(view) {
    if (cssChecked.has(view)) return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned) return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function rangeToSelectionRange(view, range) {
    var anchorNode = range.startContainer,
      anchorOffset = range.startOffset;
    var focusNode = range.endContainer,
      focusOffset = range.endOffset;
    var currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {
      var _ref73 = [focusNode, focusOffset, anchorNode, anchorOffset];
      anchorNode = _ref73[0];
      anchorOffset = _ref73[1];
      focusNode = _ref73[2];
      focusOffset = _ref73[3];
    }
    return {
      anchorNode: anchorNode,
      anchorOffset: anchorOffset,
      focusNode: focusNode,
      focusOffset: focusOffset
    };
  }
  function safariShadowSelectionRange(view, selection) {
    if (selection.getComposedRanges) {
      var range = selection.getComposedRanges(view.root)[0];
      if (range) return rangeToSelectionRange(view, range);
    }
    var found2;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read, true);
    return found2 ? rangeToSelectionRange(view, found2) : null;
  }
  function blockParent(view, node) {
    for (var p2 = node.parentNode; p2 && p2 != view.dom; p2 = p2.parentNode) {
      var desc = view.docView.nearestDesc(p2, true);
      if (desc && desc.node.isBlock) return p2;
    }
    return null;
  }
  function parseBetween(view, from_, to_) {
    var _view$docView$parseRa = view.docView.parseRange(from_, to_),
      parent = _view$docView$parseRa.node,
      fromOffset = _view$docView$parseRa.fromOffset,
      toOffset = _view$docView$parseRa.toOffset,
      from2 = _view$docView$parseRa.from,
      to = _view$docView$parseRa.to;
    var domSel = view.domSelectionRange();
    var find;
    var anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find = [{
        node: anchor,
        offset: domSel.anchorOffset
      }];
      if (!selectionCollapsed(domSel)) find.push({
        node: domSel.focusNode,
        offset: domSel.focusOffset
      });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (var off = toOffset; off > fromOffset; off--) {
        var node = parent.childNodes[off - 1],
          desc = node.pmViewDesc;
        if (node.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size) break;
      }
    }
    var startDoc = view.state.doc;
    var parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    var $from = startDoc.resolve(from2);
    var sel = null,
      doc2 = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: find,
        ruleFromNode: ruleFromNode,
        context: $from
      });
    if (find && find[0].pos != null) {
      var anchor2 = find[0].pos,
        head = find[1] && find[1].pos;
      if (head == null) head = anchor2;
      sel = {
        anchor: anchor2 + from2,
        head: head + from2
      };
    }
    return {
      doc: doc2,
      sel: sel,
      from: from2,
      to: to
    };
  }
  function ruleFromNode(dom) {
    var desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        var skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return {
          skip: skip
        };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return {
          ignore: true
        };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return {
        ignore: true
      };
    }
    return null;
  }
  var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function readDOMChange(view, from2, to, typeOver, addedNodes) {
    var compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from2 < 0) {
      var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      var newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        })) return;
        var tr2 = view.state.tr.setSelection(newSel);
        if (origin == "pointer") tr2.setMeta("pointer", true);else if (origin == "key") tr2.scrollIntoView();
        if (compositionID) tr2.setMeta("composition", compositionID);
        view.dispatch(tr2);
      }
      return;
    }
    var $before = view.state.doc.resolve(from2);
    var shared = $before.sharedDepth(to);
    from2 = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    var sel = view.state.selection;
    var parse2 = parseBetween(view, from2, to);
    var doc2 = view.state.doc,
      compare = doc2.slice(parse2.from, parse2.to);
    var preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    var change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
    if (change) view.input.domChangeCount++;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function (n) {
      return n.nodeType == 1 && !isInline.test(n.nodeName);
    }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function (f) {
      return f(view, keyEvent(13, "Enter"));
    })) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
        change = {
          start: sel.from,
          endA: sel.to,
          endB: sel.to
        };
      } else {
        if (parse2.sel) {
          var sel2 = resolveSelection(view, view.state.doc, parse2.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            var _tr = view.state.tr.setSelection(sel2);
            if (compositionID) _tr.setMeta("composition", compositionID);
            view.dispatch(_tr);
          }
        }
        return;
      }
    }
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == " \xA0") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    var $from = parse2.doc.resolveNoCache(change.start - parse2.from);
    var $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    var $fromA = doc2.resolve(change.start);
    var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    var nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function (n) {
      return n.nodeName == "DIV" || n.nodeName == "P";
    })) || !inlineChange && $from.pos < parse2.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse2.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function (f) {
      return f(view, keyEvent(13, "Enter"));
    })) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function (f) {
      return f(view, keyEvent(8, "Backspace"));
    })) {
      if (android && chrome) view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
      setTimeout(function () {
        view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    var chFrom = change.start,
      chTo = change.endA;
    var tr, storedMarks, markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(function () {
            return selectionToDOM(view);
          }, 20);
        }
        tr = view.state.tr.delete(chFrom, chTo);
        storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
        tr = view.state.tr;
        if (markChange.type == "add") tr.addMark(chFrom, chTo, markChange.mark);else tr.removeMark(chFrom, chTo, markChange.mark);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        if (view.someProp("handleTextInput", function (f) {
          return f(view, chFrom, chTo, text);
        })) return;
        tr = view.state.tr.insertText(text, chFrom, chTo);
      }
    }
    if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
    if (parse2.sel) {
      var _sel = resolveSelection(view, tr.doc, parse2.sel);
      if (_sel && !(chrome && android && view.composing && _sel.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel.head == chFrom || _sel.head == tr.mapping.map(chTo) - 1) || ie$1 && _sel.empty && _sel.head == chFrom)) tr.setSelection(_sel);
    }
    if (storedMarks) tr.ensureMarks(storedMarks);
    if (compositionID) tr.setMeta("composition", compositionID);
    view.dispatch(tr.scrollIntoView());
  }
  function resolveSelection(view, doc2, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) return null;
    return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    var curMarks = cur.firstChild.marks,
      prevMarks = prev.firstChild.marks;
    var added = curMarks,
      removed = prevMarks,
      type,
      mark,
      update;
    for (var _i224 = 0; _i224 < prevMarks.length; _i224++) added = prevMarks[_i224].removeFromSet(added);
    for (var _i225 = 0; _i225 < curMarks.length; _i225++) removed = curMarks[_i225].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark = added[0];
      type = "add";
      update = function (node) {
        return node.mark(mark.addToSet(node.marks));
      };
    } else if (added.length == 0 && removed.length == 1) {
      mark = removed[0];
      type = "remove";
      update = function (node) {
        return node.mark(mark.removeFromSet(node.marks));
      };
    } else {
      return null;
    }
    var updated2 = [];
    for (var _i226 = 0; _i226 < prev.childCount; _i226++) updated2.push(update(prev.child(_i226)));
    if (Fragment.from(updated2).eq(cur)) return {
      mark: mark,
      type: type
    };
  }
  function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
    if (end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;
    var $start = old.resolve(start);
    if (!$newStart.parent.isTextblock) {
      var after = $start.nodeAfter;
      return after != null && end == start + after.nodeSize;
    }
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;
    var $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    var depth = $pos.depth,
      end = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end++;
      fromEnd = false;
    }
    if (mayOpen) {
      var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end++;
      }
    }
    return end;
  }
  function findDiff(a, b, pos, preferredPos, preferredSide) {
    var start = a.findDiffStart(b, pos);
    if (start == null) return null;
    var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size),
      endA = _a$findDiffEnd.a,
      endB = _a$findDiffEnd.b;
    if (preferredSide == "end") {
      var adjust = Math.max(0, start - Math.min(endA, endB));
      preferredPos -= endA + adjust - start;
    }
    if (endA < start && a.size < b.size) {
      var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
      start -= move;
      if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;
      endB = start + (endB - endA);
      endA = start;
    } else if (endB < start) {
      var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
      start -= _move;
      if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += _move ? 1 : -1;
      endA = start + (endA - endB);
      endB = start;
    }
    return {
      start: start,
      endA: endA,
      endB: endB
    };
  }
  function isSurrogatePair(str) {
    if (str.length != 2) return false;
    var a = str.charCodeAt(0),
      b = str.charCodeAt(1);
    return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
  }
  var EditorView = /*#__PURE__*/function () {
    function EditorView(place, props) {
      var _this37 = this;
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.mounted = false;
      this.markCursor = null;
      this.cursorWrapper = null;
      this.lastSelectedViewDesc = void 0;
      this.input = new InputState();
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.requiresGeckoHackNode = false;
      this.dragging = null;
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild) place.appendChild(this.dom);else if (typeof place == "function") place(this.dom);else if (place.mount) this.mounted = true;
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.domObserver = new DOMObserver(this, function (from2, to, typeOver, added) {
        return readDOMChange(_this37, from2, to, typeOver, added);
      });
      this.domObserver.start();
      initInput(this);
      this.updatePluginViews();
    }
    var _proto65 = EditorView.prototype;
    _proto65.update = function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
      var prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    };
    _proto65.setProps = function setProps(props) {
      var updated2 = {};
      for (var name in this._props) updated2[name] = this._props[name];
      updated2.state = this.state;
      for (var _name5 in props) updated2[_name5] = props[_name5];
      this.update(updated2);
    };
    _proto65.updateState = function updateState(state) {
      this.updateStateInner(state, this._props);
    };
    _proto65.updateStateInner = function updateStateInner(state, prevProps) {
      var _a2;
      var prev = this.state,
        redraw = false,
        updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      var pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        var nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this),
        outerDeco = computeDocDeco(this);
      var scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (this.composing) this.input.compositionNode = findCompositionNode(this);
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco(outerDeco);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites) forceSelUpdate = true;
        }
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    };
    _proto65.scrollToSelection = function scrollToSelection() {
      var _this38 = this;
      var startDOM = this.domSelectionRange().focusNode;
      if (this.someProp("handleScrollToSelection", function (f) {
        return f(_this38);
      })) ;else if (this.state.selection instanceof NodeSelection) {
        var target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    };
    _proto65.destroyPluginViews = function destroyPluginViews() {
      var view;
      while (view = this.pluginViews.pop()) if (view.destroy) view.destroy();
    };
    _proto65.updatePluginViews = function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (var _i227 = 0; _i227 < this.directPlugins.length; _i227++) {
          var plugin = this.directPlugins[_i227];
          if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
        }
        for (var _i228 = 0; _i228 < this.state.plugins.length; _i228++) {
          var _plugin = this.state.plugins[_i228];
          if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));
        }
      } else {
        for (var _i229 = 0; _i229 < this.pluginViews.length; _i229++) {
          var pluginView = this.pluginViews[_i229];
          if (pluginView.update) pluginView.update(this, prevState);
        }
      }
    };
    _proto65.updateDraggedNode = function updateDraggedNode(dragging, prev) {
      var sel = dragging.node,
        found2 = -1;
      if (this.state.doc.nodeAt(sel.from) == sel.node) {
        found2 = sel.from;
      } else {
        var movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
        var moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
        if (moved == sel.node) found2 = movedPos;
      }
      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
    };
    _proto65.someProp = function someProp(propName, f) {
      var prop = this._props && this._props[propName],
        value;
      if (prop != null && (value = f ? f(prop) : prop)) return value;
      for (var _i230 = 0; _i230 < this.directPlugins.length; _i230++) {
        var prop2 = this.directPlugins[_i230].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2)) return value;
      }
      var plugins = this.state.plugins;
      if (plugins) for (var _i231 = 0; _i231 < plugins.length; _i231++) {
        var _prop3 = plugins[_i231].props[propName];
        if (_prop3 != null && (value = f ? f(_prop3) : _prop3)) return value;
      }
    };
    _proto65.hasFocus = function hasFocus() {
      if (ie$1) {
        var node = this.root.activeElement;
        if (node == this.dom) return true;
        if (!node || !this.dom.contains(node)) return false;
        while (node && this.dom != node && this.dom.contains(node)) {
          if (node.contentEditable == "false") return false;
          node = node.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    };
    _proto65.focus = function focus() {
      this.domObserver.stop();
      if (this.editable) focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    };
    _proto65.updateRoot = function updateRoot() {
      this._root = null;
    };
    _proto65.posAtCoords = function posAtCoords(coords) {
      return _posAtCoords(this, coords);
    };
    _proto65.coordsAtPos = function coordsAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return _coordsAtPos(this, pos, side);
    };
    _proto65.domAtPos = function domAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.docView.domFromPos(pos, side);
    };
    _proto65.nodeDOM = function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    };
    _proto65.posAtDOM = function posAtDOM(node, offset) {
      var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) throw new RangeError("DOM position not inside the editor");
      return pos;
    };
    _proto65.endOfTextblock = function endOfTextblock(dir, state) {
      return _endOfTextblock(this, state || this.state, dir);
    };
    _proto65.pasteHTML = function pasteHTML(html, event) {
      return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
    };
    _proto65.pasteText = function pasteText(text, event) {
      return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
    };
    _proto65.destroy = function destroy() {
      if (!this.docView) return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
      clearReusedRange();
    };
    _proto65.dispatchEvent = function dispatchEvent(event) {
      return _dispatchEvent(this, event);
    };
    _proto65.dispatch = function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) dispatchTransaction.call(this, tr);else this.updateState(this.state.apply(tr));
    };
    _proto65.domSelectionRange = function domSelectionRange() {
      var sel = this.domSelection();
      if (!sel) return {
        focusNode: null,
        focusOffset: 0,
        anchorNode: null,
        anchorOffset: 0
      };
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
    };
    _proto65.domSelection = function domSelection() {
      return this.root.getSelection();
    };
    return _createClass(EditorView, [{
      key: "composing",
      get: function () {
        return this.input.composing;
      }
    }, {
      key: "props",
      get: function () {
        if (this._props.state != this.state) {
          var prev = this._props;
          this._props = {};
          for (var name in prev) this._props[name] = prev[name];
          this._props.state = this.state;
        }
        return this._props;
      }
    }, {
      key: "root",
      get: function () {
        var _this39 = this;
        var cached = this._root;
        if (cached == null) {
          var _loop23 = function (search) {
              if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
                if (!search.getSelection) Object.getPrototypeOf(search).getSelection = function () {
                  return search.ownerDocument.getSelection();
                };
                return {
                  v: _this39._root = search
                };
              }
            },
            _ret6;
          for (var search = this.dom.parentNode; search; search = search.parentNode) {
            _ret6 = _loop23(search);
            if (_ret6) return _ret6.v;
          }
        }
        return cached || document;
      }
    }, {
      key: "isDestroyed",
      get: function () {
        return this.docView == null;
      }
    }]);
  }();
  function computeDocDeco(view) {
    var attrs = /* @__PURE__ */Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", function (value) {
      if (typeof value == "function") value = value(view.state);
      if (value) for (var attr in value) {
        if (attr == "class") attrs.class += " " + value[attr];else if (attr == "style") attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") attrs[attr] = String(value[attr]);
      }
    });
    if (!attrs.translate) attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      var dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = {
        dom: dom,
        deco: Decoration.widget(view.state.selection.from, dom, {
          raw: true,
          marks: view.markCursor
        })
      };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", function (value) {
      return value(view.state) === false;
    });
  }
  function selectionContextChanged(sel1, sel2) {
    var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    var result = /* @__PURE__ */Object.create(null);
    function add(obj) {
      for (var _prop4 in obj) if (!Object.prototype.hasOwnProperty.call(result, _prop4)) result[_prop4] = obj[_prop4];
    }
    view.someProp("nodeViews", add);
    view.someProp("markViews", add);
    return result;
  }
  function changedNodeViews(a, b) {
    var nA = 0,
      nB = 0;
    for (var _prop5 in a) {
      if (a[_prop5] != b[_prop5]) return true;
      nA++;
    }
    for (var _ in b) nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
  for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
  for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  function keyName(event) {
    var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc") name = "Escape";
    if (name == "Del") name = "Delete";
    if (name == "Left") name = "ArrowLeft";
    if (name == "Up") name = "ArrowUp";
    if (name == "Right") name = "ArrowRight";
    if (name == "Down") name = "ArrowDown";
    return name;
  }
  var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
  function normalizeKeyName$1(name) {
    var parts = name.split(/-(?!$)/),
      result = parts[parts.length - 1];
    if (result == "Space") result = " ";
    var alt, ctrl, shift2, meta;
    for (var _i232 = 0; _i232 < parts.length - 1; _i232++) {
      var mod = parts[_i232];
      if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift2 = true;else if (/^mod$/i.test(mod)) {
        if (mac) meta = true;else ctrl = true;
      } else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) result = "Alt-" + result;
    if (ctrl) result = "Ctrl-" + result;
    if (meta) result = "Meta-" + result;
    if (shift2) result = "Shift-" + result;
    return result;
  }
  function normalize(map3) {
    var copy2 = /* @__PURE__ */Object.create(null);
    for (var _prop6 in map3) copy2[normalizeKeyName$1(_prop6)] = map3[_prop6];
    return copy2;
  }
  function modifiers(name, event) {
    var shift2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (event.altKey) name = "Alt-" + name;
    if (event.ctrlKey) name = "Ctrl-" + name;
    if (event.metaKey) name = "Meta-" + name;
    if (shift2 && event.shiftKey) name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({
      props: {
        handleKeyDown: keydownHandler(bindings)
      }
    });
  }
  function keydownHandler(bindings) {
    var map3 = normalize(bindings);
    return function (view, event) {
      var name = keyName(event),
        baseName,
        direct = map3[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view)) return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          var noShift = map3[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view)) return true;
        }
        if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
          var fromCode = map3[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view)) return true;
        }
      }
      return false;
    };
  }
  var deleteSelection$1 = function (state, dispatch) {
    if (state.selection.empty) return false;
    if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    var $cursor = state.selection.$cursor;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) return null;
    return $cursor;
  }
  var joinBackward$1 = function (state, dispatch, view) {
    var $cursor = atBlockStart(state, view);
    if (!$cursor) return false;
    var $cut = findCutBefore($cursor);
    if (!$cut) {
      var range = $cursor.blockRange(),
        target = range && liftTarget(range);
      if (target == null) return false;
      if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    var before = $cut.nodeBefore;
    if (deleteBarrier(state, $cut, dispatch, -1)) return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      for (var depth = $cursor.depth;; depth--) {
        var delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            var tr = state.tr.step(delStep);
            tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }
        if (depth == 1 || $cursor.node(depth - 1).childCount > 1) break;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  var joinTextblockBackward$1 = function (state, dispatch, view) {
    var $cursor = atBlockStart(state, view);
    if (!$cursor) return false;
    var $cut = findCutBefore($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
  };
  var joinTextblockForward$1 = function (state, dispatch, view) {
    var $cursor = atBlockEnd(state, view);
    if (!$cursor) return false;
    var $cut = findCutAfter($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
  };
  function joinTextblocksAround(state, $cut, dispatch) {
    var before = $cut.nodeBefore,
      beforeText = before,
      beforePos = $cut.pos - 1;
    for (; !beforeText.isTextblock; beforePos--) {
      if (beforeText.type.spec.isolating) return false;
      var child = beforeText.lastChild;
      if (!child) return false;
      beforeText = child;
    }
    var after = $cut.nodeAfter,
      afterText = after,
      afterPos = $cut.pos + 1;
    for (; !afterText.isTextblock; afterPos++) {
      if (afterText.type.spec.isolating) return false;
      var _child3 = afterText.firstChild;
      if (!_child3) return false;
      afterText = _child3;
    }
    var step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
    if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos) return false;
    if (dispatch) {
      var tr = state.tr.step(step);
      tr.setSelection(TextSelection.create(tr.doc, beforePos));
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  function textblockAt(node, side) {
    var only2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock) return true;
      if (only2 && scan.childCount != 1) return false;
    }
    return false;
  }
  var selectNodeBackward$1 = function (state, dispatch, view) {
    var _state$selection2 = state.selection,
      $head = _state$selection2.$head,
      empty2 = _state$selection2.empty,
      $cut = $head;
    if (!empty2) return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) return false;
      $cut = findCutBefore($head);
    }
    var node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node)) return false;
    if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating) for (var _i233 = $pos.depth - 1; _i233 >= 0; _i233--) {
      if ($pos.index(_i233) > 0) return $pos.doc.resolve($pos.before(_i233 + 1));
      if ($pos.node(_i233).type.spec.isolating) break;
    }
    return null;
  }
  function atBlockEnd(state, view) {
    var $cursor = state.selection.$cursor;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;
    return $cursor;
  }
  var joinForward$1 = function (state, dispatch, view) {
    var $cursor = atBlockEnd(state, view);
    if (!$cursor) return false;
    var $cut = findCutAfter($cursor);
    if (!$cut) return false;
    var after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch, 1)) return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          var tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  var selectNodeForward$1 = function (state, dispatch, view) {
    var _state$selection3 = state.selection,
      $head = _state$selection3.$head,
      empty2 = _state$selection3.empty,
      $cut = $head;
    if (!empty2) return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) return false;
      $cut = findCutAfter($head);
    }
    var node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node)) return false;
    if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating) for (var _i234 = $pos.depth - 1; _i234 >= 0; _i234--) {
      var parent = $pos.node(_i234);
      if ($pos.index(_i234) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(_i234 + 1));
      if (parent.type.spec.isolating) break;
    }
    return null;
  }
  var joinUp$1 = function (state, dispatch) {
    var sel = state.selection,
      nodeSel = sel instanceof NodeSelection,
      point;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false;
      point = sel.from;
    } else {
      point = joinPoint(state.doc, sel.from, -1);
      if (point == null) return false;
    }
    if (dispatch) {
      var tr = state.tr.join(point);
      if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var joinDown$1 = function (state, dispatch) {
    var sel = state.selection,
      point;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false;
      point = sel.to;
    } else {
      point = joinPoint(state.doc, sel.to, 1);
      if (point == null) return false;
    }
    if (dispatch) dispatch(state.tr.join(point).scrollIntoView());
    return true;
  };
  var lift$1 = function (state, dispatch) {
    var _state$selection4 = state.selection,
      $from = _state$selection4.$from,
      $to = _state$selection4.$to;
    var range = $from.blockRange($to),
      target = range && liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var newlineInCode$1 = function (state, dispatch) {
    var _state$selection5 = state.selection,
      $head = _state$selection5.$head,
      $anchor = _state$selection5.$anchor;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
    if (dispatch) dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt$1(match) {
    for (var _i235 = 0; _i235 < match.edgeCount; _i235++) {
      var _match$edge2 = match.edge(_i235),
        type = _match$edge2.type;
      if (type.isTextblock && !type.hasRequiredAttrs()) return type;
    }
    return null;
  }
  var exitCode$1 = function (state, dispatch) {
    var _state$selection6 = state.selection,
      $head = _state$selection6.$head,
      $anchor = _state$selection6.$anchor;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
    var above = $head.node(-1),
      after = $head.indexAfter(-1),
      type = defaultBlockAt$1(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type)) return false;
    if (dispatch) {
      var pos = $head.after(),
        tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var createParagraphNear$1 = function (state, dispatch) {
    var sel = state.selection,
      $from = sel.$from,
      $to = sel.$to;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;
    var type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock) return false;
    if (dispatch) {
      var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      var tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
  var liftEmptyBlock$1 = function (state, dispatch) {
    var $cursor = state.selection.$cursor;
    if (!$cursor || $cursor.parent.content.size) return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      var before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch) dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    var range = $cursor.blockRange(),
      target = range && liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var selectParentNode$1 = function (state, dispatch) {
    var _state$selection7 = state.selection,
      $from = _state$selection7.$from,
      to = _state$selection7.to,
      pos;
    var same = $from.sharedDepth(to);
    if (same == 0) return false;
    pos = $from.before(same);
    if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    var before = $pos.nodeBefore,
      after = $pos.nodeAfter,
      index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type)) return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
      if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos))) return false;
    if (dispatch) dispatch(state.tr.join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch, dir) {
    var before = $cut.nodeBefore,
      after = $cut.nodeAfter,
      conn,
      match;
    var isolated = before.type.spec.isolating || after.type.spec.isolating;
    if (!isolated && joinMaybeClear(state, $cut, dispatch)) return true;
    var canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch) {
        var end = $cut.pos + after.nodeSize,
          wrap2 = Fragment.empty;
        for (var _i236 = conn.length - 1; _i236 >= 0; _i236--) wrap2 = Fragment.from(conn[_i236].create(null, wrap2));
        wrap2 = Fragment.from(before.copy(wrap2));
        var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
        var $joinAt = tr.doc.resolve(end + 2 * conn.length);
        if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos)) tr.join($joinAt.pos);
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    var selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
    var range = selAfter && selAfter.$from.blockRange(selAfter.$to),
      target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      var at = before,
        _wrap2 = [];
      for (;;) {
        _wrap2.push(at);
        if (at.isTextblock) break;
        at = at.lastChild;
      }
      var afterText = after,
        afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch) {
          var _end = Fragment.empty;
          for (var _i237 = _wrap2.length - 1; _i237 >= 0; _i237--) _end = Fragment.from(_wrap2[_i237].copy(_end));
          var _tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - _wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(_end, _wrap2.length, 0), 0, true));
          dispatch(_tr2.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function (state, dispatch) {
      var sel = state.selection,
        $pos = side < 0 ? sel.$from : sel.$to;
      var depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth) return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock) return false;
      if (dispatch) dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  var selectTextblockStart$1 = selectTextblockSide(-1);
  var selectTextblockEnd$1 = selectTextblockSide(1);
  function wrapIn$1(nodeType) {
    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return function (state, dispatch) {
      var _state$selection8 = state.selection,
        $from = _state$selection8.$from,
        $to = _state$selection8.$to;
      var range = $from.blockRange($to),
        wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping) return false;
      if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType(nodeType) {
    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return function (state, dispatch) {
      var applicable = false;
      for (var _i238 = 0; _i238 < state.selection.ranges.length && !applicable; _i238++) {
        var _state$selection$rang = state.selection.ranges[_i238],
          _from9 = _state$selection$rang.$from.pos,
          to = _state$selection$rang.$to.pos;
        state.doc.nodesBetween(_from9, to, function (node, pos) {
          if (applicable) return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            var $pos = state.doc.resolve(pos),
              index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
      }
      if (!applicable) return false;
      if (dispatch) {
        var tr = state.tr;
        for (var _i239 = 0; _i239 < state.selection.ranges.length; _i239++) {
          var _state$selection$rang2 = state.selection.ranges[_i239],
            _from10 = _state$selection$rang2.$from.pos,
            _to2 = _state$selection$rang2.$to.pos;
          tr.setBlockType(_from10, _to2, nodeType, attrs);
        }
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
  }
  typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
  function wrapInList$1(listType) {
    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return function (state, dispatch) {
      var _state$selection9 = state.selection,
        $from = _state$selection9.$from,
        $to = _state$selection9.$to;
      var range = $from.blockRange($to),
        doJoin = false,
        outerRange = range;
      if (!range) return false;
      if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if ($from.index(range.depth - 1) == 0) return false;
        var $insert = state.doc.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount) range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
        doJoin = true;
      }
      var wrap2 = findWrapping(outerRange, listType, attrs, range);
      if (!wrap2) return false;
      if (dispatch) dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
      return true;
    };
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    var content = Fragment.empty;
    for (var _i240 = wrappers.length - 1; _i240 >= 0; _i240--) content = Fragment.from(wrappers[_i240].type.create(wrappers[_i240].attrs, content));
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    var found2 = 0;
    for (var _i241 = 0; _i241 < wrappers.length; _i241++) if (wrappers[_i241].type == listType) found2 = _i241 + 1;
    var splitDepth = wrappers.length - found2;
    var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),
      parent = range.parent;
    for (var _i242 = range.startIndex, e = range.endIndex, first2 = true; _i242 < e; _i242++, first2 = false) {
      if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(_i242).nodeSize;
    }
    return tr;
  }
  function liftListItem$1(itemType) {
    return function (state, dispatch) {
      var _state$selection10 = state.selection,
        $from = _state$selection10.$from,
        $to = _state$selection10.$to;
      var range = $from.blockRange($to, function (node) {
        return node.childCount > 0 && node.firstChild.type == itemType;
      });
      if (!range) return false;
      if (!dispatch) return true;
      if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);else return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    var tr = state.tr,
      end = range.end,
      endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
      tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    var target = liftTarget(range);
    if (target == null) return false;
    tr.lift(range, target);
    var after = tr.mapping.map(end, -1) - 1;
    if (canJoin(tr.doc, after)) tr.join(after);
    dispatch(tr.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    var tr = state.tr,
      list = range.parent;
    for (var pos = range.end, _i243 = range.endIndex - 1, e = range.startIndex; _i243 > e; _i243--) {
      pos -= list.child(_i243).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    var $start = tr.doc.resolve(range.start),
      item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;
    var atStart = range.startIndex == 0,
      atEnd = range.endIndex == list.childCount;
    var parent = $start.node(-1),
      indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list)))) return false;
    var start = $start.pos,
      end = start + item.nodeSize;
    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr.scrollIntoView());
    return true;
  }
  function sinkListItem$1(itemType) {
    return function (state, dispatch) {
      var _state$selection11 = state.selection,
        $from = _state$selection11.$from,
        $to = _state$selection11.$to;
      var range = $from.blockRange($to, function (node) {
        return node.childCount > 0 && node.firstChild.type == itemType;
      });
      if (!range) return false;
      var startIndex = range.startIndex;
      if (startIndex == 0) return false;
      var parent = range.parent,
        nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType) return false;
      if (dispatch) {
        var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        var inner = Fragment.from(nestedBefore ? itemType.create() : null);
        var slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        var before = range.start,
          after = range.end;
        dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
      }
      return true;
    };
  }
  function createChainableState(config2) {
    var state = config2.state,
      transaction = config2.transaction;
    var selection = transaction.selection;
    var doc2 = transaction.doc;
    var storedMarks = transaction.storedMarks;
    return _objectSpread(_objectSpread({}, state), {}, {
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc2;
      },
      get tr() {
        selection = transaction.selection;
        doc2 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    });
  }
  var CommandManager = /*#__PURE__*/function () {
    function CommandManager(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    var _proto66 = CommandManager.prototype;
    _proto66.createChain = function createChain(startTr) {
      var _this40 = this;
      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var rawCommands = this.rawCommands,
        editor = this.editor,
        state = this.state;
      var view = editor.view;
      var callbacks = [];
      var hasStartTransaction = !!startTr;
      var tr = startTr || state.tr;
      var run2 = function () {
        if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !_this40.hasCustomState) {
          view.dispatch(tr);
        }
        return callbacks.every(function (callback) {
          return callback === true;
        });
      };
      var chain = _objectSpread(_objectSpread({}, Object.fromEntries(Object.entries(rawCommands).map(function (_ref74) {
        var _ref75 = _slicedToArray(_ref74, 2),
          name = _ref75[0],
          command2 = _ref75[1];
        var chainedCommand = function () {
          var props = _this40.buildProps(tr, shouldDispatch);
          var callback = command2.apply(void 0, arguments)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      }))), {}, {
        run: run2
      });
      return chain;
    };
    _proto66.createCan = function createCan(startTr) {
      var _this41 = this;
      var rawCommands = this.rawCommands,
        state = this.state;
      var dispatch = false;
      var tr = startTr || state.tr;
      var props = this.buildProps(tr, dispatch);
      var formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(function (_ref76) {
        var _ref77 = _slicedToArray(_ref76, 2),
          name = _ref77[0],
          command2 = _ref77[1];
        return [name, function () {
          return command2.apply(void 0, arguments)(_objectSpread(_objectSpread({}, props), {}, {
            dispatch: void 0
          }));
        }];
      }));
      return _objectSpread(_objectSpread({}, formattedCommands), {}, {
        chain: function () {
          return _this41.createChain(tr, dispatch);
        }
      });
    };
    _proto66.buildProps = function buildProps(tr) {
      var _this42 = this;
      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var rawCommands = this.rawCommands,
        editor = this.editor,
        state = this.state;
      var view = editor.view;
      var props = {
        tr: tr,
        editor: editor,
        view: view,
        state: createChainableState({
          state: state,
          transaction: tr
        }),
        dispatch: shouldDispatch ? function () {
          return void 0;
        } : void 0,
        chain: function () {
          return _this42.createChain(tr, shouldDispatch);
        },
        can: function () {
          return _this42.createCan(tr);
        },
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(function (_ref78) {
            var _ref79 = _slicedToArray(_ref78, 2),
              name = _ref79[0],
              command2 = _ref79[1];
            return [name, function () {
              return command2.apply(void 0, arguments)(props);
            }];
          }));
        }
      };
      return props;
    };
    return _createClass(CommandManager, [{
      key: "hasCustomState",
      get: function () {
        return !!this.customState;
      }
    }, {
      key: "state",
      get: function () {
        return this.customState || this.editor.state;
      }
    }, {
      key: "commands",
      get: function () {
        var _this43 = this;
        var rawCommands = this.rawCommands,
          editor = this.editor,
          state = this.state;
        var view = editor.view;
        var tr = state.tr;
        var props = this.buildProps(tr);
        return Object.fromEntries(Object.entries(rawCommands).map(function (_ref80) {
          var _ref81 = _slicedToArray(_ref80, 2),
            name = _ref81[0],
            command2 = _ref81[1];
          var method = function () {
            var callback = command2.apply(void 0, arguments)(props);
            if (!tr.getMeta("preventDispatch") && !_this43.hasCustomState) {
              view.dispatch(tr);
            }
            return callback;
          };
          return [name, method];
        }));
      }
    }, {
      key: "chain",
      get: function () {
        var _this44 = this;
        return function () {
          return _this44.createChain();
        };
      }
    }, {
      key: "can",
      get: function () {
        var _this45 = this;
        return function () {
          return _this45.createCan();
        };
      }
    }]);
  }();
  var EventEmitter = /*#__PURE__*/function () {
    function EventEmitter() {
      this.callbacks = {};
    }
    var _proto67 = EventEmitter.prototype;
    _proto67.on = function on(event, fn) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn);
      return this;
    };
    _proto67.emit = function emit(event) {
      var _this46 = this;
      for (var _len27 = arguments.length, args = new Array(_len27 > 1 ? _len27 - 1 : 0), _key40 = 1; _key40 < _len27; _key40++) {
        args[_key40 - 1] = arguments[_key40];
      }
      var callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach(function (callback) {
          return callback.apply(_this46, args);
        });
      }
      return this;
    };
    _proto67.off = function off(event, fn) {
      var callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn) {
          this.callbacks[event] = callbacks.filter(function (callback) {
            return callback !== fn;
          });
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    };
    _proto67.removeAllListeners = function removeAllListeners() {
      this.callbacks = {};
    };
    return EventEmitter;
  }();
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      var value = extension.config[field].bind(_objectSpread(_objectSpread({}, context), {}, {
        parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
      }));
      return value;
    }
    return extension.config[field];
  }
  function splitExtensions(extensions) {
    var baseExtensions = extensions.filter(function (extension) {
      return extension.type === "extension";
    });
    var nodeExtensions = extensions.filter(function (extension) {
      return extension.type === "node";
    });
    var markExtensions = extensions.filter(function (extension) {
      return extension.type === "mark";
    });
    return {
      baseExtensions: baseExtensions,
      nodeExtensions: nodeExtensions,
      markExtensions: markExtensions
    };
  }
  function getAttributesFromExtensions(extensions) {
    var extensionAttributes = [];
    var _splitExtensions = splitExtensions(extensions),
      nodeExtensions = _splitExtensions.nodeExtensions,
      markExtensions = _splitExtensions.markExtensions;
    var nodeAndMarkExtensions = [].concat(_toConsumableArray(nodeExtensions), _toConsumableArray(markExtensions));
    var defaultAttribute = {
      "default": null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    extensions.forEach(function (extension) {
      var context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        extensions: nodeAndMarkExtensions
      };
      var addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      var globalAttributes = addGlobalAttributes();
      globalAttributes.forEach(function (globalAttribute) {
        globalAttribute.types.forEach(function (type) {
          Object.entries(globalAttribute.attributes).forEach(function (_ref82) {
            var _ref83 = _slicedToArray(_ref82, 2),
              name = _ref83[0],
              attribute = _ref83[1];
            extensionAttributes.push({
              type: type,
              name: name,
              attribute: _objectSpread(_objectSpread({}, defaultAttribute), attribute)
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach(function (extension) {
      var context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      var addAttributes = getExtensionField(extension, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      var attributes = addAttributes();
      Object.entries(attributes).forEach(function (_ref84) {
        var _ref85 = _slicedToArray(_ref84, 2),
          name = _ref85[0],
          attribute = _ref85[1];
        var mergedAttr = _objectSpread(_objectSpread({}, defaultAttribute), attribute);
        if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
          mergedAttr.default = mergedAttr.default();
        }
        if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
          delete mergedAttr.default;
        }
        extensionAttributes.push({
          type: extension.name,
          name: name,
          attribute: mergedAttr
        });
      });
    });
    return extensionAttributes;
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error("There is no node type named '" + nameOrType + "'. Maybe you forgot to add the extension?");
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes() {
    for (var _len28 = arguments.length, objects = new Array(_len28), _key41 = 0; _key41 < _len28; _key41++) {
      objects[_key41] = arguments[_key41];
    }
    return objects.filter(function (item) {
      return !!item;
    }).reduce(function (items, item) {
      var mergedAttributes = _objectSpread({}, items);
      Object.entries(item).forEach(function (_ref86) {
        var _ref87 = _slicedToArray(_ref86, 2),
          key = _ref87[0],
          value = _ref87[1];
        var exists = mergedAttributes[key];
        if (!exists) {
          mergedAttributes[key] = value;
          return;
        }
        if (key === "class") {
          var valueClasses = value ? value.split(" ") : [];
          var existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          var insertClasses = valueClasses.filter(function (valueClass) {
            return !existingClasses.includes(valueClass);
          });
          mergedAttributes[key] = [].concat(_toConsumableArray(existingClasses), _toConsumableArray(insertClasses)).join(" ");
        } else if (key === "style") {
          var newStyles = value ? value.split(";").map(function (style2) {
            return style2.trim();
          }).filter(Boolean) : [];
          var existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map(function (style2) {
            return style2.trim();
          }).filter(Boolean) : [];
          var styleMap = /* @__PURE__ */new Map();
          existingStyles.forEach(function (style2) {
            var _style2$split$map = style2.split(":").map(function (part) {
                return part.trim();
              }),
              _style2$split$map2 = _slicedToArray(_style2$split$map, 2),
              property = _style2$split$map2[0],
              val = _style2$split$map2[1];
            styleMap.set(property, val);
          });
          newStyles.forEach(function (style2) {
            var _style2$split$map3 = style2.split(":").map(function (part) {
                return part.trim();
              }),
              _style2$split$map4 = _slicedToArray(_style2$split$map3, 2),
              property = _style2$split$map4[0],
              val = _style2$split$map4[1];
            styleMap.set(property, val);
          });
          mergedAttributes[key] = Array.from(styleMap.entries()).map(function (_ref88) {
            var _ref89 = _slicedToArray(_ref88, 2),
              property = _ref89[0],
              val = _ref89[1];
            return property + ": " + val;
          }).join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter(function (attribute) {
      return attribute.type === nodeOrMark.type.name;
    }).filter(function (item) {
      return item.attribute.rendered;
    }).map(function (item) {
      if (!item.attribute.renderHTML) {
        var _ref90;
        return _ref90 = {}, _ref90[item.name] = nodeOrMark.attrs[item.name], _ref90;
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce(function (attributes, attribute) {
      return mergeAttributes(attributes, attribute);
    }, {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;
    if (isFunction(value)) {
      for (var _len29 = arguments.length, props = new Array(_len29 > 2 ? _len29 - 2 : 0), _key42 = 2; _key42 < _len29; _key42++) {
        props[_key42 - 2] = arguments[_key42];
      }
      if (context) {
        return value.bind(context).apply(void 0, props);
      }
      return value.apply(void 0, props);
    }
    return value;
  }
  function isEmptyObject() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if ("style" in parseRule) {
      return parseRule;
    }
    return _objectSpread(_objectSpread({}, parseRule), {}, {
      getAttrs: function (node) {
        var oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttributes === false) {
          return false;
        }
        var newAttributes = extensionAttributes.reduce(function (items, item) {
          var _objectSpread2;
          var value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return _objectSpread(_objectSpread({}, items), {}, (_objectSpread2 = {}, _objectSpread2[item.name] = value, _objectSpread2));
        }, {});
        return _objectSpread(_objectSpread({}, oldAttributes), newAttributes);
      }
    });
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(Object.entries(data).filter(function (_ref91) {
      var _ref92 = _slicedToArray(_ref91, 2),
        key = _ref92[0],
        value = _ref92[1];
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    }));
  }
  function getSchemaByResolvedExtensions(extensions, editor) {
    var _a2;
    var allAttributes = getAttributesFromExtensions(extensions);
    var _splitExtensions2 = splitExtensions(extensions),
      nodeExtensions = _splitExtensions2.nodeExtensions,
      markExtensions = _splitExtensions2.markExtensions;
    var topNode = (_a2 = nodeExtensions.find(function (extension) {
      return getExtensionField(extension, "topNode");
    })) === null || _a2 === void 0 ? void 0 : _a2.name;
    var nodes = Object.fromEntries(nodeExtensions.map(function (extension) {
      var extensionAttributes = allAttributes.filter(function (attribute) {
        return attribute.type === extension.name;
      });
      var context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: editor
      };
      var extraNodeFields = extensions.reduce(function (fields, e) {
        var extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return _objectSpread(_objectSpread({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});
      }, {});
      var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraNodeFields), {}, {
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {
          var _a3;
          return [extensionAttribute.name, {
            "default": (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default
          }];
        }))
      }));
      var parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(function (parseRule) {
          return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);
        });
      }
      var renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = function (node) {
          return renderHTML({
            node: node,
            HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
          });
        };
      }
      var renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    }));
    var marks = Object.fromEntries(markExtensions.map(function (extension) {
      var extensionAttributes = allAttributes.filter(function (attribute) {
        return attribute.type === extension.name;
      });
      var context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: editor
      };
      var extraMarkFields = extensions.reduce(function (fields, e) {
        var extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return _objectSpread(_objectSpread({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});
      }, {});
      var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraMarkFields), {}, {
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {
          var _a3;
          return [extensionAttribute.name, {
            "default": (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default
          }];
        }))
      }));
      var parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(function (parseRule) {
          return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);
        });
      }
      var renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = function (mark) {
          return renderHTML({
            mark: mark,
            HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
          });
        };
      }
      return [extension.name, schema];
    }));
    return new Schema({
      topNode: topNode,
      nodes: nodes,
      marks: marks
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some(function (enabledExtension) {
        var name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension.name;
      });
    }
    return enabled;
  }
  var getTextContentFromNodes = function ($from) {
    var maxMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
    var textBefore = "";
    var sliceEndPos = $from.parentOffset;
    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, function (node, pos, parent, index) {
      var _a2, _b;
      var chunk2 = ((_b = (_a2 = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a2, {
        node: node,
        pos: pos,
        parent: parent,
        index: index
      })) || node.textContent || "%leaf%";
      textBefore += node.isAtom && !node.isText ? chunk2 : chunk2.slice(0, Math.max(0, sliceEndPos - pos));
    });
    return textBefore;
  };
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  var InputRule = function InputRule(config2) {
    this.find = config2.find;
    this.handler = config2.handler;
  };
  var inputRuleMatcherHandler = function (text, find) {
    if (isRegExp(find)) {
      return find.exec(text);
    }
    var inputRuleMatch = find(text);
    if (!inputRuleMatch) {
      return null;
    }
    var result = [inputRuleMatch.text];
    result.index = inputRuleMatch.index;
    result.input = text;
    result.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
      if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
      }
      result.push(inputRuleMatch.replaceWith);
    }
    return result;
  };
  function run$1(config2) {
    var _a2;
    var editor = config2.editor,
      from2 = config2.from,
      to = config2.to,
      text = config2.text,
      rules = config2.rules,
      plugin = config2.plugin;
    var view = editor.view;
    if (view.composing) {
      return false;
    }
    var $from = view.state.doc.resolve(from2);
    if ($from.parent.type.spec.code || !!((_a2 = $from.nodeBefore || $from.nodeAfter) === null || _a2 === void 0 ? void 0 : _a2.marks.find(function (mark) {
      return mark.type.spec.code;
    }))) {
      return false;
    }
    var matched = false;
    var textBefore = getTextContentFromNodes($from) + text;
    rules.forEach(function (rule) {
      if (matched) {
        return;
      }
      var match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      var tr = view.state.tr;
      var state = createChainableState({
        state: view.state,
        transaction: tr
      });
      var range = {
        from: from2 - (match[0].length - text.length),
        to: to
      };
      var _CommandManager = new CommandManager({
          editor: editor,
          state: state
        }),
        commands2 = _CommandManager.commands,
        chain = _CommandManager.chain,
        can = _CommandManager.can;
      var handler = rule.handler({
        state: state,
        range: range,
        match: match,
        commands: commands2,
        chain: chain,
        can: can
      });
      if (handler === null || !tr.steps.length) {
        return;
      }
      tr.setMeta(plugin, {
        transform: tr,
        from: from2,
        to: to,
        text: text
      });
      view.dispatch(tr);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    var editor = props.editor,
      rules = props.rules;
    var plugin = new Plugin({
      state: {
        init: function () {
          return null;
        },
        apply: function (tr, prev) {
          var stored = tr.getMeta(plugin);
          if (stored) {
            return stored;
          }
          var simulatedInputMeta = tr.getMeta("applyInputRules");
          var isSimulatedInput = !!simulatedInputMeta;
          if (isSimulatedInput) {
            setTimeout(function () {
              var from2 = simulatedInputMeta.from,
                text = simulatedInputMeta.text;
              var to = from2 + text.length;
              run$1({
                editor: editor,
                from: from2,
                to: to,
                text: text,
                rules: rules,
                plugin: plugin
              });
            });
          }
          return tr.selectionSet || tr.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput: function (view, from2, to, text) {
          return run$1({
            editor: editor,
            from: from2,
            to: to,
            text: text,
            rules: rules,
            plugin: plugin
          });
        },
        handleDOMEvents: {
          compositionend: function (view) {
            setTimeout(function () {
              var $cursor = view.state.selection.$cursor;
              if ($cursor) {
                run$1({
                  editor: editor,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules: rules,
                  plugin: plugin
                });
              }
            });
            return false;
          }
        },
        handleKeyDown: function (view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          var $cursor = view.state.selection.$cursor;
          if ($cursor) {
            return run$1({
              editor: editor,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules: rules,
              plugin: plugin
            });
          }
          return false;
        }
      },
      isInputRules: true
    });
    return plugin;
  }
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject$1(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep$1(target, source) {
    var output = _objectSpread({}, target);
    if (isPlainObject$1(target) && isPlainObject$1(source)) {
      Object.keys(source).forEach(function (key) {
        if (isPlainObject$1(source[key]) && isPlainObject$1(target[key])) {
          output[key] = mergeDeep$1(target[key], source[key]);
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }
  var Mark = /*#__PURE__*/function () {
    function Mark() {
      var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = _objectSpread(_objectSpread({}, this.config), config2);
      this.name = this.config.name;
      if (config2.defaultOptions && Object.keys(config2.defaultOptions).length > 0) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"" + this.name + "\".");
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    Mark.create = function create() {
      var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Mark(config2);
    };
    var _proto68 = Mark.prototype;
    _proto68.configure = function configure() {
      var _this47 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = this.extend(_objectSpread(_objectSpread({}, this.config), {}, {
        addOptions: function () {
          return mergeDeep$1(_this47.options, options);
        }
      }));
      extension.name = this.name;
      extension.parent = this.parent;
      return extension;
    };
    _proto68.extend = function extend() {
      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = new Mark(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"" + extension.name + "\".");
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    };
    Mark.handleExit = function handleExit(_ref93) {
      var editor = _ref93.editor,
        mark = _ref93.mark;
      var tr = editor.state.tr;
      var currentPos = editor.state.selection.$from;
      var isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        var currentMarks = currentPos.marks();
        var isInMark = !!currentMarks.find(function (m3) {
          return (m3 === null || m3 === void 0 ? void 0 : m3.type.name) === mark.name;
        });
        if (!isInMark) {
          return false;
        }
        var removeMark2 = currentMarks.find(function (m3) {
          return (m3 === null || m3 === void 0 ? void 0 : m3.type.name) === mark.name;
        });
        if (removeMark2) {
          tr.removeStoredMark(removeMark2);
        }
        tr.insertText(" ", currentPos.pos);
        editor.view.dispatch(tr);
        return true;
      }
      return false;
    };
    return Mark;
  }();
  function isNumber(value) {
    return typeof value === "number";
  }
  var PasteRule = function PasteRule(config2) {
    this.find = config2.find;
    this.handler = config2.handler;
  };
  var pasteRuleMatcherHandler = function (text, find, event) {
    if (isRegExp(find)) {
      return _toConsumableArray(text.matchAll(find));
    }
    var matches2 = find(text, event);
    if (!matches2) {
      return [];
    }
    return matches2.map(function (pasteRuleMatch) {
      var result = [pasteRuleMatch.text];
      result.index = pasteRuleMatch.index;
      result.input = text;
      result.data = pasteRuleMatch.data;
      if (pasteRuleMatch.replaceWith) {
        if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
        }
        result.push(pasteRuleMatch.replaceWith);
      }
      return result;
    });
  };
  function run$2(config2) {
    var editor = config2.editor,
      state = config2.state,
      from2 = config2.from,
      to = config2.to,
      rule = config2.rule,
      pasteEvent = config2.pasteEvent,
      dropEvent = config2.dropEvent;
    var _CommandManager2 = new CommandManager({
        editor: editor,
        state: state
      }),
      commands2 = _CommandManager2.commands,
      chain = _CommandManager2.chain,
      can = _CommandManager2.can;
    var handlers2 = [];
    state.doc.nodesBetween(from2, to, function (node, pos) {
      if (!node.isTextblock || node.type.spec.code) {
        return;
      }
      var resolvedFrom = Math.max(from2, pos);
      var resolvedTo = Math.min(to, pos + node.content.size);
      var textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
      var matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
      matches2.forEach(function (match) {
        if (match.index === void 0) {
          return;
        }
        var start = resolvedFrom + match.index + 1;
        var end = start + match[0].length;
        var range = {
          from: state.tr.mapping.map(start),
          to: state.tr.mapping.map(end)
        };
        var handler = rule.handler({
          state: state,
          range: range,
          match: match,
          commands: commands2,
          chain: chain,
          can: can,
          pasteEvent: pasteEvent,
          dropEvent: dropEvent
        });
        handlers2.push(handler);
      });
    });
    var success = handlers2.every(function (handler) {
      return handler !== null;
    });
    return success;
  }
  var createClipboardPasteEvent = function (text) {
    var _a2;
    var event = new ClipboardEvent("paste", {
      clipboardData: new DataTransfer()
    });
    (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.setData("text/html", text);
    return event;
  };
  function pasteRulesPlugin(props) {
    var editor = props.editor,
      rules = props.rules;
    var dragSourceElement = null;
    var isPastedFromProseMirror = false;
    var isDroppedFromProseMirror = false;
    var pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    var dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    var processEvent = function (_ref94) {
      var state = _ref94.state,
        from2 = _ref94.from,
        to = _ref94.to,
        rule = _ref94.rule,
        pasteEvt = _ref94.pasteEvt;
      var tr = state.tr;
      var chainableState = createChainableState({
        state: state,
        transaction: tr
      });
      var handler = run$2({
        editor: editor,
        state: chainableState,
        from: Math.max(from2 - 1, 0),
        to: to.b - 1,
        rule: rule,
        pasteEvent: pasteEvt,
        dropEvent: dropEvent
      });
      if (!handler || !tr.steps.length) {
        return;
      }
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
      pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
      return tr;
    };
    var plugins = rules.map(function (rule) {
      return new Plugin({
        view: function (view) {
          var handleDragstart = function (event) {
            var _a2;
            dragSourceElement = ((_a2 = view.dom.parentElement) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
          };
          window.addEventListener("dragstart", handleDragstart);
          return {
            destroy: function () {
              window.removeEventListener("dragstart", handleDragstart);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: function (view, event) {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              dropEvent = event;
              return false;
            },
            paste: function (_view, event) {
              var _a2;
              var html = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/html");
              pasteEvent = event;
              isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: function (transactions, oldState, state) {
          var transaction = transactions[0];
          var isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          var isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          var simulatedPasteMeta = transaction.getMeta("applyPasteRules");
          var isSimulatedPaste = !!simulatedPasteMeta;
          if (!isPaste && !isDrop && !isSimulatedPaste) {
            return;
          }
          if (isSimulatedPaste) {
            var from3 = simulatedPasteMeta.from,
              text = simulatedPasteMeta.text;
            var to2 = from3 + text.length;
            var pasteEvt = createClipboardPasteEvent(text);
            return processEvent({
              rule: rule,
              state: state,
              from: from3,
              to: {
                b: to2
              },
              pasteEvt: pasteEvt
            });
          }
          var from2 = oldState.doc.content.findDiffStart(state.doc.content);
          var to = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber(from2) || !to || from2 === to.b) {
            return;
          }
          return processEvent({
            rule: rule,
            state: state,
            from: from2,
            to: to,
            pasteEvt: pasteEvent
          });
        }
      });
    });
    return plugins;
  }
  function findDuplicates(items) {
    var filtered = items.filter(function (el, index) {
      return items.indexOf(el) !== index;
    });
    return Array.from(new Set(filtered));
  }
  var ExtensionManager = /*#__PURE__*/function () {
    function ExtensionManager(extensions, editor) {
      this.splittableMarks = [];
      this.editor = editor;
      this.extensions = ExtensionManager.resolve(extensions);
      this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
      this.setupExtensions();
    }
    ExtensionManager.resolve = function resolve(extensions) {
      var resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
      var duplicatedNames = findDuplicates(resolvedExtensions.map(function (extension) {
        return extension.name;
      }));
      if (duplicatedNames.length) {
        console.warn("[tiptap warn]: Duplicate extension names found: [" + duplicatedNames.map(function (item) {
          return "'" + item + "'";
        }).join(", ") + "]. This can lead to issues.");
      }
      return resolvedExtensions;
    };
    ExtensionManager.flatten = function flatten(extensions) {
      var _this48 = this;
      return extensions.map(function (extension) {
        var context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        var addExtensions = getExtensionField(extension, "addExtensions", context);
        if (addExtensions) {
          return [extension].concat(_toConsumableArray(_this48.flatten(addExtensions())));
        }
        return extension;
      }).flat(10);
    };
    ExtensionManager.sort = function sort(extensions) {
      var defaultPriority = 100;
      return extensions.sort(function (a, b) {
        var priorityA = getExtensionField(a, "priority") || defaultPriority;
        var priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    };
    var _proto69 = ExtensionManager.prototype;
    _proto69.setupExtensions = function setupExtensions() {
      var _this49 = this;
      this.extensions.forEach(function (extension) {
        var _a2;
        _this49.editor.extensionStorage[extension.name] = extension.storage;
        var context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: _this49.editor,
          type: getSchemaTypeByName(extension.name, _this49.schema)
        };
        if (extension.type === "mark") {
          var keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a2 !== void 0 ? _a2 : true;
          if (keepOnSplit) {
            _this49.splittableMarks.push(extension.name);
          }
        }
        var onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
        var onCreate = getExtensionField(extension, "onCreate", context);
        var onUpdate = getExtensionField(extension, "onUpdate", context);
        var onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
        var onTransaction = getExtensionField(extension, "onTransaction", context);
        var onFocus = getExtensionField(extension, "onFocus", context);
        var onBlur = getExtensionField(extension, "onBlur", context);
        var onDestroy = getExtensionField(extension, "onDestroy", context);
        if (onBeforeCreate) {
          _this49.editor.on("beforeCreate", onBeforeCreate);
        }
        if (onCreate) {
          _this49.editor.on("create", onCreate);
        }
        if (onUpdate) {
          _this49.editor.on("update", onUpdate);
        }
        if (onSelectionUpdate) {
          _this49.editor.on("selectionUpdate", onSelectionUpdate);
        }
        if (onTransaction) {
          _this49.editor.on("transaction", onTransaction);
        }
        if (onFocus) {
          _this49.editor.on("focus", onFocus);
        }
        if (onBlur) {
          _this49.editor.on("blur", onBlur);
        }
        if (onDestroy) {
          _this49.editor.on("destroy", onDestroy);
        }
      });
    };
    return _createClass(ExtensionManager, [{
      key: "commands",
      get: function () {
        var _this50 = this;
        return this.extensions.reduce(function (commands2, extension) {
          var context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: _this50.editor,
            type: getSchemaTypeByName(extension.name, _this50.schema)
          };
          var addCommands = getExtensionField(extension, "addCommands", context);
          if (!addCommands) {
            return commands2;
          }
          return _objectSpread(_objectSpread({}, commands2), addCommands());
        }, {});
      }
    }, {
      key: "plugins",
      get: function () {
        var _this51 = this;
        var editor = this.editor;
        var extensions = ExtensionManager.sort(_toConsumableArray(this.extensions).reverse());
        var inputRules = [];
        var pasteRules = [];
        var allPlugins = extensions.map(function (extension) {
          var context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: editor,
            type: getSchemaTypeByName(extension.name, _this51.schema)
          };
          var plugins = [];
          var addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
          var defaultBindings = {};
          if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
            defaultBindings.ArrowRight = function () {
              return Mark.handleExit({
                editor: editor,
                mark: extension
              });
            };
          }
          if (addKeyboardShortcuts) {
            var bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(function (_ref95) {
              var _ref96 = _slicedToArray(_ref95, 2),
                shortcut = _ref96[0],
                method = _ref96[1];
              return [shortcut, function () {
                return method({
                  editor: editor
                });
              }];
            }));
            defaultBindings = _objectSpread(_objectSpread({}, defaultBindings), bindings);
          }
          var keyMapPlugin = keymap(defaultBindings);
          plugins.push(keyMapPlugin);
          var addInputRules = getExtensionField(extension, "addInputRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
            inputRules.push.apply(inputRules, _toConsumableArray(addInputRules()));
          }
          var addPasteRules = getExtensionField(extension, "addPasteRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
            pasteRules.push.apply(pasteRules, _toConsumableArray(addPasteRules()));
          }
          var addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
          if (addProseMirrorPlugins) {
            var proseMirrorPlugins = addProseMirrorPlugins();
            plugins.push.apply(plugins, _toConsumableArray(proseMirrorPlugins));
          }
          return plugins;
        }).flat();
        return [inputRulesPlugin({
          editor: editor,
          rules: inputRules
        })].concat(_toConsumableArray(pasteRulesPlugin({
          editor: editor,
          rules: pasteRules
        })), _toConsumableArray(allPlugins));
      }
    }, {
      key: "attributes",
      get: function () {
        return getAttributesFromExtensions(this.extensions);
      }
    }, {
      key: "nodeViews",
      get: function () {
        var _this52 = this;
        var editor = this.editor;
        var _splitExtensions3 = splitExtensions(this.extensions),
          nodeExtensions = _splitExtensions3.nodeExtensions;
        return Object.fromEntries(nodeExtensions.filter(function (extension) {
          return !!getExtensionField(extension, "addNodeView");
        }).map(function (extension) {
          var extensionAttributes = _this52.attributes.filter(function (attribute) {
            return attribute.type === extension.name;
          });
          var context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: editor,
            type: getNodeType(extension.name, _this52.schema)
          };
          var addNodeView = getExtensionField(extension, "addNodeView", context);
          if (!addNodeView) {
            return [];
          }
          var nodeview = function (node, view, getPos, decorations, innerDecorations) {
            var HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
            return addNodeView()({
              node: node,
              view: view,
              getPos: getPos,
              decorations: decorations,
              innerDecorations: innerDecorations,
              editor: editor,
              extension: extension,
              HTMLAttributes: HTMLAttributes
            });
          };
          return [extension.name, nodeview];
        }));
      }
    }]);
  }();
  var Extension = /*#__PURE__*/function () {
    function Extension() {
      var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = _objectSpread(_objectSpread({}, this.config), config2);
      this.name = this.config.name;
      if (config2.defaultOptions && Object.keys(config2.defaultOptions).length > 0) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"" + this.name + "\".");
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    Extension.create = function create() {
      var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Extension(config2);
    };
    var _proto70 = Extension.prototype;
    _proto70.configure = function configure() {
      var _this53 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = this.extend(_objectSpread(_objectSpread({}, this.config), {}, {
        addOptions: function () {
          return mergeDeep$1(_this53.options, options);
        }
      }));
      extension.name = this.name;
      extension.parent = this.parent;
      return extension;
    };
    _proto70.extend = function extend() {
      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = new Extension(_objectSpread(_objectSpread({}, this.config), extendedConfig));
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"" + extension.name + "\".");
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    };
    return Extension;
  }();
  function getTextBetween(startNode, range, options) {
    var from2 = range.from,
      to = range.to;
    var _ref97 = options || {},
      _ref97$blockSeparator = _ref97.blockSeparator,
      blockSeparator = _ref97$blockSeparator === void 0 ? "\n\n" : _ref97$blockSeparator,
      _ref97$textSerializer = _ref97.textSerializers,
      textSerializers = _ref97$textSerializer === void 0 ? {} : _ref97$textSerializer;
    var text = "";
    startNode.nodesBetween(from2, to, function (node, pos, parent, index) {
      var _a2;
      if (node.isBlock && pos > from2) {
        text += blockSeparator;
      }
      var textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
      if (textSerializer) {
        if (parent) {
          text += textSerializer({
            node: node,
            pos: pos,
            parent: parent,
            index: index,
            range: range
          });
        }
        return false;
      }
      if (node.isText) {
        text += (_a2 = node === null || node === void 0 ? void 0 : node.text) === null || _a2 === void 0 ? void 0 : _a2.slice(Math.max(from2, pos) - pos, to - pos);
      }
    });
    return text;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(function (_ref98) {
      var _ref99 = _slicedToArray(_ref98, 2),
        node = _ref99[1];
      return node.spec.toText;
    }).map(function (_ref100) {
      var _ref101 = _slicedToArray(_ref100, 2),
        name = _ref101[0],
        node = _ref101[1];
      return [name, node.spec.toText];
    }));
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addOptions: function () {
      return {
        blockSeparator: void 0
      };
    },
    addProseMirrorPlugins: function () {
      var _this54 = this;
      return [new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: function () {
            var editor = _this54.editor;
            var state = editor.state,
              schema = editor.schema;
            var doc2 = state.doc,
              selection = state.selection;
            var ranges = selection.ranges;
            var from2 = Math.min.apply(Math, _toConsumableArray(ranges.map(function (range2) {
              return range2.$from.pos;
            })));
            var to = Math.max.apply(Math, _toConsumableArray(ranges.map(function (range2) {
              return range2.$to.pos;
            })));
            var textSerializers = getTextSerializersFromSchema(schema);
            var range = {
              from: from2,
              to: to
            };
            return getTextBetween(doc2, range, _objectSpread(_objectSpread({}, _this54.options.blockSeparator !== void 0 ? {
              blockSeparator: _this54.options.blockSeparator
            } : {}), {}, {
              textSerializers: textSerializers
            }));
          }
        }
      })];
    }
  });
  var blur = function () {
    return function (_ref102) {
      var editor = _ref102.editor,
        view = _ref102.view;
      requestAnimationFrame(function () {
        var _a2;
        if (!editor.isDestroyed) {
          view.dom.blur();
          (_a2 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a2 === void 0 ? void 0 : _a2.removeAllRanges();
        }
      });
      return true;
    };
  };
  var clearContent = function () {
    var emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return function (_ref103) {
      var commands2 = _ref103.commands;
      return commands2.setContent("", emitUpdate);
    };
  };
  var clearNodes = function () {
    return function (_ref104) {
      var state = _ref104.state,
        tr = _ref104.tr,
        dispatch = _ref104.dispatch;
      var selection = tr.selection;
      var ranges = selection.ranges;
      if (!dispatch) {
        return true;
      }
      ranges.forEach(function (_ref105) {
        var $from = _ref105.$from,
          $to = _ref105.$to;
        state.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {
          if (node.type.isText) {
            return;
          }
          var doc2 = tr.doc,
            mapping = tr.mapping;
          var $mappedFrom = doc2.resolve(mapping.map(pos));
          var $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
          var nodeRange = $mappedFrom.blockRange($mappedTo);
          if (!nodeRange) {
            return;
          }
          var targetLiftDepth = liftTarget(nodeRange);
          if (node.type.isTextblock) {
            var _$mappedFrom$parent$c = $mappedFrom.parent.contentMatchAt($mappedFrom.index()),
              defaultType = _$mappedFrom$parent$c.defaultType;
            tr.setNodeMarkup(nodeRange.start, defaultType);
          }
          if (targetLiftDepth || targetLiftDepth === 0) {
            tr.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
  };
  var command = function (fn) {
    return function (props) {
      return fn(props);
    };
  };
  var createParagraphNear = function () {
    return function (_ref106) {
      var state = _ref106.state,
        dispatch = _ref106.dispatch;
      return createParagraphNear$1(state, dispatch);
    };
  };
  var cut = function (originRange, targetPos) {
    return function (_ref107) {
      var editor = _ref107.editor,
        tr = _ref107.tr;
      var state = editor.state;
      var contentSlice = state.doc.slice(originRange.from, originRange.to);
      tr.deleteRange(originRange.from, originRange.to);
      var newPos = tr.mapping.map(targetPos);
      tr.insert(newPos, contentSlice.content);
      tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
      return true;
    };
  };
  var deleteCurrentNode = function () {
    return function (_ref108) {
      var tr = _ref108.tr,
        dispatch = _ref108.dispatch;
      var selection = tr.selection;
      var currentNode = selection.$anchor.node();
      if (currentNode.content.size > 0) {
        return false;
      }
      var $pos = tr.selection.$anchor;
      for (var depth = $pos.depth; depth > 0; depth -= 1) {
        var node = $pos.node(depth);
        if (node.type === currentNode.type) {
          if (dispatch) {
            var _from11 = $pos.before(depth);
            var to = $pos.after(depth);
            tr.delete(_from11, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
  };
  var deleteNode = function (typeOrName) {
    return function (_ref109) {
      var tr = _ref109.tr,
        state = _ref109.state,
        dispatch = _ref109.dispatch;
      var type = getNodeType(typeOrName, state.schema);
      var $pos = tr.selection.$anchor;
      for (var depth = $pos.depth; depth > 0; depth -= 1) {
        var node = $pos.node(depth);
        if (node.type === type) {
          if (dispatch) {
            var _from12 = $pos.before(depth);
            var to = $pos.after(depth);
            tr.delete(_from12, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
  };
  var deleteRange = function (range) {
    return function (_ref110) {
      var tr = _ref110.tr,
        dispatch = _ref110.dispatch;
      var from2 = range.from,
        to = range.to;
      if (dispatch) {
        tr.delete(from2, to);
      }
      return true;
    };
  };
  var deleteSelection = function () {
    return function (_ref111) {
      var state = _ref111.state,
        dispatch = _ref111.dispatch;
      return deleteSelection$1(state, dispatch);
    };
  };
  var enter = function () {
    return function (_ref112) {
      var commands2 = _ref112.commands;
      return commands2.keyboardShortcut("Enter");
    };
  };
  var exitCode = function () {
    return function (_ref113) {
      var state = _ref113.state,
        dispatch = _ref113.dispatch;
      return exitCode$1(state, dispatch);
    };
  };
  function objectIncludes(object1, object2) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      strict: true
    };
    var keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every(function (key) {
      if (options.strict) {
        return object2[key] === object1[key];
      }
      if (isRegExp(object2[key])) {
        return object2[key].test(object1[key]);
      }
      return object2[key] === object1[key];
    });
  }
  function findMarkInSet(marks, type) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return marks.find(function (item) {
      return item.type === type && objectIncludes(item.attrs, attributes);
    });
  }
  function isMarkInSet(marks, type) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!$pos || !type) {
      return;
    }
    var start = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start.offset && start.offset !== 0) {
      start = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start.node) {
      return;
    }
    var mark = findMarkInSet(_toConsumableArray(start.node.marks), type, attributes);
    if (!mark) {
      return;
    }
    var startIndex = start.index;
    var startPos = $pos.start() + start.offset;
    var endIndex = startIndex + 1;
    var endPos = startPos + start.node.nodeSize;
    findMarkInSet(_toConsumableArray(start.node.marks), type, attributes);
    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet(_toConsumableArray($pos.parent.child(endIndex).marks), type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error("There is no mark type named '" + nameOrType + "'. Maybe you forgot to add the extension?");
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  var extendMarkRange = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref114) {
      var tr = _ref114.tr,
        state = _ref114.state,
        dispatch = _ref114.dispatch;
      var type = getMarkType(typeOrName, state.schema);
      var doc2 = tr.doc,
        selection = tr.selection;
      var $from = selection.$from,
        from2 = selection.from,
        to = selection.to;
      if (dispatch) {
        var range = getMarkRange($from, type, attributes);
        if (range && range.from <= from2 && range.to >= to) {
          var newSelection = TextSelection.create(doc2, range.from, range.to);
          tr.setSelection(newSelection);
        }
      }
      return true;
    };
  };
  var first = function (commands2) {
    return function (props) {
      var items = typeof commands2 === "function" ? commands2(props) : commands2;
      for (var _i244 = 0; _i244 < items.length; _i244 += 1) {
        if (items[_i244](props)) {
          return true;
        }
      }
      return false;
    };
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return Math.min(Math.max(value, min), max);
  }
  function resolveFocusPosition(doc2) {
    var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!position) {
      return null;
    }
    var selectionAtStart = Selection.atStart(doc2);
    var selectionAtEnd = Selection.atEnd(doc2);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    var minPos = selectionAtStart.from;
    var maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
  }
  function isiOS() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  var focus = function () {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref115) {
      var editor = _ref115.editor,
        view = _ref115.view,
        tr = _ref115.tr,
        dispatch = _ref115.dispatch;
      options = _objectSpread({
        scrollIntoView: true
      }, options);
      var delayedFocus = function () {
        if (isiOS()) {
          view.dom.focus();
        }
        requestAnimationFrame(function () {
          if (!editor.isDestroyed) {
            view.focus();
            if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
              editor.commands.scrollIntoView();
            }
          }
        });
      };
      if (view.hasFocus() && position === null || position === false) {
        return true;
      }
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
      }
      var selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
      var isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr.setSelection(selection);
        }
        if (isSameSelection && tr.storedMarks) {
          tr.setStoredMarks(tr.storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
  };
  var forEach = function (items, fn) {
    return function (props) {
      return items.every(function (item, index) {
        return fn(item, _objectSpread(_objectSpread({}, props), {}, {
          index: index
        }));
      });
    };
  };
  var insertContent = function (value, options) {
    return function (_ref116) {
      var tr = _ref116.tr,
        commands2 = _ref116.commands;
      return commands2.insertContentAt({
        from: tr.selection.from,
        to: tr.selection.to
      }, value, options);
    };
  };
  var removeWhitespaces = function (node) {
    var children = node.childNodes;
    for (var _i245 = children.length - 1; _i245 >= 0; _i245 -= 1) {
      var child = children[_i245];
      if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
        node.removeChild(child);
      } else if (child.nodeType === 1) {
        removeWhitespaces(child);
      }
    }
    return node;
  };
  function elementFromString(value) {
    var wrappedValue = "<body>" + value + "</body>";
    var html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
    return removeWhitespaces(html);
  }
  function createNodeFromContent(content, schema, options) {
    options = _objectSpread({
      slice: true,
      parseOptions: {}
    }, options);
    var isJSONContent = _typeof(content) === "object" && content !== null;
    var isTextContent = typeof content === "string";
    if (isJSONContent) {
      try {
        var isArrayContent = Array.isArray(content) && content.length > 0;
        if (isArrayContent) {
          return Fragment.fromArray(content.map(function (item) {
            return schema.nodeFromJSON(item);
          }));
        }
        var node = schema.nodeFromJSON(content);
        if (options.errorOnInvalidContent) {
          node.check();
        }
        return node;
      } catch (error) {
        if (options.errorOnInvalidContent) {
          throw new Error("[tiptap error]: Invalid JSON content", {
            cause: error
          });
        }
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
        return createNodeFromContent("", schema, options);
      }
    }
    if (isTextContent) {
      if (options.errorOnInvalidContent) {
        var hasInvalidContent = false;
        var invalidContent = "";
        var contentCheckSchema = new Schema({
          topNode: schema.spec.topNode,
          marks: schema.spec.marks,
          nodes: schema.spec.nodes.append({
            __tiptap__private__unknown__catch__all__node: {
              content: "inline*",
              group: "block",
              parseDOM: [{
                tag: "*",
                getAttrs: function (e) {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }]
            }
          })
        });
        if (options.slice) {
          DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
        } else {
          DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
        }
        if (options.errorOnInvalidContent && hasInvalidContent) {
          throw new Error("[tiptap error]: Invalid HTML content", {
            cause: new Error("Invalid element found: " + invalidContent)
          });
        }
      }
      var parser = DOMParser.fromSchema(schema);
      if (options.slice) {
        return parser.parseSlice(elementFromString(content), options.parseOptions).content;
      }
      return parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    var last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    var step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    var map3 = tr.mapping.maps[last];
    var end = 0;
    map3.forEach(function (_from, _to, _newFrom, newTo) {
      if (end === 0) {
        end = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
  }
  var isFragment = function (nodeOrFragment) {
    return !("type" in nodeOrFragment);
  };
  var insertContentAt = function (position, value, options) {
    return function (_ref117) {
      var tr = _ref117.tr,
        dispatch = _ref117.dispatch,
        editor = _ref117.editor;
      var _a2;
      if (dispatch) {
        options = _objectSpread({
          parseOptions: {},
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false
        }, options);
        var content;
        try {
          content = createNodeFromContent(value, editor.schema, {
            parseOptions: _objectSpread({
              preserveWhitespace: "full"
            }, options.parseOptions),
            errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
          });
        } catch (e) {
          editor.emit("contentError", {
            editor: editor,
            error: e,
            disableCollaboration: function () {
              console.error("[tiptap error]: Unable to disable collaboration at this point in time");
            }
          });
          return false;
        }
        var _ref118 = typeof position === "number" ? {
            from: position,
            to: position
          } : {
            from: position.from,
            to: position.to
          },
          _from13 = _ref118.from,
          to = _ref118.to;
        var isOnlyTextContent = true;
        var isOnlyBlockContent = true;
        var nodes = isFragment(content) ? content : [content];
        nodes.forEach(function (node) {
          node.check();
          isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
          isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
        });
        if (_from13 === to && isOnlyBlockContent) {
          var _tr$doc$resolve = tr.doc.resolve(_from13),
            parent = _tr$doc$resolve.parent;
          var isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
          if (isEmptyTextBlock) {
            _from13 -= 1;
            to += 1;
          }
        }
        var newContent;
        if (isOnlyTextContent) {
          if (Array.isArray(value)) {
            newContent = value.map(function (v) {
              return v.text || "";
            }).join("");
          } else if (_typeof(value) === "object" && !!value && !!value.text) {
            newContent = value.text;
          } else {
            newContent = value;
          }
          tr.insertText(newContent, _from13, to);
        } else {
          newContent = content;
          tr.replaceWith(_from13, to, newContent);
        }
        if (options.updateSelection) {
          selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
        }
        if (options.applyInputRules) {
          tr.setMeta("applyInputRules", {
            from: _from13,
            text: newContent
          });
        }
        if (options.applyPasteRules) {
          tr.setMeta("applyPasteRules", {
            from: _from13,
            text: newContent
          });
        }
      }
      return true;
    };
  };
  var joinUp = function () {
    return function (_ref119) {
      var state = _ref119.state,
        dispatch = _ref119.dispatch;
      return joinUp$1(state, dispatch);
    };
  };
  var joinDown = function () {
    return function (_ref120) {
      var state = _ref120.state,
        dispatch = _ref120.dispatch;
      return joinDown$1(state, dispatch);
    };
  };
  var joinBackward = function () {
    return function (_ref121) {
      var state = _ref121.state,
        dispatch = _ref121.dispatch;
      return joinBackward$1(state, dispatch);
    };
  };
  var joinForward = function () {
    return function (_ref122) {
      var state = _ref122.state,
        dispatch = _ref122.dispatch;
      return joinForward$1(state, dispatch);
    };
  };
  var joinItemBackward = function () {
    return function (_ref123) {
      var state = _ref123.state,
        dispatch = _ref123.dispatch,
        tr = _ref123.tr;
      try {
        var point = joinPoint(state.doc, state.selection.$from.pos, -1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch (e) {
        return false;
      }
    };
  };
  var joinItemForward = function () {
    return function (_ref124) {
      var state = _ref124.state,
        dispatch = _ref124.dispatch,
        tr = _ref124.tr;
      try {
        var point = joinPoint(state.doc, state.selection.$from.pos, 1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch (e) {
        return false;
      }
    };
  };
  var joinTextblockBackward = function () {
    return function (_ref125) {
      var state = _ref125.state,
        dispatch = _ref125.dispatch;
      return joinTextblockBackward$1(state, dispatch);
    };
  };
  var joinTextblockForward = function () {
    return function (_ref126) {
      var state = _ref126.state,
        dispatch = _ref126.dispatch;
      return joinTextblockForward$1(state, dispatch);
    };
  };
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    var result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    var alt;
    var ctrl;
    var shift2;
    var meta;
    for (var _i246 = 0; _i246 < parts.length - 1; _i246 += 1) {
      var mod = parts[_i246];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      result = "Alt-" + result;
    }
    if (ctrl) {
      result = "Ctrl-" + result;
    }
    if (meta) {
      result = "Meta-" + result;
    }
    if (shift2) {
      result = "Shift-" + result;
    }
    return result;
  }
  var keyboardShortcut = function (name) {
    return function (_ref127) {
      var editor = _ref127.editor,
        view = _ref127.view,
        tr = _ref127.tr,
        dispatch = _ref127.dispatch;
      var keys2 = normalizeKeyName(name).split(/-(?!$)/);
      var key = keys2.find(function (item) {
        return !["Alt", "Ctrl", "Meta", "Shift"].includes(item);
      });
      var event = new KeyboardEvent("keydown", {
        key: key === "Space" ? " " : key,
        altKey: keys2.includes("Alt"),
        ctrlKey: keys2.includes("Ctrl"),
        metaKey: keys2.includes("Meta"),
        shiftKey: keys2.includes("Shift"),
        bubbles: true,
        cancelable: true
      });
      var capturedTransaction = editor.captureTransaction(function () {
        view.someProp("handleKeyDown", function (f) {
          return f(view, event);
        });
      });
      capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(function (step) {
        var newStep = step.map(tr.mapping);
        if (newStep && dispatch) {
          tr.maybeStep(newStep);
        }
      });
      return true;
    };
  };
  function isNodeActive(state, typeOrName) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _state$selection12 = state.selection,
      from2 = _state$selection12.from,
      to = _state$selection12.to,
      empty2 = _state$selection12.empty;
    var type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    var nodeRanges = [];
    state.doc.nodesBetween(from2, to, function (node, pos) {
      if (node.isText) {
        return;
      }
      var relativeFrom = Math.max(from2, pos);
      var relativeTo = Math.min(to, pos + node.nodeSize);
      nodeRanges.push({
        node: node,
        from: relativeFrom,
        to: relativeTo
      });
    });
    var selectionRange = to - from2;
    var matchedNodeRanges = nodeRanges.filter(function (nodeRange) {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter(function (nodeRange) {
      return objectIncludes(nodeRange.node.attrs, attributes, {
        strict: false
      });
    });
    if (empty2) {
      return !!matchedNodeRanges.length;
    }
    var range = matchedNodeRanges.reduce(function (sum, nodeRange) {
      return sum + nodeRange.to - nodeRange.from;
    }, 0);
    return range >= selectionRange;
  }
  var lift = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref128) {
      var state = _ref128.state,
        dispatch = _ref128.dispatch;
      var type = getNodeType(typeOrName, state.schema);
      var isActive2 = isNodeActive(state, type, attributes);
      if (!isActive2) {
        return false;
      }
      return lift$1(state, dispatch);
    };
  };
  var liftEmptyBlock = function () {
    return function (_ref129) {
      var state = _ref129.state,
        dispatch = _ref129.dispatch;
      return liftEmptyBlock$1(state, dispatch);
    };
  };
  var liftListItem = function (typeOrName) {
    return function (_ref130) {
      var state = _ref130.state,
        dispatch = _ref130.dispatch;
      var type = getNodeType(typeOrName, state.schema);
      return liftListItem$1(type)(state, dispatch);
    };
  };
  var newlineInCode = function () {
    return function (_ref131) {
      var state = _ref131.state,
        dispatch = _ref131.dispatch;
      return newlineInCode$1(state, dispatch);
    };
  };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    var props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce(function (newObj, prop) {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes = function (typeOrName, attributes) {
    return function (_ref132) {
      var tr = _ref132.tr,
        state = _ref132.state,
        dispatch = _ref132.dispatch;
      var nodeType = null;
      var markType = null;
      var schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach(function (range) {
          state.doc.nodesBetween(range.$from.pos, range.$to.pos, function (node, pos) {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
            }
            if (markType && node.marks.length) {
              node.marks.forEach(function (mark) {
                if (markType === mark.type) {
                  tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                }
              });
            }
          });
        });
      }
      return true;
    };
  };
  var scrollIntoView = function () {
    return function (_ref133) {
      var tr = _ref133.tr,
        dispatch = _ref133.dispatch;
      if (dispatch) {
        tr.scrollIntoView();
      }
      return true;
    };
  };
  var selectAll = function () {
    return function (_ref134) {
      var tr = _ref134.tr,
        commands2 = _ref134.commands;
      return commands2.setTextSelection({
        from: 0,
        to: tr.doc.content.size
      });
    };
  };
  var selectNodeBackward = function () {
    return function (_ref135) {
      var state = _ref135.state,
        dispatch = _ref135.dispatch;
      return selectNodeBackward$1(state, dispatch);
    };
  };
  var selectNodeForward = function () {
    return function (_ref136) {
      var state = _ref136.state,
        dispatch = _ref136.dispatch;
      return selectNodeForward$1(state, dispatch);
    };
  };
  var selectParentNode = function () {
    return function (_ref137) {
      var state = _ref137.state,
        dispatch = _ref137.dispatch;
      return selectParentNode$1(state, dispatch);
    };
  };
  var selectTextblockEnd = function () {
    return function (_ref138) {
      var state = _ref138.state,
        dispatch = _ref138.dispatch;
      return selectTextblockEnd$1(state, dispatch);
    };
  };
  var selectTextblockStart = function () {
    return function (_ref139) {
      var state = _ref139.state,
        dispatch = _ref139.dispatch;
      return selectTextblockStart$1(state, dispatch);
    };
  };
  function createDocument(content, schema) {
    var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return createNodeFromContent(content, schema, {
      slice: false,
      parseOptions: parseOptions,
      errorOnInvalidContent: options.errorOnInvalidContent
    });
  }
  var setContent = function (content) {
    var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return function (_ref140) {
      var editor = _ref140.editor,
        tr = _ref140.tr,
        dispatch = _ref140.dispatch,
        commands2 = _ref140.commands;
      var _a2, _b;
      var doc2 = tr.doc;
      if (parseOptions.preserveWhitespace !== "full") {
        var document2 = createDocument(content, editor.schema, parseOptions, {
          errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
        });
        if (dispatch) {
          tr.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
        }
        return true;
      }
      if (dispatch) {
        tr.setMeta("preventUpdate", !emitUpdate);
      }
      return commands2.insertContentAt({
        from: 0,
        to: doc2.content.size
      }, content, {
        parseOptions: parseOptions,
        errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
      });
    };
  };
  function getMarkAttributes(state, typeOrName) {
    var type = getMarkType(typeOrName, state.schema);
    var _state$selection13 = state.selection,
      from2 = _state$selection13.from,
      to = _state$selection13.to,
      empty2 = _state$selection13.empty;
    var marks = [];
    if (empty2) {
      if (state.storedMarks) {
        marks.push.apply(marks, _toConsumableArray(state.storedMarks));
      }
      marks.push.apply(marks, _toConsumableArray(state.selection.$head.marks()));
    } else {
      state.doc.nodesBetween(from2, to, function (node) {
        marks.push.apply(marks, _toConsumableArray(node.marks));
      });
    }
    var mark = marks.find(function (markItem) {
      return markItem.type.name === type.name;
    });
    if (!mark) {
      return {};
    }
    return _objectSpread({}, mark.attrs);
  }
  function defaultBlockAt(match) {
    for (var _i247 = 0; _i247 < match.edgeCount; _i247 += 1) {
      var _match$edge3 = match.edge(_i247),
        type = _match$edge3.type;
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (var _i248 = $pos.depth; _i248 > 0; _i248 -= 1) {
      var node = $pos.node(_i248);
      if (predicate(node)) {
        return {
          pos: _i248 > 0 ? $pos.before(_i248) : 0,
          start: $pos.start(_i248),
          depth: _i248,
          node: node
        };
      }
    }
  }
  function findParentNode(predicate) {
    return function (selection) {
      return findParentNodeClosestToPos(selection.$from, predicate);
    };
  }
  function getHTMLFromFragment(fragment, schema) {
    var documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
    var temporaryDocument = document.implementation.createHTMLDocument();
    var container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  function _getText(node, options) {
    var range = {
      from: 0,
      to: node.content.size
    };
    return getTextBetween(node, range, options);
  }
  function getNodeAttributes(state, typeOrName) {
    var type = getNodeType(typeOrName, state.schema);
    var _state$selection14 = state.selection,
      from2 = _state$selection14.from,
      to = _state$selection14.to;
    var nodes = [];
    state.doc.nodesBetween(from2, to, function (node2) {
      nodes.push(node2);
    });
    var node = nodes.reverse().find(function (nodeItem) {
      return nodeItem.type.name === type.name;
    });
    if (!node) {
      return {};
    }
    return _objectSpread({}, node.attrs);
  }
  function _getAttributes(state, typeOrName) {
    var schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function getMarksBetween(from2, to, doc2) {
    var marks = [];
    if (from2 === to) {
      doc2.resolve(from2).marks().forEach(function (mark) {
        var $pos = doc2.resolve(from2);
        var range = getMarkRange($pos, mark.type);
        if (!range) {
          return;
        }
        marks.push(_objectSpread({
          mark: mark
        }, range));
      });
    } else {
      doc2.nodesBetween(from2, to, function (node, pos) {
        if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
          return;
        }
        marks.push.apply(marks, _toConsumableArray(node.marks.map(function (mark) {
          return {
            from: pos,
            to: pos + node.nodeSize,
            mark: mark
          };
        })));
      });
    }
    return marks;
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(function (_ref141) {
      var _ref142 = _slicedToArray(_ref141, 1),
        name = _ref142[0];
      var extensionAttribute = extensionAttributes.find(function (item) {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _state$selection15 = state.selection,
      empty2 = _state$selection15.empty,
      ranges = _state$selection15.ranges;
    var type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty2) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter(function (mark) {
        if (!type) {
          return true;
        }
        return type.name === mark.type.name;
      }).find(function (mark) {
        return objectIncludes(mark.attrs, attributes, {
          strict: false
        });
      });
    }
    var selectionRange = 0;
    var markRanges = [];
    ranges.forEach(function (_ref143) {
      var $from = _ref143.$from,
        $to = _ref143.$to;
      var from2 = $from.pos;
      var to = $to.pos;
      state.doc.nodesBetween(from2, to, function (node, pos) {
        if (!node.isText && !node.marks.length) {
          return;
        }
        var relativeFrom = Math.max(from2, pos);
        var relativeTo = Math.min(to, pos + node.nodeSize);
        var range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push.apply(markRanges, _toConsumableArray(node.marks.map(function (mark) {
          return {
            mark: mark,
            from: relativeFrom,
            to: relativeTo
          };
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    var matchedRange = markRanges.filter(function (markRange) {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter(function (markRange) {
      return objectIncludes(markRange.mark.attrs, attributes, {
        strict: false
      });
    }).reduce(function (sum, markRange) {
      return sum + markRange.to - markRange.from;
    }, 0);
    var excludedRange = markRanges.filter(function (markRange) {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce(function (sum, markRange) {
      return sum + markRange.to - markRange.from;
    }, 0);
    var range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function _isActive(state, name) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    var schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  function isList(name, extensions) {
    var _splitExtensions4 = splitExtensions(extensions),
      nodeExtensions = _splitExtensions4.nodeExtensions;
    var extension = nodeExtensions.find(function (item) {
      return item.name === name;
    });
    if (!extension) {
      return false;
    }
    var context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    var group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function isNodeEmpty(node) {
    var _ref144 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref144$checkChildren = _ref144.checkChildren,
      checkChildren = _ref144$checkChildren === void 0 ? true : _ref144$checkChildren,
      _ref144$ignoreWhitesp = _ref144.ignoreWhitespace,
      ignoreWhitespace = _ref144$ignoreWhitesp === void 0 ? false : _ref144$ignoreWhitesp;
    var _a2;
    if (ignoreWhitespace) {
      if (node.type.name === "hardBreak") {
        return true;
      }
      if (node.isText) {
        return /^\s*$/m.test((_a2 = node.text) !== null && _a2 !== void 0 ? _a2 : "");
      }
    }
    if (node.isText) {
      return !node.text;
    }
    if (node.isAtom || node.isLeaf) {
      return false;
    }
    if (node.content.childCount === 0) {
      return true;
    }
    if (checkChildren) {
      var isContentEmpty = true;
      node.content.forEach(function (childNode) {
        if (isContentEmpty === false) {
          return;
        }
        if (!isNodeEmpty(childNode, {
          ignoreWhitespace: ignoreWhitespace,
          checkChildren: checkChildren
        })) {
          isContentEmpty = false;
        }
      });
      return isContentEmpty;
    }
    return false;
  }
  function isNodeSelection(value) {
    return value instanceof NodeSelection;
  }
  function canSetMark(state, tr, newMarkType) {
    var _a2;
    var selection = tr.selection;
    var cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      var currentMarks = (_a2 = state.storedMarks) !== null && _a2 !== void 0 ? _a2 : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(function (mark) {
        return mark.type.excludes(newMarkType);
      });
    }
    var ranges = selection.ranges;
    return ranges.some(function (_ref145) {
      var $from = _ref145.$from,
        $to = _ref145.$to;
      var someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, function (node, _pos, parent) {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node.isInline) {
          var parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          var currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(function (otherMark) {
            return otherMark.type.excludes(newMarkType);
          });
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  var setMark = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref146) {
      var tr = _ref146.tr,
        state = _ref146.state,
        dispatch = _ref146.dispatch;
      var selection = tr.selection;
      var empty2 = selection.empty,
        ranges = selection.ranges;
      var type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
        if (empty2) {
          var oldAttributes = getMarkAttributes(state, type);
          tr.addStoredMark(type.create(_objectSpread(_objectSpread({}, oldAttributes), attributes)));
        } else {
          ranges.forEach(function (range) {
            var from2 = range.$from.pos;
            var to = range.$to.pos;
            state.doc.nodesBetween(from2, to, function (node, pos) {
              var trimmedFrom = Math.max(pos, from2);
              var trimmedTo = Math.min(pos + node.nodeSize, to);
              var someHasMark = node.marks.find(function (mark) {
                return mark.type === type;
              });
              if (someHasMark) {
                node.marks.forEach(function (mark) {
                  if (type === mark.type) {
                    tr.addMark(trimmedFrom, trimmedTo, type.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));
                  }
                });
              } else {
                tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
              }
            });
          });
        }
      }
      return canSetMark(state, tr, type);
    };
  };
  var setMeta = function (key, value) {
    return function (_ref147) {
      var tr = _ref147.tr;
      tr.setMeta(key, value);
      return true;
    };
  };
  var setNode = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref148) {
      var state = _ref148.state,
        dispatch = _ref148.dispatch,
        chain = _ref148.chain;
      var type = getNodeType(typeOrName, state.schema);
      if (!type.isTextblock) {
        console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
        return false;
      }
      return chain().command(function (_ref149) {
        var commands2 = _ref149.commands;
        var canSetBlock = setBlockType(type, attributes)(state);
        if (canSetBlock) {
          return true;
        }
        return commands2.clearNodes();
      }).command(function (_ref150) {
        var updatedState = _ref150.state;
        return setBlockType(type, attributes)(updatedState, dispatch);
      }).run();
    };
  };
  var setNodeSelection = function (position) {
    return function (_ref151) {
      var tr = _ref151.tr,
        dispatch = _ref151.dispatch;
      if (dispatch) {
        var doc2 = tr.doc;
        var _from14 = minMax(position, 0, doc2.content.size);
        var selection = NodeSelection.create(doc2, _from14);
        tr.setSelection(selection);
      }
      return true;
    };
  };
  var setTextSelection = function (position) {
    return function (_ref152) {
      var tr = _ref152.tr,
        dispatch = _ref152.dispatch;
      if (dispatch) {
        var doc2 = tr.doc;
        var _ref153 = typeof position === "number" ? {
            from: position,
            to: position
          } : position,
          _from15 = _ref153.from,
          to = _ref153.to;
        var minPos = TextSelection.atStart(doc2).from;
        var maxPos = TextSelection.atEnd(doc2).to;
        var resolvedFrom = minMax(_from15, minPos, maxPos);
        var resolvedEnd = minMax(to, minPos, maxPos);
        var selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
        tr.setSelection(selection);
      }
      return true;
    };
  };
  var sinkListItem = function (typeOrName) {
    return function (_ref154) {
      var state = _ref154.state,
        dispatch = _ref154.dispatch;
      var type = getNodeType(typeOrName, state.schema);
      return sinkListItem$1(type)(state, dispatch);
    };
  };
  function ensureMarks(state, splittableMarks) {
    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      var filteredMarks = marks.filter(function (mark) {
        return splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name);
      });
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock = function () {
    var _ref155 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref155$keepMarks = _ref155.keepMarks,
      keepMarks = _ref155$keepMarks === void 0 ? true : _ref155$keepMarks;
    return function (_ref156) {
      var tr = _ref156.tr,
        state = _ref156.state,
        dispatch = _ref156.dispatch,
        editor = _ref156.editor;
      var selection = tr.selection,
        doc2 = tr.doc;
      var $from = selection.$from,
        $to = selection.$to;
      var extensionAttributes = editor.extensionManager.attributes;
      var newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      var atEnd = $to.parentOffset === $to.parent.content.size;
      var deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      var types = atEnd && deflt ? [{
        type: deflt,
        attrs: newAttributes
      }] : void 0;
      var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{
        type: deflt
      }] : void 0)) {
        can = true;
        types = deflt ? [{
          type: deflt,
          attrs: newAttributes
        }] : void 0;
      }
      if (dispatch) {
        if (can) {
          if (selection instanceof TextSelection) {
            tr.deleteSelection();
          }
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
            var first2 = tr.mapping.map($from.before());
            var $first = tr.doc.resolve(first2);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.scrollIntoView();
      }
      return can;
    };
  };
  var splitListItem = function (typeOrName) {
    var overrideAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref157) {
      var tr = _ref157.tr,
        state = _ref157.state,
        dispatch = _ref157.dispatch,
        editor = _ref157.editor;
      var _a2;
      var type = getNodeType(typeOrName, state.schema);
      var _state$selection16 = state.selection,
        $from = _state$selection16.$from,
        $to = _state$selection16.$to;
      var node = state.selection.node;
      if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      var grandParent = $from.node(-1);
      if (grandParent.type !== type) {
        return false;
      }
      var extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
          return false;
        }
        if (dispatch) {
          var wrap2 = Fragment.empty;
          var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
            wrap2 = Fragment.from($from.node(d).copy(wrap2));
          }
          var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
          var newNextTypeAttributes2 = _objectSpread(_objectSpread({}, getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)), overrideAttrs);
          var nextType2 = ((_a2 = type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
          var start = $from.before($from.depth - (depthBefore - 1));
          tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
          var sel = -1;
          tr.doc.nodesBetween(start, tr.doc.content.size, function (n, pos) {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
          }
          tr.scrollIntoView();
        }
        return true;
      }
      var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      var newTypeAttributes = _objectSpread(_objectSpread({}, getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs)), overrideAttrs);
      var newNextTypeAttributes = _objectSpread(_objectSpread({}, getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)), overrideAttrs);
      tr.delete($from.pos, $to.pos);
      var types = nextType ? [{
        type: type,
        attrs: newTypeAttributes
      }, {
        type: nextType,
        attrs: newNextTypeAttributes
      }] : [{
        type: type,
        attrs: newTypeAttributes
      }];
      if (!canSplit(tr.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        var selection = state.selection,
          storedMarks = state.storedMarks;
        var splittableMarks = editor.extensionManager.splittableMarks;
        var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        tr.split($from.pos, 2, types).scrollIntoView();
        if (!marks || !dispatch) {
          return true;
        }
        var filteredMarks = marks.filter(function (mark) {
          return splittableMarks.includes(mark.type.name);
        });
        tr.ensureMarks(filteredMarks);
      }
      return true;
    };
  };
  var joinListBackwards = function (tr, listType) {
    var list = findParentNode(function (node) {
      return node.type === listType;
    })(tr.selection);
    if (!list) {
      return true;
    }
    var before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before === void 0) {
      return true;
    }
    var nodeBefore = tr.doc.nodeAt(before);
    var canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr.join(list.pos);
    return true;
  };
  var joinListForwards = function (tr, listType) {
    var list = findParentNode(function (node) {
      return node.type === listType;
    })(tr.selection);
    if (!list) {
      return true;
    }
    var after = tr.doc.resolve(list.start).after(list.depth);
    if (after === void 0) {
      return true;
    }
    var nodeAfter = tr.doc.nodeAt(after);
    var canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr.join(after);
    return true;
  };
  var toggleList = function (listTypeOrName, itemTypeOrName, keepMarks) {
    var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return function (_ref158) {
      var editor = _ref158.editor,
        tr = _ref158.tr,
        state = _ref158.state,
        dispatch = _ref158.dispatch,
        chain = _ref158.chain,
        commands2 = _ref158.commands,
        can = _ref158.can;
      var _editor$extensionMana = editor.extensionManager,
        extensions = _editor$extensionMana.extensions,
        splittableMarks = _editor$extensionMana.splittableMarks;
      var listType = getNodeType(listTypeOrName, state.schema);
      var itemType = getNodeType(itemTypeOrName, state.schema);
      var selection = state.selection,
        storedMarks = state.storedMarks;
      var $from = selection.$from,
        $to = selection.$to;
      var range = $from.blockRange($to);
      var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      if (!range) {
        return false;
      }
      var parentList = findParentNode(function (node) {
        return isList(node.type.name, extensions);
      })(selection);
      if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
        if (parentList.node.type === listType) {
          return commands2.liftListItem(itemType);
        }
        if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
          return chain().command(function () {
            tr.setNodeMarkup(parentList.pos, listType);
            return true;
          }).command(function () {
            return joinListBackwards(tr, listType);
          }).command(function () {
            return joinListForwards(tr, listType);
          }).run();
        }
      }
      if (!keepMarks || !marks || !dispatch) {
        return chain().command(function () {
          var canWrapInList = can().wrapInList(listType, attributes);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        }).wrapInList(listType, attributes).command(function () {
          return joinListBackwards(tr, listType);
        }).command(function () {
          return joinListForwards(tr, listType);
        }).run();
      }
      return chain().command(function () {
        var canWrapInList = can().wrapInList(listType, attributes);
        var filteredMarks = marks.filter(function (mark) {
          return splittableMarks.includes(mark.type.name);
        });
        tr.ensureMarks(filteredMarks);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(function () {
        return joinListBackwards(tr, listType);
      }).command(function () {
        return joinListForwards(tr, listType);
      }).run();
    };
  };
  var toggleMark = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return function (_ref159) {
      var state = _ref159.state,
        commands2 = _ref159.commands;
      var _options$extendEmptyM = options.extendEmptyMarkRange,
        extendEmptyMarkRange = _options$extendEmptyM === void 0 ? false : _options$extendEmptyM;
      var type = getMarkType(typeOrName, state.schema);
      var isActive2 = isMarkActive(state, type, attributes);
      if (isActive2) {
        return commands2.unsetMark(type, {
          extendEmptyMarkRange: extendEmptyMarkRange
        });
      }
      return commands2.setMark(type, attributes);
    };
  };
  var toggleNode = function (typeOrName, toggleTypeOrName) {
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return function (_ref160) {
      var state = _ref160.state,
        commands2 = _ref160.commands;
      var type = getNodeType(typeOrName, state.schema);
      var toggleType = getNodeType(toggleTypeOrName, state.schema);
      var isActive2 = isNodeActive(state, type, attributes);
      var attributesToCopy;
      if (state.selection.$anchor.sameParent(state.selection.$head)) {
        attributesToCopy = state.selection.$anchor.parent.attrs;
      }
      if (isActive2) {
        return commands2.setNode(toggleType, attributesToCopy);
      }
      return commands2.setNode(type, _objectSpread(_objectSpread({}, attributesToCopy), attributes));
    };
  };
  var toggleWrap = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref161) {
      var state = _ref161.state,
        commands2 = _ref161.commands;
      var type = getNodeType(typeOrName, state.schema);
      var isActive2 = isNodeActive(state, type, attributes);
      if (isActive2) {
        return commands2.lift(type);
      }
      return commands2.wrapIn(type, attributes);
    };
  };
  var undoInputRule = function () {
    return function (_ref162) {
      var state = _ref162.state,
        dispatch = _ref162.dispatch;
      var plugins = state.plugins;
      for (var _i249 = 0; _i249 < plugins.length; _i249 += 1) {
        var plugin = plugins[_i249];
        var undoable = void 0;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            var tr = state.tr;
            var toUndo = undoable.transform;
            for (var j = toUndo.steps.length - 1; j >= 0; j -= 1) {
              tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
            }
            if (undoable.text) {
              var marks = tr.doc.resolve(undoable.from).marks();
              tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
            } else {
              tr.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
  };
  var unsetAllMarks = function () {
    return function (_ref163) {
      var tr = _ref163.tr,
        dispatch = _ref163.dispatch;
      var selection = tr.selection;
      var empty2 = selection.empty,
        ranges = selection.ranges;
      if (empty2) {
        return true;
      }
      if (dispatch) {
        ranges.forEach(function (range) {
          tr.removeMark(range.$from.pos, range.$to.pos);
        });
      }
      return true;
    };
  };
  var unsetMark = function (typeOrName) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref164) {
      var tr = _ref164.tr,
        state = _ref164.state,
        dispatch = _ref164.dispatch;
      var _a2;
      var _options$extendEmptyM2 = options.extendEmptyMarkRange,
        extendEmptyMarkRange = _options$extendEmptyM2 === void 0 ? false : _options$extendEmptyM2;
      var selection = tr.selection;
      var type = getMarkType(typeOrName, state.schema);
      var $from = selection.$from,
        empty2 = selection.empty,
        ranges = selection.ranges;
      if (!dispatch) {
        return true;
      }
      if (empty2 && extendEmptyMarkRange) {
        var _from16 = selection.from,
          to = selection.to;
        var attrs = (_a2 = $from.marks().find(function (mark) {
          return mark.type === type;
        })) === null || _a2 === void 0 ? void 0 : _a2.attrs;
        var range = getMarkRange($from, type, attrs);
        if (range) {
          _from16 = range.from;
          to = range.to;
        }
        tr.removeMark(_from16, to, type);
      } else {
        ranges.forEach(function (range) {
          tr.removeMark(range.$from.pos, range.$to.pos, type);
        });
      }
      tr.removeStoredMark(type);
      return true;
    };
  };
  var updateAttributes = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref165) {
      var tr = _ref165.tr,
        state = _ref165.state,
        dispatch = _ref165.dispatch;
      var nodeType = null;
      var markType = null;
      var schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach(function (range) {
          var from2 = range.$from.pos;
          var to = range.$to.pos;
          state.doc.nodesBetween(from2, to, function (node, pos) {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, _objectSpread(_objectSpread({}, node.attrs), attributes));
            }
            if (markType && node.marks.length) {
              node.marks.forEach(function (mark) {
                if (markType === mark.type) {
                  var trimmedFrom = Math.max(pos, from2);
                  var trimmedTo = Math.min(pos + node.nodeSize, to);
                  tr.addMark(trimmedFrom, trimmedTo, markType.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));
                }
              });
            }
          });
        });
      }
      return true;
    };
  };
  var wrapIn = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref166) {
      var state = _ref166.state,
        dispatch = _ref166.dispatch;
      var type = getNodeType(typeOrName, state.schema);
      return wrapIn$1(type, attributes)(state, dispatch);
    };
  };
  var wrapInList = function (typeOrName) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (_ref167) {
      var state = _ref167.state,
        dispatch = _ref167.dispatch;
      var type = getNodeType(typeOrName, state.schema);
      return wrapInList$1(type, attributes)(state, dispatch);
    };
  };
  var commands = /* @__PURE__ */Object.freeze({
    __proto__: null,
    blur: blur,
    clearContent: clearContent,
    clearNodes: clearNodes,
    command: command,
    createParagraphNear: createParagraphNear,
    cut: cut,
    deleteCurrentNode: deleteCurrentNode,
    deleteNode: deleteNode,
    deleteRange: deleteRange,
    deleteSelection: deleteSelection,
    enter: enter,
    exitCode: exitCode,
    extendMarkRange: extendMarkRange,
    first: first,
    focus: focus,
    forEach: forEach,
    insertContent: insertContent,
    insertContentAt: insertContentAt,
    joinBackward: joinBackward,
    joinDown: joinDown,
    joinForward: joinForward,
    joinItemBackward: joinItemBackward,
    joinItemForward: joinItemForward,
    joinTextblockBackward: joinTextblockBackward,
    joinTextblockForward: joinTextblockForward,
    joinUp: joinUp,
    keyboardShortcut: keyboardShortcut,
    lift: lift,
    liftEmptyBlock: liftEmptyBlock,
    liftListItem: liftListItem,
    newlineInCode: newlineInCode,
    resetAttributes: resetAttributes,
    scrollIntoView: scrollIntoView,
    selectAll: selectAll,
    selectNodeBackward: selectNodeBackward,
    selectNodeForward: selectNodeForward,
    selectParentNode: selectParentNode,
    selectTextblockEnd: selectTextblockEnd,
    selectTextblockStart: selectTextblockStart,
    setContent: setContent,
    setMark: setMark,
    setMeta: setMeta,
    setNode: setNode,
    setNodeSelection: setNodeSelection,
    setTextSelection: setTextSelection,
    sinkListItem: sinkListItem,
    splitBlock: splitBlock,
    splitListItem: splitListItem,
    toggleList: toggleList,
    toggleMark: toggleMark,
    toggleNode: toggleNode,
    toggleWrap: toggleWrap,
    undoInputRule: undoInputRule,
    unsetAllMarks: unsetAllMarks,
    unsetMark: unsetMark,
    updateAttributes: updateAttributes,
    wrapIn: wrapIn,
    wrapInList: wrapInList
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands: function () {
      return _objectSpread({}, commands);
    }
  });
  var Drop = Extension.create({
    name: "drop",
    addProseMirrorPlugins: function () {
      var _this55 = this;
      return [new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: function (_, e, slice2, moved) {
            _this55.editor.emit("drop", {
              editor: _this55.editor,
              event: e,
              slice: slice2,
              moved: moved
            });
          }
        }
      })];
    }
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins: function () {
      var _this56 = this;
      return [new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: function () {
            return _this56.editor.options.editable;
          }
        }
      })];
    }
  });
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins: function () {
      var editor = this.editor;
      return [new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: function (view, event) {
              editor.isFocused = true;
              var transaction = editor.state.tr.setMeta("focus", {
                event: event
              }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: function (view, event) {
              editor.isFocused = false;
              var transaction = editor.state.tr.setMeta("blur", {
                event: event
              }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })];
    }
  });
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts: function () {
      var _this57 = this;
      var handleBackspace = function () {
        return _this57.editor.commands.first(function (_ref168) {
          var commands2 = _ref168.commands;
          return [function () {
            return commands2.undoInputRule();
          }, function () {
            return commands2.command(function (_ref169) {
              var tr = _ref169.tr;
              var selection = tr.selection,
                doc2 = tr.doc;
              var empty2 = selection.empty,
                $anchor = selection.$anchor;
              var pos = $anchor.pos,
                parent = $anchor.parent;
              var $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
              var parentIsIsolating = $parentPos.parent.type.spec.isolating;
              var parentPos = $anchor.pos - $anchor.parentOffset;
              var isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
              if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
                return false;
              }
              return commands2.clearNodes();
            });
          }, function () {
            return commands2.deleteSelection();
          }, function () {
            return commands2.joinBackward();
          }, function () {
            return commands2.selectNodeBackward();
          }];
        });
      };
      var handleDelete = function () {
        return _this57.editor.commands.first(function (_ref170) {
          var commands2 = _ref170.commands;
          return [function () {
            return commands2.deleteSelection();
          }, function () {
            return commands2.deleteCurrentNode();
          }, function () {
            return commands2.joinForward();
          }, function () {
            return commands2.selectNodeForward();
          }];
        });
      };
      var handleEnter = function () {
        return _this57.editor.commands.first(function (_ref171) {
          var commands2 = _ref171.commands;
          return [function () {
            return commands2.newlineInCode();
          }, function () {
            return commands2.createParagraphNear();
          }, function () {
            return commands2.liftEmptyBlock();
          }, function () {
            return commands2.splitBlock();
          }];
        });
      };
      var baseKeymap = {
        Enter: handleEnter,
        "Mod-Enter": function () {
          return _this57.editor.commands.exitCode();
        },
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete,
        "Mod-Delete": handleDelete,
        "Mod-a": function () {
          return _this57.editor.commands.selectAll();
        }
      };
      var pcKeymap = _objectSpread({}, baseKeymap);
      var macKeymap = _objectSpread(_objectSpread({}, baseKeymap), {}, {
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete,
        "Ctrl-Alt-Backspace": handleDelete,
        "Alt-Delete": handleDelete,
        "Alt-d": handleDelete,
        "Ctrl-a": function () {
          return _this57.editor.commands.selectTextblockStart();
        },
        "Ctrl-e": function () {
          return _this57.editor.commands.selectTextblockEnd();
        }
      });
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins: function () {
      var _this58 = this;
      return [new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: function (transactions, oldState, newState) {
          var docChanges = transactions.some(function (transaction) {
            return transaction.docChanged;
          }) && !oldState.doc.eq(newState.doc);
          var ignoreTr = transactions.some(function (transaction) {
            return transaction.getMeta("preventClearDocument");
          });
          if (!docChanges || ignoreTr) {
            return;
          }
          var _oldState$selection = oldState.selection,
            empty2 = _oldState$selection.empty,
            from2 = _oldState$selection.from,
            to = _oldState$selection.to;
          var allFrom = Selection.atStart(oldState.doc).from;
          var allEnd = Selection.atEnd(oldState.doc).to;
          var allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          var isEmpty2 = isNodeEmpty(newState.doc);
          if (!isEmpty2) {
            return;
          }
          var tr = newState.tr;
          var state = createChainableState({
            state: newState,
            transaction: tr
          });
          var _CommandManager3 = new CommandManager({
              editor: _this58.editor,
              state: state
            }),
            commands2 = _CommandManager3.commands;
          commands2.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })];
    }
  });
  var Paste = Extension.create({
    name: "paste",
    addProseMirrorPlugins: function () {
      var _this59 = this;
      return [new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: function (_view, e, slice2) {
            _this59.editor.emit("paste", {
              editor: _this59.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })];
    }
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins: function () {
      var _this60 = this;
      return [new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: function () {
            return _this60.editor.isEditable ? {
              tabindex: "0"
            } : {};
          }
        }
      })];
    }
  });
  var NodePos = /*#__PURE__*/function () {
    function NodePos(pos, editor) {
      var isBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var node = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      this.currentNode = null;
      this.actualDepth = null;
      this.isBlock = isBlock;
      this.resolvedPos = pos;
      this.editor = editor;
      this.currentNode = node;
    }
    var _proto71 = NodePos.prototype;
    _proto71.closest = function closest(selector) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var node = null;
      var currentNode = this.parent;
      while (currentNode && !node) {
        if (currentNode.node.type.name === selector) {
          if (Object.keys(attributes).length > 0) {
            var nodeAttributes = currentNode.node.attrs;
            var attrKeys = Object.keys(attributes);
            for (var index = 0; index < attrKeys.length; index += 1) {
              var key = attrKeys[index];
              if (nodeAttributes[key] !== attributes[key]) {
                break;
              }
            }
          } else {
            node = currentNode;
          }
        }
        currentNode = currentNode.parent;
      }
      return node;
    };
    _proto71.querySelector = function querySelector(selector) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.querySelectorAll(selector, attributes, true)[0] || null;
    };
    _proto71.querySelectorAll = function querySelectorAll(selector) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var firstItemOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var nodes = [];
      if (!this.children || this.children.length === 0) {
        return nodes;
      }
      var attrKeys = Object.keys(attributes);
      this.children.forEach(function (childPos) {
        if (firstItemOnly && nodes.length > 0) {
          return;
        }
        if (childPos.node.type.name === selector) {
          var doesAllAttributesMatch = attrKeys.every(function (key) {
            return attributes[key] === childPos.node.attrs[key];
          });
          if (doesAllAttributesMatch) {
            nodes.push(childPos);
          }
        }
        if (firstItemOnly && nodes.length > 0) {
          return;
        }
        nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
      });
      return nodes;
    };
    _proto71.setAttribute = function setAttribute(attributes) {
      var oldSelection = this.editor.state.selection;
      this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();
    };
    return _createClass(NodePos, [{
      key: "name",
      get: function () {
        return this.node.type.name;
      }
    }, {
      key: "node",
      get: function () {
        return this.currentNode || this.resolvedPos.node();
      }
    }, {
      key: "element",
      get: function () {
        return this.editor.view.domAtPos(this.pos).node;
      }
    }, {
      key: "depth",
      get: function () {
        var _a2;
        return (_a2 = this.actualDepth) !== null && _a2 !== void 0 ? _a2 : this.resolvedPos.depth;
      }
    }, {
      key: "pos",
      get: function () {
        return this.resolvedPos.pos;
      }
    }, {
      key: "content",
      get: function () {
        return this.node.content;
      },
      set: function (content) {
        var from2 = this.from;
        var to = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error("You can\u2019t set content on a block node. Tried to set content on " + this.name + " at " + this.pos);
            return;
          }
          from2 = this.from + 1;
          to = this.to - 1;
        }
        this.editor.commands.insertContentAt({
          from: from2,
          to: to
        }, content);
      }
    }, {
      key: "attributes",
      get: function () {
        return this.node.attrs;
      }
    }, {
      key: "textContent",
      get: function () {
        return this.node.textContent;
      }
    }, {
      key: "size",
      get: function () {
        return this.node.nodeSize;
      }
    }, {
      key: "from",
      get: function () {
        if (this.isBlock) {
          return this.pos;
        }
        return this.resolvedPos.start(this.resolvedPos.depth);
      }
    }, {
      key: "range",
      get: function () {
        return {
          from: this.from,
          to: this.to
        };
      }
    }, {
      key: "to",
      get: function () {
        if (this.isBlock) {
          return this.pos + this.size;
        }
        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
    }, {
      key: "parent",
      get: function () {
        if (this.depth === 0) {
          return null;
        }
        var parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
        var $pos = this.resolvedPos.doc.resolve(parentPos);
        return new NodePos($pos, this.editor);
      }
    }, {
      key: "before",
      get: function () {
        var $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.from - 3);
        }
        return new NodePos($pos, this.editor);
      }
    }, {
      key: "after",
      get: function () {
        var $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.to + 3);
        }
        return new NodePos($pos, this.editor);
      }
    }, {
      key: "children",
      get: function () {
        var _this61 = this;
        var children = [];
        this.node.content.forEach(function (node, offset) {
          var isBlock = node.isBlock && !node.isTextblock;
          var targetPos = _this61.pos + offset + 1;
          var $pos = _this61.resolvedPos.doc.resolve(targetPos);
          if (!isBlock && $pos.depth <= _this61.depth) {
            return;
          }
          var childNodePos = new NodePos($pos, _this61.editor, isBlock, isBlock ? node : null);
          if (isBlock) {
            childNodePos.actualDepth = _this61.depth + 1;
          }
          children.push(new NodePos($pos, _this61.editor, isBlock, isBlock ? node : null));
        });
        return children;
      }
    }, {
      key: "firstChild",
      get: function () {
        return this.children[0] || null;
      }
    }, {
      key: "lastChild",
      get: function () {
        var children = this.children;
        return children[children.length - 1] || null;
      }
    }]);
  }();
  var style = ".ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}";
  function createStyleTag(style2, nonce, suffix) {
    var tiptapStyleTag = document.querySelector("style[data-tiptap-style" + (suffix ? "-" + suffix : "") + "]");
    if (tiptapStyleTag !== null) {
      return tiptapStyleTag;
    }
    var styleNode = document.createElement("style");
    if (nonce) {
      styleNode.setAttribute("nonce", nonce);
    }
    styleNode.setAttribute("data-tiptap-style" + (suffix ? "-" + suffix : ""), "");
    styleNode.innerHTML = style2;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  var Editor$1 = /*#__PURE__*/function (_EventEmitter) {
    function Editor$1() {
      var _this62;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _this62 = _EventEmitter.call(this) || this;
      _this62.isFocused = false;
      _this62.isInitialized = false;
      _this62.extensionStorage = {};
      _this62.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        injectNonce: void 0,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        enableContentCheck: false,
        onBeforeCreate: function () {
          return null;
        },
        onCreate: function () {
          return null;
        },
        onUpdate: function () {
          return null;
        },
        onSelectionUpdate: function () {
          return null;
        },
        onTransaction: function () {
          return null;
        },
        onFocus: function () {
          return null;
        },
        onBlur: function () {
          return null;
        },
        onDestroy: function () {
          return null;
        },
        onContentError: function (_ref172) {
          var error = _ref172.error;
          throw error;
        },
        onPaste: function () {
          return null;
        },
        onDrop: function () {
          return null;
        }
      };
      _this62.isCapturingTransaction = false;
      _this62.capturedTransaction = null;
      _this62.setOptions(options);
      _this62.createExtensionManager();
      _this62.createCommandManager();
      _this62.createSchema();
      _this62.on("beforeCreate", _this62.options.onBeforeCreate);
      _this62.emit("beforeCreate", {
        editor: _this62
      });
      _this62.on("contentError", _this62.options.onContentError);
      _this62.createView();
      _this62.injectCSS();
      _this62.on("create", _this62.options.onCreate);
      _this62.on("update", _this62.options.onUpdate);
      _this62.on("selectionUpdate", _this62.options.onSelectionUpdate);
      _this62.on("transaction", _this62.options.onTransaction);
      _this62.on("focus", _this62.options.onFocus);
      _this62.on("blur", _this62.options.onBlur);
      _this62.on("destroy", _this62.options.onDestroy);
      _this62.on("drop", function (_ref173) {
        var event = _ref173.event,
          slice2 = _ref173.slice,
          moved = _ref173.moved;
        return _this62.options.onDrop(event, slice2, moved);
      });
      _this62.on("paste", function (_ref174) {
        var event = _ref174.event,
          slice2 = _ref174.slice;
        return _this62.options.onPaste(event, slice2);
      });
      window.setTimeout(function () {
        if (_this62.isDestroyed) {
          return;
        }
        _this62.commands.focus(_this62.options.autofocus);
        _this62.emit("create", {
          editor: _this62
        });
        _this62.isInitialized = true;
      }, 0);
      return _this62;
    }
    _inheritsLoose(Editor$1, _EventEmitter);
    var _proto72 = Editor$1.prototype;
    _proto72.chain = function chain() {
      return this.commandManager.chain();
    };
    _proto72.can = function can() {
      return this.commandManager.can();
    };
    _proto72.injectCSS = function injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style, this.options.injectNonce);
      }
    };
    _proto72.setOptions = function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = _objectSpread(_objectSpread({}, this.options), options);
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    };
    _proto72.setEditable = function setEditable(editable) {
      var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.setOptions({
        editable: editable
      });
      if (emitUpdate) {
        this.emit("update", {
          editor: this,
          transaction: this.state.tr
        });
      }
    };
    _proto72.registerPlugin = function registerPlugin(plugin, handlePlugins) {
      var plugins = isFunction(handlePlugins) ? handlePlugins(plugin, _toConsumableArray(this.state.plugins)) : [].concat(_toConsumableArray(this.state.plugins), [plugin]);
      var state = this.state.reconfigure({
        plugins: plugins
      });
      this.view.updateState(state);
      return state;
    };
    _proto72.unregisterPlugin = function unregisterPlugin(nameOrPluginKey) {
      if (this.isDestroyed) {
        return void 0;
      }
      var name = typeof nameOrPluginKey === "string" ? nameOrPluginKey + "$" : nameOrPluginKey.key;
      var state = this.state.reconfigure({
        plugins: this.state.plugins.filter(function (plugin) {
          return !plugin.key.startsWith(name);
        })
      });
      this.view.updateState(state);
      return state;
    };
    _proto72.createExtensionManager = function createExtensionManager() {
      var _this63 = this;
      var _a2, _b;
      var coreExtensions = this.options.enableCoreExtensions ? [Editable, ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a2 = this.options.coreExtensionOptions) === null || _a2 === void 0 ? void 0 : _a2.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
      }), Commands, FocusEvents, Keymap, Tabindex, Drop, Paste].filter(function (ext) {
        if (_typeof(_this63.options.enableCoreExtensions) === "object") {
          return _this63.options.enableCoreExtensions[ext.name] !== false;
        }
        return true;
      }) : [];
      var allExtensions = [].concat(_toConsumableArray(coreExtensions), _toConsumableArray(this.options.extensions)).filter(function (extension) {
        return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    };
    _proto72.createCommandManager = function createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    };
    _proto72.createSchema = function createSchema() {
      this.schema = this.extensionManager.schema;
    };
    _proto72.createView = function createView() {
      var _this64 = this;
      var doc2;
      try {
        doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: this.options.enableContentCheck
        });
      } catch (e) {
        if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
          throw e;
        }
        this.emit("contentError", {
          editor: this,
          error: e,
          disableCollaboration: function () {
            _this64.options.extensions = _this64.options.extensions.filter(function (extension) {
              return extension.name !== "collaboration";
            });
            _this64.createExtensionManager();
          }
        });
        doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
          errorOnInvalidContent: false
        });
      }
      var selection = resolveFocusPosition(doc2, this.options.autofocus);
      this.view = new EditorView(this.options.element, _objectSpread(_objectSpread({}, this.options.editorProps), {}, {
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: EditorState.create({
          doc: doc2,
          selection: selection || void 0
        })
      }));
      var newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      this.prependClass();
      var dom = this.view.dom;
      dom.editor = this;
    };
    _proto72.createNodeViews = function createNodeViews() {
      if (this.view.isDestroyed) {
        return;
      }
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    };
    _proto72.prependClass = function prependClass() {
      this.view.dom.className = "tiptap " + this.view.dom.className;
    };
    _proto72.captureTransaction = function captureTransaction(fn) {
      this.isCapturingTransaction = true;
      fn();
      this.isCapturingTransaction = false;
      var tr = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr;
    };
    _proto72.dispatchTransaction = function dispatchTransaction(transaction) {
      var _this65 = this;
      if (this.view.isDestroyed) {
        return;
      }
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach(function (step) {
          var _a2;
          return (_a2 = _this65.capturedTransaction) === null || _a2 === void 0 ? void 0 : _a2.step(step);
        });
        return;
      }
      var state = this.state.apply(transaction);
      var selectionHasChanged = !this.state.selection.eq(state.selection);
      this.emit("beforeTransaction", {
        editor: this,
        transaction: transaction,
        nextState: state
      });
      this.view.updateState(state);
      this.emit("transaction", {
        editor: this,
        transaction: transaction
      });
      if (selectionHasChanged) {
        this.emit("selectionUpdate", {
          editor: this,
          transaction: transaction
        });
      }
      var focus2 = transaction.getMeta("focus");
      var blur2 = transaction.getMeta("blur");
      if (focus2) {
        this.emit("focus", {
          editor: this,
          event: focus2.event,
          transaction: transaction
        });
      }
      if (blur2) {
        this.emit("blur", {
          editor: this,
          event: blur2.event,
          transaction: transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
        return;
      }
      this.emit("update", {
        editor: this,
        transaction: transaction
      });
    };
    _proto72.getAttributes = function getAttributes(nameOrType) {
      return _getAttributes(this.state, nameOrType);
    };
    _proto72.isActive = function isActive(nameOrAttributes, attributesOrUndefined) {
      var name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
      var attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
      return _isActive(this.state, name, attributes);
    };
    _proto72.getJSON = function getJSON() {
      return this.state.doc.toJSON();
    };
    _proto72.getHTML = function getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    };
    _proto72.getText = function getText(options) {
      var _ref175 = options || {},
        _ref175$blockSeparato = _ref175.blockSeparator,
        blockSeparator = _ref175$blockSeparato === void 0 ? "\n\n" : _ref175$blockSeparato,
        _ref175$textSerialize = _ref175.textSerializers,
        textSerializers = _ref175$textSerialize === void 0 ? {} : _ref175$textSerialize;
      return _getText(this.state.doc, {
        blockSeparator: blockSeparator,
        textSerializers: _objectSpread(_objectSpread({}, getTextSerializersFromSchema(this.schema)), textSerializers)
      });
    };
    _proto72.getCharacterCount = function getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    };
    _proto72.destroy = function destroy() {
      this.emit("destroy");
      if (this.view) {
        var dom = this.view.dom;
        if (dom && dom.editor) {
          delete dom.editor;
        }
        this.view.destroy();
      }
      this.removeAllListeners();
    };
    _proto72.$node = function $node(selector, attributes) {
      var _a2;
      return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector, attributes)) || null;
    };
    _proto72.$nodes = function $nodes(selector, attributes) {
      var _a2;
      return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(selector, attributes)) || null;
    };
    _proto72.$pos = function $pos(pos) {
      var $pos = this.state.doc.resolve(pos);
      return new NodePos($pos, this);
    };
    return _createClass(Editor$1, [{
      key: "storage",
      get: function () {
        return this.extensionStorage;
      }
    }, {
      key: "commands",
      get: function () {
        return this.commandManager.commands;
      }
    }, {
      key: "isEditable",
      get: function () {
        return this.options.editable && this.view && this.view.editable;
      }
    }, {
      key: "state",
      get: function () {
        return this.view.state;
      }
    }, {
      key: "isEmpty",
      get: function () {
        return isNodeEmpty(this.state.doc);
      }
    }, {
      key: "isDestroyed",
      get: function () {
        var _a2;
        return !((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.docView);
      }
    }, {
      key: "$doc",
      get: function () {
        return this.$pos(0);
      }
    }]);
  }(EventEmitter);
  function markInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: function (_ref176) {
        var state = _ref176.state,
          range = _ref176.range,
          match = _ref176.match;
        var attributes = callOrReturn(config2.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        var tr = state.tr;
        var captureGroup = match[match.length - 1];
        var fullMatch = match[0];
        if (captureGroup) {
          var startSpaces = fullMatch.search(/\S/);
          var textStart = range.from + fullMatch.indexOf(captureGroup);
          var textEnd = textStart + captureGroup.length;
          var excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(function (item) {
            var excluded = item.mark.type.excluded;
            return excluded.find(function (type) {
              return type === config2.type && type !== item.mark.type;
            });
          }).filter(function (item) {
            return item.to > textStart;
          });
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          var markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config2.type.create(attributes || {}));
          tr.removeStoredMark(config2.type);
        }
      }
    });
  }
  function nodeInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: function (_ref177) {
        var state = _ref177.state,
          range = _ref177.range,
          match = _ref177.match;
        var attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        var tr = state.tr;
        var start = range.from;
        var end = range.to;
        var newNode = config2.type.create(attributes);
        if (match[1]) {
          var offset = match[0].lastIndexOf(match[1]);
          var matchStart = start + offset;
          if (matchStart > end) {
            matchStart = end;
          } else {
            end = matchStart + match[1].length;
          }
          var lastChar = match[0][match[0].length - 1];
          tr.insertText(lastChar, start + match[0].length - 1);
          tr.replaceWith(matchStart, end, newNode);
        } else if (match[0]) {
          var insertionStart = config2.type.isInline ? start : start - 1;
          tr.insert(insertionStart, config2.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));
        }
        tr.scrollIntoView();
      }
    });
  }
  function textblockTypeInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: function (_ref178) {
        var state = _ref178.state,
          range = _ref178.range,
          match = _ref178.match;
        var $start = state.doc.resolve(range.from);
        var attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config2.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config2.type, attributes);
      }
    });
  }
  function wrappingInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: function (_ref179) {
        var state = _ref179.state,
          range = _ref179.range,
          match = _ref179.match,
          chain = _ref179.chain;
        var attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        var tr = state.tr.delete(range.from, range.to);
        var $start = tr.doc.resolve(range.from);
        var blockRange = $start.blockRange();
        var wrapping = blockRange && findWrapping(blockRange, config2.type, attributes);
        if (!wrapping) {
          return null;
        }
        tr.wrap(blockRange, wrapping);
        if (config2.keepMarks && config2.editor) {
          var selection = state.selection,
            storedMarks = state.storedMarks;
          var splittableMarks = config2.editor.extensionManager.splittableMarks;
          var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          if (marks) {
            var filteredMarks = marks.filter(function (mark) {
              return splittableMarks.includes(mark.type.name);
            });
            tr.ensureMarks(filteredMarks);
          }
        }
        if (config2.keepAttributes) {
          var nodeType = config2.type.name === "bulletList" || config2.type.name === "orderedList" ? "listItem" : "taskList";
          chain().updateAttributes(nodeType, attributes).run();
        }
        var before = tr.doc.resolve(range.from - 1).nodeBefore;
        if (before && before.type === config2.type && canJoin(tr.doc, range.from - 1) && (!config2.joinPredicate || config2.joinPredicate(match, before))) {
          tr.join(range.from - 1);
        }
      }
    });
  }
  var Node$1 = /*#__PURE__*/function () {
    function Node$1() {
      var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = _objectSpread(_objectSpread({}, this.config), config2);
      this.name = this.config.name;
      if (config2.defaultOptions && Object.keys(config2.defaultOptions).length > 0) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"" + this.name + "\".");
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    Node$1.create = function create() {
      var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Node$1(config2);
    };
    var _proto73 = Node$1.prototype;
    _proto73.configure = function configure() {
      var _this66 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = this.extend(_objectSpread(_objectSpread({}, this.config), {}, {
        addOptions: function () {
          return mergeDeep$1(_this66.options, options);
        }
      }));
      extension.name = this.name;
      extension.parent = this.parent;
      return extension;
    };
    _proto73.extend = function extend() {
      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = new Node$1(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"" + extension.name + "\".");
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    };
    return Node$1;
  }();
  function markPasteRule(config2) {
    return new PasteRule({
      find: config2.find,
      handler: function (_ref180) {
        var state = _ref180.state,
          range = _ref180.range,
          match = _ref180.match,
          pasteEvent = _ref180.pasteEvent;
        var attributes = callOrReturn(config2.getAttributes, void 0, match, pasteEvent);
        if (attributes === false || attributes === null) {
          return null;
        }
        var tr = state.tr;
        var captureGroup = match[match.length - 1];
        var fullMatch = match[0];
        var markEnd = range.to;
        if (captureGroup) {
          var startSpaces = fullMatch.search(/\S/);
          var textStart = range.from + fullMatch.indexOf(captureGroup);
          var textEnd = textStart + captureGroup.length;
          var excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(function (item) {
            var excluded = item.mark.type.excluded;
            return excluded.find(function (type) {
              return type === config2.type && type !== item.mark.type;
            });
          }).filter(function (item) {
            return item.to > textStart;
          });
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config2.type.create(attributes || {}));
          tr.removeStoredMark(config2.type);
        }
      }
    });
  }
  function useDebouncedRef(value) {
    return customRef(function (track2, trigger2) {
      return {
        get: function () {
          track2();
          return value;
        },
        set: function (newValue) {
          value = newValue;
          requestAnimationFrame(function () {
            requestAnimationFrame(function () {
              trigger2();
            });
          });
        }
      };
    });
  }
  var Editor = /*#__PURE__*/function (_Editor$) {
    function Editor() {
      var _this67;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _this67 = _Editor$.call(this, options) || this;
      _this67.contentComponent = null;
      _this67.appContext = null;
      _this67.reactiveState = useDebouncedRef(_this67.view.state);
      _this67.reactiveExtensionStorage = useDebouncedRef(_this67.extensionStorage);
      _this67.on("beforeTransaction", function (_ref181) {
        var nextState = _ref181.nextState;
        _this67.reactiveState.value = nextState;
        _this67.reactiveExtensionStorage.value = _this67.extensionStorage;
      });
      return markRaw(_this67) || _assertThisInitialized(_this67);
    }
    _inheritsLoose(Editor, _Editor$);
    var _proto74 = Editor.prototype;
    _proto74.registerPlugin = function registerPlugin(plugin, handlePlugins) {
      var nextState = _Editor$.prototype.registerPlugin.call(this, plugin, handlePlugins);
      if (this.reactiveState) {
        this.reactiveState.value = nextState;
      }
      return nextState;
    };
    _proto74.unregisterPlugin = function unregisterPlugin(nameOrPluginKey) {
      var nextState = _Editor$.prototype.unregisterPlugin.call(this, nameOrPluginKey);
      if (this.reactiveState && nextState) {
        this.reactiveState.value = nextState;
      }
      return nextState;
    };
    return _createClass(Editor, [{
      key: "state",
      get: function () {
        return this.reactiveState ? this.reactiveState.value : this.view.state;
      }
    }, {
      key: "storage",
      get: function () {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : _Editor$.prototype.storage;
      }
    }]);
  }(Editor$1);
  var EditorContent = defineComponent$1({
    name: "EditorContent",
    props: {
      editor: {
        "default": null,
        type: Object
      }
    },
    setup: function (props) {
      var rootEl = ref();
      var instance = getCurrentInstance$1();
      watchEffect(function () {
        var editor = props.editor;
        if (editor && editor.options.element && rootEl.value) {
          nextTick(function () {
            var _rootEl$value;
            if (!rootEl.value || !editor.options.element.firstChild) {
              return;
            }
            var element = unref(rootEl.value);
            (_rootEl$value = rootEl.value).append.apply(_rootEl$value, _toConsumableArray(editor.options.element.childNodes));
            editor.contentComponent = instance.ctx._;
            if (instance) {
              editor.appContext = _objectSpread(_objectSpread({}, instance.appContext), {}, {
                provides: instance.provides
              });
            }
            editor.setOptions({
              element: element
            });
            editor.createNodeViews();
          });
        }
      });
      onBeforeUnmount(function () {
        var editor = props.editor;
        if (!editor) {
          return;
        }
        if (!editor.isDestroyed) {
          editor.view.setProps({
            nodeViews: {}
          });
        }
        editor.contentComponent = null;
        editor.appContext = null;
        if (!editor.options.element.firstChild) {
          return;
        }
        var newElement = document.createElement("div");
        newElement.append.apply(newElement, _toConsumableArray(editor.options.element.childNodes));
        editor.setOptions({
          element: newElement
        });
      });
      return {
        rootEl: rootEl
      };
    },
    render: function () {
      var _this68 = this;
      return h("div", {
        ref: function (el) {
          _this68.rootEl = el;
        }
      });
    }
  });
  var useEditor = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var editor = shallowRef();
    onMounted(function () {
      editor.value = new Editor(options);
    });
    onBeforeUnmount(function () {
      var _a2;
      (_a2 = editor.value) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    });
    return editor;
  };
  var inputRegex$4 = /^\s*>\s$/;
  var Blockquote = Node$1.create({
    name: "blockquote",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    group: "block",
    defining: true,
    parseHTML: function () {
      return [{
        tag: "blockquote"
      }];
    },
    renderHTML: function (_ref182) {
      var HTMLAttributes = _ref182.HTMLAttributes;
      return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this69 = this;
      return {
        setBlockquote: function () {
          return function (_ref183) {
            var commands2 = _ref183.commands;
            return commands2.wrapIn(_this69.name);
          };
        },
        toggleBlockquote: function () {
          return function (_ref184) {
            var commands2 = _ref184.commands;
            return commands2.toggleWrap(_this69.name);
          };
        },
        unsetBlockquote: function () {
          return function (_ref185) {
            var commands2 = _ref185.commands;
            return commands2.lift(_this69.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this70 = this;
      return {
        "Mod-Shift-b": function () {
          return _this70.editor.commands.toggleBlockquote();
        }
      };
    },
    addInputRules: function () {
      return [wrappingInputRule({
        find: inputRegex$4,
        type: this.type
      })];
    }
  });
  var starInputRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
  var starPasteRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
  var underscoreInputRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
  var underscorePasteRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
  var Bold = Mark.create({
    name: "bold",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML: function () {
      return [{
        tag: "strong"
      }, {
        tag: "b",
        getAttrs: function (node) {
          return node.style.fontWeight !== "normal" && null;
        }
      }, {
        style: "font-weight",
        getAttrs: function (value) {
          return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
        }
      }];
    },
    renderHTML: function (_ref186) {
      var HTMLAttributes = _ref186.HTMLAttributes;
      return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this71 = this;
      return {
        setBold: function () {
          return function (_ref187) {
            var commands2 = _ref187.commands;
            return commands2.setMark(_this71.name);
          };
        },
        toggleBold: function () {
          return function (_ref188) {
            var commands2 = _ref188.commands;
            return commands2.toggleMark(_this71.name);
          };
        },
        unsetBold: function () {
          return function (_ref189) {
            var commands2 = _ref189.commands;
            return commands2.unsetMark(_this71.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this72 = this;
      return {
        "Mod-b": function () {
          return _this72.editor.commands.toggleBold();
        },
        "Mod-B": function () {
          return _this72.editor.commands.toggleBold();
        }
      };
    },
    addInputRules: function () {
      return [markInputRule({
        find: starInputRegex$1,
        type: this.type
      }), markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })];
    },
    addPasteRules: function () {
      return [markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }), markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })];
    }
  });
  var ListItem = Node$1.create({
    name: "listItem",
    addOptions: function () {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML: function () {
      return [{
        tag: "li"
      }];
    },
    renderHTML: function (_ref190) {
      var HTMLAttributes = _ref190.HTMLAttributes;
      return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts: function () {
      var _this73 = this;
      return {
        Enter: function () {
          return _this73.editor.commands.splitListItem(_this73.name);
        },
        Tab: function () {
          return _this73.editor.commands.sinkListItem(_this73.name);
        },
        "Shift-Tab": function () {
          return _this73.editor.commands.liftListItem(_this73.name);
        }
      };
    }
  });
  var TextStyle = Mark.create({
    name: "textStyle",
    priority: 101,
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML: function () {
      return [{
        tag: "span",
        getAttrs: function (element) {
          var hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }];
    },
    renderHTML: function (_ref191) {
      var HTMLAttributes = _ref191.HTMLAttributes;
      return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this74 = this;
      return {
        removeEmptyTextStyle: function () {
          return function (_ref192) {
            var state = _ref192.state,
              commands2 = _ref192.commands;
            var attributes = getMarkAttributes(state, _this74.type);
            var hasStyles = Object.entries(attributes).some(function (_ref193) {
              var _ref194 = _slicedToArray(_ref193, 2),
                value = _ref194[1];
              return !!value;
            });
            if (hasStyles) {
              return true;
            }
            return commands2.unsetMark(_this74.name);
          };
        }
      };
    }
  });
  var inputRegex$3 = /^\s*([-+*])\s$/;
  var BulletList = Node$1.create({
    name: "bulletList",
    addOptions: function () {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content: function () {
      return this.options.itemTypeName + "+";
    },
    parseHTML: function () {
      return [{
        tag: "ul"
      }];
    },
    renderHTML: function (_ref195) {
      var HTMLAttributes = _ref195.HTMLAttributes;
      return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this75 = this;
      return {
        toggleBulletList: function () {
          return function (_ref196) {
            var commands2 = _ref196.commands,
              chain = _ref196.chain;
            if (_this75.options.keepAttributes) {
              return chain().toggleList(_this75.name, _this75.options.itemTypeName, _this75.options.keepMarks).updateAttributes(ListItem.name, _this75.editor.getAttributes(TextStyle.name)).run();
            }
            return commands2.toggleList(_this75.name, _this75.options.itemTypeName, _this75.options.keepMarks);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this76 = this;
      return {
        "Mod-Shift-8": function () {
          return _this76.editor.commands.toggleBulletList();
        }
      };
    },
    addInputRules: function () {
      var _this77 = this;
      var inputRule = wrappingInputRule({
        find: inputRegex$3,
        type: this.type
      });
      if (this.options.keepMarks || this.options.keepAttributes) {
        inputRule = wrappingInputRule({
          find: inputRegex$3,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: function () {
            return _this77.editor.getAttributes(TextStyle.name);
          },
          editor: this.editor
        });
      }
      return [inputRule];
    }
  });
  var inputRegex$2 = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/;
  var pasteRegex$1 = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g;
  var Code = Mark.create({
    name: "code",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    exitable: true,
    parseHTML: function () {
      return [{
        tag: "code"
      }];
    },
    renderHTML: function (_ref197) {
      var HTMLAttributes = _ref197.HTMLAttributes;
      return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this78 = this;
      return {
        setCode: function () {
          return function (_ref198) {
            var commands2 = _ref198.commands;
            return commands2.setMark(_this78.name);
          };
        },
        toggleCode: function () {
          return function (_ref199) {
            var commands2 = _ref199.commands;
            return commands2.toggleMark(_this78.name);
          };
        },
        unsetCode: function () {
          return function (_ref200) {
            var commands2 = _ref200.commands;
            return commands2.unsetMark(_this78.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this79 = this;
      return {
        "Mod-e": function () {
          return _this79.editor.commands.toggleCode();
        }
      };
    },
    addInputRules: function () {
      return [markInputRule({
        find: inputRegex$2,
        type: this.type
      })];
    },
    addPasteRules: function () {
      return [markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })];
    }
  });
  var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
  var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
  var CodeBlock = Node$1.create({
    name: "codeBlock",
    addOptions: function () {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: true,
        exitOnArrowDown: true,
        defaultLanguage: null,
        HTMLAttributes: {}
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    addAttributes: function () {
      var _this80 = this;
      return {
        language: {
          "default": this.options.defaultLanguage,
          parseHTML: function (element) {
            var _a2;
            var languageClassPrefix = _this80.options.languageClassPrefix;
            var classNames = _toConsumableArray(((_a2 = element.firstElementChild) === null || _a2 === void 0 ? void 0 : _a2.classList) || []);
            var languages = classNames.filter(function (className) {
              return className.startsWith(languageClassPrefix);
            }).map(function (className) {
              return className.replace(languageClassPrefix, "");
            });
            var language = languages[0];
            if (!language) {
              return null;
            }
            return language;
          },
          rendered: false
        }
      };
    },
    parseHTML: function () {
      return [{
        tag: "pre",
        preserveWhitespace: "full"
      }];
    },
    renderHTML: function (_ref201) {
      var node = _ref201.node,
        HTMLAttributes = _ref201.HTMLAttributes;
      return ["pre", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ["code", {
        "class": node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
      }, 0]];
    },
    addCommands: function () {
      var _this81 = this;
      return {
        setCodeBlock: function (attributes) {
          return function (_ref202) {
            var commands2 = _ref202.commands;
            return commands2.setNode(_this81.name, attributes);
          };
        },
        toggleCodeBlock: function (attributes) {
          return function (_ref203) {
            var commands2 = _ref203.commands;
            return commands2.toggleNode(_this81.name, "paragraph", attributes);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this82 = this;
      return {
        "Mod-Alt-c": function () {
          return _this82.editor.commands.toggleCodeBlock();
        },
        Backspace: function () {
          var _this82$editor$state$ = _this82.editor.state.selection,
            empty2 = _this82$editor$state$.empty,
            $anchor = _this82$editor$state$.$anchor;
          var isAtStart = $anchor.pos === 1;
          if (!empty2 || $anchor.parent.type.name !== _this82.name) {
            return false;
          }
          if (isAtStart || !$anchor.parent.textContent.length) {
            return _this82.editor.commands.clearNodes();
          }
          return false;
        },
        Enter: function (_ref204) {
          var editor = _ref204.editor;
          if (!_this82.options.exitOnTripleEnter) {
            return false;
          }
          var state = editor.state;
          var selection = state.selection;
          var $from = selection.$from,
            empty2 = selection.empty;
          if (!empty2 || $from.parent.type !== _this82.type) {
            return false;
          }
          var isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          var endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
          if (!isAtEnd || !endsWithDoubleNewline) {
            return false;
          }
          return editor.chain().command(function (_ref205) {
            var tr = _ref205.tr;
            tr.delete($from.pos - 2, $from.pos);
            return true;
          }).exitCode().run();
        },
        ArrowDown: function (_ref206) {
          var editor = _ref206.editor;
          if (!_this82.options.exitOnArrowDown) {
            return false;
          }
          var state = editor.state;
          var selection = state.selection,
            doc2 = state.doc;
          var $from = selection.$from,
            empty2 = selection.empty;
          if (!empty2 || $from.parent.type !== _this82.type) {
            return false;
          }
          var isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          if (!isAtEnd) {
            return false;
          }
          var after = $from.after();
          if (after === void 0) {
            return false;
          }
          var nodeAfter = doc2.nodeAt(after);
          if (nodeAfter) {
            return editor.commands.command(function (_ref207) {
              var tr = _ref207.tr;
              tr.setSelection(Selection.near(doc2.resolve(after)));
              return true;
            });
          }
          return editor.commands.exitCode();
        }
      };
    },
    addInputRules: function () {
      return [textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: function (match) {
          return {
            language: match[1]
          };
        }
      }), textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: function (match) {
          return {
            language: match[1]
          };
        }
      })];
    },
    addProseMirrorPlugins: function () {
      var _this83 = this;
      return [new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: function (view, event) {
            if (!event.clipboardData) {
              return false;
            }
            if (_this83.editor.isActive(_this83.type.name)) {
              return false;
            }
            var text = event.clipboardData.getData("text/plain");
            var vscode = event.clipboardData.getData("vscode-editor-data");
            var vscodeData = vscode ? JSON.parse(vscode) : void 0;
            var language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            var _view$state = view.state,
              tr = _view$state.tr,
              schema = _view$state.schema;
            var textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr.replaceSelectionWith(_this83.type.create({
              language: language
            }, textNode));
            if (tr.selection.$from.parent.type !== _this83.type) {
              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
            }
            tr.setMeta("paste", true);
            view.dispatch(tr);
            return true;
          }
        }
      })];
    }
  });
  var Document$1 = Node$1.create({
    name: "doc",
    topNode: true,
    content: "block+"
  });
  function dropCursor() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new Plugin({
      view: function (editorView) {
        return new DropCursorView(editorView, options);
      }
    });
  }
  var DropCursorView = /*#__PURE__*/function () {
    function DropCursorView(editorView, options) {
      var _this84 = this;
      var _a2;
      this.editorView = editorView;
      this.cursorPos = null;
      this.element = null;
      this.timeout = -1;
      this.width = (_a2 = options.width) !== null && _a2 !== void 0 ? _a2 : 1;
      this.color = options.color === false ? void 0 : options.color || "black";
      this.class = options.class;
      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
        var handler = function (e) {
          _this84[name](e);
        };
        editorView.dom.addEventListener(name, handler);
        return {
          name: name,
          handler: handler
        };
      });
    }
    var _proto75 = DropCursorView.prototype;
    _proto75.destroy = function destroy() {
      var _this85 = this;
      this.handlers.forEach(function (_ref208) {
        var name = _ref208.name,
          handler = _ref208.handler;
        return _this85.editorView.dom.removeEventListener(name, handler);
      });
    };
    _proto75.update = function update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null);else this.updateOverlay();
      }
    };
    _proto75.setCursor = function setCursor(pos) {
      if (pos == this.cursorPos) return;
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    };
    _proto75.updateOverlay = function updateOverlay() {
      var $pos = this.editorView.state.doc.resolve(this.cursorPos);
      var isBlock = !$pos.parent.inlineContent,
        rect;
      if (isBlock) {
        var before = $pos.nodeBefore,
          after = $pos.nodeAfter;
        if (before || after) {
          var node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
          if (node) {
            var nodeRect = node.getBoundingClientRect();
            var top = before ? nodeRect.bottom : nodeRect.top;
            if (before && after) top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
            rect = {
              left: nodeRect.left,
              right: nodeRect.right,
              top: top - this.width / 2,
              bottom: top + this.width / 2
            };
          }
        }
      }
      if (!rect) {
        var coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = {
          left: coords.left - this.width / 2,
          right: coords.left + this.width / 2,
          top: coords.top,
          bottom: coords.bottom
        };
      }
      var parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class) this.element.className = this.class;
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
        if (this.color) {
          this.element.style.backgroundColor = this.color;
        }
      }
      this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
      this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
      var parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        var rect2 = parent.getBoundingClientRect();
        parentLeft = rect2.left - parent.scrollLeft;
        parentTop = rect2.top - parent.scrollTop;
      }
      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    };
    _proto75.scheduleRemoval = function scheduleRemoval(timeout) {
      var _this86 = this;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        return _this86.setCursor(null);
      }, timeout);
    };
    _proto75.dragover = function dragover(event) {
      if (!this.editorView.editable) return;
      var pos = this.editorView.posAtCoords({
        left: event.clientX,
        top: event.clientY
      });
      var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      var disableDropCursor = node && node.type.spec.disableDropCursor;
      var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
      if (pos && !disabled) {
        var target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          var point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (point != null) target = point;
        }
        this.setCursor(target);
        this.scheduleRemoval(5e3);
      }
    };
    _proto75.dragend = function dragend() {
      this.scheduleRemoval(20);
    };
    _proto75.drop = function drop() {
      this.scheduleRemoval(20);
    };
    _proto75.dragleave = function dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) this.setCursor(null);
    };
    return DropCursorView;
  }();
  var Dropcursor = Extension.create({
    name: "dropCursor",
    addOptions: function () {
      return {
        color: "currentColor",
        width: 1,
        "class": void 0
      };
    },
    addProseMirrorPlugins: function () {
      return [dropCursor(this.options)];
    }
  });
  var GapCursor = /*#__PURE__*/function (_Selection4) {
    function GapCursor($pos) {
      return _Selection4.call(this, $pos, $pos) || this;
    }
    _inheritsLoose(GapCursor, _Selection4);
    var _proto76 = GapCursor.prototype;
    _proto76.map = function map(doc2, mapping) {
      var $pos = doc2.resolve(mapping.map(this.head));
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    };
    _proto76.content = function content() {
      return Slice.empty;
    };
    _proto76.eq = function eq(other) {
      return other instanceof GapCursor && other.head == this.head;
    };
    _proto76.toJSON = function toJSON() {
      return {
        type: "gapcursor",
        pos: this.head
      };
    };
    GapCursor.fromJSON = function fromJSON(doc2, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new GapCursor(doc2.resolve(json.pos));
    };
    _proto76.getBookmark = function getBookmark() {
      return new GapBookmark(this.anchor);
    };
    GapCursor.valid = function valid($pos) {
      var parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;
      var override = parent.type.spec.allowGapCursor;
      if (override != null) return override;
      var deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    };
    GapCursor.findGapCursorFrom = function findGapCursorFrom($pos, dir) {
      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      search: for (;;) {
        if (!mustMove && GapCursor.valid($pos)) return $pos;
        var pos = $pos.pos,
          next = null;
        for (var d = $pos.depth;; d--) {
          var parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          var $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur)) return $cur;
        }
        for (;;) {
          var inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          var _$cur = $pos.doc.resolve(pos);
          if (GapCursor.valid(_$cur)) return _$cur;
        }
        return null;
      }
    };
    return GapCursor;
  }(Selection);
  GapCursor.prototype.visible = false;
  GapCursor.findFrom = GapCursor.findGapCursorFrom;
  Selection.jsonID("gapcursor", GapCursor);
  var GapBookmark = /*#__PURE__*/function () {
    function GapBookmark(pos) {
      this.pos = pos;
    }
    var _proto77 = GapBookmark.prototype;
    _proto77.map = function map(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    };
    _proto77.resolve = function resolve(doc2) {
      var $pos = doc2.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    };
    return GapBookmark;
  }();
  function closedBefore($pos) {
    for (var d = $pos.depth; d >= 0; d--) {
      var index = $pos.index(d),
        parent = $pos.node(d);
      if (index == 0) {
        if (parent.type.spec.isolating) return true;
        continue;
      }
      for (var before = parent.child(index - 1);; before = before.lastChild) {
        if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;
        if (before.inlineContent) return false;
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (var d = $pos.depth; d >= 0; d--) {
      var index = $pos.indexAfter(d),
        parent = $pos.node(d);
      if (index == parent.childCount) {
        if (parent.type.spec.isolating) return true;
        continue;
      }
      for (var after = parent.child(index);; after = after.firstChild) {
        if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;
        if (after.inlineContent) return false;
      }
    }
    return true;
  }
  function gapCursor() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween: function (_view, $anchor, $head) {
          return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
        },
        handleClick: handleClick,
        handleKeyDown: handleKeyDown,
        handleDOMEvents: {
          beforeinput: beforeinput
        }
      }
    });
  }
  var handleKeyDown = keydownHandler({
    "ArrowLeft": arrow("horiz", -1),
    "ArrowRight": arrow("horiz", 1),
    "ArrowUp": arrow("vert", -1),
    "ArrowDown": arrow("vert", 1)
  });
  function arrow(axis, dir) {
    var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function (state, dispatch, view) {
      var sel = state.selection;
      var $start = dir > 0 ? sel.$to : sel.$from,
        mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
      if (!$found) return false;
      if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view || !view.editable) return false;
    var $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos)) return false;
    var clickPos = view.posAtCoords({
      left: event.clientX,
      top: event.clientY
    });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) return false;
    var $from = view.state.selection.$from;
    var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert) return false;
    var frag = Fragment.empty;
    for (var _i250 = insert.length - 1; _i250 >= 0; _i250--) frag = Fragment.from(insert[_i250].createAndFill(null, frag));
    var tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
    view.dispatch(tr);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor)) return null;
    var node = document.createElement("div");
    node.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {
      key: "gapcursor"
    })]);
  }
  var Gapcursor = Extension.create({
    name: "gapCursor",
    addProseMirrorPlugins: function () {
      return [gapCursor()];
    },
    extendNodeSchema: function (extension) {
      var _a2;
      var context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      return {
        allowGapCursor: (_a2 = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a2 !== void 0 ? _a2 : null
      };
    }
  });
  var HardBreak = Node$1.create({
    name: "hardBreak",
    addOptions: function () {
      return {
        keepMarks: true,
        HTMLAttributes: {}
      };
    },
    inline: true,
    group: "inline",
    selectable: false,
    parseHTML: function () {
      return [{
        tag: "br"
      }];
    },
    renderHTML: function (_ref209) {
      var HTMLAttributes = _ref209.HTMLAttributes;
      return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    renderText: function () {
      return "\n";
    },
    addCommands: function () {
      var _this87 = this;
      return {
        setHardBreak: function () {
          return function (_ref210) {
            var commands2 = _ref210.commands,
              chain = _ref210.chain,
              state = _ref210.state,
              editor = _ref210.editor;
            return commands2.first([function () {
              return commands2.exitCode();
            }, function () {
              return commands2.command(function () {
                var selection = state.selection,
                  storedMarks = state.storedMarks;
                if (selection.$from.parent.type.spec.isolating) {
                  return false;
                }
                var keepMarks = _this87.options.keepMarks;
                var splittableMarks = editor.extensionManager.splittableMarks;
                var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
                return chain().insertContent({
                  type: _this87.name
                }).command(function (_ref211) {
                  var tr = _ref211.tr,
                    dispatch = _ref211.dispatch;
                  if (dispatch && marks && keepMarks) {
                    var filteredMarks = marks.filter(function (mark) {
                      return splittableMarks.includes(mark.type.name);
                    });
                    tr.ensureMarks(filteredMarks);
                  }
                  return true;
                }).run();
              });
            }]);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this88 = this;
      return {
        "Mod-Enter": function () {
          return _this88.editor.commands.setHardBreak();
        },
        "Shift-Enter": function () {
          return _this88.editor.commands.setHardBreak();
        }
      };
    }
  });
  var Heading = Node$1.create({
    name: "heading",
    addOptions: function () {
      return {
        levels: [1, 2, 3, 4, 5, 6],
        HTMLAttributes: {}
      };
    },
    content: "inline*",
    group: "block",
    defining: true,
    addAttributes: function () {
      return {
        level: {
          "default": 1,
          rendered: false
        }
      };
    },
    parseHTML: function () {
      return this.options.levels.map(function (level) {
        return {
          tag: "h" + level,
          attrs: {
            level: level
          }
        };
      });
    },
    renderHTML: function (_ref212) {
      var node = _ref212.node,
        HTMLAttributes = _ref212.HTMLAttributes;
      var hasLevel = this.options.levels.includes(node.attrs.level);
      var level = hasLevel ? node.attrs.level : this.options.levels[0];
      return ["h" + level, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this89 = this;
      return {
        setHeading: function (attributes) {
          return function (_ref213) {
            var commands2 = _ref213.commands;
            if (!_this89.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.setNode(_this89.name, attributes);
          };
        },
        toggleHeading: function (attributes) {
          return function (_ref214) {
            var commands2 = _ref214.commands;
            if (!_this89.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.toggleNode(_this89.name, "paragraph", attributes);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this90 = this;
      return this.options.levels.reduce(function (items, level) {
        var _objectSpread3;
        return _objectSpread(_objectSpread({}, items), (_objectSpread3 = {}, _objectSpread3["Mod-Alt-" + level] = function () {
          return _this90.editor.commands.toggleHeading({
            level: level
          });
        }, _objectSpread3));
      }, {});
    },
    addInputRules: function () {
      var _this91 = this;
      return this.options.levels.map(function (level) {
        return textblockTypeInputRule({
          find: new RegExp("^(#{1," + level + "})\\s$"),
          type: _this91.type,
          getAttributes: {
            level: level
          }
        });
      });
    }
  });
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {};
  RopeSequence.prototype.append = function append(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice(from2, to) {
    if (from2 === void 0) from2 = 0;
    if (to === void 0) to = this.length;
    if (from2 >= to) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
  };
  RopeSequence.prototype.get = function get(i) {
    if (i < 0 || i >= this.length) {
      return void 0;
    }
    return this.getInner(i);
  };
  RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
    if (from2 === void 0) from2 = 0;
    if (to === void 0) to = this.length;
    if (from2 <= to) {
      this.forEachInner(f, from2, to, 0);
    } else {
      this.forEachInvertedInner(f, from2, to, 0);
    }
  };
  RopeSequence.prototype.map = function map2(f, from2, to) {
    if (from2 === void 0) from2 = 0;
    if (to === void 0) to = this.length;
    var result = [];
    this.forEach(function (elt, i) {
      return result.push(f(elt, i));
    }, from2, to);
    return result;
  };
  RopeSequence.from = function from(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */function (RopeSequence3) {
    function Leaf2(values) {
      RopeSequence3.call(this);
      this.values = values;
    }
    if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
    Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Leaf2.prototype.constructor = Leaf2;
    var prototypeAccessors = {
      length: {
        configurable: true
      },
      depth: {
        configurable: true
      }
    };
    Leaf2.prototype.flatten = function flatten() {
      return this.values;
    };
    Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      return new Leaf2(this.values.slice(from2, to));
    };
    Leaf2.prototype.getInner = function getInner(i) {
      return this.values[i];
    };
    Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
      for (var i = from2; i < to; i++) {
        if (f(this.values[i], start + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
      for (var i = from2 - 1; i >= to; i--) {
        if (f(this.values[i], start + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(this.values.concat(other.flatten()));
      }
    };
    Leaf2.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors.length.get = function () {
      return this.values.length;
    };
    prototypeAccessors.depth.get = function () {
      return 0;
    };
    Object.defineProperties(Leaf2.prototype, prototypeAccessors);
    return Leaf2;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */function (RopeSequence3) {
    function Append2(left, right) {
      RopeSequence3.call(this);
      this.left = left;
      this.right = right;
      this.length = left.length + right.length;
      this.depth = Math.max(left.depth, right.depth) + 1;
    }
    if (RopeSequence3) Append2.__proto__ = RopeSequence3;
    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i) {
      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
      var leftLen = this.left.length;
      if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
        return false;
      }
      if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
      var leftLen = this.left.length;
      if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
        return false;
      }
      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to <= leftLen) {
        return this.left.slice(from2, to);
      }
      if (from2 >= leftLen) {
        return this.right.slice(from2 - leftLen, to - leftLen);
      }
      return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner2(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  var max_empty_items = 500;
  var Branch = /*#__PURE__*/function () {
    function Branch(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    }
    var _proto78 = Branch.prototype;
    _proto78.popEvent = function popEvent(state, preserveItems) {
      var _this92 = this;
      if (this.eventCount == 0) return null;
      var end = this.items.length;
      for (;; end--) {
        var next = this.items.get(end - 1);
        if (next.selection) {
          --end;
          break;
        }
      }
      var remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      var transform2 = state.tr;
      var selection, remaining;
      var addAfter = [],
        addBefore = [];
      this.items.forEach(function (item, i) {
        if (!item.step) {
          if (!remap) {
            remap = _this92.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)),
            map3;
          if (step && transform2.maybeStep(step).doc) {
            map3 = transform2.mapping.maps[transform2.mapping.maps.length - 1];
            addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map3) remap.appendMap(map3, mapFrom);
        } else {
          transform2.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(_this92.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this92.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return {
        remaining: remaining,
        transform: transform2,
        selection: selection
      };
    };
    _proto78.addTransform = function addTransform(transform2, selection, histOptions, preserveItems) {
      var newItems = [],
        eventCount = this.eventCount;
      var oldItems = this.items,
        lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (var _i251 = 0; _i251 < transform2.steps.length; _i251++) {
        var step = transform2.steps[_i251].invert(transform2.docs[_i251]);
        var item = new Item(transform2.mapping.maps[_i251], step, selection),
          merged = void 0;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (_i251) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = void 0;
        }
        if (!preserveItems) lastItem = item;
      }
      var overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new Branch(oldItems.append(newItems), eventCount);
    };
    _proto78.remapping = function remapping(from2, to) {
      var maps = new Mapping();
      this.items.forEach(function (item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
        maps.appendMap(item.map, mirrorPos);
      }, from2, to);
      return maps;
    };
    _proto78.addMaps = function addMaps(array) {
      if (this.eventCount == 0) return this;
      return new Branch(this.items.append(array.map(function (map3) {
        return new Item(map3);
      })), this.eventCount);
    };
    _proto78.rebased = function rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount) return this;
      var rebasedItems = [],
        start = Math.max(0, this.items.length - rebasedCount);
      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function (item) {
        if (item.selection) eventCount--;
      }, start);
      var iRebased = rebasedCount;
      this.items.forEach(function (item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) return;
        newUntil = Math.min(newUntil, pos);
        var map3 = mapping.maps[pos];
        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) eventCount++;
          rebasedItems.push(new Item(map3, step, selection));
        } else {
          rebasedItems.push(new Item(map3));
        }
      }, start);
      var newMaps = [];
      for (var _i252 = rebasedCount; _i252 < newUntil; _i252++) newMaps.push(new Item(mapping.maps[_i252]));
      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    };
    _proto78.emptyItemCount = function emptyItemCount() {
      var count = 0;
      this.items.forEach(function (item) {
        if (!item.step) count++;
      });
      return count;
    };
    _proto78.compress = function compress() {
      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
      var remap = this.remapping(0, upto),
        mapFrom = remap.maps.length;
      var items = [],
        events = 0;
      this.items.forEach(function (item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) events++;
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)),
            map3 = step && step.getMap();
          mapFrom--;
          if (map3) remap.appendMap(map3, mapFrom);
          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) events++;
            var newItem = new Item(map3.invert(), step, selection),
              merged,
              last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence.from(items.reverse()), events);
    };
    return Branch;
  }();
  Branch.empty = new Branch(RopeSequence.empty, 0);
  function cutOffEvents(items, n) {
    var cutPoint;
    items.forEach(function (item, i) {
      if (item.selection && n-- == 0) {
        cutPoint = i;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  var Item = /*#__PURE__*/function () {
    function Item(map3, step, selection, mirrorOffset) {
      this.map = map3;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    }
    var _proto79 = Item.prototype;
    _proto79.merge = function merge(other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) return new Item(step.getMap().invert(), step, this.selection);
      }
    };
    return Item;
  }();
  var HistoryState = function HistoryState(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  };
  var DEPTH_OVERFLOW = 20;
  function applyTransaction(history2, state, tr, options) {
    var historyTr = tr.getMeta(historyKey),
      rebased;
    if (historyTr) return historyTr.historyState;
    if (tr.getMeta(closeHistoryKey)) history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
    var appended = tr.getMeta("appendedTransaction");
    if (tr.steps.length == 0) {
      return history2;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo) return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);else return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
    } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      var composition = tr.getMeta("composition");
      var newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
      var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
      return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
    } else if (rebased = tr.getMeta("rebased")) {
      return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
    } else {
      return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
    }
  }
  function isAdjacentTo(transform2, prevRanges) {
    if (!prevRanges) return false;
    if (!transform2.docChanged) return true;
    var adjacent = false;
    transform2.mapping.maps[0].forEach(function (start, end) {
      for (var _i253 = 0; _i253 < prevRanges.length; _i253 += 2) if (start <= prevRanges[_i253 + 1] && end >= prevRanges[_i253]) adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(maps) {
    var result = [];
    for (var _i254 = maps.length - 1; _i254 >= 0 && result.length == 0; _i254--) maps[_i254].forEach(function (_from, _to, from2, to) {
      return result.push(from2, to);
    });
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges) return null;
    var result = [];
    for (var _i255 = 0; _i255 < ranges.length; _i255 += 2) {
      var _from17 = mapping.map(ranges[_i255], 1),
        to = mapping.map(ranges[_i255 + 1], -1);
      if (_from17 <= to) result.push(_from17, to);
    }
    return result;
  }
  function histTransaction(history2, state, redo2) {
    var preserveItems = mustPreserveItems(state);
    var histOptions = historyKey.get(state).spec.config;
    var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
    if (!pop) return null;
    var selection = pop.selection.resolve(pop.transform.doc);
    var added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
    return pop.transform.setSelection(selection).setMeta(historyKey, {
      redo: redo2,
      historyState: newHist
    });
  }
  var cachedPreserveItems = false,
    cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    var plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (var _i256 = 0; _i256 < plugins.length; _i256++) if (plugins[_i256].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
    return cachedPreserveItems;
  }
  var historyKey = new PluginKey("history");
  var closeHistoryKey = new PluginKey("closeHistory");
  function history$1() {
    var config2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    config2 = {
      depth: config2.depth || 100,
      newGroupDelay: config2.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init: function () {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply: function (tr, hist, state) {
          return applyTransaction(hist, state, tr, config2);
        }
      },
      config: config2,
      props: {
        handleDOMEvents: {
          beforeinput: function (view, e) {
            var inputType = e.inputType;
            var command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command2) return false;
            e.preventDefault();
            return command2(view.state, view.dispatch);
          }
        }
      }
    });
  }
  function buildCommand(redo2, scroll) {
    return function (state, dispatch) {
      var hist = historyKey.getState(state);
      if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0) return false;
      if (dispatch) {
        var tr = histTransaction(hist, state, redo2);
        if (tr) dispatch(scroll ? tr.scrollIntoView() : tr);
      }
      return true;
    };
  }
  var undo = buildCommand(false, true);
  var redo = buildCommand(true, true);
  var History = Extension.create({
    name: "history",
    addOptions: function () {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands: function () {
      return {
        undo: function () {
          return function (_ref215) {
            var state = _ref215.state,
              dispatch = _ref215.dispatch;
            return undo(state, dispatch);
          };
        },
        redo: function () {
          return function (_ref216) {
            var state = _ref216.state,
              dispatch = _ref216.dispatch;
            return redo(state, dispatch);
          };
        }
      };
    },
    addProseMirrorPlugins: function () {
      return [history$1(this.options)];
    },
    addKeyboardShortcuts: function () {
      var _this93 = this;
      return {
        "Mod-z": function () {
          return _this93.editor.commands.undo();
        },
        "Shift-Mod-z": function () {
          return _this93.editor.commands.redo();
        },
        "Mod-y": function () {
          return _this93.editor.commands.redo();
        },
        "Mod-\u044F": function () {
          return _this93.editor.commands.undo();
        },
        "Shift-Mod-\u044F": function () {
          return _this93.editor.commands.redo();
        }
      };
    }
  });
  var HorizontalRule = Node$1.create({
    name: "horizontalRule",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    parseHTML: function () {
      return [{
        tag: "hr"
      }];
    },
    renderHTML: function (_ref217) {
      var HTMLAttributes = _ref217.HTMLAttributes;
      return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands: function () {
      var _this94 = this;
      return {
        setHorizontalRule: function () {
          return function (_ref218) {
            var chain = _ref218.chain,
              state = _ref218.state;
            var selection = state.selection;
            var $originFrom = selection.$from,
              $originTo = selection.$to;
            var currentChain = chain();
            if ($originFrom.parentOffset === 0) {
              currentChain.insertContentAt({
                from: Math.max($originFrom.pos - 1, 0),
                to: $originTo.pos
              }, {
                type: _this94.name
              });
            } else if (isNodeSelection(selection)) {
              currentChain.insertContentAt($originTo.pos, {
                type: _this94.name
              });
            } else {
              currentChain.insertContent({
                type: _this94.name
              });
            }
            return currentChain.command(function (_ref219) {
              var tr = _ref219.tr,
                dispatch = _ref219.dispatch;
              var _a2;
              if (dispatch) {
                var $to = tr.selection.$to;
                var posAfter = $to.end();
                if ($to.nodeAfter) {
                  if ($to.nodeAfter.isTextblock) {
                    tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));
                  } else if ($to.nodeAfter.isBlock) {
                    tr.setSelection(NodeSelection.create(tr.doc, $to.pos));
                  } else {
                    tr.setSelection(TextSelection.create(tr.doc, $to.pos));
                  }
                } else {
                  var node = (_a2 = $to.parent.type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.create();
                  if (node) {
                    tr.insert(posAfter, node);
                    tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));
                  }
                }
                tr.scrollIntoView();
              }
              return true;
            }).run();
          };
        }
      };
    },
    addInputRules: function () {
      return [nodeInputRule({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })];
    }
  });
  var starInputRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
  var starPasteRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
  var underscoreInputRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
  var underscorePasteRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
  var Italic = Mark.create({
    name: "italic",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML: function () {
      return [{
        tag: "em"
      }, {
        tag: "i",
        getAttrs: function (node) {
          return node.style.fontStyle !== "normal" && null;
        }
      }, {
        style: "font-style=italic"
      }];
    },
    renderHTML: function (_ref220) {
      var HTMLAttributes = _ref220.HTMLAttributes;
      return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this95 = this;
      return {
        setItalic: function () {
          return function (_ref221) {
            var commands2 = _ref221.commands;
            return commands2.setMark(_this95.name);
          };
        },
        toggleItalic: function () {
          return function (_ref222) {
            var commands2 = _ref222.commands;
            return commands2.toggleMark(_this95.name);
          };
        },
        unsetItalic: function () {
          return function (_ref223) {
            var commands2 = _ref223.commands;
            return commands2.unsetMark(_this95.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this96 = this;
      return {
        "Mod-i": function () {
          return _this96.editor.commands.toggleItalic();
        },
        "Mod-I": function () {
          return _this96.editor.commands.toggleItalic();
        }
      };
    },
    addInputRules: function () {
      return [markInputRule({
        find: starInputRegex,
        type: this.type
      }), markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })];
    },
    addPasteRules: function () {
      return [markPasteRule({
        find: starPasteRegex,
        type: this.type
      }), markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })];
    }
  });
  var inputRegex$1 = /^(\d+)\.\s$/;
  var OrderedList = Node$1.create({
    name: "orderedList",
    addOptions: function () {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content: function () {
      return this.options.itemTypeName + "+";
    },
    addAttributes: function () {
      return {
        start: {
          "default": 1,
          parseHTML: function (element) {
            return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
          }
        },
        type: {
          "default": void 0,
          parseHTML: function (element) {
            return element.getAttribute("type");
          }
        }
      };
    },
    parseHTML: function () {
      return [{
        tag: "ol"
      }];
    },
    renderHTML: function (_ref224) {
      var HTMLAttributes = _ref224.HTMLAttributes;
      var start = HTMLAttributes.start,
        attributesWithoutStart = _objectWithoutProperties(HTMLAttributes, _excluded);
      return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this97 = this;
      return {
        toggleOrderedList: function () {
          return function (_ref225) {
            var commands2 = _ref225.commands,
              chain = _ref225.chain;
            if (_this97.options.keepAttributes) {
              return chain().toggleList(_this97.name, _this97.options.itemTypeName, _this97.options.keepMarks).updateAttributes(ListItem.name, _this97.editor.getAttributes(TextStyle.name)).run();
            }
            return commands2.toggleList(_this97.name, _this97.options.itemTypeName, _this97.options.keepMarks);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this98 = this;
      return {
        "Mod-Shift-7": function () {
          return _this98.editor.commands.toggleOrderedList();
        }
      };
    },
    addInputRules: function () {
      var _this99 = this;
      var inputRule = wrappingInputRule({
        find: inputRegex$1,
        type: this.type,
        getAttributes: function (match) {
          return {
            start: +match[1]
          };
        },
        joinPredicate: function (match, node) {
          return node.childCount + node.attrs.start === +match[1];
        }
      });
      if (this.options.keepMarks || this.options.keepAttributes) {
        inputRule = wrappingInputRule({
          find: inputRegex$1,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: function (match) {
            return _objectSpread({
              start: +match[1]
            }, _this99.editor.getAttributes(TextStyle.name));
          },
          joinPredicate: function (match, node) {
            return node.childCount + node.attrs.start === +match[1];
          },
          editor: this.editor
        });
      }
      return [inputRule];
    }
  });
  var Paragraph = Node$1.create({
    name: "paragraph",
    priority: 1e3,
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    content: "inline*",
    parseHTML: function () {
      return [{
        tag: "p"
      }];
    },
    renderHTML: function (_ref226) {
      var HTMLAttributes = _ref226.HTMLAttributes;
      return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this100 = this;
      return {
        setParagraph: function () {
          return function (_ref227) {
            var commands2 = _ref227.commands;
            return commands2.setNode(_this100.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this101 = this;
      return {
        "Mod-Alt-0": function () {
          return _this101.editor.commands.setParagraph();
        }
      };
    }
  });
  var inputRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
  var pasteRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
  var Strike = Mark.create({
    name: "strike",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML: function () {
      return [{
        tag: "s"
      }, {
        tag: "del"
      }, {
        tag: "strike"
      }, {
        style: "text-decoration",
        consuming: false,
        getAttrs: function (style2) {
          return style2.includes("line-through") ? {} : false;
        }
      }];
    },
    renderHTML: function (_ref228) {
      var HTMLAttributes = _ref228.HTMLAttributes;
      return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this102 = this;
      return {
        setStrike: function () {
          return function (_ref229) {
            var commands2 = _ref229.commands;
            return commands2.setMark(_this102.name);
          };
        },
        toggleStrike: function () {
          return function (_ref230) {
            var commands2 = _ref230.commands;
            return commands2.toggleMark(_this102.name);
          };
        },
        unsetStrike: function () {
          return function (_ref231) {
            var commands2 = _ref231.commands;
            return commands2.unsetMark(_this102.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this103 = this;
      return {
        "Mod-Shift-s": function () {
          return _this103.editor.commands.toggleStrike();
        }
      };
    },
    addInputRules: function () {
      return [markInputRule({
        find: inputRegex,
        type: this.type
      })];
    },
    addPasteRules: function () {
      return [markPasteRule({
        find: pasteRegex,
        type: this.type
      })];
    }
  });
  var Text = Node$1.create({
    name: "text",
    group: "inline"
  });
  var StarterKit = Extension.create({
    name: "starterKit",
    addExtensions: function () {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      var extensions = [];
      if (this.options.bold !== false) {
        extensions.push(Bold.configure((_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.bold));
      }
      if (this.options.blockquote !== false) {
        extensions.push(Blockquote.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.blockquote));
      }
      if (this.options.bulletList !== false) {
        extensions.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
      }
      if (this.options.code !== false) {
        extensions.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
      }
      if (this.options.codeBlock !== false) {
        extensions.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
      }
      if (this.options.document !== false) {
        extensions.push(Document$1.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
      }
      if (this.options.dropcursor !== false) {
        extensions.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
      }
      if (this.options.gapcursor !== false) {
        extensions.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
      }
      if (this.options.hardBreak !== false) {
        extensions.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
      }
      if (this.options.heading !== false) {
        extensions.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
      }
      if (this.options.history !== false) {
        extensions.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
      }
      if (this.options.horizontalRule !== false) {
        extensions.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
      }
      if (this.options.italic !== false) {
        extensions.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
      }
      if (this.options.listItem !== false) {
        extensions.push(ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
      }
      if (this.options.orderedList !== false) {
        extensions.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
      }
      if (this.options.paragraph !== false) {
        extensions.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
      }
      if (this.options.strike !== false) {
        extensions.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
      }
      if (this.options.text !== false) {
        extensions.push(Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
      }
      return extensions;
    }
  });
  var Underline = Mark.create({
    name: "underline",
    addOptions: function () {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML: function () {
      return [{
        tag: "u"
      }, {
        style: "text-decoration",
        consuming: false,
        getAttrs: function (style2) {
          return style2.includes("underline") ? {} : false;
        }
      }];
    },
    renderHTML: function (_ref232) {
      var HTMLAttributes = _ref232.HTMLAttributes;
      return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands: function () {
      var _this104 = this;
      return {
        setUnderline: function () {
          return function (_ref233) {
            var commands2 = _ref233.commands;
            return commands2.setMark(_this104.name);
          };
        },
        toggleUnderline: function () {
          return function (_ref234) {
            var commands2 = _ref234.commands;
            return commands2.toggleMark(_this104.name);
          };
        },
        unsetUnderline: function () {
          return function (_ref235) {
            var commands2 = _ref235.commands;
            return commands2.unsetMark(_this104.name);
          };
        }
      };
    },
    addKeyboardShortcuts: function () {
      var _this105 = this;
      return {
        "Mod-u": function () {
          return _this105.editor.commands.toggleUnderline();
        },
        "Mod-U": function () {
          return _this105.editor.commands.toggleUnderline();
        }
      };
    }
  });
  var Color = Extension.create({
    name: "color",
    addOptions: function () {
      return {
        types: ["textStyle"]
      };
    },
    addGlobalAttributes: function () {
      return [{
        types: this.options.types,
        attributes: {
          color: {
            "default": null,
            parseHTML: function (element) {
              var _a2;
              return (_a2 = element.style.color) === null || _a2 === void 0 ? void 0 : _a2.replace(/['"]+/g, "");
            },
            renderHTML: function (attributes) {
              if (!attributes.color) {
                return {};
              }
              return {
                style: "color: " + attributes.color
              };
            }
          }
        }
      }];
    },
    addCommands: function () {
      return {
        setColor: function (color) {
          return function (_ref236) {
            var chain = _ref236.chain;
            return chain().setMark("textStyle", {
              color: color
            }).run();
          };
        },
        unsetColor: function () {
          return function (_ref237) {
            var chain = _ref237.chain;
            return chain().setMark("textStyle", {
              color: null
            }).removeEmptyTextStyle().run();
          };
        }
      };
    }
  });
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var lodash = {
    exports: {}
  };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function (module, exports) {
    (function () {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
        FUNC_ERROR_TEXT = "Expected a function",
        INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800,
        HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 17976931348623157e292,
        NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];
      var argsTag = "[object Arguments]",
        arrayTag = "[object Array]",
        asyncTag = "[object AsyncFunction]",
        boolTag = "[object Boolean]",
        dateTag = "[object Date]",
        domExcTag = "[object DOMException]",
        errorTag = "[object Error]",
        funcTag = "[object Function]",
        genTag = "[object GeneratorFunction]",
        mapTag = "[object Map]",
        numberTag = "[object Number]",
        nullTag = "[object Null]",
        objectTag = "[object Object]",
        promiseTag = "[object Promise]",
        proxyTag = "[object Proxy]",
        regexpTag = "[object RegExp]",
        setTag = "[object Set]",
        stringTag = "[object String]",
        symbolTag = "[object Symbol]",
        undefinedTag = "[object Undefined]",
        weakMapTag = "[object WeakMap]",
        weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]",
        dataViewTag = "[object DataView]",
        float32Tag = "[object Float32Array]",
        float64Tag = "[object Float64Array]",
        int8Tag = "[object Int8Array]",
        int16Tag = "[object Int16Array]",
        int32Tag = "[object Int32Array]",
        uint8Tag = "[object Uint8Array]",
        uint8ClampedTag = "[object Uint8ClampedArray]",
        uint16Tag = "[object Uint16Array]",
        uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reUnescapedHtml = /[&<>"']/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff",
        rsComboMarksRange = "\\u0300-\\u036f",
        reComboHalfMarksRange = "\\ufe20-\\ufe2f",
        rsComboSymbolsRange = "\\u20d0-\\u20ff",
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsDingbatRange = "\\u2700-\\u27bf",
        rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
        rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
        rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
        rsPunctuationRange = "\\u2000-\\u206f",
        rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
        rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
        rsVarRange = "\\ufe0e\\ufe0f",
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]",
        rsAstral = "[" + rsAstralRange + "]",
        rsBreak = "[" + rsBreakRange + "]",
        rsCombo = "[" + rsComboRange + "]",
        rsDigits = "\\d+",
        rsDingbat = "[" + rsDingbatRange + "]",
        rsLower = "[" + rsLowerRange + "]",
        rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
        rsFitz = "\\ud83c[\\udffb-\\udfff]",
        rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
        rsNonAstral = "[^" + rsAstralRange + "]",
        rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        rsUpper = "[" + rsUpperRange + "]",
        rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
        rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
        rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
        rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
        reOptMod = rsModifier + "?",
        rsOptVar = "[" + rsVarRange + "]?",
        rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
        rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
        rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
        rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat,
        freeParseInt = parseInt;
      var freeGlobal = _typeof(commonjsGlobal) == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function () {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {}
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply2(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1,
          length = values.length,
          offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
          length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function (value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
          length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function (object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function (value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result,
          index = -1,
          length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1,
          result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function (key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function (key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
          length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length,
          result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator2) {
        var data,
          result = [];
        while (!(data = iterator2.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map3) {
        var index = -1,
          result = Array(map3.size);
        map3.forEach(function (value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function (arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1,
          result = Array(set.size);
        set.forEach(function (value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1,
          result = Array(set.size);
        set.forEach(function (value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
          length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array,
          Date2 = context.Date,
          Error2 = context.Error,
          Function2 = context.Function,
          Math2 = context.Math,
          Object2 = context.Object,
          RegExp2 = context.RegExp,
          String2 = context.String,
          TypeError2 = context.TypeError;
        var arrayProto2 = Array2.prototype,
          funcProto = Function2.prototype,
          objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function () {
          var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid2 ? "Symbol(src)_1." + uid2 : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer = moduleExports ? context.Buffer : undefined$1,
          Symbol2 = context.Symbol,
          Uint8Array = context.Uint8Array,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
          getPrototype = overArg(Object2.getPrototypeOf, Object2),
          objectCreate = Object2.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto2.splice,
          spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1,
          symIterator = Symbol2 ? Symbol2.iterator : undefined$1,
          symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function () {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {}
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
          ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now,
          ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil,
          nativeFloor = Math2.floor,
          nativeGetSymbols = Object2.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto2.join,
          nativeKeys = overArg(Object2.keys, Object2),
          nativeMax = Math2.max,
          nativeMin = Math2.min,
          nativeNow = Date2.now,
          nativeParseInt = context.parseInt,
          nativeRandom = Math2.random,
          nativeReverse = arrayProto2.reverse;
        var DataView = getNative(context, "DataView"),
          Map2 = getNative(context, "Map"),
          Promise2 = getNative(context, "Promise"),
          Set2 = getNative(context, "Set"),
          WeakMap2 = getNative(context, "WeakMap"),
          nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map2),
          promiseCtorString = toSource(Promise2),
          setCtorString = toSource(Set2),
          weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
          symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function () {
          function object() {}
          return function (proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray2(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : start - 1,
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
              value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                iteratee2 = data.iteratee,
                type = data.type,
                computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1,
            length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__,
            result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result2 = skipIndexes ? baseTimes(value.length, String2) : [],
            length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function (value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys2(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1,
            length = paths.length,
            result2 = Array2(length),
            skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined$1 : get2(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack2) {
          var result2,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack2) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack2 || (stack2 = new Stack());
          var stacked = stack2.get(value);
          if (stacked) {
            return stacked;
          }
          stack2.set(value, result2);
          if (isSet2(value)) {
            value.forEach(function (subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
            });
          } else if (isMap2(value)) {
            value.forEach(function (subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function (subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function (object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length],
              predicate = source[key],
              value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function () {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1,
            includes3 = arrayIncludes,
            isCommon = true,
            length = array.length,
            result2 = [],
            valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes3 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes3 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer: while (++index < length) {
            var value = array[index],
              computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes3(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function (value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1,
            length = array.length;
          while (++index < length) {
            var value = array[index],
              current = iteratee2(value);
            if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
              var computed2 = current,
                result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function (value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function (key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0,
            length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes3 = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array2(othLength),
            maxLength = Infinity,
            result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1,
            seen = caches[0];
          outer: while (++index < length && result2.length < maxLength) {
            var value = array[index],
              computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes3(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes3(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function (value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply2(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack2) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
          var objIsArr = isArray2(object),
            othIsArr = isArray2(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack2 || (stack2 = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"),
              othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;
              stack2 || (stack2 = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack2 || (stack2 = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
              objValue = object[key],
              srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack2 = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack2);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (_typeof(value) == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
            result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1,
            result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function (value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function (object) {
            var objValue = get2(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack2) {
          if (object === source) {
            return;
          }
          baseFor(source, function (srcValue, key) {
            stack2 || (stack2 = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
          var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack2.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack2.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
            stack2["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function (iteratee2) {
              if (isArray2(iteratee2)) {
                return function (value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function (value, key, collection2) {
            var criteria = arrayMap(iteratees, function (iteratee2) {
              return iteratee2(value);
            });
            return {
              "criteria": criteria,
              "index": ++index,
              "value": value
            };
          });
          return baseSortBy(result2, function (object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function (value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result2 = {};
          while (++index < length) {
            var path = paths[index],
              value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function (object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values2.length,
            seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0,
              value = values2[index],
              computed2 = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
            lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
              newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function (func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function (func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1,
            length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function (value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
            high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1,
                computed2 = array[mid];
              if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0,
            high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol2(value),
            valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
              computed2 = iteratee2(array[mid]),
              othIsDefined = computed2 !== undefined$1,
              othIsNull = computed2 === null,
              othIsReflexive = computed2 === computed2,
              othIsSymbol = isSymbol2(computed2);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed2 <= value : computed2 < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1,
            length = array.length,
            resIndex = 0,
            result2 = [];
          while (++index < length) {
            var value = array[index],
              computed2 = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed2, seen)) {
              var seen = computed2;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol2(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1,
            includes3 = arrayIncludes,
            length = array.length,
            isCommon = true,
            result2 = [],
            seen = result2;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes3 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer: while (++index < length) {
            var value = array[index],
              computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes3(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
            index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function (result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
            result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index],
              othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1,
            length = props.length,
            valsLength = values2.length,
            result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function (id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length = buffer2.length,
            result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          buffer2.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol2(value);
            var othIsDefined = other !== undefined$1,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol2(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result2 = Array2(leftLength + rangeLength),
            isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result2 = Array2(rangeLength + rightLength),
            isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function (collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined$1,
              guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function (object, iteratee2, keysFunc) {
            var index = -1,
              iterable = Object2(object),
              props = keysFunc(object),
              length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function (string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function (string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function () {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
              result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length,
              args = Array2(length),
              index = length,
              placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply2(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function (collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function (key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function (funcs) {
            var length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function () {
              var args = arguments,
                value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0,
                result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG,
            isBind = bitmask & WRAP_BIND_FLAG,
            isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
            isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
            isFlip = bitmask & WRAP_FLIP_FLAG,
            Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length,
              args = Array2(length),
              index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function (object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function (value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function (iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function (args) {
              var thisArg = this;
              return arrayFunc(iteratees, function (iteratee2) {
                return apply2(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array2(leftLength + argsLength),
              fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply2(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange2(fromRight) {
          return function (start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function (value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
            newHolders = isCurry ? holders : undefined$1,
            newHoldersRight = isCurry ? undefined$1 : holders,
            newPartials = isCurry ? partials : undefined$1,
            newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary2, arity];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function (number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"),
                value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function (values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function (object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
              holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack2.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
            stack2["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack2.get(array);
          var othStacked = stack2.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
            result2 = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack2.set(array, other);
          stack2.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function (othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
              result2 = false;
              break;
            }
          }
          stack2["delete"](array);
          stack2["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack2.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack2.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
              stack2["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack2.get(object);
          var othStacked = stack2.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack2.set(object, other);
          stack2.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
              othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor;
            if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack2["delete"](object);
          stack2["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys2, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function (func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "",
            array = realNames[result2],
            length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length],
              otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map4, key) {
          var data = map4.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys2(object),
            length = result2.length;
          while (length--) {
            var key = result2[length],
              value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag),
            tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {}
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function (symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function (value) {
            var result2 = baseGetTag(value),
              Ctor = result2 == objectTag ? value.constructor : undefined$1,
              ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1,
            length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
              size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return {
            "start": start,
            "end": end
          };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length,
            result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = _typeof(value);
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = _typeof(index);
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = _typeof(value);
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = _typeof(value);
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func),
            other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString2(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform3(array);
            return apply2(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function (func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1,
            length = array.length,
            lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex),
              value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function (string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function (match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol2(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return func + "";
            } catch (e) {}
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function (pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk2(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0,
            resIndex = 0,
            result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1),
            array = arguments[0],
            index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function (array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function (array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function (array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1,
            length = pairs == null ? 0 : pairs.length,
            result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function (arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function (arrays) {
          var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function (array, indexes) {
          var length = array == null ? 0 : array.length,
            result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function (index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1,
            indexes = [],
            length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function (arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function (arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function (group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function (index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function (group) {
            return apply2(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function (array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function (arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function (arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function (arrays) {
          var length = arrays.length,
            iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function (paths) {
          var length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function (object) {
              return baseAt(object, paths);
            };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function (array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
            value = done ? undefined$1 : this.__values__[this.__index__++];
          return {
            "done": done,
            "value": value
          };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2,
            parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function (result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map3(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map3(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map3(collection, iteratee2), depth);
        }
        function forEach3(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function (result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes2(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function (collection, path, args) {
          var index = -1,
            isFunc = typeof path == "function",
            result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function (value) {
            result2[++index] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function (result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map3(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function (result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function () {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function (collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function () {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function () {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function (func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function (object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result2,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber2(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(),
              isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer2 = baseRest(function (func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function (func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function () {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function (func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function (args) {
            var index = -1,
              length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply2(func, this, args);
          });
        });
        var partial = baseRest(function (func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function (func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function (func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function (args) {
            var array = args[start],
              otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply2(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true,
            trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap2(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function (value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function () {
          return arguments;
        }()) ? baseIsArguments : function (value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = _typeof(value);
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && _typeof(value) == "object";
        }
        var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol2(value) {
          return _typeof(value) == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function (value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
            func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value),
            remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function (object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function (object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function (object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function (args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply2(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get2(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has2(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function (result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function (result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function (value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function (value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function (object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function (path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function (prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function (value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1,
            length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object, iteratee2, accumulator) {
          var isArr = isArray2(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp2(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber2(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function (result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize2(word) : word);
        });
        function capitalize2(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd2(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart2(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace2() {
          var args = arguments,
            string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split2(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
            importsKeys = keys2(imports),
            importsValues = baseValues(imports, importsKeys);
          var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function () {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function (func, args) {
          try {
            return apply2(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function (object, methodNames) {
          arrayEach(methodNames, function (key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
            toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function (pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function (args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply2(pair[0], this, args)) {
                return apply2(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function () {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches2(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function (path, args) {
          return function (object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function (object, args) {
          return function (path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys2(source),
            methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain,
            isFunc = isFunction2(object);
          arrayEach(methodNames, function (methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function () {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__),
                    actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({
                    "func": func,
                    "args": arguments,
                    "thisArg": object
                  });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {}
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function (args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function (path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        var range = createRange2();
        var rangeRight = createRange2(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol2(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function (augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function (dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor2 = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function (multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function (minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign2;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind2;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk2;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer2;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys2;
        lodash2.keysIn = keysIn;
        lodash2.map = map3;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches2;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit2;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick2;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove2;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split2;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform2;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap2;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize2;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp2;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor2;
        lodash2.forEach = forEach3;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get2;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has2;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes2;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean2;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty2;
        lodash2.isEqual = isEqual2;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap2;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp2;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet2;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol2;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join2;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now2;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd2;
        lodash2.padStart = padStart2;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce2;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace2;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber2;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach3;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function () {
          var source = {};
          baseForOwn(lodash2, function (func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), {
          "chain": false
        });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function (methodName, index) {
          LazyWrapper.prototype[methodName] = function (n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function (n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
          var type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function (iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function (methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function () {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function (methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function () {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function () {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function (predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function (predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function (value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function (predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function (start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function (predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function () {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName],
            retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function () {
            var value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee2 = args[0],
              useLazy2 = isLazy || isArray2(value);
            var interceptor = function (value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy2 && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy2 = false;
            }
            var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy2) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({
                "func": thru,
                "args": [interceptor],
                "thisArg": undefined$1
              });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function (methodName) {
          var func = arrayProto2[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
            retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function () {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function (value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({
              "name": methodName,
              "func": lodashFunc
            });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _ = runInContext();
      if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var m2;
  var require2 = Package.modules.meteorInstall({
    "__vite_stub2.js": function (require3, exports, module) {
      m2 = require3("meteor/ostrio:files/client.js");
      validateStub(m2, {
        "requestId": "meteor/ostrio:files",
        "packageName": "meteor/ostrio:files",
        "exportKeys": ["FilesCollection", "helpers"],
        "warnOnly": true
      });
    }
  }, {
    "extensions": [".js"]
  });
  require2("/__vite_stub2.js");
  var FilesCollection = m2.FilesCollection;
  m2.helpers;
  var os$1 = {};
  var getFilePath = function () {
    return os$1.join(os$1.homedir(), "file_uploads");
  };
  var Files = new FilesCollection({
    debug: false,
    storagePath: function () {
      return getFilePath();
    },
    collectionName: "app_files",
    onAfterUpload: function (fileRef) {
      console.log("File uploaded on server:", fileRef);
    }
  });
  var TextEditor_vue_vue_type_style_index_0_lang = "";
  var _hoisted_1$1 = {
    key: 0,
    "class": "buttons flex items-center flex-wrap gap-x-4 border border-t border-l border-r border-black p-4"
  };
  var _hoisted_2$1 = ["disabled"];
  var _hoisted_3$1 = ["disabled"];
  var _hoisted_4$1 = ["disabled"];
  var _hoisted_5 = ["disabled"];
  var _hoisted_6 = ["disabled"];
  var _hoisted_7 = ["value"];
  var _hoisted_8 = ["src"];
  var _sfc_main$4 = {
    __name: "TextEditor",
    setup: function (__props) {
      useRouter$1();
      var route = useRoute$1();
      var editmode = ref(false);
      var form = ref({
        price: 0,
        data: "",
        photoId: "",
        categoryId: "",
        name: ""
      });
      var editor = useEditor({
        editorProps: {
          attributes: {
            "class": "border border-gray-400 p-4 min-h-[12rem] max-h-[12rem] overflow-y-auto "
          }
        },
        content: form.value.data,
        extensions: [StarterKit, Underline, Blockquote, TextStyle, Color],
        onUpdate: function (_ref238) {
          var editor2 = _ref238.editor;
          form.value.data = editor2.getHTML();
        }
      });
      watch(function () {
        return form.value.data;
      }, function (newData) {
        editor.value.commands.setContent(newData);
      });
      function resetForm() {
        form.value = {
          price: 0,
          data: "",
          photoId: "",
          categoryId: "",
          name: ""
        };
      }
      ref();
      var filePhotos = ref("");
      var getfilePhotos = ref([]);
      var handleChange = function ($event) {
        var target = $event.target;
        if (target && target.files) {
          filePhotos.value = target.files[0];
        }
      };
      var onUploadToServer = function () {
        var uploadInstance = Files.insert({
          file: filePhotos.value,
          chunkSize: "dynamic",
          onError: function (err) {
            console.log("Error during upload:", err);
          }
        });
        uploadInstance.on("end", function (error, fileObj) {
          if (error) {
            console.log("Upload error:", error);
          } else {
            console.log("Uploaded fileObj:", fileObj);
            console.log("end this", this.config);
            form.value.photoId = this.config.fileId;
            createProduct();
          }
        });
      };
      var getFileUploads = function () {
        Meteor.call("findImageData", function (err, res) {
          if (res) {
            getfilePhotos.value = res;
            console.log("get", getfilePhotos.value);
          } else {
            console.log(err);
          }
        });
      };
      var category = ref([]);
      function getCategory() {
        Meteor.call("category.find", function (err, result) {
          if (result) {
            category.value = result;
          } else {
            console.log(err);
          }
        });
      }
      function createProduct() {
        form.value.price = lodash.exports.toNumber(form.value.price);
        Meteor.call("products.create", form.value, function (err, result) {
          if (result) {
            console.log("create successfully");
            resetForm();
          } else {
            console.log(err);
          }
        });
      }
      function findProductById() {
        Meteor.call("product.findById", {
          id: route.params.id
        }, function (err, result) {
          if (result) {
            form.value = result;
            console.log(form.value);
          } else {
            console.log(err);
          }
        });
      }
      var submit = function () {
        if (filePhotos.value) {
          onUploadToServer();
        } else {
          createProduct();
        }
      };
      onMounted(function () {
        getCategory();
        if (route.params.id) {
          editmode.value = true;
        }
        console.log(editmode.value);
        getFileUploads();
      });
      console.log(form.value.photoId);
      findProductById();
      return function (_ctx, _cache) {
        var _component_v_icon = resolveComponent("v-icon");
        var _component_v_col = resolveComponent("v-col");
        var _component_v_select = resolveComponent("v-select");
        var _component_VTextField = resolveComponent("VTextField");
        var _component_v_file_input = resolveComponent("v-file-input");
        var _component_v_btn = resolveComponent("v-btn");
        var _component_v_row = resolveComponent("v-row");
        var _component_v_card_text = resolveComponent("v-card-text");
        var _component_v_card = resolveComponent("v-card");
        var _component_v_container = resolveComponent("v-container");
        return openBlock(), createBlock(_component_v_container, null, {
          "default": withCtx(function () {
            return [createVNode(_component_v_card, {
              "class": "w-50 mx-auto"
            }, {
              "default": withCtx(function () {
                return [createVNode(_component_v_card_text, null, {
                  "default": withCtx(function () {
                    return [createVNode(_component_v_row, null, {
                      "default": withCtx(function () {
                        return [createVNode(_component_v_col, {
                          cols: "12",
                          md: "12"
                        }, {
                          "default": withCtx(function () {
                            return [unref(editor) ? (openBlock(), createElementBlock("section", _hoisted_1$1, [createBaseVNode("button", {
                              onClick: _cache[0] || (_cache[0] = function ($event) {
                                return unref(editor).chain().focus().toggleBold().run();
                              }),
                              disabled: !unref(editor).can().chain().focus().toggleBold().run(),
                              "class": normalizeClass([{
                                "bg-gray-200": unref(editor).isActive("bold")
                              }, "p-1"])
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[13] || (_cache[13] = [createTextVNode(" mdi-format-bold ")]);
                              }),
                              _: 1
                            })], 10, _hoisted_2$1), createBaseVNode("button", {
                              onClick: _cache[1] || (_cache[1] = function ($event) {
                                return unref(editor).chain().focus().toggleItalic().run();
                              }),
                              disabled: !unref(editor).can().chain().focus().toggleItalic().run(),
                              "class": normalizeClass([{
                                "bg-gray-200": unref(editor).isActive("italic")
                              }, "p-1 font-weight-bold rounded"]),
                              style: {
                                "font-style": "italic"
                              }
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[14] || (_cache[14] = [createTextVNode(" mdi-format-italic ")]);
                              }),
                              _: 1
                            })], 10, _hoisted_3$1), createBaseVNode("button", {
                              onClick: _cache[2] || (_cache[2] = function ($event) {
                                return unref(editor).chain().focus().toggleUnderline().run();
                              }),
                              disabled: !unref(editor).can().chain().focus().toggleUnderline().run(),
                              "class": normalizeClass([{
                                "bg-gray-200": unref(editor).isActive("underline")
                              }, "p-1 font-weight-bold rounded"]),
                              style: {
                                "font-style": "italic"
                              }
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[15] || (_cache[15] = [createTextVNode(" mdi-format-underline ")]);
                              }),
                              _: 1
                            })], 10, _hoisted_4$1), createBaseVNode("button", {
                              type: "button",
                              onClick: _cache[3] || (_cache[3] = function ($event) {
                                return unref(editor).chain().focus().toggleHeading({
                                  level: 1
                                }).run();
                              }),
                              "class": normalizeClass([{
                                "bg-gray-200 rounded": unref(editor).isActive("heading", {
                                  level: 1
                                })
                              }, "p-1"])
                            }, " H1 ", 2), createBaseVNode("button", {
                              type: "button",
                              onClick: _cache[4] || (_cache[4] = function ($event) {
                                return unref(editor).chain().focus().toggleHeading({
                                  level: 2
                                }).run();
                              }),
                              "class": normalizeClass([{
                                "bg-gray-200 rounded": unref(editor).isActive("heading", {
                                  level: 2
                                })
                              }, "p-1"])
                            }, " H2 ", 2), createBaseVNode("button", {
                              type: "button",
                              onClick: _cache[5] || (_cache[5] = function ($event) {
                                return unref(editor).chain().focus().toggleBulletList().run();
                              }),
                              "class": normalizeClass([{
                                "bg-gray-200 rounded": unref(editor).isActive("bulletList")
                              }, "p-1"])
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[16] || (_cache[16] = [createTextVNode(" mdi-format-list-bulleted ")]);
                              }),
                              _: 1
                            })], 2), createBaseVNode("button", {
                              type: "button",
                              onClick: _cache[6] || (_cache[6] = function ($event) {
                                return unref(editor).chain().focus().toggleOrderedList().run();
                              }),
                              "class": normalizeClass([{
                                "bg-gray-200 rounded": unref(editor).isActive("orderedList")
                              }, "p-1"])
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[17] || (_cache[17] = [createTextVNode("mdi-format-list-numbered")]);
                              }),
                              _: 1
                            })], 2), createBaseVNode("button", {
                              type: "button",
                              "class": "p-1 disabled:text-gray-400",
                              onClick: _cache[7] || (_cache[7] = function ($event) {
                                return unref(editor).chain().focus().undo().run();
                              }),
                              disabled: !unref(editor).can().chain().focus().undo().run()
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[18] || (_cache[18] = [createTextVNode(" mdi-undo ")]);
                              }),
                              _: 1
                            })], 8, _hoisted_5), createBaseVNode("button", {
                              type: "button",
                              onClick: _cache[8] || (_cache[8] = function ($event) {
                                return unref(editor).chain().focus().redo().run();
                              }),
                              disabled: !unref(editor).can().chain().focus().redo().run(),
                              "class": "p-1 disabled:text-gray-400"
                            }, [createVNode(_component_v_icon, null, {
                              "default": withCtx(function () {
                                return _cache[19] || (_cache[19] = [createTextVNode(" mdi-redo ")]);
                              }),
                              _: 1
                            })], 8, _hoisted_6), createBaseVNode("input", {
                              type: "color",
                              onInput: _cache[9] || (_cache[9] = function ($event) {
                                return unref(editor).chain().focus().setColor($event.target.value).run();
                              }),
                              value: unref(editor).getAttributes("textStyle").color
                            }, null, 40, _hoisted_7), _cache[20] || (_cache[20] = createTextVNode(" //color "))])) : createCommentVNode("", true), createVNode(unref(EditorContent), {
                              editor: unref(editor)
                            }, null, 8, ["editor"])];
                          }),
                          _: 1
                        }), createVNode(_component_v_col, {
                          cols: "12",
                          md: "6"
                        }, {
                          "default": withCtx(function () {
                            return [createVNode(_component_v_select, {
                              placeholder: "Select Category",
                              label: "Select Category",
                              variant: "outlined",
                              items: category.value,
                              "item-title": "name",
                              "item-value": "_id",
                              modelValue: form.value.categoryId,
                              "onUpdate:modelValue": _cache[10] || (_cache[10] = function ($event) {
                                return form.value.categoryId = $event;
                              })
                            }, null, 8, ["items", "modelValue"])];
                          }),
                          _: 1
                        }), createVNode(_component_v_col, {
                          md: "6",
                          cols: "12"
                        }, {
                          "default": withCtx(function () {
                            return [createVNode(_component_VTextField, {
                              placeholder: "200",
                              label: "Price",
                              variant: "outlined",
                              modelValue: form.value.price,
                              "onUpdate:modelValue": _cache[11] || (_cache[11] = function ($event) {
                                return form.value.price = $event;
                              }),
                              modelModifiers: {
                                number: true
                              },
                              type: "number",
                              clearable: ""
                            }, null, 8, ["modelValue"])];
                          }),
                          _: 1
                        }), createVNode(_component_v_col, {
                          md: "6",
                          cols: "12"
                        }, {
                          "default": withCtx(function () {
                            return [createVNode(_component_VTextField, {
                              placeholder: "200",
                              label: "Name",
                              variant: "outlined",
                              modelValue: form.value.name,
                              "onUpdate:modelValue": _cache[12] || (_cache[12] = function ($event) {
                                return form.value.name = $event;
                              }),
                              clearable: ""
                            }, null, 8, ["modelValue"])];
                          }),
                          _: 1
                        }), createVNode(_component_v_col, {
                          cols: "12",
                          md: "6"
                        }, {
                          "default": withCtx(function () {
                            return [createVNode(_component_v_file_input, {
                              accept: "image/png, image/jpeg, image/bmp",
                              label: "Avatar",
                              placeholder: "Pick an avatar",
                              variant: "outlined",
                              "prepend-icon": "mdi-camera",
                              onChange: handleChange
                            })];
                          }),
                          _: 1
                        }), createVNode(_component_v_col, {
                          cols: "12",
                          md: "6"
                        }, {
                          "default": withCtx(function () {
                            return [createVNode(_component_v_btn, {
                              onClick: submit
                            }, {
                              "default": withCtx(function () {
                                return _cache[21] || (_cache[21] = [createTextVNode("Submit")]);
                              }),
                              _: 1
                            })];
                          }),
                          _: 1
                        })];
                      }),
                      _: 1
                    })];
                  }),
                  _: 1
                })];
              }),
              _: 1
            }), (openBlock(true), createElementBlock(Fragment$1, null, renderList(getfilePhotos.value, function (file) {
              return openBlock(), createElementBlock("div", {
                key: file._id
              }, [createBaseVNode("img", {
                src: file.pat,
                alt: ""
              }, null, 8, _hoisted_8), createTextVNode(" " + toDisplayString(file.path), 1)]);
            }), 128))];
          }),
          _: 1
        });
      };
    }
  };
  var _sfc_main$3 = {
    __name: "CategoryForm",
    setup: function (__props) {
      var form = ref({
        name: ""
      });
      function submitForm() {
        Meteor.call("category.create", form.value, function (err, result) {
          if (result) {
            console.log("add sus");
          } else {
            console.log("Error: ", err);
          }
        });
      }
      return function (_ctx, _cache) {
        var _component_v_card_title = resolveComponent("v-card-title");
        var _component_v_text_field = resolveComponent("v-text-field");
        var _component_v_col = resolveComponent("v-col");
        var _component_v_btn = resolveComponent("v-btn");
        var _component_v_row = resolveComponent("v-row");
        var _component_v_form = resolveComponent("v-form");
        var _component_v_card_text = resolveComponent("v-card-text");
        var _component_v_card = resolveComponent("v-card");
        var _component_v_container = resolveComponent("v-container");
        return openBlock(), createBlock(_component_v_container, null, {
          "default": withCtx(function () {
            return [createVNode(_component_v_card, {
              "class": "w-25 pa-3"
            }, {
              "default": withCtx(function () {
                return [createVNode(_component_v_card_title, null, {
                  "default": withCtx(function () {
                    return _cache[1] || (_cache[1] = [createTextVNode(" Category Form ")]);
                  }),
                  _: 1
                }), createVNode(_component_v_card_text, null, {
                  "default": withCtx(function () {
                    return [createVNode(_component_v_form, null, {
                      "default": withCtx(function () {
                        return [createVNode(_component_v_row, null, {
                          "default": withCtx(function () {
                            return [createVNode(_component_v_col, {
                              cols: "12",
                              md: "12"
                            }, {
                              "default": withCtx(function () {
                                return [createVNode(_component_v_text_field, {
                                  variant: "outlined",
                                  placeholder: "MSI",
                                  label: "CategoryName",
                                  modelValue: form.value.name,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
                                    return form.value.name = $event;
                                  })
                                }, null, 8, ["modelValue"])];
                              }),
                              _: 1
                            }), createVNode(_component_v_col, null, {
                              "default": withCtx(function () {
                                return [createVNode(_component_v_btn, {
                                  color: "primary",
                                  onClick: submitForm
                                }, {
                                  "default": withCtx(function () {
                                    return _cache[2] || (_cache[2] = [createTextVNode("Submit")]);
                                  }),
                                  _: 1
                                })];
                              }),
                              _: 1
                            })];
                          }),
                          _: 1
                        })];
                      }),
                      _: 1
                    })];
                  }),
                  _: 1
                })];
              }),
              _: 1
            })];
          }),
          _: 1
        });
      };
    }
  };
  var _export_sfc = function (sfc, props) {
    var target = sfc.__vccOpts || sfc;
    for (var _iterator30 = _createForOfIteratorHelperLoose(props), _step32; !(_step32 = _iterator30()).done;) {
      var _ref239 = _step32.value;
      var _ref240 = _slicedToArray(_ref239, 2);
      var key = _ref240[0];
      var val = _ref240[1];
      target[key] = val;
    }
    return target;
  };
  var _sfc_main$2 = {};
  function _sfc_render$1(_ctx, _cache) {
    return "hello world";
  }
  var Default = /* @__PURE__ */_export_sfc(_sfc_main$2, [["render", _sfc_render$1]]);
  var _sfc_main$1 = {};
  function _sfc_render(_ctx, _cache) {
    return "hello world";
  }
  var Blank = /* @__PURE__ */_export_sfc(_sfc_main$1, [["render", _sfc_render]]);
  var _hoisted_1 = {
    "class": "w-75 mx-auto mt-6",
    align: "end"
  };
  var _hoisted_2 = {
    "class": "text-red text-h4 text-center my-2 font-weight-bold"
  };
  var _hoisted_3 = {
    "class": "text-blue text-h6 text-center my-2 font-weight-bold"
  };
  var _hoisted_4 = ["innerHTML"];
  var _sfc_main = {
    __name: "Admin",
    setup: function (__props) {
      var router2 = useRouter$1();
      useRoute$1();
      var dataGet = ref([]);
      function getData() {
        Meteor.call("productJoinCategory", function (err, result) {
          if (result) {
            dataGet.value = result;
            console.log("data", dataGet.value);
          } else {
            console.log(err);
          }
        });
      }
      function deleteProduct(id) {
        Meteor.call("product.remove", {
          id: id
        }, function (err, result) {
          if (result) {
            console.log("delete success");
            getData();
          } else {
            console.log(err);
          }
        });
      }
      function editProduct(id) {
        router2.push("/form/" + id);
      }
      onMounted(function () {
        getData();
      });
      return function (_ctx, _cache) {
        var _component_v_icon = resolveComponent("v-icon");
        var _component_v_btn = resolveComponent("v-btn");
        var _component_v_card_title = resolveComponent("v-card-title");
        var _component_v_img = resolveComponent("v-img");
        var _component_v_col = resolveComponent("v-col");
        var _component_v_row = resolveComponent("v-row");
        var _component_v_card_text = resolveComponent("v-card-text");
        var _component_v_card = resolveComponent("v-card");
        return openBlock(), createElementBlock(Fragment$1, null, [createBaseVNode("div", _hoisted_1, [createVNode(_component_v_btn, {
          flat: "",
          "class": "bg-green",
          to: "/form"
        }, {
          "default": withCtx(function () {
            return [createVNode(_component_v_icon, null, {
              "default": withCtx(function () {
                return _cache[0] || (_cache[0] = [createTextVNode("mdi-plus")]);
              }),
              _: 1
            }), _cache[1] || (_cache[1] = createTextVNode(" ADD "))];
          }),
          _: 1
        })]), (openBlock(true), createElementBlock(Fragment$1, null, renderList(dataGet.value, function (cat, catidx) {
          return openBlock(), createBlock(_component_v_card, {
            "class": "w-75 mx-auto mt-5 pa-4",
            key: catidx,
            elevation: "3"
          }, {
            "default": withCtx(function () {
              return [createVNode(_component_v_card_title, {
                "class": "text-red text-h5 font-weight-bold"
              }, {
                "default": withCtx(function () {
                  return [createTextVNode(toDisplayString(cat._id), 1)];
                }),
                _: 2
              }, 1024), createVNode(_component_v_card_text, {
                "class": "mt-5"
              }, {
                "default": withCtx(function () {
                  return [createVNode(_component_v_row, null, {
                    "default": withCtx(function () {
                      return [(openBlock(true), createElementBlock(Fragment$1, null, renderList(cat.products, function (i, idx) {
                        return openBlock(), createBlock(_component_v_col, {
                          cols: "12",
                          md: "3",
                          "class": "border border-secondary",
                          key: idx
                        }, {
                          "default": withCtx(function () {
                            return [i.photo_path ? (openBlock(), createBlock(_component_v_img, {
                              key: 0,
                              "class": "mx-auto",
                              width: 180,
                              src: i.photo_path
                            }, null, 8, ["src"])) : (openBlock(), createBlock(_component_v_img, {
                              key: 1,
                              "class": "mx-auto",
                              width: 180,
                              src: "https://media.istockphoto.com/id/1055079680/id/vektor/kamera-foto-linear-hitam-tidak-seperti-gambar-yang-tersedia.jpg?s=612x612&w=0&k=20&c=JwsOavJ9ghdrwbjvJTUsAUEODcVv5-SXQdxhjEsJ_V4="
                            })), createVNode(_component_v_img, {
                              "class": "mx-auto",
                              width: 180,
                              src: "https://cccomputerkh.com/ori.gif"
                            }), createBaseVNode("p", _hoisted_2, toDisplayString(i.price) + "$ ", 1), createBaseVNode("p", _hoisted_3, toDisplayString(i.name), 1), createBaseVNode("div", {
                              innerHTML: i.data,
                              "class": "tiptap mt-3"
                            }, null, 8, _hoisted_4), createVNode(_component_v_btn, {
                              flat: "",
                              "class": "mt-3 bg-yellow-lighten-4",
                              onClick: function ($event) {
                                return editProduct(i._id);
                              }
                            }, {
                              "default": withCtx(function () {
                                return [createVNode(_component_v_icon, null, {
                                  "default": withCtx(function () {
                                    return _cache[2] || (_cache[2] = [createTextVNode(" mdi-pen ")]);
                                  }),
                                  _: 1
                                })];
                              }),
                              _: 2
                            }, 1032, ["onClick"]), createVNode(_component_v_btn, {
                              flat: "",
                              "class": "mt-3 bg-red-lighten-4 ml-2",
                              onClick: function ($event) {
                                return deleteProduct(i._id);
                              }
                            }, {
                              "default": withCtx(function () {
                                return [createVNode(_component_v_icon, null, {
                                  "default": withCtx(function () {
                                    return _cache[3] || (_cache[3] = [createTextVNode(" mdi-delete ")]);
                                  }),
                                  _: 1
                                })];
                              }),
                              _: 2
                            }, 1032, ["onClick"])];
                          }),
                          _: 2
                        }, 1024);
                      }), 128))];
                    }),
                    _: 2
                  }, 1024)];
                }),
                _: 2
              }, 1024)];
            }),
            _: 2
          }, 1024);
        }), 128))], 64);
      };
    }
  };
  var router = createRouter({
    history: createWebHistory(),
    routes: [{
      path: "/",
      name: "Home",
      component: _sfc_main$5
    }, {
      path: "/admin",
      name: "Admin",
      component: _sfc_main
    }, {
      path: "/form/:id?",
      name: "TextEditor",
      component: _sfc_main$4
    }, {
      path: "/default",
      name: "Default",
      component: Default
    }, {
      path: "/blank",
      name: "Blank",
      component: Blank
    }, {
      path: "/categoryform",
      name: "CategoryForm",
      component: _sfc_main$3
    }]
  });
  var materialdesignicons = "";
  var main = "";
  function useToggleScope(source, fn) {
    var scope;
    function start() {
      scope = effectScope();
      scope.run(function () {
        return fn.length ? fn(function () {
          scope == null ? void 0 : scope.stop();
          start();
        }) : fn();
      });
    }
    watch(source, function (active) {
      if (active && !scope) {
        start();
      } else if (!active) {
        scope == null ? void 0 : scope.stop();
        scope = void 0;
      }
    }, {
      immediate: true
    });
    onScopeDispose(function () {
      scope == null ? void 0 : scope.stop();
    });
  }
  var IN_BROWSER = typeof window !== "undefined";
  var SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
  var SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
  var SUPPORTS_EYE_DROPPER = IN_BROWSER && "EyeDropper" in window;
  function _classPrivateFieldInitSpec(e, t, a) {
    _checkPrivateRedeclaration(e, t), t.set(e, a);
  }
  function _checkPrivateRedeclaration(e, t) {
    if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function _classPrivateFieldSet(s, a, r) {
    return s.set(_assertClassBrand(s, a), r), r;
  }
  function _classPrivateFieldGet(s, a) {
    return s.get(_assertClassBrand(s, a));
  }
  function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
  }
  function getNestedValue(obj, path, fallback) {
    var last = path.length - 1;
    if (last < 0) return obj === void 0 ? fallback : obj;
    for (var _i257 = 0; _i257 < last; _i257++) {
      if (obj == null) {
        return fallback;
      }
      obj = obj[path[_i257]];
    }
    if (obj == null) return fallback;
    return obj[path[last]] === void 0 ? fallback : obj[path[last]];
  }
  function deepEqual(a, b) {
    if (a === b) return true;
    if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
      return false;
    }
    if (a !== Object(a) || b !== Object(b)) {
      return false;
    }
    var props = Object.keys(a);
    if (props.length !== Object.keys(b).length) {
      return false;
    }
    return props.every(function (p2) {
      return deepEqual(a[p2], b[p2]);
    });
  }
  function getObjectValueByPath(obj, path, fallback) {
    if (obj == null || !path || typeof path !== "string") return fallback;
    if (obj[path] !== void 0) return obj[path];
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    return getNestedValue(obj, path.split("."), fallback);
  }
  function getPropertyFromItem(item, property, fallback) {
    if (property === true) return item === void 0 ? fallback : item;
    if (property == null || typeof property === "boolean") return fallback;
    if (item !== Object(item)) {
      if (typeof property !== "function") return fallback;
      var value2 = property(item, fallback);
      return typeof value2 === "undefined" ? fallback : value2;
    }
    if (typeof property === "string") return getObjectValueByPath(item, property, fallback);
    if (Array.isArray(property)) return getNestedValue(item, property, fallback);
    if (typeof property !== "function") return fallback;
    var value = property(item, fallback);
    return typeof value === "undefined" ? fallback : value;
  }
  function createRange(length) {
    var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return Array.from({
      length: length
    }, function (v, k) {
      return start + k;
    });
  }
  function convertToUnit(str) {
    var unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
    if (str == null || str === "") {
      return void 0;
    } else if (isNaN(+str)) {
      return String(str);
    } else if (!isFinite(+str)) {
      return void 0;
    } else {
      return "" + Number(str) + unit;
    }
  }
  function isObject(obj) {
    return obj !== null && _typeof(obj) === "object" && !Array.isArray(obj);
  }
  function isPlainObject(obj) {
    var proto;
    return obj !== null && _typeof(obj) === "object" && ((proto = Object.getPrototypeOf(obj)) === Object.prototype || proto === null);
  }
  function refElement(obj) {
    if (obj && "$el" in obj) {
      var el = obj.$el;
      if ((el == null ? void 0 : el.nodeType) === Node.TEXT_NODE) {
        return el.nextElementSibling;
      }
      return el;
    }
    return obj;
  }
  var keyCodes = Object.freeze({
    enter: 13,
    tab: 9,
    "delete": 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34,
    shift: 16
  });
  var keyValues = Object.freeze({
    enter: "Enter",
    tab: "Tab",
    "delete": "Delete",
    esc: "Escape",
    space: "Space",
    up: "ArrowUp",
    down: "ArrowDown",
    left: "ArrowLeft",
    right: "ArrowRight",
    end: "End",
    home: "Home",
    del: "Delete",
    backspace: "Backspace",
    insert: "Insert",
    pageup: "PageUp",
    pagedown: "PageDown",
    shift: "Shift"
  });
  function keys(o) {
    return Object.keys(o);
  }
  function has(obj, key) {
    return key.every(function (k) {
      return obj.hasOwnProperty(k);
    });
  }
  function pick(obj, paths) {
    var found2 = {};
    var keys2 = new Set(Object.keys(obj));
    for (var _iterator31 = _createForOfIteratorHelperLoose(paths), _step33; !(_step33 = _iterator31()).done;) {
      var path = _step33.value;
      if (keys2.has(path)) {
        found2[path] = obj[path];
      }
    }
    return found2;
  }
  function pickWithRest(obj, paths, exclude) {
    var found2 = /* @__PURE__ */Object.create(null);
    var rest = /* @__PURE__ */Object.create(null);
    var _loop24 = function (key) {
      if (paths.some(function (path) {
        return path instanceof RegExp ? path.test(key) : path === key;
      }) && !(exclude == null ? void 0 : exclude.some(function (path) {
        return path === key;
      }))) {
        found2[key] = obj[key];
      } else {
        rest[key] = obj[key];
      }
    };
    for (var key in obj) {
      _loop24(key);
    }
    return [found2, rest];
  }
  function omit(obj, exclude) {
    var clone = _objectSpread({}, obj);
    exclude.forEach(function (prop) {
      return delete clone[prop];
    });
    return clone;
  }
  function only(obj, include) {
    var clone = {};
    include.forEach(function (prop) {
      return clone[prop] = obj[prop];
    });
    return clone;
  }
  var onRE = /^on[^a-z]/;
  var isOn = function (key) {
    return onRE.test(key);
  };
  var bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
  var compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
  function isComposingIgnoreKey(e) {
    return e.isComposing && compositionIgnoreKeys.includes(e.key);
  }
  function filterInputAttrs(attrs) {
    var _pickWithRest = pickWithRest(attrs, [onRE]),
      _pickWithRest2 = _slicedToArray(_pickWithRest, 2),
      events = _pickWithRest2[0],
      props = _pickWithRest2[1];
    var inputEvents = omit(events, bubblingEvents);
    var _pickWithRest3 = pickWithRest(props, ["class", "style", "id", /^data-/]),
      _pickWithRest4 = _slicedToArray(_pickWithRest3, 2),
      rootAttrs = _pickWithRest4[0],
      inputAttrs = _pickWithRest4[1];
    Object.assign(rootAttrs, events);
    Object.assign(inputAttrs, inputEvents);
    return [rootAttrs, inputAttrs];
  }
  function wrapInArray(v) {
    return v == null ? [] : Array.isArray(v) ? v : [v];
  }
  function debounce(fn, delay) {
    var timeoutId = 0;
    var wrap2 = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      clearTimeout(timeoutId);
      timeoutId = setTimeout(function () {
        return fn.apply(void 0, args);
      }, unref(delay));
    };
    wrap2.clear = function () {
      clearTimeout(timeoutId);
    };
    wrap2.immediate = fn;
    return wrap2;
  }
  function clamp(value) {
    var min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    return Math.max(min, Math.min(max, value));
  }
  function getDecimals(value) {
    var trimmedStr = value.toString().trim();
    return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
  }
  function padEnd(str, length) {
    var char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return str + char.repeat(Math.max(0, length - str.length));
  }
  function padStart(str, length) {
    var char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return char.repeat(Math.max(0, length - str.length)) + str;
  }
  function chunk(str) {
    var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var chunked = [];
    var index = 0;
    while (index < str.length) {
      chunked.push(str.substr(index, size));
      index += size;
    }
    return chunked;
  }
  function humanReadableFileSize(bytes) {
    var base2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    if (bytes < base2) {
      return bytes + " B";
    }
    var prefix = base2 === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
    var unit = -1;
    while (Math.abs(bytes) >= base2 && unit < prefix.length - 1) {
      bytes /= base2;
      ++unit;
    }
    return bytes.toFixed(1) + " " + prefix[unit] + "B";
  }
  function mergeDeep() {
    var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var arrayFn = arguments.length > 2 ? arguments[2] : void 0;
    var out = {};
    for (var key in source) {
      out[key] = source[key];
    }
    for (var _key43 in target) {
      var sourceProperty = source[_key43];
      var targetProperty = target[_key43];
      if (isPlainObject(sourceProperty) && isPlainObject(targetProperty)) {
        out[_key43] = mergeDeep(sourceProperty, targetProperty, arrayFn);
        continue;
      }
      if (arrayFn && Array.isArray(sourceProperty) && Array.isArray(targetProperty)) {
        out[_key43] = arrayFn(sourceProperty, targetProperty);
        continue;
      }
      out[_key43] = targetProperty;
    }
    return out;
  }
  function flattenFragments(nodes) {
    return nodes.map(function (node) {
      if (node.type === Fragment$1) {
        return flattenFragments(node.children);
      } else {
        return node;
      }
    }).flat();
  }
  function toKebabCase() {
    var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    if (toKebabCase.cache.has(str)) return toKebabCase.cache.get(str);
    var kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
    toKebabCase.cache.set(str, kebab);
    return kebab;
  }
  toKebabCase.cache = /* @__PURE__ */new Map();
  function findChildrenWithProvide(key, vnode) {
    if (!vnode || _typeof(vnode) !== "object") return [];
    if (Array.isArray(vnode)) {
      return vnode.map(function (child) {
        return findChildrenWithProvide(key, child);
      }).flat(1);
    } else if (vnode.suspense) {
      return findChildrenWithProvide(key, vnode.ssContent);
    } else if (Array.isArray(vnode.children)) {
      return vnode.children.map(function (child) {
        return findChildrenWithProvide(key, child);
      }).flat(1);
    } else if (vnode.component) {
      if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
        return [vnode.component];
      } else if (vnode.component.subTree) {
        return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
      }
    }
    return [];
  }
  var _arr = /* @__PURE__ */new WeakMap();
  var _pointer = /* @__PURE__ */new WeakMap();
  var CircularBuffer = /*#__PURE__*/function () {
    function CircularBuffer(size) {
      _classPrivateFieldInitSpec(this, _arr, []);
      _classPrivateFieldInitSpec(this, _pointer, 0);
      this.size = size;
    }
    var _proto80 = CircularBuffer.prototype;
    _proto80.push = function push(val) {
      _classPrivateFieldGet(_arr, this)[_classPrivateFieldGet(_pointer, this)] = val;
      _classPrivateFieldSet(_pointer, this, (_classPrivateFieldGet(_pointer, this) + 1) % this.size);
    };
    _proto80.values = function values() {
      return _classPrivateFieldGet(_arr, this).slice(_classPrivateFieldGet(_pointer, this)).concat(_classPrivateFieldGet(_arr, this).slice(0, _classPrivateFieldGet(_pointer, this)));
    };
    return CircularBuffer;
  }();
  function getEventCoordinates(e) {
    if ("touches" in e) {
      return {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
      };
    }
    return {
      clientX: e.clientX,
      clientY: e.clientY
    };
  }
  function destructComputed(getter) {
    var refs = reactive({});
    var base2 = computed(getter);
    watchEffect(function () {
      for (var key in base2.value) {
        refs[key] = base2.value[key];
      }
    }, {
      flush: "sync"
    });
    return toRefs(refs);
  }
  function includes(arr, val) {
    return arr.includes(val);
  }
  function eventName(propName) {
    return propName[2].toLowerCase() + propName.slice(3);
  }
  var EventProp = function () {
    return [Function, Array];
  };
  function hasEvent(props, name) {
    name = "on" + capitalize(name);
    return !!(props[name] || props[name + "Once"] || props[name + "Capture"] || props[name + "OnceCapture"] || props[name + "CaptureOnce"]);
  }
  function callEvent(handler) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (Array.isArray(handler)) {
      for (var _iterator32 = _createForOfIteratorHelperLoose(handler), _step34; !(_step34 = _iterator32()).done;) {
        var h2 = _step34.value;
        h2.apply(void 0, args);
      }
    } else if (typeof handler === "function") {
      handler.apply(void 0, args);
    }
  }
  function focusableChildren(el) {
    var filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map(function (s) {
      return "" + s + (filterByTabIndex ? ':not([tabindex="-1"])' : "") + ":not([disabled])";
    }).join(", ");
    return _toConsumableArray(el.querySelectorAll(targets));
  }
  function getNextElement(elements, location2, condition) {
    var _a2;
    var _el;
    var idx = elements.indexOf(document.activeElement);
    var inc = location2 === "next" ? 1 : -1;
    do {
      idx += inc;
      _el = elements[idx];
    } while ((!_el || _el.offsetParent == null || !((_a2 = condition == null ? void 0 : condition(_el)) != null ? _a2 : true)) && idx < elements.length && idx >= 0);
    return _el;
  }
  function focusChild(el, location2) {
    var _a2, _b, _c, _d;
    var focusable = focusableChildren(el);
    if (!location2) {
      if (el === document.activeElement || !el.contains(document.activeElement)) {
        (_a2 = focusable[0]) == null ? void 0 : _a2.focus();
      }
    } else if (location2 === "first") {
      (_b = focusable[0]) == null ? void 0 : _b.focus();
    } else if (location2 === "last") {
      (_c = focusable.at(-1)) == null ? void 0 : _c.focus();
    } else if (typeof location2 === "number") {
      (_d = focusable[location2]) == null ? void 0 : _d.focus();
    } else {
      var _el = getNextElement(focusable, location2);
      if (_el) _el.focus();else focusChild(el, location2 === "next" ? "first" : "last");
    }
  }
  function isEmpty(val) {
    return val === null || val === void 0 || typeof val === "string" && val.trim() === "";
  }
  function noop() {}
  function matchesSelector(el, selector) {
    var supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports("selector(" + selector + ")");
    if (!supportsSelector) return null;
    try {
      return !!el && el.matches(selector);
    } catch (err) {
      return null;
    }
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some(function (child) {
      if (!isVNode(child)) return true;
      if (child.type === Comment) return false;
      return child.type !== Fragment$1 || ensureValidVNode(child.children);
    }) ? vnodes : null;
  }
  function defer(timeout, cb) {
    if (!IN_BROWSER || timeout === 0) {
      cb();
      return function () {};
    }
    var timeoutId = window.setTimeout(cb, timeout);
    return function () {
      return window.clearTimeout(timeoutId);
    };
  }
  function isClickInsideElement(event, targetDiv) {
    var mouseX = event.clientX;
    var mouseY = event.clientY;
    var divRect = targetDiv.getBoundingClientRect();
    var divLeft = divRect.left;
    var divTop = divRect.top;
    var divRight = divRect.right;
    var divBottom = divRect.bottom;
    return mouseX >= divLeft && mouseX <= divRight && mouseY >= divTop && mouseY <= divBottom;
  }
  function templateRef() {
    var el = shallowRef();
    var fn = function (target) {
      el.value = target;
    };
    Object.defineProperty(fn, "value", {
      enumerable: true,
      get: function () {
        return el.value;
      },
      set: function (val) {
        return el.value = val;
      }
    });
    Object.defineProperty(fn, "el", {
      enumerable: true,
      get: function () {
        return refElement(el.value);
      }
    });
    return fn;
  }
  function checkPrintable(e) {
    var isPrintableChar = e.key.length === 1;
    var noModifier = !e.ctrlKey && !e.metaKey && !e.altKey;
    return isPrintableChar && noModifier;
  }
  var block = ["top", "bottom"];
  var inline = ["start", "end", "left", "right"];
  function parseAnchor(anchor, isRtl) {
    var _anchor$split = anchor.split(" "),
      _anchor$split2 = _slicedToArray(_anchor$split, 2),
      side = _anchor$split2[0],
      align = _anchor$split2[1];
    if (!align) {
      align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
    }
    return {
      side: toPhysical(side, isRtl),
      align: toPhysical(align, isRtl)
    };
  }
  function toPhysical(str, isRtl) {
    if (str === "start") return isRtl ? "right" : "left";
    if (str === "end") return isRtl ? "left" : "right";
    return str;
  }
  function flipSide(anchor) {
    return {
      side: {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[anchor.side],
      align: anchor.align
    };
  }
  function flipAlign(anchor) {
    return {
      side: anchor.side,
      align: {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }[anchor.align]
    };
  }
  function flipCorner(anchor) {
    return {
      side: anchor.align,
      align: anchor.side
    };
  }
  function getAxis(anchor) {
    return includes(block, anchor.side) ? "y" : "x";
  }
  var Box = /*#__PURE__*/function () {
    function Box(_ref) {
      var x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    return _createClass(Box, [{
      key: "top",
      get: function () {
        return this.y;
      }
    }, {
      key: "bottom",
      get: function () {
        return this.y + this.height;
      }
    }, {
      key: "left",
      get: function () {
        return this.x;
      }
    }, {
      key: "right",
      get: function () {
        return this.x + this.width;
      }
    }]);
  }();
  function getOverflow(a, b) {
    return {
      x: {
        before: Math.max(0, b.left - a.left),
        after: Math.max(0, a.right - b.right)
      },
      y: {
        before: Math.max(0, b.top - a.top),
        after: Math.max(0, a.bottom - b.bottom)
      }
    };
  }
  function getTargetBox(target) {
    if (Array.isArray(target)) {
      return new Box({
        x: target[0],
        y: target[1],
        width: 0,
        height: 0
      });
    } else {
      return target.getBoundingClientRect();
    }
  }
  function nullifyTransforms(el) {
    var rect = el.getBoundingClientRect();
    var style2 = getComputedStyle(el);
    var tx = style2.transform;
    if (tx) {
      var ta, sx, sy, dx, dy;
      if (tx.startsWith("matrix3d(")) {
        ta = tx.slice(9, -1).split(/, /);
        sx = +ta[0];
        sy = +ta[5];
        dx = +ta[12];
        dy = +ta[13];
      } else if (tx.startsWith("matrix(")) {
        ta = tx.slice(7, -1).split(/, /);
        sx = +ta[0];
        sy = +ta[3];
        dx = +ta[4];
        dy = +ta[5];
      } else {
        return new Box(rect);
      }
      var to = style2.transformOrigin;
      var x = rect.x - dx - (1 - sx) * parseFloat(to);
      var y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
      var w = sx ? rect.width / sx : el.offsetWidth + 1;
      var h2 = sy ? rect.height / sy : el.offsetHeight + 1;
      return new Box({
        x: x,
        y: y,
        width: w,
        height: h2
      });
    } else {
      return new Box(rect);
    }
  }
  function animate(el, keyframes, options) {
    if (typeof el.animate === "undefined") return {
      finished: Promise.resolve()
    };
    var animation;
    try {
      animation = el.animate(keyframes, options);
    } catch (err) {
      return {
        finished: Promise.resolve()
      };
    }
    if (typeof animation.finished === "undefined") {
      animation.finished = new Promise(function (resolve2) {
        animation.onfinish = function () {
          resolve2(animation);
        };
      });
    }
    return animation;
  }
  var handlers = /* @__PURE__ */new WeakMap();
  function bindProps(el, props) {
    Object.keys(props).forEach(function (k) {
      var _a2;
      if (isOn(k)) {
        var name = eventName(k);
        var handler = handlers.get(el);
        if (props[k] == null) {
          handler == null ? void 0 : handler.forEach(function (v) {
            var _v = _slicedToArray(v, 2),
              n = _v[0],
              fn = _v[1];
            if (n === name) {
              el.removeEventListener(name, fn);
              handler.delete(v);
            }
          });
        } else if (!handler || !((_a2 = _toConsumableArray(handler)) == null ? void 0 : _a2.some(function (v) {
          return v[0] === name && v[1] === props[k];
        }))) {
          el.addEventListener(name, props[k]);
          var _handler = handler || /* @__PURE__ */new Set();
          _handler.add([name, props[k]]);
          if (!handlers.has(el)) handlers.set(el, _handler);
        }
      } else {
        if (props[k] == null) {
          el.removeAttribute(k);
        } else {
          el.setAttribute(k, props[k]);
        }
      }
    });
  }
  function unbindProps(el, props) {
    Object.keys(props).forEach(function (k) {
      if (isOn(k)) {
        var name = eventName(k);
        var handler = handlers.get(el);
        handler == null ? void 0 : handler.forEach(function (v) {
          var _v2 = _slicedToArray(v, 2),
            n = _v2[0],
            fn = _v2[1];
          if (n === name) {
            el.removeEventListener(name, fn);
            handler.delete(v);
          }
        });
      } else {
        el.removeAttribute(k);
      }
    });
  }
  var mainTRC = 2.4;
  var Rco = 0.2126729;
  var Gco = 0.7151522;
  var Bco = 0.072175;
  var normBG = 0.55;
  var normTXT = 0.58;
  var revTXT = 0.57;
  var revBG = 0.62;
  var blkThrs = 0.03;
  var blkClmp = 1.45;
  var deltaYmin = 5e-4;
  var scaleBoW = 1.25;
  var scaleWoB = 1.25;
  var loConThresh = 0.078;
  var loConFactor = 12.82051282051282;
  var loConOffset = 0.06;
  var loClip = 1e-3;
  function APCAcontrast(text, background) {
    var Rtxt = Math.pow(text.r / 255, mainTRC);
    var Gtxt = Math.pow(text.g / 255, mainTRC);
    var Btxt = Math.pow(text.b / 255, mainTRC);
    var Rbg = Math.pow(background.r / 255, mainTRC);
    var Gbg = Math.pow(background.g / 255, mainTRC);
    var Bbg = Math.pow(background.b / 255, mainTRC);
    var Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
    var Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
    if (Ytxt <= blkThrs) Ytxt += Math.pow(blkThrs - Ytxt, blkClmp);
    if (Ybg <= blkThrs) Ybg += Math.pow(blkThrs - Ybg, blkClmp);
    if (Math.abs(Ybg - Ytxt) < deltaYmin) return 0;
    var outputContrast;
    if (Ybg > Ytxt) {
      var SAPC = (Math.pow(Ybg, normBG) - Math.pow(Ytxt, normTXT)) * scaleBoW;
      outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
    } else {
      var _SAPC = (Math.pow(Ybg, revBG) - Math.pow(Ytxt, revTXT)) * scaleWoB;
      outputContrast = _SAPC > -loClip ? 0 : _SAPC > -loConThresh ? _SAPC - _SAPC * loConFactor * loConOffset : _SAPC + loConOffset;
    }
    return outputContrast * 100;
  }
  function consoleWarn(message) {
    warn$2("Vuetify: " + message);
  }
  function consoleError(message) {
    warn$2("Vuetify error: " + message);
  }
  function deprecate(original, replacement) {
    replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map(function (s) {
      return "'" + s + "'";
    }).join(", ") + (" or '" + replacement.at(-1) + "'") : "'" + replacement + "'";
    warn$2("[Vuetify UPGRADE] '" + original + "' is deprecated, use " + replacement + " instead.");
  }
  var delta = 0.20689655172413793;
  var cielabForwardTransform = function (t) {
    return t > Math.pow(delta, 3) ? Math.cbrt(t) : t / (3 * Math.pow(delta, 2)) + 4 / 29;
  };
  var cielabReverseTransform = function (t) {
    return t > delta ? Math.pow(t, 3) : 3 * Math.pow(delta, 2) * (t - 4 / 29);
  };
  function fromXYZ$1(xyz) {
    var transform2 = cielabForwardTransform;
    var transformedY = transform2(xyz[1]);
    return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
  }
  function toXYZ$1(lab) {
    var transform2 = cielabReverseTransform;
    var Ln = (lab[0] + 16) / 116;
    return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
  }
  var srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
  var srgbForwardTransform = function (C) {
    return C <= 31308e-7 ? C * 12.92 : 1.055 * Math.pow(C, 1 / 2.4) - 0.055;
  };
  var srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
  var srgbReverseTransform = function (C) {
    return C <= 0.04045 ? C / 12.92 : Math.pow((C + 0.055) / 1.055, 2.4);
  };
  function fromXYZ(xyz) {
    var rgb2 = Array(3);
    var transform2 = srgbForwardTransform;
    var matrix = srgbForwardMatrix;
    for (var _i258 = 0; _i258 < 3; ++_i258) {
      rgb2[_i258] = Math.round(clamp(transform2(matrix[_i258][0] * xyz[0] + matrix[_i258][1] * xyz[1] + matrix[_i258][2] * xyz[2])) * 255);
    }
    return {
      r: rgb2[0],
      g: rgb2[1],
      b: rgb2[2]
    };
  }
  function toXYZ(_ref) {
    var r = _ref.r,
      g2 = _ref.g,
      b = _ref.b;
    var xyz = [0, 0, 0];
    var transform2 = srgbReverseTransform;
    var matrix = srgbReverseMatrix;
    r = transform2(r / 255);
    g2 = transform2(g2 / 255);
    b = transform2(b / 255);
    for (var _i259 = 0; _i259 < 3; ++_i259) {
      xyz[_i259] = matrix[_i259][0] * r + matrix[_i259][1] * g2 + matrix[_i259][2] * b;
    }
    return xyz;
  }
  function isCssColor(color) {
    return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
  }
  function isParsableColor(color) {
    return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
  }
  var cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
  var mappers = {
    rgb: function (r, g2, b, a) {
      return {
        r: r,
        g: g2,
        b: b,
        a: a
      };
    },
    rgba: function (r, g2, b, a) {
      return {
        r: r,
        g: g2,
        b: b,
        a: a
      };
    },
    hsl: function (h2, s, l, a) {
      return HSLtoRGB({
        h: h2,
        s: s,
        l: l,
        a: a
      });
    },
    hsla: function (h2, s, l, a) {
      return HSLtoRGB({
        h: h2,
        s: s,
        l: l,
        a: a
      });
    },
    hsv: function (h2, s, v, a) {
      return HSVtoRGB({
        h: h2,
        s: s,
        v: v,
        a: a
      });
    },
    hsva: function (h2, s, v, a) {
      return HSVtoRGB({
        h: h2,
        s: s,
        v: v,
        a: a
      });
    }
  };
  function parseColor(color) {
    if (typeof color === "number") {
      if (isNaN(color) || color < 0 || color > 16777215) {
        consoleWarn("'" + color + "' is not a valid hex color");
      }
      return {
        r: (color & 16711680) >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    } else if (typeof color === "string" && cssColorRe.test(color)) {
      var _color$match = color.match(cssColorRe),
        groups = _color$match.groups;
      var fn = groups.fn,
        values = groups.values;
      var realValues = values.split(/,\s*/).map(function (v) {
        if (v.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
          return parseFloat(v) / 100;
        } else {
          return parseFloat(v);
        }
      });
      return mappers[fn].apply(mappers, _toConsumableArray(realValues));
    } else if (typeof color === "string") {
      var hex2 = color.startsWith("#") ? color.slice(1) : color;
      if ([3, 4].includes(hex2.length)) {
        hex2 = hex2.split("").map(function (char) {
          return char + char;
        }).join("");
      } else if (![6, 8].includes(hex2.length)) {
        consoleWarn("'" + color + "' is not a valid hex(a) color");
      }
      var int2 = parseInt(hex2, 16);
      if (isNaN(int2) || int2 < 0 || int2 > 4294967295) {
        consoleWarn("'" + color + "' is not a valid hex(a) color");
      }
      return HexToRGB(hex2);
    } else if (_typeof(color) === "object") {
      if (has(color, ["r", "g", "b"])) {
        return color;
      } else if (has(color, ["h", "s", "l"])) {
        return HSVtoRGB(HSLtoHSV(color));
      } else if (has(color, ["h", "s", "v"])) {
        return HSVtoRGB(color);
      }
    }
    throw new TypeError("Invalid color: " + (color == null ? color : String(color) || color.constructor.name) + "\nExpected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number");
  }
  function HSVtoRGB(hsva) {
    var h2 = hsva.h,
      s = hsva.s,
      v = hsva.v,
      a = hsva.a;
    var f = function (n) {
      var k = (n + h2 / 60) % 6;
      return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    };
    var rgb2 = [f(5), f(3), f(1)].map(function (v2) {
      return Math.round(v2 * 255);
    });
    return {
      r: rgb2[0],
      g: rgb2[1],
      b: rgb2[2],
      a: a
    };
  }
  function HSLtoRGB(hsla2) {
    return HSVtoRGB(HSLtoHSV(hsla2));
  }
  function RGBtoHSV(rgba2) {
    if (!rgba2) return {
      h: 0,
      s: 1,
      v: 1,
      a: 1
    };
    var r = rgba2.r / 255;
    var g2 = rgba2.g / 255;
    var b = rgba2.b / 255;
    var max = Math.max(r, g2, b);
    var min = Math.min(r, g2, b);
    var h2 = 0;
    if (max !== min) {
      if (max === r) {
        h2 = 60 * (0 + (g2 - b) / (max - min));
      } else if (max === g2) {
        h2 = 60 * (2 + (b - r) / (max - min));
      } else if (max === b) {
        h2 = 60 * (4 + (r - g2) / (max - min));
      }
    }
    if (h2 < 0) h2 = h2 + 360;
    var s = max === 0 ? 0 : (max - min) / max;
    var hsv = [h2, s, max];
    return {
      h: hsv[0],
      s: hsv[1],
      v: hsv[2],
      a: rgba2.a
    };
  }
  function HSVtoHSL(hsva) {
    var h2 = hsva.h,
      s = hsva.s,
      v = hsva.v,
      a = hsva.a;
    var l = v - v * s / 2;
    var sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
    return {
      h: h2,
      s: sprime,
      l: l,
      a: a
    };
  }
  function HSLtoHSV(hsl2) {
    var h2 = hsl2.h,
      s = hsl2.s,
      l = hsl2.l,
      a = hsl2.a;
    var v = l + s * Math.min(l, 1 - l);
    var sprime = v === 0 ? 0 : 2 - 2 * l / v;
    return {
      h: h2,
      s: sprime,
      v: v,
      a: a
    };
  }
  function RGBtoCSS(_ref) {
    var r = _ref.r,
      g2 = _ref.g,
      b = _ref.b,
      a = _ref.a;
    return a === void 0 ? "rgb(" + r + ", " + g2 + ", " + b + ")" : "rgba(" + r + ", " + g2 + ", " + b + ", " + a + ")";
  }
  function HSVtoCSS(hsva) {
    return RGBtoCSS(HSVtoRGB(hsva));
  }
  function toHex(v) {
    var h2 = Math.round(v).toString(16);
    return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
  }
  function RGBtoHex(_ref2) {
    var r = _ref2.r,
      g2 = _ref2.g,
      b = _ref2.b,
      a = _ref2.a;
    return "#" + [toHex(r), toHex(g2), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("");
  }
  function HexToRGB(hex2) {
    hex2 = parseHex(hex2);
    var _chunk$map = chunk(hex2, 2).map(function (c) {
        return parseInt(c, 16);
      }),
      _chunk$map2 = _slicedToArray(_chunk$map, 4),
      r = _chunk$map2[0],
      g2 = _chunk$map2[1],
      b = _chunk$map2[2],
      a = _chunk$map2[3];
    a = a === void 0 ? a : a / 255;
    return {
      r: r,
      g: g2,
      b: b,
      a: a
    };
  }
  function HexToHSV(hex2) {
    var rgb2 = HexToRGB(hex2);
    return RGBtoHSV(rgb2);
  }
  function HSVtoHex(hsva) {
    return RGBtoHex(HSVtoRGB(hsva));
  }
  function parseHex(hex2) {
    if (hex2.startsWith("#")) {
      hex2 = hex2.slice(1);
    }
    hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
    if (hex2.length === 3 || hex2.length === 4) {
      hex2 = hex2.split("").map(function (x) {
        return x + x;
      }).join("");
    }
    if (hex2.length !== 6) {
      hex2 = padEnd(padEnd(hex2, 6), 8, "F");
    }
    return hex2;
  }
  function lighten(value, amount) {
    var lab = fromXYZ$1(toXYZ(value));
    lab[0] = lab[0] + amount * 10;
    return fromXYZ(toXYZ$1(lab));
  }
  function darken(value, amount) {
    var lab = fromXYZ$1(toXYZ(value));
    lab[0] = lab[0] - amount * 10;
    return fromXYZ(toXYZ$1(lab));
  }
  function getLuma(color) {
    var rgb2 = parseColor(color);
    return toXYZ(rgb2)[1];
  }
  function getContrast(first2, second) {
    var l1 = getLuma(first2);
    var l2 = getLuma(second);
    var light = Math.max(l1, l2);
    var dark = Math.min(l1, l2);
    return (light + 0.05) / (dark + 0.05);
  }
  function getForeground(color) {
    var blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
    var whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
    return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
  }
  function propsFactory(props, source) {
    return function (defaults) {
      return Object.keys(props).reduce(function (obj, prop) {
        var isObjectDefinition = _typeof(props[prop]) === "object" && props[prop] != null && !Array.isArray(props[prop]);
        var definition = isObjectDefinition ? props[prop] : {
          type: props[prop]
        };
        if (defaults && prop in defaults) {
          obj[prop] = _objectSpread(_objectSpread({}, definition), {}, {
            "default": defaults[prop]
          });
        } else {
          obj[prop] = definition;
        }
        if (source && !obj[prop].source) {
          obj[prop].source = source;
        }
        return obj;
      }, {});
    };
  }
  var makeComponentProps = propsFactory({
    "class": [String, Array, Object],
    style: {
      type: [String, Array, Object],
      "default": null
    }
  }, "component");
  function getCurrentInstance(name, message) {
    var vm = getCurrentInstance$1();
    if (!vm) {
      throw new Error("[Vuetify] " + name + " " + (message || "must be called from inside a setup function"));
    }
    return vm;
  }
  function getCurrentInstanceName() {
    var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
    var vm = getCurrentInstance(name).type;
    return toKebabCase((vm == null ? void 0 : vm.aliasName) || (vm == null ? void 0 : vm.name));
  }
  var _uid = 0;
  var _map = /* @__PURE__ */new WeakMap();
  function getUid() {
    var vm = getCurrentInstance("getUid");
    if (_map.has(vm)) return _map.get(vm);else {
      var uid2 = _uid++;
      _map.set(vm, uid2);
      return uid2;
    }
  }
  getUid.reset = function () {
    _uid = 0;
    _map = /* @__PURE__ */new WeakMap();
  };
  function injectSelf(key) {
    var vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance("injectSelf");
    var provides = vm.provides;
    if (provides && key in provides) {
      return provides[key];
    }
    return void 0;
  }
  var DefaultsSymbol = Symbol.for("vuetify:defaults");
  function createDefaults(options) {
    return ref(options);
  }
  function injectDefaults() {
    var defaults = inject$1(DefaultsSymbol);
    if (!defaults) throw new Error("[Vuetify] Could not find defaults instance");
    return defaults;
  }
  function provideDefaults(defaults, options) {
    var injectedDefaults = injectDefaults();
    var providedDefaults = ref(defaults);
    var newDefaults = computed(function () {
      var disabled = unref(options == null ? void 0 : options.disabled);
      if (disabled) return injectedDefaults.value;
      var scoped = unref(options == null ? void 0 : options.scoped);
      var reset = unref(options == null ? void 0 : options.reset);
      var root = unref(options == null ? void 0 : options.root);
      if (providedDefaults.value == null && !(scoped || reset || root)) return injectedDefaults.value;
      var properties = mergeDeep(providedDefaults.value, {
        prev: injectedDefaults.value
      });
      if (scoped) return properties;
      if (reset || root) {
        var len = Number(reset || Infinity);
        for (var _i260 = 0; _i260 <= len; _i260++) {
          if (!properties || !("prev" in properties)) {
            break;
          }
          properties = properties.prev;
        }
        if (properties && typeof root === "string" && root in properties) {
          properties = mergeDeep(mergeDeep(properties, {
            prev: properties
          }), properties[root]);
        }
        return properties;
      }
      return properties.prev ? mergeDeep(properties.prev, properties) : properties;
    });
    provide(DefaultsSymbol, newDefaults);
    return newDefaults;
  }
  function propIsDefined(vnode, prop) {
    var _a2, _b;
    return typeof ((_a2 = vnode.props) == null ? void 0 : _a2[prop]) !== "undefined" || typeof ((_b = vnode.props) == null ? void 0 : _b[toKebabCase(prop)]) !== "undefined";
  }
  function internalUseDefaults() {
    var _a2;
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var name = arguments.length > 1 ? arguments[1] : void 0;
    var defaults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
    var vm = getCurrentInstance("useDefaults");
    name = (_a2 = name != null ? name : vm.type.name) != null ? _a2 : vm.type.__name;
    if (!name) {
      throw new Error("[Vuetify] Could not determine component name");
    }
    var componentDefaults = computed(function () {
      var _a3, _b;
      return (_b = defaults.value) == null ? void 0 : _b[(_a3 = props._as) != null ? _a3 : name];
    });
    var _props = new Proxy(props, {
      get: function (target, prop) {
        var _a3, _b, _c, _d, _e, _f, _g;
        var propValue = Reflect.get(target, prop);
        if (prop === "class" || prop === "style") {
          return [(_a3 = componentDefaults.value) == null ? void 0 : _a3[prop], propValue].filter(function (v) {
            return v != null;
          });
        } else if (typeof prop === "string" && !propIsDefined(vm.vnode, prop)) {
          return ((_b = componentDefaults.value) == null ? void 0 : _b[prop]) !== void 0 ? (_c = componentDefaults.value) == null ? void 0 : _c[prop] : ((_e = (_d = defaults.value) == null ? void 0 : _d.global) == null ? void 0 : _e[prop]) !== void 0 ? (_g = (_f = defaults.value) == null ? void 0 : _f.global) == null ? void 0 : _g[prop] : propValue;
        }
        return propValue;
      }
    });
    var _subcomponentDefaults = shallowRef();
    watchEffect(function () {
      if (componentDefaults.value) {
        var subComponents = Object.entries(componentDefaults.value).filter(function (_ref) {
          var _ref241 = _slicedToArray(_ref, 1),
            key = _ref241[0];
          return key.startsWith(key[0].toUpperCase());
        });
        _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
      } else {
        _subcomponentDefaults.value = void 0;
      }
    });
    function provideSubDefaults() {
      var injected = injectSelf(DefaultsSymbol, vm);
      provide(DefaultsSymbol, computed(function () {
        var _a3;
        return _subcomponentDefaults.value ? mergeDeep((_a3 = injected == null ? void 0 : injected.value) != null ? _a3 : {}, _subcomponentDefaults.value) : injected == null ? void 0 : injected.value;
      }));
    }
    return {
      props: _props,
      provideSubDefaults: provideSubDefaults
    };
  }
  function defineComponent(options) {
    var _a2, _b;
    options._setup = (_a2 = options._setup) != null ? _a2 : options.setup;
    if (!options.name) {
      consoleWarn("The component is missing an explicit name, unable to generate default prop value");
      return options;
    }
    if (options._setup) {
      options.props = propsFactory((_b = options.props) != null ? _b : {}, options.name)();
      var propKeys = Object.keys(options.props).filter(function (key) {
        return key !== "class" && key !== "style";
      });
      options.filterProps = function filterProps(props) {
        return pick(props, propKeys);
      };
      options.props._as = String;
      options.setup = function setup(props, ctx) {
        var _a3;
        var defaults = injectDefaults();
        if (!defaults.value) return options._setup(props, ctx);
        var _internalUseDefaults = internalUseDefaults(props, (_a3 = props._as) != null ? _a3 : options.name, defaults),
          _props = _internalUseDefaults.props,
          provideSubDefaults = _internalUseDefaults.provideSubDefaults;
        var setupBindings = options._setup(_props, ctx);
        provideSubDefaults();
        return setupBindings;
      };
    }
    return options;
  }
  function genericComponent() {
    var exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return function (options) {
      return (exposeDefaults ? defineComponent : defineComponent$1)(options);
    };
  }
  function defineFunctionalComponent(props, render2) {
    render2.props = props;
    return render2;
  }
  function createSimpleFunctional(klass) {
    var tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
    var name = arguments.length > 2 ? arguments[2] : void 0;
    return genericComponent()({
      name: name != null ? name : capitalize(camelize(klass.replace(/__/g, "-"))),
      props: _objectSpread({
        tag: {
          type: String,
          "default": tag
        }
      }, makeComponentProps()),
      setup: function (props, _ref) {
        var slots = _ref.slots;
        return function () {
          var _a2;
          return h(props.tag, {
            "class": [klass, props.class],
            style: props.style
          }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
        };
      }
    });
  }
  function attachedRoot(node) {
    if (typeof node.getRootNode !== "function") {
      while (node.parentNode) node = node.parentNode;
      if (node !== document) return null;
      return document;
    }
    var root = node.getRootNode();
    if (root !== document && root.getRootNode({
      composed: true
    }) !== document) return null;
    return root;
  }
  var standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
  var deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
  var acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
  function getPrefixedEventHandlers(attrs, suffix, getData) {
    return Object.keys(attrs).filter(function (key) {
      return isOn(key) && key.endsWith(suffix);
    }).reduce(function (acc, key) {
      acc[key.slice(0, -suffix.length)] = function (event) {
        return attrs[key](event, getData(event));
      };
      return acc;
    }, {});
  }
  function getScrollParent(el) {
    var includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    while (el) {
      if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el)) return el;
      el = el.parentElement;
    }
    return document.scrollingElement;
  }
  function getScrollParents(el, stopAt) {
    var elements = [];
    if (stopAt && el && !stopAt.contains(el)) return elements;
    while (el) {
      if (hasScrollbar(el)) elements.push(el);
      if (el === stopAt) break;
      el = el.parentElement;
    }
    return elements;
  }
  function hasScrollbar(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
    var style2 = window.getComputedStyle(el);
    return style2.overflowY === "scroll" || style2.overflowY === "auto" && el.scrollHeight > el.clientHeight;
  }
  function isPotentiallyScrollable(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
    var style2 = window.getComputedStyle(el);
    return ["scroll", "auto"].includes(style2.overflowY);
  }
  function isFixedPosition(el) {
    while (el) {
      if (window.getComputedStyle(el).position === "fixed") {
        return true;
      }
      el = el.offsetParent;
    }
    return false;
  }
  function useRender(render2) {
    var vm = getCurrentInstance("useRender");
    vm.render = render2;
  }
  function useProxiedModel(props, prop, defaultValue) {
    var transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function (v) {
      return v;
    };
    var transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function (v) {
      return v;
    };
    var vm = getCurrentInstance("useProxiedModel");
    var internal = ref(props[prop] !== void 0 ? props[prop] : defaultValue);
    var kebabProp = toKebabCase(prop);
    var checkKebab = kebabProp !== prop;
    var isControlled = checkKebab ? computed(function () {
      var _a2, _b, _c, _d;
      void props[prop];
      return !!((((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop)) || ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty(kebabProp))) && (((_c = vm.vnode.props) == null ? void 0 : _c.hasOwnProperty("onUpdate:" + prop)) || ((_d = vm.vnode.props) == null ? void 0 : _d.hasOwnProperty("onUpdate:" + kebabProp))));
    }) : computed(function () {
      var _a2, _b;
      void props[prop];
      return !!(((_a2 = vm.vnode.props) == null ? void 0 : _a2.hasOwnProperty(prop)) && ((_b = vm.vnode.props) == null ? void 0 : _b.hasOwnProperty("onUpdate:" + prop)));
    });
    useToggleScope(function () {
      return !isControlled.value;
    }, function () {
      watch(function () {
        return props[prop];
      }, function (val) {
        internal.value = val;
      });
    });
    var model = computed({
      get: function () {
        var externalValue = props[prop];
        return transformIn(isControlled.value ? externalValue : internal.value);
      },
      set: function (internalValue) {
        var newValue = transformOut(internalValue);
        var value = toRaw(isControlled.value ? props[prop] : internal.value);
        if (value === newValue || transformIn(value) === internalValue) {
          return;
        }
        internal.value = newValue;
        vm == null ? void 0 : vm.emit("update:" + prop, newValue);
      }
    });
    Object.defineProperty(model, "externalValue", {
      get: function () {
        return isControlled.value ? props[prop] : internal.value;
      }
    });
    return model;
  }
  var en = {
    badge: "Badge",
    open: "Open",
    close: "Close",
    dismiss: "Dismiss",
    confirmEdit: {
      ok: "OK",
      cancel: "Cancel"
    },
    dataIterator: {
      noResultsText: "No matching records found",
      loadingText: "Loading items..."
    },
    dataTable: {
      itemsPerPageText: "Rows per page:",
      ariaLabel: {
        sortDescending: "Sorted descending.",
        sortAscending: "Sorted ascending.",
        sortNone: "Not sorted.",
        activateNone: "Activate to remove sorting.",
        activateDescending: "Activate to sort descending.",
        activateAscending: "Activate to sort ascending."
      },
      sortBy: "Sort by"
    },
    dataFooter: {
      itemsPerPageText: "Items per page:",
      itemsPerPageAll: "All",
      nextPage: "Next page",
      prevPage: "Previous page",
      firstPage: "First page",
      lastPage: "Last page",
      pageText: "{0}-{1} of {2}"
    },
    dateRangeInput: {
      divider: "to"
    },
    datePicker: {
      itemsSelected: "{0} selected",
      range: {
        title: "Select dates",
        header: "Enter dates"
      },
      title: "Select date",
      header: "Enter date",
      input: {
        placeholder: "Enter date"
      }
    },
    noDataText: "No data available",
    carousel: {
      prev: "Previous visual",
      next: "Next visual",
      ariaLabel: {
        delimiter: "Carousel slide {0} of {1}"
      }
    },
    calendar: {
      moreEvents: "{0} more",
      today: "Today"
    },
    input: {
      clear: "Clear {0}",
      prependAction: "{0} prepended action",
      appendAction: "{0} appended action",
      otp: "Please enter OTP character {0}"
    },
    fileInput: {
      counter: "{0} files",
      counterSize: "{0} files ({1} in total)"
    },
    timePicker: {
      am: "AM",
      pm: "PM",
      title: "Select Time"
    },
    pagination: {
      ariaLabel: {
        root: "Pagination Navigation",
        next: "Next page",
        previous: "Previous page",
        page: "Go to page {0}",
        currentPage: "Page {0}, Current page",
        first: "First page",
        last: "Last page"
      }
    },
    stepper: {
      next: "Next",
      prev: "Previous"
    },
    rating: {
      ariaLabel: {
        item: "Rating {0} of {1}"
      }
    },
    loading: "Loading...",
    infiniteScroll: {
      loadMore: "Load more",
      empty: "No more"
    }
  };
  var LANG_PREFIX = "$vuetify.";
  var replace = function (str, params) {
    return str.replace(/\{(\d+)\}/g, function (match, index) {
      return String(params[+index]);
    });
  };
  var createTranslateFunction = function (current, fallback, messages) {
    return function (key) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      if (!key.startsWith(LANG_PREFIX)) {
        return replace(key, params);
      }
      var shortKey = key.replace(LANG_PREFIX, "");
      var currentLocale = current.value && messages.value[current.value];
      var fallbackLocale = fallback.value && messages.value[fallback.value];
      var str = getObjectValueByPath(currentLocale, shortKey, null);
      if (!str) {
        consoleWarn("Translation key \"" + key + "\" not found in \"" + current.value + "\", trying fallback locale");
        str = getObjectValueByPath(fallbackLocale, shortKey, null);
      }
      if (!str) {
        consoleError("Translation key \"" + key + "\" not found in fallback");
        str = key;
      }
      if (typeof str !== "string") {
        consoleError("Translation key \"" + key + "\" has a non-string value");
        str = key;
      }
      return replace(str, params);
    };
  };
  function createNumberFunction(current, fallback) {
    return function (value, options) {
      var numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
      return numberFormat.format(value);
    };
  }
  function useProvided(props, prop, provided) {
    var _a2, _b;
    var internal = useProxiedModel(props, prop, (_a2 = props[prop]) != null ? _a2 : provided.value);
    internal.value = (_b = props[prop]) != null ? _b : provided.value;
    watch(provided, function (v) {
      if (props[prop] == null) {
        internal.value = provided.value;
      }
    });
    return internal;
  }
  function createProvideFunction(state) {
    return function (props) {
      var current = useProvided(props, "locale", state.current);
      var fallback = useProvided(props, "fallback", state.fallback);
      var messages = useProvided(props, "messages", state.messages);
      return {
        name: "vuetify",
        current: current,
        fallback: fallback,
        messages: messages,
        t: createTranslateFunction(current, fallback, messages),
        n: createNumberFunction(current, fallback),
        provide: createProvideFunction({
          current: current,
          fallback: fallback,
          messages: messages
        })
      };
    };
  }
  function createVuetifyAdapter(options) {
    var _a2, _b;
    var current = shallowRef((_a2 = options == null ? void 0 : options.locale) != null ? _a2 : "en");
    var fallback = shallowRef((_b = options == null ? void 0 : options.fallback) != null ? _b : "en");
    var messages = ref(_objectSpread({
      en: en
    }, options == null ? void 0 : options.messages));
    return {
      name: "vuetify",
      current: current,
      fallback: fallback,
      messages: messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current: current,
        fallback: fallback,
        messages: messages
      })
    };
  }
  var LocaleSymbol = Symbol.for("vuetify:locale");
  function isLocaleInstance(obj) {
    return obj.name != null;
  }
  function createLocale(options) {
    var i18n = (options == null ? void 0 : options.adapter) && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
    var rtl = createRtl(i18n, options);
    return _objectSpread(_objectSpread({}, i18n), rtl);
  }
  function useLocale() {
    var locale = inject$1(LocaleSymbol);
    if (!locale) throw new Error("[Vuetify] Could not find injected locale instance");
    return locale;
  }
  function provideLocale(props) {
    var locale = inject$1(LocaleSymbol);
    if (!locale) throw new Error("[Vuetify] Could not find injected locale instance");
    var i18n = locale.provide(props);
    var rtl = provideRtl(i18n, locale.rtl, props);
    var data = _objectSpread(_objectSpread({}, i18n), rtl);
    provide(LocaleSymbol, data);
    return data;
  }
  function genDefaults$3() {
    return {
      af: false,
      ar: true,
      bg: false,
      ca: false,
      ckb: false,
      cs: false,
      de: false,
      el: false,
      en: false,
      es: false,
      et: false,
      fa: true,
      fi: false,
      fr: false,
      hr: false,
      hu: false,
      he: true,
      id: false,
      it: false,
      ja: false,
      km: false,
      ko: false,
      lv: false,
      lt: false,
      nl: false,
      no: false,
      pl: false,
      pt: false,
      ro: false,
      ru: false,
      sk: false,
      sl: false,
      srCyrl: false,
      srLatn: false,
      sv: false,
      th: false,
      tr: false,
      az: false,
      uk: false,
      vi: false,
      zhHans: false,
      zhHant: false
    };
  }
  function createRtl(i18n, options) {
    var _a2;
    var rtl = ref((_a2 = options == null ? void 0 : options.rtl) != null ? _a2 : genDefaults$3());
    var isRtl = computed(function () {
      var _a3;
      return (_a3 = rtl.value[i18n.current.value]) != null ? _a3 : false;
    });
    return {
      isRtl: isRtl,
      rtl: rtl,
      rtlClasses: computed(function () {
        return "v-locale--is-" + (isRtl.value ? "rtl" : "ltr");
      })
    };
  }
  function provideRtl(locale, rtl, props) {
    var isRtl = computed(function () {
      var _a2, _b;
      return (_b = (_a2 = props.rtl) != null ? _a2 : rtl.value[locale.current.value]) != null ? _b : false;
    });
    return {
      isRtl: isRtl,
      rtl: rtl,
      rtlClasses: computed(function () {
        return "v-locale--is-" + (isRtl.value ? "rtl" : "ltr");
      })
    };
  }
  function useRtl() {
    var locale = inject$1(LocaleSymbol);
    if (!locale) throw new Error("[Vuetify] Could not find injected rtl instance");
    return {
      isRtl: locale.isRtl,
      rtlClasses: locale.rtlClasses
    };
  }
  var firstDay = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AG: 0,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AS: 0,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BD: 0,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BR: 0,
    BS: 0,
    BT: 0,
    BW: 0,
    BY: 1,
    BZ: 0,
    CA: 0,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CO: 0,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DM: 0,
    DO: 0,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    ET: 0,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    "GB-alt-variant": 0,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    GT: 0,
    GU: 0,
    HK: 0,
    HN: 0,
    HR: 1,
    HU: 1,
    ID: 0,
    IE: 1,
    IL: 0,
    IN: 0,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JM: 0,
    JO: 6,
    JP: 0,
    KE: 0,
    KG: 1,
    KH: 0,
    KR: 0,
    KW: 6,
    KZ: 1,
    LA: 0,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MH: 0,
    MK: 1,
    MM: 0,
    MN: 1,
    MO: 0,
    MQ: 1,
    MT: 0,
    MV: 5,
    MX: 0,
    MY: 1,
    MZ: 0,
    NI: 0,
    NL: 1,
    NO: 1,
    NP: 0,
    NZ: 1,
    OM: 6,
    PA: 0,
    PE: 0,
    PH: 0,
    PK: 0,
    PL: 1,
    PR: 0,
    PT: 0,
    PY: 0,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SA: 0,
    SD: 6,
    SE: 1,
    SG: 0,
    SI: 1,
    SK: 1,
    SM: 1,
    SV: 0,
    SY: 6,
    TH: 0,
    TJ: 1,
    TM: 1,
    TR: 1,
    TT: 0,
    TW: 0,
    UA: 1,
    UM: 0,
    US: 0,
    UY: 1,
    UZ: 1,
    VA: 1,
    VE: 0,
    VI: 0,
    VN: 1,
    WS: 0,
    XK: 1,
    YE: 0,
    ZA: 0,
    ZW: 0
  };
  function _getWeekArray(date2, locale, firstDayOfWeek) {
    var _a2;
    var weeks = [];
    var currentWeek = [];
    var firstDayOfMonth = _startOfMonth(date2);
    var lastDayOfMonth = _endOfMonth(date2);
    var first2 = (_a2 = firstDayOfWeek != null ? firstDayOfWeek : firstDay[locale.slice(-2).toUpperCase()]) != null ? _a2 : 0;
    var firstDayWeekIndex = (firstDayOfMonth.getDay() - first2 + 7) % 7;
    var lastDayWeekIndex = (lastDayOfMonth.getDay() - first2 + 7) % 7;
    for (var _i261 = 0; _i261 < firstDayWeekIndex; _i261++) {
      var adjacentDay = new Date(firstDayOfMonth);
      adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - _i261));
      currentWeek.push(adjacentDay);
    }
    for (var _i262 = 1; _i262 <= lastDayOfMonth.getDate(); _i262++) {
      var day = new Date(date2.getFullYear(), date2.getMonth(), _i262);
      currentWeek.push(day);
      if (currentWeek.length === 7) {
        weeks.push(currentWeek);
        currentWeek = [];
      }
    }
    for (var _i263 = 1; _i263 < 7 - lastDayWeekIndex; _i263++) {
      var _adjacentDay = new Date(lastDayOfMonth);
      _adjacentDay.setDate(_adjacentDay.getDate() + _i263);
      currentWeek.push(_adjacentDay);
    }
    if (currentWeek.length > 0) {
      weeks.push(currentWeek);
    }
    return weeks;
  }
  function _startOfWeek(date2, locale, firstDayOfWeek) {
    var _a2;
    var day = (_a2 = firstDayOfWeek != null ? firstDayOfWeek : firstDay[locale.slice(-2).toUpperCase()]) != null ? _a2 : 0;
    var d = new Date(date2);
    while (d.getDay() !== day) {
      d.setDate(d.getDate() - 1);
    }
    return d;
  }
  function _endOfWeek(date2, locale) {
    var _a2;
    var d = new Date(date2);
    var lastDay = (((_a2 = firstDay[locale.slice(-2).toUpperCase()]) != null ? _a2 : 0) + 6) % 7;
    while (d.getDay() !== lastDay) {
      d.setDate(d.getDate() + 1);
    }
    return d;
  }
  function _startOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), 1);
  }
  function _endOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
  }
  function parseLocalDate(value) {
    var parts = value.split("-").map(Number);
    return new Date(parts[0], parts[1] - 1, parts[2]);
  }
  var _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
  function _date2(value) {
    if (value == null) return new Date();
    if (value instanceof Date) return value;
    if (typeof value === "string") {
      var parsed;
      if (_YYYMMDD.test(value)) {
        return parseLocalDate(value);
      } else {
        parsed = Date.parse(value);
      }
      if (!isNaN(parsed)) return new Date(parsed);
    }
    return null;
  }
  var sundayJanuarySecond2000 = new Date(2e3, 0, 2);
  function _getWeekdays(locale, firstDayOfWeek) {
    var _a2;
    var daysFromSunday = (_a2 = firstDayOfWeek != null ? firstDayOfWeek : firstDay[locale.slice(-2).toUpperCase()]) != null ? _a2 : 0;
    return createRange(7).map(function (i) {
      var weekday = new Date(sundayJanuarySecond2000);
      weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
      return new Intl.DateTimeFormat(locale, {
        weekday: "narrow"
      }).format(weekday);
    });
  }
  function _format(value, formatString, locale, formats) {
    var _a2;
    var newDate = (_a2 = _date2(value)) != null ? _a2 : new Date();
    var customFormat = formats == null ? void 0 : formats[formatString];
    if (typeof customFormat === "function") {
      return customFormat(newDate, formatString, locale);
    }
    var options = {};
    switch (formatString) {
      case "fullDate":
        options = {
          year: "numeric",
          month: "long",
          day: "numeric"
        };
        break;
      case "fullDateWithWeekday":
        options = {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric"
        };
        break;
      case "normalDate":
        var day = newDate.getDate();
        var month = new Intl.DateTimeFormat(locale, {
          month: "long"
        }).format(newDate);
        return day + " " + month;
      case "normalDateWithWeekday":
        options = {
          weekday: "short",
          day: "numeric",
          month: "short"
        };
        break;
      case "shortDate":
        options = {
          month: "short",
          day: "numeric"
        };
        break;
      case "year":
        options = {
          year: "numeric"
        };
        break;
      case "month":
        options = {
          month: "long"
        };
        break;
      case "monthShort":
        options = {
          month: "short"
        };
        break;
      case "monthAndYear":
        options = {
          month: "long",
          year: "numeric"
        };
        break;
      case "monthAndDate":
        options = {
          month: "long",
          day: "numeric"
        };
        break;
      case "weekday":
        options = {
          weekday: "long"
        };
        break;
      case "weekdayShort":
        options = {
          weekday: "short"
        };
        break;
      case "dayOfMonth":
        return new Intl.NumberFormat(locale).format(newDate.getDate());
      case "hours12h":
        options = {
          hour: "numeric",
          hour12: true
        };
        break;
      case "hours24h":
        options = {
          hour: "numeric",
          hour12: false
        };
        break;
      case "minutes":
        options = {
          minute: "numeric"
        };
        break;
      case "seconds":
        options = {
          second: "numeric"
        };
        break;
      case "fullTime":
        options = {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: true
        };
        break;
      case "fullTime12h":
        options = {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: true
        };
        break;
      case "fullTime24h":
        options = {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: false
        };
        break;
      case "fullDateTime":
        options = {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: true
        };
        break;
      case "fullDateTime12h":
        options = {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: true
        };
        break;
      case "fullDateTime24h":
        options = {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: false
        };
        break;
      case "keyboardDate":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit"
        };
        break;
      case "keyboardDateTime":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: false
        };
        break;
      case "keyboardDateTime12h":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: true
        };
        break;
      case "keyboardDateTime24h":
        options = {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: false
        };
        break;
      default:
        options = customFormat != null ? customFormat : {
          timeZone: "UTC",
          timeZoneName: "short"
        };
    }
    return new Intl.DateTimeFormat(locale, options).format(newDate);
  }
  function _toISO(adapter, value) {
    var date2 = adapter.toJsDate(value);
    var year = date2.getFullYear();
    var month = padStart(String(date2.getMonth() + 1), 2, "0");
    var day = padStart(String(date2.getDate()), 2, "0");
    return year + "-" + month + "-" + day;
  }
  function _parseISO(value) {
    var _value$split$map = value.split("-").map(Number),
      _value$split$map2 = _slicedToArray(_value$split$map, 3),
      year = _value$split$map2[0],
      month = _value$split$map2[1],
      day = _value$split$map2[2];
    return new Date(year, month - 1, day);
  }
  function _addMinutes(date2, amount) {
    var d = new Date(date2);
    d.setMinutes(d.getMinutes() + amount);
    return d;
  }
  function _addHours(date2, amount) {
    var d = new Date(date2);
    d.setHours(d.getHours() + amount);
    return d;
  }
  function _addDays(date2, amount) {
    var d = new Date(date2);
    d.setDate(d.getDate() + amount);
    return d;
  }
  function _addWeeks(date2, amount) {
    var d = new Date(date2);
    d.setDate(d.getDate() + amount * 7);
    return d;
  }
  function _addMonths(date2, amount) {
    var d = new Date(date2);
    d.setDate(1);
    d.setMonth(d.getMonth() + amount);
    return d;
  }
  function _getYear(date2) {
    return date2.getFullYear();
  }
  function _getMonth(date2) {
    return date2.getMonth();
  }
  function _getDate(date2) {
    return date2.getDate();
  }
  function _getNextMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
  }
  function _getPreviousMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() - 1, 1);
  }
  function _getHours(date2) {
    return date2.getHours();
  }
  function _getMinutes(date2) {
    return date2.getMinutes();
  }
  function _startOfYear(date2) {
    return new Date(date2.getFullYear(), 0, 1);
  }
  function _endOfYear(date2) {
    return new Date(date2.getFullYear(), 11, 31);
  }
  function _isWithinRange(date2, range) {
    return _isAfter(date2, range[0]) && isBefore(date2, range[1]);
  }
  function _isValid(date2) {
    var d = new Date(date2);
    return d instanceof Date && !isNaN(d.getTime());
  }
  function _isAfter(date2, comparing) {
    return date2.getTime() > comparing.getTime();
  }
  function _isAfterDay(date2, comparing) {
    return _isAfter(_startOfDay(date2), _startOfDay(comparing));
  }
  function isBefore(date2, comparing) {
    return date2.getTime() < comparing.getTime();
  }
  function _isEqual(date2, comparing) {
    return date2.getTime() === comparing.getTime();
  }
  function _isSameDay(date2, comparing) {
    return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
  }
  function _isSameMonth(date2, comparing) {
    return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
  }
  function _isSameYear(date2, comparing) {
    return date2.getFullYear() === comparing.getFullYear();
  }
  function _getDiff(date2, comparing, unit) {
    var d = new Date(date2);
    var c = new Date(comparing);
    switch (unit) {
      case "years":
        return d.getFullYear() - c.getFullYear();
      case "quarters":
        return Math.floor((d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12) / 4);
      case "months":
        return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
      case "weeks":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24 * 7));
      case "days":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
      case "hours":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60));
      case "minutes":
        return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60));
      case "seconds":
        return Math.floor((d.getTime() - c.getTime()) / 1e3);
      default:
        {
          return d.getTime() - c.getTime();
        }
    }
  }
  function _setHours(date2, count) {
    var d = new Date(date2);
    d.setHours(count);
    return d;
  }
  function _setMinutes(date2, count) {
    var d = new Date(date2);
    d.setMinutes(count);
    return d;
  }
  function _setMonth(date2, count) {
    var d = new Date(date2);
    d.setMonth(count);
    return d;
  }
  function _setDate(date2, day) {
    var d = new Date(date2);
    d.setDate(day);
    return d;
  }
  function _setYear(date2, year) {
    var d = new Date(date2);
    d.setFullYear(year);
    return d;
  }
  function _startOfDay(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 0, 0, 0, 0);
  }
  function _endOfDay(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
  }
  var VuetifyDateAdapter = /*#__PURE__*/function () {
    function VuetifyDateAdapter(options) {
      this.locale = options.locale;
      this.formats = options.formats;
    }
    var _proto81 = VuetifyDateAdapter.prototype;
    _proto81.date = function date(value) {
      return _date2(value);
    };
    _proto81.toJsDate = function toJsDate(date2) {
      return date2;
    };
    _proto81.toISO = function toISO(date2) {
      return _toISO(this, date2);
    };
    _proto81.parseISO = function parseISO(date2) {
      return _parseISO(date2);
    };
    _proto81.addMinutes = function addMinutes(date2, amount) {
      return _addMinutes(date2, amount);
    };
    _proto81.addHours = function addHours(date2, amount) {
      return _addHours(date2, amount);
    };
    _proto81.addDays = function addDays(date2, amount) {
      return _addDays(date2, amount);
    };
    _proto81.addWeeks = function addWeeks(date2, amount) {
      return _addWeeks(date2, amount);
    };
    _proto81.addMonths = function addMonths(date2, amount) {
      return _addMonths(date2, amount);
    };
    _proto81.getWeekArray = function getWeekArray(date2, firstDayOfWeek) {
      return _getWeekArray(date2, this.locale, firstDayOfWeek ? Number(firstDayOfWeek) : void 0);
    };
    _proto81.startOfWeek = function startOfWeek(date2, firstDayOfWeek) {
      return _startOfWeek(date2, this.locale, firstDayOfWeek ? Number(firstDayOfWeek) : void 0);
    };
    _proto81.endOfWeek = function endOfWeek(date2) {
      return _endOfWeek(date2, this.locale);
    };
    _proto81.startOfMonth = function startOfMonth(date2) {
      return _startOfMonth(date2);
    };
    _proto81.endOfMonth = function endOfMonth(date2) {
      return _endOfMonth(date2);
    };
    _proto81.format = function format(date2, formatString) {
      return _format(date2, formatString, this.locale, this.formats);
    };
    _proto81.isEqual = function isEqual(date2, comparing) {
      return _isEqual(date2, comparing);
    };
    _proto81.isValid = function isValid(date2) {
      return _isValid(date2);
    };
    _proto81.isWithinRange = function isWithinRange(date2, range) {
      return _isWithinRange(date2, range);
    };
    _proto81.isAfter = function isAfter(date2, comparing) {
      return _isAfter(date2, comparing);
    };
    _proto81.isAfterDay = function isAfterDay(date2, comparing) {
      return _isAfterDay(date2, comparing);
    };
    _proto81.isBefore = function isBefore(date2, comparing) {
      return !_isAfter(date2, comparing) && !_isEqual(date2, comparing);
    };
    _proto81.isSameDay = function isSameDay(date2, comparing) {
      return _isSameDay(date2, comparing);
    };
    _proto81.isSameMonth = function isSameMonth(date2, comparing) {
      return _isSameMonth(date2, comparing);
    };
    _proto81.isSameYear = function isSameYear(date2, comparing) {
      return _isSameYear(date2, comparing);
    };
    _proto81.setMinutes = function setMinutes(date2, count) {
      return _setMinutes(date2, count);
    };
    _proto81.setHours = function setHours(date2, count) {
      return _setHours(date2, count);
    };
    _proto81.setMonth = function setMonth(date2, count) {
      return _setMonth(date2, count);
    };
    _proto81.setDate = function setDate(date2, day) {
      return _setDate(date2, day);
    };
    _proto81.setYear = function setYear(date2, year) {
      return _setYear(date2, year);
    };
    _proto81.getDiff = function getDiff(date2, comparing, unit) {
      return _getDiff(date2, comparing, unit);
    };
    _proto81.getWeekdays = function getWeekdays(firstDayOfWeek) {
      return _getWeekdays(this.locale, firstDayOfWeek ? Number(firstDayOfWeek) : void 0);
    };
    _proto81.getYear = function getYear(date2) {
      return _getYear(date2);
    };
    _proto81.getMonth = function getMonth(date2) {
      return _getMonth(date2);
    };
    _proto81.getDate = function getDate(date2) {
      return _getDate(date2);
    };
    _proto81.getNextMonth = function getNextMonth(date2) {
      return _getNextMonth(date2);
    };
    _proto81.getPreviousMonth = function getPreviousMonth(date2) {
      return _getPreviousMonth(date2);
    };
    _proto81.getHours = function getHours(date2) {
      return _getHours(date2);
    };
    _proto81.getMinutes = function getMinutes(date2) {
      return _getMinutes(date2);
    };
    _proto81.startOfDay = function startOfDay(date2) {
      return _startOfDay(date2);
    };
    _proto81.endOfDay = function endOfDay(date2) {
      return _endOfDay(date2);
    };
    _proto81.startOfYear = function startOfYear(date2) {
      return _startOfYear(date2);
    };
    _proto81.endOfYear = function endOfYear(date2) {
      return _endOfYear(date2);
    };
    return VuetifyDateAdapter;
  }();
  var DateOptionsSymbol = Symbol.for("vuetify:date-options");
  var DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
  function createDate(options, locale) {
    var _options = mergeDeep({
      adapter: VuetifyDateAdapter,
      locale: {
        af: "af-ZA",
        bg: "bg-BG",
        ca: "ca-ES",
        ckb: "",
        cs: "cs-CZ",
        de: "de-DE",
        el: "el-GR",
        en: "en-US",
        et: "et-EE",
        fa: "fa-IR",
        fi: "fi-FI",
        hr: "hr-HR",
        hu: "hu-HU",
        he: "he-IL",
        id: "id-ID",
        it: "it-IT",
        ja: "ja-JP",
        ko: "ko-KR",
        lv: "lv-LV",
        lt: "lt-LT",
        nl: "nl-NL",
        no: "no-NO",
        pl: "pl-PL",
        pt: "pt-PT",
        ro: "ro-RO",
        ru: "ru-RU",
        sk: "sk-SK",
        sl: "sl-SI",
        srCyrl: "sr-SP",
        srLatn: "sr-SP",
        sv: "sv-SE",
        th: "th-TH",
        tr: "tr-TR",
        az: "az-AZ",
        uk: "uk-UA",
        vi: "vi-VN",
        zhHans: "zh-CN",
        zhHant: "zh-TW"
      }
    }, options);
    return {
      options: _options,
      instance: createInstance(_options, locale)
    };
  }
  function createInstance(options, locale) {
    var _a2;
    var instance = reactive(typeof options.adapter === "function" ? new options.adapter({
      locale: (_a2 = options.locale[locale.current.value]) != null ? _a2 : locale.current.value,
      formats: options.formats
    }) : options.adapter);
    watch(locale.current, function (value) {
      var _a3, _b;
      instance.locale = (_b = (_a3 = options.locale[value]) != null ? _a3 : value) != null ? _b : instance.locale;
    });
    return instance;
  }
  function useDate() {
    var options = inject$1(DateOptionsSymbol);
    if (!options) throw new Error("[Vuetify] Could not find injected date options");
    var locale = useLocale();
    return createInstance(options, locale);
  }
  function getWeek(adapter, value) {
    var date2 = adapter.toJsDate(value);
    var year = date2.getFullYear();
    var d1w1 = new Date(year, 0, 1);
    if (date2 < d1w1) {
      year = year - 1;
      d1w1 = new Date(year, 0, 1);
    } else {
      var tv = new Date(year + 1, 0, 1);
      if (date2 >= tv) {
        year = year + 1;
        d1w1 = tv;
      }
    }
    var diffTime = Math.abs(date2.getTime() - d1w1.getTime());
    var diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    return Math.floor(diffDays / 7) + 1;
  }
  var breakpoints = ["sm", "md", "lg", "xl", "xxl"];
  var DisplaySymbol = Symbol.for("vuetify:display");
  var defaultDisplayOptions = {
    mobileBreakpoint: "lg",
    thresholds: {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920,
      xxl: 2560
    }
  };
  var parseDisplayOptions = function () {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
    return mergeDeep(defaultDisplayOptions, options);
  };
  function getClientWidth(ssr) {
    return IN_BROWSER && !ssr ? window.innerWidth : _typeof(ssr) === "object" && ssr.clientWidth || 0;
  }
  function getClientHeight(ssr) {
    return IN_BROWSER && !ssr ? window.innerHeight : _typeof(ssr) === "object" && ssr.clientHeight || 0;
  }
  function getPlatform(ssr) {
    var userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
    function match(regexp) {
      return Boolean(userAgent.match(regexp));
    }
    var android2 = match(/android/i);
    var ios2 = match(/iphone|ipad|ipod/i);
    var cordova = match(/cordova/i);
    var electron = match(/electron/i);
    var chrome2 = match(/chrome/i);
    var edge = match(/edge/i);
    var firefox = match(/firefox/i);
    var opera = match(/opera/i);
    var win = match(/win/i);
    var mac2 = match(/mac/i);
    var linux = match(/linux/i);
    return {
      android: android2,
      ios: ios2,
      cordova: cordova,
      electron: electron,
      chrome: chrome2,
      edge: edge,
      firefox: firefox,
      opera: opera,
      win: win,
      mac: mac2,
      linux: linux,
      touch: SUPPORTS_TOUCH,
      ssr: userAgent === "ssr"
    };
  }
  function createDisplay(options, ssr) {
    var _parseDisplayOptions = parseDisplayOptions(options),
      thresholds = _parseDisplayOptions.thresholds,
      mobileBreakpoint = _parseDisplayOptions.mobileBreakpoint;
    var height = shallowRef(getClientHeight(ssr));
    var platform = shallowRef(getPlatform(ssr));
    var state = reactive({});
    var width = shallowRef(getClientWidth(ssr));
    function updateSize() {
      height.value = getClientHeight();
      width.value = getClientWidth();
    }
    function update() {
      updateSize();
      platform.value = getPlatform();
    }
    watchEffect(function () {
      var xs = width.value < thresholds.sm;
      var sm = width.value < thresholds.md && !xs;
      var md = width.value < thresholds.lg && !(sm || xs);
      var lg = width.value < thresholds.xl && !(md || sm || xs);
      var xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
      var xxl = width.value >= thresholds.xxl;
      var name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
      var breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
      var mobile = width.value < breakpointValue;
      state.xs = xs;
      state.sm = sm;
      state.md = md;
      state.lg = lg;
      state.xl = xl;
      state.xxl = xxl;
      state.smAndUp = !xs;
      state.mdAndUp = !(xs || sm);
      state.lgAndUp = !(xs || sm || md);
      state.xlAndUp = !(xs || sm || md || lg);
      state.smAndDown = !(md || lg || xl || xxl);
      state.mdAndDown = !(lg || xl || xxl);
      state.lgAndDown = !(xl || xxl);
      state.xlAndDown = !xxl;
      state.name = name;
      state.height = height.value;
      state.width = width.value;
      state.mobile = mobile;
      state.mobileBreakpoint = mobileBreakpoint;
      state.platform = platform.value;
      state.thresholds = thresholds;
    });
    if (IN_BROWSER) {
      window.addEventListener("resize", updateSize, {
        passive: true
      });
    }
    return _objectSpread(_objectSpread({}, toRefs(state)), {}, {
      update: update,
      ssr: !!ssr
    });
  }
  var makeDisplayProps = propsFactory({
    mobile: {
      type: Boolean,
      "default": false
    },
    mobileBreakpoint: [Number, String]
  }, "display");
  function useDisplay() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var display = inject$1(DisplaySymbol);
    if (!display) throw new Error("Could not find Vuetify display injection");
    var mobile = computed(function () {
      if (props.mobile != null) return props.mobile;
      if (!props.mobileBreakpoint) return display.mobile.value;
      var breakpointValue = typeof props.mobileBreakpoint === "number" ? props.mobileBreakpoint : display.thresholds.value[props.mobileBreakpoint];
      return display.width.value < breakpointValue;
    });
    var displayClasses = computed(function () {
      var _ref242;
      if (!name) return {};
      return _ref242 = {}, _ref242[name + "--mobile"] = mobile.value, _ref242;
    });
    return _objectSpread(_objectSpread({}, display), {}, {
      displayClasses: displayClasses,
      mobile: mobile
    });
  }
  var GoToSymbol = Symbol.for("vuetify:goto");
  function genDefaults$2() {
    return {
      container: void 0,
      duration: 300,
      layout: false,
      offset: 0,
      easing: "easeInOutCubic",
      patterns: {
        linear: function (t) {
          return t;
        },
        easeInQuad: function (t) {
          return Math.pow(t, 2);
        },
        easeOutQuad: function (t) {
          return t * (2 - t);
        },
        easeInOutQuad: function (t) {
          return t < 0.5 ? 2 * Math.pow(t, 2) : -1 + (4 - 2 * t) * t;
        },
        easeInCubic: function (t) {
          return Math.pow(t, 3);
        },
        easeOutCubic: function (t) {
          return Math.pow(--t, 3) + 1;
        },
        easeInOutCubic: function (t) {
          return t < 0.5 ? 4 * Math.pow(t, 3) : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        },
        easeInQuart: function (t) {
          return Math.pow(t, 4);
        },
        easeOutQuart: function (t) {
          return 1 - Math.pow(--t, 4);
        },
        easeInOutQuart: function (t) {
          return t < 0.5 ? 8 * Math.pow(t, 4) : 1 - 8 * Math.pow(--t, 4);
        },
        easeInQuint: function (t) {
          return Math.pow(t, 5);
        },
        easeOutQuint: function (t) {
          return 1 + Math.pow(--t, 5);
        },
        easeInOutQuint: function (t) {
          return t < 0.5 ? 16 * Math.pow(t, 5) : 1 + 16 * Math.pow(--t, 5);
        }
      }
    };
  }
  function getContainer(el) {
    var _a2;
    return (_a2 = getTarget$1(el)) != null ? _a2 : document.scrollingElement || document.body;
  }
  function getTarget$1(el) {
    return typeof el === "string" ? document.querySelector(el) : refElement(el);
  }
  function getOffset$2(target, horizontal, rtl) {
    if (typeof target === "number") return horizontal && rtl ? -target : target;
    var el = getTarget$1(target);
    var totalOffset = 0;
    while (el) {
      totalOffset += horizontal ? el.offsetLeft : el.offsetTop;
      el = el.offsetParent;
    }
    return totalOffset;
  }
  function createGoTo(options, locale) {
    return {
      rtl: locale.isRtl,
      options: mergeDeep(genDefaults$2(), options)
    };
  }
  function scrollTo(_target, _options, horizontal, goTo) {
    var _a2, _b, _c, property, options, rtl, target, container, ease, targetLocation, styles, layoutOffset, startLocation, startTime;
    return _regeneratorRuntime.async(function scrollTo$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          property = horizontal ? "scrollLeft" : "scrollTop";
          options = mergeDeep((_a2 = goTo == null ? void 0 : goTo.options) != null ? _a2 : genDefaults$2(), _options);
          rtl = goTo == null ? void 0 : goTo.rtl.value;
          target = (_b = typeof _target === "number" ? _target : getTarget$1(_target)) != null ? _b : 0;
          container = options.container === "parent" && target instanceof HTMLElement ? target.parentElement : getContainer(options.container);
          ease = typeof options.easing === "function" ? options.easing : options.patterns[options.easing];
          if (ease) {
            _context2.next = 8;
            break;
          }
          throw new TypeError("Easing function \"" + options.easing + "\" not found.");
        case 8:
          if (typeof target === "number") {
            targetLocation = getOffset$2(target, horizontal, rtl);
          } else {
            targetLocation = getOffset$2(target, horizontal, rtl) - getOffset$2(container, horizontal, rtl);
            if (options.layout) {
              styles = window.getComputedStyle(target);
              layoutOffset = styles.getPropertyValue("--v-layout-top");
              if (layoutOffset) targetLocation -= parseInt(layoutOffset, 10);
            }
          }
          targetLocation += options.offset;
          targetLocation = clampTarget(container, targetLocation, !!rtl, !!horizontal);
          startLocation = (_c = container[property]) != null ? _c : 0;
          if (!(targetLocation === startLocation)) {
            _context2.next = 14;
            break;
          }
          return _context2.abrupt("return", Promise.resolve(targetLocation));
        case 14:
          startTime = performance.now();
          return _context2.abrupt("return", new Promise(function (resolve2) {
            return requestAnimationFrame(function step(currentTime) {
              var timeElapsed = currentTime - startTime;
              var progress = timeElapsed / options.duration;
              var location2 = Math.floor(startLocation + (targetLocation - startLocation) * ease(clamp(progress, 0, 1)));
              container[property] = location2;
              if (progress >= 1 && Math.abs(location2 - container[property]) < 10) {
                return resolve2(targetLocation);
              } else if (progress > 2) {
                consoleWarn("Scroll target is not reachable");
                return resolve2(container[property]);
              }
              requestAnimationFrame(step);
            });
          }));
        case 16:
        case "end":
          return _context2.stop();
      }
    }, null, null, null, Promise);
  }
  function useGoTo() {
    var _options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var goToInstance = inject$1(GoToSymbol);
    var _useRtl = useRtl(),
      isRtl = _useRtl.isRtl;
    if (!goToInstance) throw new Error("[Vuetify] Could not find injected goto instance");
    var goTo = _objectSpread(_objectSpread({}, goToInstance), {}, {
      rtl: computed(function () {
        return goToInstance.rtl.value || isRtl.value;
      })
    });
    function go(target, options) {
      return _regeneratorRuntime.async(function go$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", scrollTo(target, mergeDeep(_options, options), false, goTo));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, null, null, null, Promise);
    }
    go.horizontal = function _callee(target, options) {
      return _regeneratorRuntime.async(function _callee$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", scrollTo(target, mergeDeep(_options, options), true, goTo));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, null, null, null, Promise);
    };
    return go;
  }
  function clampTarget(container, value, rtl, horizontal) {
    var scrollWidth = container.scrollWidth,
      scrollHeight = container.scrollHeight;
    var _ref243 = container === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [container.offsetWidth, container.offsetHeight],
      _ref244 = _slicedToArray(_ref243, 2),
      containerWidth = _ref244[0],
      containerHeight = _ref244[1];
    var min;
    var max;
    if (horizontal) {
      if (rtl) {
        min = -(scrollWidth - containerWidth);
        max = 0;
      } else {
        min = 0;
        max = scrollWidth - containerWidth;
      }
    } else {
      min = 0;
      max = scrollHeight + -containerHeight;
    }
    return Math.max(Math.min(value, max), min);
  }
  var aliases = {
    collapse: "mdi-chevron-up",
    complete: "mdi-check",
    cancel: "mdi-close-circle",
    close: "mdi-close",
    "delete": "mdi-close-circle",
    clear: "mdi-close-circle",
    success: "mdi-check-circle",
    info: "mdi-information",
    warning: "mdi-alert-circle",
    error: "mdi-close-circle",
    prev: "mdi-chevron-left",
    next: "mdi-chevron-right",
    checkboxOn: "mdi-checkbox-marked",
    checkboxOff: "mdi-checkbox-blank-outline",
    checkboxIndeterminate: "mdi-minus-box",
    delimiter: "mdi-circle",
    sortAsc: "mdi-arrow-up",
    sortDesc: "mdi-arrow-down",
    expand: "mdi-chevron-down",
    menu: "mdi-menu",
    subgroup: "mdi-menu-down",
    dropdown: "mdi-menu-down",
    radioOn: "mdi-radiobox-marked",
    radioOff: "mdi-radiobox-blank",
    edit: "mdi-pencil",
    ratingEmpty: "mdi-star-outline",
    ratingFull: "mdi-star",
    ratingHalf: "mdi-star-half-full",
    loading: "mdi-cached",
    first: "mdi-page-first",
    last: "mdi-page-last",
    unfold: "mdi-unfold-more-horizontal",
    file: "mdi-paperclip",
    plus: "mdi-plus",
    minus: "mdi-minus",
    calendar: "mdi-calendar",
    treeviewCollapse: "mdi-menu-down",
    treeviewExpand: "mdi-menu-right",
    eyeDropper: "mdi-eyedropper"
  };
  var mdi = {
    component: function (props) {
      return h(VClassIcon, _objectSpread(_objectSpread({}, props), {}, {
        "class": "mdi"
      }));
    }
  };
  var IconValue = [String, Function, Object, Array];
  var IconSymbol = Symbol.for("vuetify:icons");
  var makeIconProps = propsFactory({
    icon: {
      type: IconValue
    },
    tag: {
      type: String,
      required: true
    }
  }, "icon");
  var VComponentIcon = genericComponent()({
    name: "VComponentIcon",
    props: makeIconProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      return function () {
        var Icon = props.icon;
        return createVNode(props.tag, null, {
          "default": function () {
            var _a2;
            return [props.icon ? createVNode(Icon, null, null) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
          }
        });
      };
    }
  });
  var VSvgIcon = defineComponent({
    name: "VSvgIcon",
    inheritAttrs: false,
    props: makeIconProps(),
    setup: function (props, _ref2) {
      var attrs = _ref2.attrs;
      return function () {
        return createVNode(props.tag, mergeProps(attrs, {
          "style": null
        }), {
          "default": function () {
            return [createVNode("svg", {
              "class": "v-icon__svg",
              "xmlns": "http://www.w3.org/2000/svg",
              "viewBox": "0 0 24 24",
              "role": "img",
              "aria-hidden": "true"
            }, [Array.isArray(props.icon) ? props.icon.map(function (path) {
              return Array.isArray(path) ? createVNode("path", {
                "d": path[0],
                "fill-opacity": path[1]
              }, null) : createVNode("path", {
                "d": path
              }, null);
            }) : createVNode("path", {
              "d": props.icon
            }, null)])];
          }
        });
      };
    }
  });
  var VLigatureIcon = defineComponent({
    name: "VLigatureIcon",
    props: makeIconProps(),
    setup: function (props) {
      return function () {
        return createVNode(props.tag, null, {
          "default": function () {
            return [props.icon];
          }
        });
      };
    }
  });
  var VClassIcon = defineComponent({
    name: "VClassIcon",
    props: makeIconProps(),
    setup: function (props) {
      return function () {
        return createVNode(props.tag, {
          "class": props.icon
        }, null);
      };
    }
  });
  function genDefaults$1() {
    return {
      svg: {
        component: VSvgIcon
      },
      "class": {
        component: VClassIcon
      }
    };
  }
  function createIcons(options) {
    var _a2;
    var sets = genDefaults$1();
    var defaultSet = (_a2 = options == null ? void 0 : options.defaultSet) != null ? _a2 : "mdi";
    if (defaultSet === "mdi" && !sets.mdi) {
      sets.mdi = mdi;
    }
    return mergeDeep({
      defaultSet: defaultSet,
      sets: sets,
      aliases: _objectSpread(_objectSpread({}, aliases), {}, {
        vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
        "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
        "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      })
    }, options);
  }
  var useIcon = function (props) {
    var icons = inject$1(IconSymbol);
    if (!icons) throw new Error("Missing Vuetify Icons provide!");
    var iconData = computed(function () {
      var _a2;
      var iconAlias = unref(props);
      if (!iconAlias) return {
        component: VComponentIcon
      };
      var icon = iconAlias;
      if (typeof icon === "string") {
        icon = icon.trim();
        if (icon.startsWith("$")) {
          icon = (_a2 = icons.aliases) == null ? void 0 : _a2[icon.slice(1)];
        }
      }
      if (!icon) consoleWarn("Could not find aliased icon \"" + iconAlias + "\"");
      if (Array.isArray(icon)) {
        return {
          component: VSvgIcon,
          icon: icon
        };
      } else if (typeof icon !== "string") {
        return {
          component: VComponentIcon,
          icon: icon
        };
      }
      var iconSetName = Object.keys(icons.sets).find(function (setName) {
        return typeof icon === "string" && icon.startsWith(setName + ":");
      });
      var iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
      var iconSet = icons.sets[iconSetName != null ? iconSetName : icons.defaultSet];
      return {
        component: iconSet.component,
        icon: iconName
      };
    });
    return {
      iconData: iconData
    };
  };
  var ThemeSymbol = Symbol.for("vuetify:theme");
  var makeThemeProps = propsFactory({
    theme: String
  }, "theme");
  function genDefaults() {
    return {
      defaultTheme: "light",
      variations: {
        colors: [],
        lighten: 0,
        darken: 0
      },
      themes: {
        light: {
          dark: false,
          colors: {
            background: "#FFFFFF",
            surface: "#FFFFFF",
            "surface-bright": "#FFFFFF",
            "surface-light": "#EEEEEE",
            "surface-variant": "#424242",
            "on-surface-variant": "#EEEEEE",
            primary: "#1867C0",
            "primary-darken-1": "#1F5592",
            secondary: "#48A9A6",
            "secondary-darken-1": "#018786",
            error: "#B00020",
            info: "#2196F3",
            success: "#4CAF50",
            warning: "#FB8C00"
          },
          variables: {
            "border-color": "#000000",
            "border-opacity": 0.12,
            "high-emphasis-opacity": 0.87,
            "medium-emphasis-opacity": 0.6,
            "disabled-opacity": 0.38,
            "idle-opacity": 0.04,
            "hover-opacity": 0.04,
            "focus-opacity": 0.12,
            "selected-opacity": 0.08,
            "activated-opacity": 0.12,
            "pressed-opacity": 0.12,
            "dragged-opacity": 0.08,
            "theme-kbd": "#212529",
            "theme-on-kbd": "#FFFFFF",
            "theme-code": "#F5F5F5",
            "theme-on-code": "#000000"
          }
        },
        dark: {
          dark: true,
          colors: {
            background: "#121212",
            surface: "#212121",
            "surface-bright": "#ccbfd6",
            "surface-light": "#424242",
            "surface-variant": "#a3a3a3",
            "on-surface-variant": "#424242",
            primary: "#2196F3",
            "primary-darken-1": "#277CC1",
            secondary: "#54B6B2",
            "secondary-darken-1": "#48A9A6",
            error: "#CF6679",
            info: "#2196F3",
            success: "#4CAF50",
            warning: "#FB8C00"
          },
          variables: {
            "border-color": "#FFFFFF",
            "border-opacity": 0.12,
            "high-emphasis-opacity": 1,
            "medium-emphasis-opacity": 0.7,
            "disabled-opacity": 0.5,
            "idle-opacity": 0.1,
            "hover-opacity": 0.04,
            "focus-opacity": 0.12,
            "selected-opacity": 0.08,
            "activated-opacity": 0.12,
            "pressed-opacity": 0.16,
            "dragged-opacity": 0.08,
            "theme-kbd": "#212529",
            "theme-on-kbd": "#FFFFFF",
            "theme-code": "#343434",
            "theme-on-code": "#CCCCCC"
          }
        }
      }
    };
  }
  function parseThemeOptions() {
    var _a2, _b, _c;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults();
    var defaults = genDefaults();
    if (!options) return _objectSpread(_objectSpread({}, defaults), {}, {
      isDisabled: true
    });
    var themes = {};
    for (var _i264 = 0, _Object$entries = Object.entries((_a2 = options.themes) != null ? _a2 : {}); _i264 < _Object$entries.length; _i264++) {
      var _ref245 = _Object$entries[_i264];
      var _ref246 = _slicedToArray(_ref245, 2);
      var key = _ref246[0];
      var theme = _ref246[1];
      var defaultTheme = theme.dark || key === "dark" ? (_b = defaults.themes) == null ? void 0 : _b.dark : (_c = defaults.themes) == null ? void 0 : _c.light;
      themes[key] = mergeDeep(defaultTheme, theme);
    }
    return mergeDeep(defaults, _objectSpread(_objectSpread({}, options), {}, {
      themes: themes
    }));
  }
  function createTheme(options) {
    var parsedOptions = parseThemeOptions(options);
    var name = ref(parsedOptions.defaultTheme);
    var themes = ref(parsedOptions.themes);
    var computedThemes = computed(function () {
      var acc = {};
      for (var _i265 = 0, _Object$entries2 = Object.entries(themes.value); _i265 < _Object$entries2.length; _i265++) {
        var _ref247 = _Object$entries2[_i265];
        var _ref248 = _slicedToArray(_ref247, 2);
        var name2 = _ref248[0];
        var original = _ref248[1];
        var theme = acc[name2] = _objectSpread(_objectSpread({}, original), {}, {
          colors: _objectSpread({}, original.colors)
        });
        if (parsedOptions.variations) {
          for (var _iterator33 = _createForOfIteratorHelperLoose(parsedOptions.variations.colors), _step35; !(_step35 = _iterator33()).done;) {
            var name3 = _step35.value;
            var color = theme.colors[name3];
            if (!color) continue;
            for (var _i266 = 0, _arr2 = ["lighten", "darken"]; _i266 < _arr2.length; _i266++) {
              var variation = _arr2[_i266];
              var fn = variation === "lighten" ? lighten : darken;
              for (var _iterator34 = _createForOfIteratorHelperLoose(createRange(parsedOptions.variations[variation], 1)), _step36; !(_step36 = _iterator34()).done;) {
                var amount = _step36.value;
                theme.colors[name3 + "-" + variation + "-" + amount] = RGBtoHex(fn(parseColor(color), amount));
              }
            }
          }
        }
        for (var _i267 = 0, _Object$keys = Object.keys(theme.colors); _i267 < _Object$keys.length; _i267++) {
          var _color = _Object$keys[_i267];
          if (/^on-[a-z]/.test(_color) || theme.colors["on-" + _color]) continue;
          var onColor = "on-" + _color;
          var colorVal = parseColor(theme.colors[_color]);
          theme.colors[onColor] = getForeground(colorVal);
        }
      }
      return acc;
    });
    var current = computed(function () {
      return computedThemes.value[name.value];
    });
    var styles = computed(function () {
      var _a2;
      var lines = [];
      if ((_a2 = current.value) == null ? void 0 : _a2.dark) {
        createCssClass(lines, ":root", ["color-scheme: dark"]);
      }
      createCssClass(lines, ":root", genCssVariables(current.value));
      for (var _i268 = 0, _Object$entries3 = Object.entries(computedThemes.value); _i268 < _Object$entries3.length; _i268++) {
        var _ref249 = _Object$entries3[_i268];
        var _ref250 = _slicedToArray(_ref249, 2);
        var themeName = _ref250[0];
        var theme = _ref250[1];
        createCssClass(lines, ".v-theme--" + themeName, ["color-scheme: " + (theme.dark ? "dark" : "normal")].concat(_toConsumableArray(genCssVariables(theme))));
      }
      var bgLines = [];
      var fgLines = [];
      var colors2 = new Set(Object.values(computedThemes.value).flatMap(function (theme) {
        return Object.keys(theme.colors);
      }));
      for (var _iterator35 = _createForOfIteratorHelperLoose(colors2), _step37; !(_step37 = _iterator35()).done;) {
        var key = _step37.value;
        if (/^on-[a-z]/.test(key)) {
          createCssClass(fgLines, "." + key, ["color: rgb(var(--v-theme-" + key + ")) !important"]);
        } else {
          createCssClass(bgLines, ".bg-" + key, ["--v-theme-overlay-multiplier: var(--v-theme-" + key + "-overlay-multiplier)", "background-color: rgb(var(--v-theme-" + key + ")) !important", "color: rgb(var(--v-theme-on-" + key + ")) !important"]);
          createCssClass(fgLines, ".text-" + key, ["color: rgb(var(--v-theme-" + key + ")) !important"]);
          createCssClass(fgLines, ".border-" + key, ["--v-border-color: var(--v-theme-" + key + ")"]);
        }
      }
      lines.push.apply(lines, bgLines.concat(fgLines));
      return lines.map(function (str, i) {
        return i === 0 ? str : "    " + str;
      }).join("");
    });
    function getHead() {
      return {
        style: [{
          children: styles.value,
          id: "vuetify-theme-stylesheet",
          nonce: parsedOptions.cspNonce || false
        }]
      };
    }
    function install(app) {
      if (parsedOptions.isDisabled) return;
      var head = app._context.provides.usehead;
      if (head) {
        if (head.push) {
          var entry = head.push(getHead);
          if (IN_BROWSER) {
            watch(styles, function () {
              entry.patch(getHead);
            });
          }
        } else {
          if (IN_BROWSER) {
            head.addHeadObjs(computed(getHead));
            watchEffect(function () {
              return head.updateDOM();
            });
          } else {
            head.addHeadObjs(getHead());
          }
        }
      } else {
        var updateStyles2 = function () {
          if (typeof document !== "undefined" && !styleEl) {
            var el = document.createElement("style");
            el.type = "text/css";
            el.id = "vuetify-theme-stylesheet";
            if (parsedOptions.cspNonce) el.setAttribute("nonce", parsedOptions.cspNonce);
            styleEl = el;
            document.head.appendChild(styleEl);
          }
          if (styleEl) styleEl.innerHTML = styles.value;
        };
        var updateStyles = updateStyles2;
        var styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
        if (IN_BROWSER) {
          watch(styles, updateStyles2, {
            immediate: true
          });
        } else {
          updateStyles2();
        }
      }
    }
    var themeClasses = computed(function () {
      return parsedOptions.isDisabled ? void 0 : "v-theme--" + name.value;
    });
    return {
      install: install,
      isDisabled: parsedOptions.isDisabled,
      name: name,
      themes: themes,
      current: current,
      computedThemes: computedThemes,
      themeClasses: themeClasses,
      styles: styles,
      global: {
        name: name,
        current: current
      }
    };
  }
  function provideTheme(props) {
    getCurrentInstance("provideTheme");
    var theme = inject$1(ThemeSymbol, null);
    if (!theme) throw new Error("Could not find Vuetify theme injection");
    var name = computed(function () {
      var _a2;
      return (_a2 = props.theme) != null ? _a2 : theme.name.value;
    });
    var current = computed(function () {
      return theme.themes.value[name.value];
    });
    var themeClasses = computed(function () {
      return theme.isDisabled ? void 0 : "v-theme--" + name.value;
    });
    var newTheme = _objectSpread(_objectSpread({}, theme), {}, {
      name: name,
      current: current,
      themeClasses: themeClasses
    });
    provide(ThemeSymbol, newTheme);
    return newTheme;
  }
  function useTheme() {
    getCurrentInstance("useTheme");
    var theme = inject$1(ThemeSymbol, null);
    if (!theme) throw new Error("Could not find Vuetify theme injection");
    return theme;
  }
  function createCssClass(lines, selector, content) {
    lines.push.apply(lines, [selector + " {\n"].concat(_toConsumableArray(content.map(function (line) {
      return "  " + line + ";\n";
    })), ["}\n"]));
  }
  function genCssVariables(theme) {
    var lightOverlay = theme.dark ? 2 : 1;
    var darkOverlay = theme.dark ? 1 : 2;
    var variables = [];
    for (var _i269 = 0, _Object$entries4 = Object.entries(theme.colors); _i269 < _Object$entries4.length; _i269++) {
      var _ref251 = _Object$entries4[_i269];
      var _ref252 = _slicedToArray(_ref251, 2);
      var key = _ref252[0];
      var value = _ref252[1];
      var rgb2 = parseColor(value);
      variables.push("--v-theme-" + key + ": " + rgb2.r + "," + rgb2.g + "," + rgb2.b);
      if (!key.startsWith("on-")) {
        variables.push("--v-theme-" + key + "-overlay-multiplier: " + (getLuma(value) > 0.18 ? lightOverlay : darkOverlay));
      }
    }
    for (var _i270 = 0, _Object$entries5 = Object.entries(theme.variables); _i270 < _Object$entries5.length; _i270++) {
      var _ref253 = _Object$entries5[_i270];
      var _ref254 = _slicedToArray(_ref253, 2);
      var _key44 = _ref254[0];
      var _value2 = _ref254[1];
      {
        var color = typeof _value2 === "string" && _value2.startsWith("#") ? parseColor(_value2) : void 0;
        var _rgb = color ? color.r + ", " + color.g + ", " + color.b : void 0;
        variables.push("--v-" + _key44 + ": " + (_rgb != null ? _rgb : _value2));
      }
    }
    return variables;
  }
  function useResizeObserver(callback) {
    var box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
    var resizeRef = templateRef();
    var contentRect = ref();
    if (IN_BROWSER) {
      var observer = new ResizeObserver(function (entries) {
        callback == null ? void 0 : callback(entries, observer);
        if (!entries.length) return;
        if (box === "content") {
          contentRect.value = entries[0].contentRect;
        } else {
          contentRect.value = entries[0].target.getBoundingClientRect();
        }
      });
      onBeforeUnmount(function () {
        observer.disconnect();
      });
      watch(function () {
        return resizeRef.el;
      }, function (newValue, oldValue) {
        if (oldValue) {
          observer.unobserve(oldValue);
          contentRect.value = void 0;
        }
        if (newValue) observer.observe(newValue);
      }, {
        flush: "post"
      });
    }
    return {
      resizeRef: resizeRef,
      contentRect: readonly(contentRect)
    };
  }
  var VuetifyLayoutKey = Symbol.for("vuetify:layout");
  var VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
  var ROOT_ZINDEX = 1e3;
  var makeLayoutProps = propsFactory({
    overlaps: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    fullHeight: Boolean
  }, "layout");
  var makeLayoutItemProps = propsFactory({
    name: {
      type: String
    },
    order: {
      type: [Number, String],
      "default": 0
    },
    absolute: Boolean
  }, "layout-item");
  function useLayout() {
    var layout = inject$1(VuetifyLayoutKey);
    if (!layout) throw new Error("[Vuetify] Could not find injected layout");
    return {
      getLayoutItem: layout.getLayoutItem,
      mainRect: layout.mainRect,
      mainStyles: layout.mainStyles
    };
  }
  function useLayoutItem(options) {
    var _a2;
    var layout = inject$1(VuetifyLayoutKey);
    if (!layout) throw new Error("[Vuetify] Could not find injected layout");
    var id = (_a2 = options.id) != null ? _a2 : "layout-item-" + getUid();
    var vm = getCurrentInstance("useLayoutItem");
    provide(VuetifyLayoutItemKey, {
      id: id
    });
    var isKeptAlive = shallowRef(false);
    onDeactivated(function () {
      return isKeptAlive.value = true;
    });
    onActivated(function () {
      return isKeptAlive.value = false;
    });
    var _layout$register = layout.register(vm, _objectSpread(_objectSpread({}, options), {}, {
        active: computed(function () {
          return isKeptAlive.value ? false : options.active.value;
        }),
        id: id
      })),
      layoutItemStyles = _layout$register.layoutItemStyles,
      layoutItemScrimStyles = _layout$register.layoutItemScrimStyles;
    onBeforeUnmount(function () {
      return layout.unregister(id);
    });
    return {
      layoutItemStyles: layoutItemStyles,
      layoutRect: layout.layoutRect,
      layoutItemScrimStyles: layoutItemScrimStyles
    };
  }
  var generateLayers = function (layout, positions, layoutSizes, activeItems) {
    var previousLayer = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    };
    var layers = [{
      id: "",
      layer: _objectSpread({}, previousLayer)
    }];
    for (var _iterator36 = _createForOfIteratorHelperLoose(layout), _step38; !(_step38 = _iterator36()).done;) {
      var _objectSpread4;
      var id = _step38.value;
      var position = positions.get(id);
      var amount = layoutSizes.get(id);
      var active = activeItems.get(id);
      if (!position || !amount || !active) continue;
      var layer = _objectSpread(_objectSpread({}, previousLayer), {}, (_objectSpread4 = {}, _objectSpread4[position.value] = parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0), _objectSpread4));
      layers.push({
        id: id,
        layer: layer
      });
      previousLayer = layer;
    }
    return layers;
  };
  function createLayout(props) {
    var parentLayout = inject$1(VuetifyLayoutKey, null);
    var rootZIndex = computed(function () {
      return parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX;
    });
    var registered = ref([]);
    var positions = reactive( /* @__PURE__ */new Map());
    var layoutSizes = reactive( /* @__PURE__ */new Map());
    var priorities = reactive( /* @__PURE__ */new Map());
    var activeItems = reactive( /* @__PURE__ */new Map());
    var disabledTransitions = reactive( /* @__PURE__ */new Map());
    var _useResizeObserver = useResizeObserver(),
      resizeRef = _useResizeObserver.resizeRef,
      layoutRect = _useResizeObserver.contentRect;
    var computedOverlaps = computed(function () {
      var _a2;
      var map3 = /* @__PURE__ */new Map();
      var overlaps = (_a2 = props.overlaps) != null ? _a2 : [];
      for (var _iterator37 = _createForOfIteratorHelperLoose(overlaps.filter(function (item) {
          return item.includes(":");
        })), _step39; !(_step39 = _iterator37()).done;) {
        var overlap = _step39.value;
        var _overlap$split = overlap.split(":"),
          _overlap$split2 = _slicedToArray(_overlap$split, 2),
          top = _overlap$split2[0],
          bottom = _overlap$split2[1];
        if (!registered.value.includes(top) || !registered.value.includes(bottom)) continue;
        var topPosition = positions.get(top);
        var bottomPosition = positions.get(bottom);
        var topAmount = layoutSizes.get(top);
        var bottomAmount = layoutSizes.get(bottom);
        if (!topPosition || !bottomPosition || !topAmount || !bottomAmount) continue;
        map3.set(bottom, {
          position: topPosition.value,
          amount: parseInt(topAmount.value, 10)
        });
        map3.set(top, {
          position: bottomPosition.value,
          amount: -parseInt(bottomAmount.value, 10)
        });
      }
      return map3;
    });
    var layers = computed(function () {
      var uniquePriorities = _toConsumableArray(new Set(_toConsumableArray(priorities.values()).map(function (p2) {
        return p2.value;
      }))).sort(function (a, b) {
        return a - b;
      });
      var layout = [];
      var _loop25 = function (p2) {
        var items2 = registered.value.filter(function (id) {
          var _a2;
          return ((_a2 = priorities.get(id)) == null ? void 0 : _a2.value) === p2;
        });
        layout.push.apply(layout, _toConsumableArray(items2));
      };
      for (var _iterator38 = _createForOfIteratorHelperLoose(uniquePriorities), _step40; !(_step40 = _iterator38()).done;) {
        var p2 = _step40.value;
        _loop25(p2);
      }
      return generateLayers(layout, positions, layoutSizes, activeItems);
    });
    var transitionsEnabled = computed(function () {
      return !Array.from(disabledTransitions.values()).some(function (ref2) {
        return ref2.value;
      });
    });
    var mainRect = computed(function () {
      return layers.value[layers.value.length - 1].layer;
    });
    var mainStyles = computed(function () {
      return _objectSpread({
        "--v-layout-left": convertToUnit(mainRect.value.left),
        "--v-layout-right": convertToUnit(mainRect.value.right),
        "--v-layout-top": convertToUnit(mainRect.value.top),
        "--v-layout-bottom": convertToUnit(mainRect.value.bottom)
      }, transitionsEnabled.value ? void 0 : {
        transition: "none"
      });
    });
    var items = computed(function () {
      return layers.value.slice(1).map(function (_ref, index) {
        var id = _ref.id;
        var layer = layers.value[index].layer;
        var size = layoutSizes.get(id);
        var position = positions.get(id);
        return _objectSpread(_objectSpread({
          id: id
        }, layer), {}, {
          size: Number(size.value),
          position: position.value
        });
      });
    });
    var getLayoutItem = function (id) {
      return items.value.find(function (item) {
        return item.id === id;
      });
    };
    var rootVm = getCurrentInstance("createLayout");
    var isMounted = shallowRef(false);
    onMounted(function () {
      isMounted.value = true;
    });
    provide(VuetifyLayoutKey, {
      register: function (vm, _ref2) {
        var id = _ref2.id,
          order = _ref2.order,
          position = _ref2.position,
          layoutSize = _ref2.layoutSize,
          elementSize = _ref2.elementSize,
          active = _ref2.active,
          disableTransitions = _ref2.disableTransitions,
          absolute = _ref2.absolute;
        priorities.set(id, order);
        positions.set(id, position);
        layoutSizes.set(id, layoutSize);
        activeItems.set(id, active);
        disableTransitions && disabledTransitions.set(id, disableTransitions);
        var instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
        var instanceIndex = instances.indexOf(vm);
        if (instanceIndex > -1) registered.value.splice(instanceIndex, 0, id);else registered.value.push(id);
        var index = computed(function () {
          return items.value.findIndex(function (i) {
            return i.id === id;
          });
        });
        var zIndex = computed(function () {
          return rootZIndex.value + layers.value.length * 2 - index.value * 2;
        });
        var layoutItemStyles = computed(function () {
          var _objectSpread5;
          var _a2;
          var isHorizontal = position.value === "left" || position.value === "right";
          var isOppositeHorizontal = position.value === "right";
          var isOppositeVertical = position.value === "bottom";
          var size = (_a2 = elementSize.value) != null ? _a2 : layoutSize.value;
          var unit = size === 0 ? "%" : "px";
          var styles = _objectSpread((_objectSpread5 = {}, _objectSpread5[position.value] = 0, _objectSpread5.zIndex = zIndex.value, _objectSpread5.transform = "translate" + (isHorizontal ? "X" : "Y") + "(" + (active.value ? 0 : -(size === 0 ? 100 : size)) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1) + unit + ")", _objectSpread5.position = absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed", _objectSpread5), transitionsEnabled.value ? void 0 : {
            transition: "none"
          });
          if (!isMounted.value) return styles;
          var item = items.value[index.value];
          if (!item) throw new Error("[Vuetify] Could not find layout item \"" + id + "\"");
          var overlap = computedOverlaps.value.get(id);
          if (overlap) {
            item[overlap.position] += overlap.amount;
          }
          return _objectSpread(_objectSpread({}, styles), {}, {
            height: isHorizontal ? "calc(100% - " + item.top + "px - " + item.bottom + "px)" : elementSize.value ? elementSize.value + "px" : void 0,
            left: isOppositeHorizontal ? void 0 : item.left + "px",
            right: isOppositeHorizontal ? item.right + "px" : void 0,
            top: position.value !== "bottom" ? item.top + "px" : void 0,
            bottom: position.value !== "top" ? item.bottom + "px" : void 0,
            width: !isHorizontal ? "calc(100% - " + item.left + "px - " + item.right + "px)" : elementSize.value ? elementSize.value + "px" : void 0
          });
        });
        var layoutItemScrimStyles = computed(function () {
          return {
            zIndex: zIndex.value - 1
          };
        });
        return {
          layoutItemStyles: layoutItemStyles,
          layoutItemScrimStyles: layoutItemScrimStyles,
          zIndex: zIndex
        };
      },
      unregister: function (id) {
        priorities.delete(id);
        positions.delete(id);
        layoutSizes.delete(id);
        activeItems.delete(id);
        disabledTransitions.delete(id);
        registered.value = registered.value.filter(function (v) {
          return v !== id;
        });
      },
      mainRect: mainRect,
      mainStyles: mainStyles,
      getLayoutItem: getLayoutItem,
      items: items,
      layoutRect: layoutRect,
      rootZIndex: rootZIndex
    });
    var layoutClasses = computed(function () {
      return ["v-layout", {
        "v-layout--full-height": props.fullHeight
      }];
    });
    var layoutStyles = computed(function () {
      return {
        zIndex: parentLayout ? rootZIndex.value : void 0,
        position: parentLayout ? "relative" : void 0,
        overflow: parentLayout ? "hidden" : void 0
      };
    });
    return {
      layoutClasses: layoutClasses,
      layoutStyles: layoutStyles,
      getLayoutItem: getLayoutItem,
      items: items,
      layoutRect: layoutRect,
      layoutRef: resizeRef
    };
  }
  function createVuetify() {
    var vuetify2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var blueprint = vuetify2.blueprint,
      rest = _objectWithoutProperties(vuetify2, _excluded2);
    var options = mergeDeep(blueprint, rest);
    var _options$aliases = options.aliases,
      aliases2 = _options$aliases === void 0 ? {} : _options$aliases,
      _options$components = options.components,
      components2 = _options$components === void 0 ? {} : _options$components,
      _options$directives = options.directives,
      directives2 = _options$directives === void 0 ? {} : _options$directives;
    var defaults = createDefaults(options.defaults);
    var display = createDisplay(options.display, options.ssr);
    var theme = createTheme(options.theme);
    var icons = createIcons(options.icons);
    var locale = createLocale(options.locale);
    var date2 = createDate(options.date, locale);
    var goTo = createGoTo(options.goTo, locale);
    var install = function (app) {
      for (var key in directives2) {
        app.directive(key, directives2[key]);
      }
      for (var _key45 in components2) {
        app.component(_key45, components2[_key45]);
      }
      for (var _key46 in aliases2) {
        app.component(_key46, defineComponent(_objectSpread(_objectSpread({}, aliases2[_key46]), {}, {
          name: _key46,
          aliasName: aliases2[_key46].name
        })));
      }
      theme.install(app);
      app.provide(DefaultsSymbol, defaults);
      app.provide(DisplaySymbol, display);
      app.provide(ThemeSymbol, theme);
      app.provide(IconSymbol, icons);
      app.provide(LocaleSymbol, locale);
      app.provide(DateOptionsSymbol, date2.options);
      app.provide(DateAdapterSymbol, date2.instance);
      app.provide(GoToSymbol, goTo);
      if (IN_BROWSER && options.ssr) {
        if (app.$nuxt) {
          app.$nuxt.hook("app:suspense:resolve", function () {
            display.update();
          });
        } else {
          var mount = app.mount;
          app.mount = function () {
            var vm = mount.apply(void 0, arguments);
            nextTick(function () {
              return display.update();
            });
            app.mount = mount;
            return vm;
          };
        }
      }
      getUid.reset();
      {
        app.mixin({
          computed: {
            $vuetify: function () {
              return reactive({
                defaults: inject.call(this, DefaultsSymbol),
                display: inject.call(this, DisplaySymbol),
                theme: inject.call(this, ThemeSymbol),
                icons: inject.call(this, IconSymbol),
                locale: inject.call(this, LocaleSymbol),
                date: inject.call(this, DateAdapterSymbol)
              });
            }
          }
        });
      }
    };
    return {
      install: install,
      defaults: defaults,
      display: display,
      theme: theme,
      icons: icons,
      locale: locale,
      date: date2,
      goTo: goTo
    };
  }
  var version = "3.7.3";
  createVuetify.version = version;
  function inject(key) {
    var _a2, _b, _c;
    var vm = this.$;
    var provides = (_c = (_a2 = vm.parent) == null ? void 0 : _a2.provides) != null ? _c : (_b = vm.vnode.appContext) == null ? void 0 : _b.provides;
    if (provides && key in provides) {
      return provides[key];
    }
  }
  var VApp$1 = "";
  var makeVAppProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({}, makeComponentProps()), makeLayoutProps({
    fullHeight: true
  })), makeThemeProps()), "VApp");
  var VApp = genericComponent()({
    name: "VApp",
    props: makeVAppProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var theme = provideTheme(props);
      var _createLayout = createLayout(props),
        layoutClasses = _createLayout.layoutClasses,
        getLayoutItem = _createLayout.getLayoutItem,
        items = _createLayout.items,
        layoutRef = _createLayout.layoutRef;
      var _useRtl2 = useRtl(),
        rtlClasses = _useRtl2.rtlClasses;
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "ref": layoutRef,
          "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props.class],
          "style": [props.style]
        }, [createVNode("div", {
          "class": "v-application__wrap"
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
      });
      return {
        getLayoutItem: getLayoutItem,
        items: items,
        theme: theme
      };
    }
  });
  var VAppBar$1 = "";
  var VToolbar$1 = "";
  var makeTagProps = propsFactory({
    tag: {
      type: String,
      "default": "div"
    }
  }, "tag");
  var makeVToolbarTitleProps = propsFactory(_objectSpread(_objectSpread({
    text: String
  }, makeComponentProps()), makeTagProps()), "VToolbarTitle");
  var VToolbarTitle = genericComponent()({
    name: "VToolbarTitle",
    props: makeVToolbarTitleProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var hasText = !!(slots.default || slots.text || props.text);
        return createVNode(props.tag, {
          "class": ["v-toolbar-title", props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a2;
            return [hasText && createVNode("div", {
              "class": "v-toolbar-title__placeholder"
            }, [slots.text ? slots.text() : props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])];
          }
        });
      });
      return {};
    }
  });
  var makeTransitionProps$1 = propsFactory({
    disabled: Boolean,
    group: Boolean,
    hideOnLeave: Boolean,
    leaveAbsolute: Boolean,
    mode: String,
    origin: String
  }, "transition");
  function createCssTransition(name, origin, mode) {
    return genericComponent()({
      name: name,
      props: makeTransitionProps$1({
        mode: mode,
        origin: origin
      }),
      setup: function (props, _ref) {
        var slots = _ref.slots;
        var functions = {
          onBeforeEnter: function (el) {
            if (props.origin) {
              el.style.transformOrigin = props.origin;
            }
          },
          onLeave: function (el) {
            if (props.leaveAbsolute) {
              var offsetTop = el.offsetTop,
                offsetLeft = el.offsetLeft,
                offsetWidth = el.offsetWidth,
                offsetHeight = el.offsetHeight;
              el._transitionInitialStyles = {
                position: el.style.position,
                top: el.style.top,
                left: el.style.left,
                width: el.style.width,
                height: el.style.height
              };
              el.style.position = "absolute";
              el.style.top = offsetTop + "px";
              el.style.left = offsetLeft + "px";
              el.style.width = offsetWidth + "px";
              el.style.height = offsetHeight + "px";
            }
            if (props.hideOnLeave) {
              el.style.setProperty("display", "none", "important");
            }
          },
          onAfterLeave: function (el) {
            if (props.leaveAbsolute && (el == null ? void 0 : el._transitionInitialStyles)) {
              var _el$_transitionInitia = el._transitionInitialStyles,
                position = _el$_transitionInitia.position,
                top = _el$_transitionInitia.top,
                left = _el$_transitionInitia.left,
                width = _el$_transitionInitia.width,
                height = _el$_transitionInitia.height;
              delete el._transitionInitialStyles;
              el.style.position = position || "";
              el.style.top = top || "";
              el.style.left = left || "";
              el.style.width = width || "";
              el.style.height = height || "";
            }
          }
        };
        return function () {
          var tag = props.group ? TransitionGroup : Transition;
          return h(tag, _objectSpread(_objectSpread({
            name: props.disabled ? "" : name,
            css: !props.disabled
          }, props.group ? void 0 : {
            mode: props.mode
          }), props.disabled ? {} : functions), slots.default);
        };
      }
    });
  }
  function createJavascriptTransition(name, functions) {
    var mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
    return genericComponent()({
      name: name,
      props: {
        mode: {
          type: String,
          "default": mode
        },
        disabled: Boolean,
        group: Boolean
      },
      setup: function (props, _ref2) {
        var slots = _ref2.slots;
        var tag = props.group ? TransitionGroup : Transition;
        return function () {
          return h(tag, _objectSpread({
            name: props.disabled ? "" : name,
            css: !props.disabled
          }, props.disabled ? {} : functions), slots.default);
        };
      }
    });
  }
  function ExpandTransitionGenerator() {
    var expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var sizeProperty = x ? "width" : "height";
    var offsetProperty = camelize("offset-" + sizeProperty);
    return {
      onBeforeEnter: function (el) {
        var _el$_initialStyle;
        el._parent = el.parentNode;
        el._initialStyle = (_el$_initialStyle = {
          transition: el.style.transition,
          overflow: el.style.overflow
        }, _el$_initialStyle[sizeProperty] = el.style[sizeProperty], _el$_initialStyle);
      },
      onEnter: function (el) {
        var initialStyle = el._initialStyle;
        el.style.setProperty("transition", "none", "important");
        el.style.overflow = "hidden";
        var offset = el[offsetProperty] + "px";
        el.style[sizeProperty] = "0";
        void el.offsetHeight;
        el.style.transition = initialStyle.transition;
        if (expandedParentClass && el._parent) {
          el._parent.classList.add(expandedParentClass);
        }
        requestAnimationFrame(function () {
          el.style[sizeProperty] = offset;
        });
      },
      onAfterEnter: resetStyles,
      onEnterCancelled: resetStyles,
      onLeave: function (el) {
        var _el$_initialStyle2;
        el._initialStyle = (_el$_initialStyle2 = {
          transition: "",
          overflow: el.style.overflow
        }, _el$_initialStyle2[sizeProperty] = el.style[sizeProperty], _el$_initialStyle2);
        el.style.overflow = "hidden";
        el.style[sizeProperty] = el[offsetProperty] + "px";
        void el.offsetHeight;
        requestAnimationFrame(function () {
          return el.style[sizeProperty] = "0";
        });
      },
      onAfterLeave: onAfterLeave,
      onLeaveCancelled: onAfterLeave
    };
    function onAfterLeave(el) {
      if (expandedParentClass && el._parent) {
        el._parent.classList.remove(expandedParentClass);
      }
      resetStyles(el);
    }
    function resetStyles(el) {
      var size = el._initialStyle[sizeProperty];
      el.style.overflow = el._initialStyle.overflow;
      if (size != null) el.style[sizeProperty] = size;
      delete el._initialStyle;
    }
  }
  var makeVDialogTransitionProps = propsFactory({
    target: [Object, Array]
  }, "v-dialog-transition");
  var VDialogTransition = genericComponent()({
    name: "VDialogTransition",
    props: makeVDialogTransitionProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var functions = {
        onBeforeEnter: function (el) {
          el.style.pointerEvents = "none";
          el.style.visibility = "hidden";
        },
        onEnter: function _callee2(el, done) {
          var _a2, _getDimensions, x, y, sx, sy, speed, animation;
          return _regeneratorRuntime.async(function _callee2$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
                  return requestAnimationFrame(resolve2);
                }));
              case 2:
                _context5.next = 4;
                return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
                  return requestAnimationFrame(resolve2);
                }));
              case 4:
                el.style.visibility = "";
                _getDimensions = getDimensions(props.target, el), x = _getDimensions.x, y = _getDimensions.y, sx = _getDimensions.sx, sy = _getDimensions.sy, speed = _getDimensions.speed;
                animation = animate(el, [{
                  transform: "translate(" + x + "px, " + y + "px) scale(" + sx + ", " + sy + ")",
                  opacity: 0
                }, {}], {
                  duration: 225 * speed,
                  easing: deceleratedEasing
                });
                (_a2 = getChildren(el)) == null ? void 0 : _a2.forEach(function (el2) {
                  animate(el2, [{
                    opacity: 0
                  }, {
                    opacity: 0,
                    offset: 0.33
                  }, {}], {
                    duration: 225 * 2 * speed,
                    easing: standardEasing
                  });
                });
                animation.finished.then(function () {
                  return done();
                });
              case 9:
              case "end":
                return _context5.stop();
            }
          }, null, null, null, Promise);
        },
        onAfterEnter: function (el) {
          el.style.removeProperty("pointer-events");
        },
        onBeforeLeave: function (el) {
          el.style.pointerEvents = "none";
        },
        onLeave: function _callee3(el, done) {
          var _a2, _getDimensions2, x, y, sx, sy, speed, animation;
          return _regeneratorRuntime.async(function _callee3$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
                  return requestAnimationFrame(resolve2);
                }));
              case 2:
                _getDimensions2 = getDimensions(props.target, el), x = _getDimensions2.x, y = _getDimensions2.y, sx = _getDimensions2.sx, sy = _getDimensions2.sy, speed = _getDimensions2.speed;
                animation = animate(el, [{}, {
                  transform: "translate(" + x + "px, " + y + "px) scale(" + sx + ", " + sy + ")",
                  opacity: 0
                }], {
                  duration: 125 * speed,
                  easing: acceleratedEasing
                });
                animation.finished.then(function () {
                  return done();
                });
                (_a2 = getChildren(el)) == null ? void 0 : _a2.forEach(function (el2) {
                  animate(el2, [{}, {
                    opacity: 0,
                    offset: 0.2
                  }, {
                    opacity: 0
                  }], {
                    duration: 125 * 2 * speed,
                    easing: standardEasing
                  });
                });
              case 6:
              case "end":
                return _context6.stop();
            }
          }, null, null, null, Promise);
        },
        onAfterLeave: function (el) {
          el.style.removeProperty("pointer-events");
        }
      };
      return function () {
        return props.target ? createVNode(Transition, mergeProps({
          "name": "dialog-transition"
        }, functions, {
          "css": false
        }), slots) : createVNode(Transition, {
          "name": "dialog-transition"
        }, slots);
      };
    }
  });
  function getChildren(el) {
    var _a2;
    var els = (_a2 = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _a2.children;
    return els && _toConsumableArray(els);
  }
  function getDimensions(target, el) {
    var targetBox = getTargetBox(target);
    var elBox = nullifyTransforms(el);
    var _getComputedStyle$tra = getComputedStyle(el).transformOrigin.split(" ").map(function (v) {
        return parseFloat(v);
      }),
      _getComputedStyle$tra2 = _slicedToArray(_getComputedStyle$tra, 2),
      originX = _getComputedStyle$tra2[0],
      originY = _getComputedStyle$tra2[1];
    var _getComputedStyle$get = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" "),
      _getComputedStyle$get2 = _slicedToArray(_getComputedStyle$get, 2),
      anchorSide = _getComputedStyle$get2[0],
      anchorOffset = _getComputedStyle$get2[1];
    var offsetX = targetBox.left + targetBox.width / 2;
    if (anchorSide === "left" || anchorOffset === "left") {
      offsetX -= targetBox.width / 2;
    } else if (anchorSide === "right" || anchorOffset === "right") {
      offsetX += targetBox.width / 2;
    }
    var offsetY = targetBox.top + targetBox.height / 2;
    if (anchorSide === "top" || anchorOffset === "top") {
      offsetY -= targetBox.height / 2;
    } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
      offsetY += targetBox.height / 2;
    }
    var tsx = targetBox.width / elBox.width;
    var tsy = targetBox.height / elBox.height;
    var maxs = Math.max(1, tsx, tsy);
    var sx = tsx / maxs || 0;
    var sy = tsy / maxs || 0;
    var asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
    var speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
    return {
      x: offsetX - (originX + elBox.left),
      y: offsetY - (originY + elBox.top),
      sx: sx,
      sy: sy,
      speed: speed
    };
  }
  var VFabTransition = createCssTransition("fab-transition", "center center", "out-in");
  var VDialogBottomTransition = createCssTransition("dialog-bottom-transition");
  var VDialogTopTransition = createCssTransition("dialog-top-transition");
  var VFadeTransition = createCssTransition("fade-transition");
  var VScaleTransition = createCssTransition("scale-transition");
  var VScrollXTransition = createCssTransition("scroll-x-transition");
  var VScrollXReverseTransition = createCssTransition("scroll-x-reverse-transition");
  var VScrollYTransition = createCssTransition("scroll-y-transition");
  var VScrollYReverseTransition = createCssTransition("scroll-y-reverse-transition");
  var VSlideXTransition = createCssTransition("slide-x-transition");
  var VSlideXReverseTransition = createCssTransition("slide-x-reverse-transition");
  var VSlideYTransition = createCssTransition("slide-y-transition");
  var VSlideYReverseTransition = createCssTransition("slide-y-reverse-transition");
  var VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
  var VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
  var makeVDefaultsProviderProps = propsFactory({
    defaults: Object,
    disabled: Boolean,
    reset: [Number, String],
    root: [Boolean, String],
    scoped: Boolean
  }, "VDefaultsProvider");
  var VDefaultsProvider = genericComponent(false)({
    name: "VDefaultsProvider",
    props: makeVDefaultsProviderProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _toRefs = toRefs(props),
        defaults = _toRefs.defaults,
        disabled = _toRefs.disabled,
        reset = _toRefs.reset,
        root = _toRefs.root,
        scoped = _toRefs.scoped;
      provideDefaults(defaults, {
        reset: reset,
        root: root,
        scoped: scoped,
        disabled: disabled
      });
      return function () {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      };
    }
  });
  var VImg$1 = "";
  var VResponsive$1 = "";
  var makeDimensionProps = propsFactory({
    height: [Number, String],
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    width: [Number, String]
  }, "dimension");
  function useDimension(props) {
    var dimensionStyles = computed(function () {
      var styles = {};
      var height = convertToUnit(props.height);
      var maxHeight = convertToUnit(props.maxHeight);
      var maxWidth = convertToUnit(props.maxWidth);
      var minHeight = convertToUnit(props.minHeight);
      var minWidth = convertToUnit(props.minWidth);
      var width = convertToUnit(props.width);
      if (height != null) styles.height = height;
      if (maxHeight != null) styles.maxHeight = maxHeight;
      if (maxWidth != null) styles.maxWidth = maxWidth;
      if (minHeight != null) styles.minHeight = minHeight;
      if (minWidth != null) styles.minWidth = minWidth;
      if (width != null) styles.width = width;
      return styles;
    });
    return {
      dimensionStyles: dimensionStyles
    };
  }
  function useAspectStyles(props) {
    return {
      aspectStyles: computed(function () {
        var ratio = Number(props.aspectRatio);
        return ratio ? {
          paddingBottom: String(1 / ratio * 100) + "%"
        } : void 0;
      })
    };
  }
  var makeVResponsiveProps = propsFactory(_objectSpread(_objectSpread({
    aspectRatio: [String, Number],
    contentClass: null,
    inline: Boolean
  }, makeComponentProps()), makeDimensionProps()), "VResponsive");
  var VResponsive = genericComponent()({
    name: "VResponsive",
    props: makeVResponsiveProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useAspectStyles = useAspectStyles(props),
        aspectStyles = _useAspectStyles.aspectStyles;
      var _useDimension = useDimension(props),
        dimensionStyles = _useDimension.dimensionStyles;
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-responsive", {
            "v-responsive--inline": props.inline
          }, props.class],
          "style": [dimensionStyles.value, props.style]
        }, [createVNode("div", {
          "class": "v-responsive__sizer",
          "style": aspectStyles.value
        }, null), (_a2 = slots.additional) == null ? void 0 : _a2.call(slots), slots.default && createVNode("div", {
          "class": ["v-responsive__content", props.contentClass]
        }, [slots.default()])]);
      });
      return {};
    }
  });
  function useColor(colors2) {
    return destructComputed(function () {
      var classes = [];
      var styles = {};
      if (colors2.value.background) {
        if (isCssColor(colors2.value.background)) {
          styles.backgroundColor = colors2.value.background;
          if (!colors2.value.text && isParsableColor(colors2.value.background)) {
            var backgroundColor = parseColor(colors2.value.background);
            if (backgroundColor.a == null || backgroundColor.a === 1) {
              var textColor = getForeground(backgroundColor);
              styles.color = textColor;
              styles.caretColor = textColor;
            }
          }
        } else {
          classes.push("bg-" + colors2.value.background);
        }
      }
      if (colors2.value.text) {
        if (isCssColor(colors2.value.text)) {
          styles.color = colors2.value.text;
          styles.caretColor = colors2.value.text;
        } else {
          classes.push("text-" + colors2.value.text);
        }
      }
      return {
        colorClasses: classes,
        colorStyles: styles
      };
    });
  }
  function useTextColor(props, name) {
    var colors2 = computed(function () {
      return {
        text: isRef(props) ? props.value : name ? props[name] : null
      };
    });
    var _useColor = useColor(colors2),
      textColorClasses = _useColor.colorClasses,
      textColorStyles = _useColor.colorStyles;
    return {
      textColorClasses: textColorClasses,
      textColorStyles: textColorStyles
    };
  }
  function useBackgroundColor(props, name) {
    var colors2 = computed(function () {
      return {
        background: isRef(props) ? props.value : name ? props[name] : null
      };
    });
    var _useColor2 = useColor(colors2),
      backgroundColorClasses = _useColor2.colorClasses,
      backgroundColorStyles = _useColor2.colorStyles;
    return {
      backgroundColorClasses: backgroundColorClasses,
      backgroundColorStyles: backgroundColorStyles
    };
  }
  var makeRoundedProps = propsFactory({
    rounded: {
      type: [Boolean, Number, String],
      "default": void 0
    },
    tile: Boolean
  }, "rounded");
  function useRounded(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var roundedClasses = computed(function () {
      var rounded = isRef(props) ? props.value : props.rounded;
      var tile = isRef(props) ? props.value : props.tile;
      var classes = [];
      if (rounded === true || rounded === "") {
        classes.push(name + "--rounded");
      } else if (typeof rounded === "string" || rounded === 0) {
        for (var _iterator39 = _createForOfIteratorHelperLoose(String(rounded).split(" ")), _step41; !(_step41 = _iterator39()).done;) {
          var value = _step41.value;
          classes.push("rounded-" + value);
        }
      } else if (tile || rounded === false) {
        classes.push("rounded-0");
      }
      return classes;
    });
    return {
      roundedClasses: roundedClasses
    };
  }
  var makeTransitionProps = propsFactory({
    transition: {
      type: [Boolean, String, Object],
      "default": "fade-transition",
      validator: function (val) {
        return val !== true;
      }
    }
  }, "transition");
  var MaybeTransition = function (props, _ref) {
    var slots = _ref.slots;
    var transition = props.transition,
      disabled = props.disabled,
      group = props.group,
      rest = _objectWithoutProperties(props, _excluded3);
    var _ref255 = _typeof(transition) === "object" ? transition : {},
      _ref255$component = _ref255.component,
      component = _ref255$component === void 0 ? group ? TransitionGroup : Transition : _ref255$component,
      customProps = _objectWithoutProperties(_ref255, _excluded4);
    return h(component, mergeProps(typeof transition === "string" ? {
      name: disabled ? "" : transition
    } : customProps, typeof transition === "string" ? {} : Object.fromEntries(Object.entries({
      disabled: disabled,
      group: group
    }).filter(function (_ref2) {
      var _ref256 = _slicedToArray(_ref2, 2),
        _ = _ref256[0],
        v = _ref256[1];
      return v !== void 0;
    })), rest), slots);
  };
  function mounted$5(el, binding) {
    if (!SUPPORTS_INTERSECTION) return;
    var modifiers2 = binding.modifiers || {};
    var value = binding.value;
    var _ref257 = _typeof(value) === "object" ? value : {
        handler: value,
        options: {}
      },
      handler = _ref257.handler,
      options = _ref257.options;
    var observer = new IntersectionObserver(function () {
      var _a2;
      var entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var observer2 = arguments.length > 1 ? arguments[1] : void 0;
      var _observe = (_a2 = el._observe) == null ? void 0 : _a2[binding.instance.$.uid];
      if (!_observe) return;
      var isIntersecting = entries.some(function (entry) {
        return entry.isIntersecting;
      });
      if (handler && (!modifiers2.quiet || _observe.init) && (!modifiers2.once || isIntersecting || _observe.init)) {
        handler(isIntersecting, entries, observer2);
      }
      if (isIntersecting && modifiers2.once) unmounted$5(el, binding);else _observe.init = true;
    }, options);
    el._observe = Object(el._observe);
    el._observe[binding.instance.$.uid] = {
      init: false,
      observer: observer
    };
    observer.observe(el);
  }
  function unmounted$5(el, binding) {
    var _a2;
    var observe = (_a2 = el._observe) == null ? void 0 : _a2[binding.instance.$.uid];
    if (!observe) return;
    observe.observer.unobserve(el);
    delete el._observe[binding.instance.$.uid];
  }
  var Intersect = {
    mounted: mounted$5,
    unmounted: unmounted$5
  };
  var makeVImgProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    absolute: Boolean,
    alt: String,
    cover: Boolean,
    color: String,
    draggable: {
      type: [Boolean, String],
      "default": void 0
    },
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
      type: Object,
      "default": function () {
        return {
          root: void 0,
          rootMargin: void 0,
          threshold: void 0
        };
      }
    },
    sizes: String,
    src: {
      type: [String, Object],
      "default": ""
    },
    crossorigin: String,
    referrerpolicy: String,
    srcset: String,
    position: String
  }, makeVResponsiveProps()), makeComponentProps()), makeRoundedProps()), makeTransitionProps()), "VImg");
  var VImg = genericComponent()({
    name: "VImg",
    directives: {
      intersect: Intersect
    },
    props: makeVImgProps(),
    emits: {
      loadstart: function (value) {
        return true;
      },
      load: function (value) {
        return true;
      },
      error: function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var _useBackgroundColor = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor.backgroundColorStyles;
      var _useRounded = useRounded(props),
        roundedClasses = _useRounded.roundedClasses;
      var vm = getCurrentInstance("VImg");
      var currentSrc = shallowRef("");
      var image = ref();
      var state = shallowRef(props.eager ? "loading" : "idle");
      var naturalWidth = shallowRef();
      var naturalHeight = shallowRef();
      var normalisedSrc = computed(function () {
        return props.src && _typeof(props.src) === "object" ? {
          src: props.src.src,
          srcset: props.srcset || props.src.srcset,
          lazySrc: props.lazySrc || props.src.lazySrc,
          aspect: Number(props.aspectRatio || props.src.aspect || 0)
        } : {
          src: props.src,
          srcset: props.srcset,
          lazySrc: props.lazySrc,
          aspect: Number(props.aspectRatio || 0)
        };
      });
      var aspectRatio = computed(function () {
        return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
      });
      watch(function () {
        return props.src;
      }, function () {
        init(state.value !== "idle");
      });
      watch(aspectRatio, function (val, oldVal) {
        if (!val && oldVal && image.value) {
          pollForSize(image.value);
        }
      });
      onBeforeMount(function () {
        return init();
      });
      function init(isIntersecting) {
        if (props.eager && isIntersecting) return;
        if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager) return;
        state.value = "loading";
        if (normalisedSrc.value.lazySrc) {
          var lazyImg = new Image();
          lazyImg.src = normalisedSrc.value.lazySrc;
          pollForSize(lazyImg, null);
        }
        if (!normalisedSrc.value.src) return;
        nextTick(function () {
          var _a2;
          emit2("loadstart", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
          setTimeout(function () {
            var _a3;
            if (vm.isUnmounted) return;
            if ((_a3 = image.value) == null ? void 0 : _a3.complete) {
              if (!image.value.naturalWidth) {
                onError();
              }
              if (state.value === "error") return;
              if (!aspectRatio.value) pollForSize(image.value, null);
              if (state.value === "loading") onLoad();
            } else {
              if (!aspectRatio.value) pollForSize(image.value);
              getSrc();
            }
          });
        });
      }
      function onLoad() {
        var _a2;
        if (vm.isUnmounted) return;
        getSrc();
        pollForSize(image.value);
        state.value = "loaded";
        emit2("load", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
      }
      function onError() {
        var _a2;
        if (vm.isUnmounted) return;
        state.value = "error";
        emit2("error", ((_a2 = image.value) == null ? void 0 : _a2.currentSrc) || normalisedSrc.value.src);
      }
      function getSrc() {
        var img = image.value;
        if (img) currentSrc.value = img.currentSrc || img.src;
      }
      var timer = -1;
      onBeforeUnmount(function () {
        clearTimeout(timer);
      });
      function pollForSize(img) {
        var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        var poll = function () {
          clearTimeout(timer);
          if (vm.isUnmounted) return;
          var imgHeight = img.naturalHeight,
            imgWidth = img.naturalWidth;
          if (imgHeight || imgWidth) {
            naturalWidth.value = imgWidth;
            naturalHeight.value = imgHeight;
          } else if (!img.complete && state.value === "loading" && timeout != null) {
            timer = window.setTimeout(poll, timeout);
          } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
            naturalWidth.value = 1;
            naturalHeight.value = 1;
          }
        };
        poll();
      }
      var containClasses = computed(function () {
        return {
          "v-img__img--cover": props.cover,
          "v-img__img--contain": !props.cover
        };
      });
      var __image = function () {
        var _a2;
        if (!normalisedSrc.value.src || state.value === "idle") return null;
        var img = createVNode("img", {
          "class": ["v-img__img", containClasses.value],
          "style": {
            objectPosition: props.position
          },
          "src": normalisedSrc.value.src,
          "srcset": normalisedSrc.value.srcset,
          "alt": props.alt,
          "crossorigin": props.crossorigin,
          "referrerpolicy": props.referrerpolicy,
          "draggable": props.draggable,
          "sizes": props.sizes,
          "ref": image,
          "onLoad": onLoad,
          "onError": onError
        }, null);
        var sources = (_a2 = slots.sources) == null ? void 0 : _a2.call(slots);
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          "default": function () {
            return [withDirectives(sources ? createVNode("picture", {
              "class": "v-img__picture"
            }, [sources, img]) : img, [[vShow, state.value === "loaded"]])];
          }
        });
      };
      var __preloadImage = function () {
        return createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          "default": function () {
            return [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
              "class": ["v-img__img", "v-img__img--preload", containClasses.value],
              "style": {
                objectPosition: props.position
              },
              "src": normalisedSrc.value.lazySrc,
              "alt": props.alt,
              "crossorigin": props.crossorigin,
              "referrerpolicy": props.referrerpolicy,
              "draggable": props.draggable
            }, null)];
          }
        });
      };
      var __placeholder = function () {
        if (!slots.placeholder) return null;
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          "default": function () {
            return [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
              "class": "v-img__placeholder"
            }, [slots.placeholder()])];
          }
        });
      };
      var __error = function () {
        if (!slots.error) return null;
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "appear": true
        }, {
          "default": function () {
            return [state.value === "error" && createVNode("div", {
              "class": "v-img__error"
            }, [slots.error()])];
          }
        });
      };
      var __gradient = function () {
        if (!props.gradient) return null;
        return createVNode("div", {
          "class": "v-img__gradient",
          "style": {
            backgroundImage: "linear-gradient(" + props.gradient + ")"
          }
        }, null);
      };
      var isBooted = shallowRef(false);
      {
        var stop = watch(aspectRatio, function (val) {
          if (val) {
            requestAnimationFrame(function () {
              requestAnimationFrame(function () {
                isBooted.value = true;
              });
            });
            stop();
          }
        });
      }
      useRender(function () {
        var responsiveProps = VResponsive.filterProps(props);
        return withDirectives(createVNode(VResponsive, mergeProps({
          "class": ["v-img", {
            "v-img--absolute": props.absolute,
            "v-img--booting": !isBooted.value
          }, backgroundColorClasses.value, roundedClasses.value, props.class],
          "style": [{
            width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
          }, backgroundColorStyles.value, props.style]
        }, responsiveProps, {
          "aspectRatio": aspectRatio.value,
          "aria-label": props.alt,
          "role": props.alt ? "img" : void 0
        }), {
          additional: function () {
            return createVNode(Fragment$1, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]);
          },
          "default": slots.default
        }), [[resolveDirective("intersect"), {
          handler: init,
          options: props.options
        }, null, {
          once: true
        }]]);
      });
      return {
        currentSrc: currentSrc,
        image: image,
        state: state,
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight
      };
    }
  });
  var makeBorderProps = propsFactory({
    border: [Boolean, Number, String]
  }, "border");
  function useBorder(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var borderClasses = computed(function () {
      var border = isRef(props) ? props.value : props.border;
      var classes = [];
      if (border === true || border === "") {
        classes.push(name + "--border");
      } else if (typeof border === "string" || border === 0) {
        for (var _iterator40 = _createForOfIteratorHelperLoose(String(border).split(" ")), _step42; !(_step42 = _iterator40()).done;) {
          var value = _step42.value;
          classes.push("border-" + value);
        }
      }
      return classes;
    });
    return {
      borderClasses: borderClasses
    };
  }
  var makeElevationProps = propsFactory({
    elevation: {
      type: [Number, String],
      validator: function (v) {
        var value = parseInt(v);
        return !isNaN(value) && value >= 0 && value <= 24;
      }
    }
  }, "elevation");
  function useElevation(props) {
    var elevationClasses = computed(function () {
      var elevation = isRef(props) ? props.value : props.elevation;
      var classes = [];
      if (elevation == null) return classes;
      classes.push("elevation-" + elevation);
      return classes;
    });
    return {
      elevationClasses: elevationClasses
    };
  }
  var allowedDensities$1 = [null, "prominent", "default", "comfortable", "compact"];
  var makeVToolbarProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    absolute: Boolean,
    collapse: Boolean,
    color: String,
    density: {
      type: String,
      "default": "default",
      validator: function (v) {
        return allowedDensities$1.includes(v);
      }
    },
    extended: Boolean,
    extensionHeight: {
      type: [Number, String],
      "default": 48
    },
    flat: Boolean,
    floating: Boolean,
    height: {
      type: [Number, String],
      "default": 64
    },
    image: String,
    title: String
  }, makeBorderProps()), makeComponentProps()), makeElevationProps()), makeRoundedProps()), makeTagProps({
    tag: "header"
  })), makeThemeProps()), "VToolbar");
  var VToolbar = genericComponent()({
    name: "VToolbar",
    props: makeVToolbarProps(),
    setup: function (props, _ref) {
      var _a2;
      var slots = _ref.slots;
      var _useBackgroundColor2 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor2.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor2.backgroundColorStyles;
      var _useBorder = useBorder(props),
        borderClasses = _useBorder.borderClasses;
      var _useElevation = useElevation(props),
        elevationClasses = _useElevation.elevationClasses;
      var _useRounded2 = useRounded(props),
        roundedClasses = _useRounded2.roundedClasses;
      var _provideTheme = provideTheme(props),
        themeClasses = _provideTheme.themeClasses;
      var _useRtl3 = useRtl(),
        rtlClasses = _useRtl3.rtlClasses;
      var isExtended = shallowRef(!!(props.extended || ((_a2 = slots.extension) == null ? void 0 : _a2.call(slots))));
      var contentHeight = computed(function () {
        return parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10);
      });
      var extensionHeight = computed(function () {
        return isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0;
      });
      provideDefaults({
        VBtn: {
          variant: "text"
        }
      });
      useRender(function () {
        var _ref258;
        var _a3;
        var hasTitle = !!(props.title || slots.title);
        var hasImage = !!(slots.image || props.image);
        var extension = (_a3 = slots.extension) == null ? void 0 : _a3.call(slots);
        isExtended.value = !!(props.extended || extension);
        return createVNode(props.tag, {
          "class": ["v-toolbar", (_ref258 = {
            "v-toolbar--absolute": props.absolute,
            "v-toolbar--collapse": props.collapse,
            "v-toolbar--flat": props.flat,
            "v-toolbar--floating": props.floating
          }, _ref258["v-toolbar--density-" + props.density] = true, _ref258), backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style]
        }, {
          "default": function () {
            return [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-toolbar__image"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "cover": true,
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                }
              }
            }, slots.image)]), createVNode(VDefaultsProvider, {
              "defaults": {
                VTabs: {
                  height: convertToUnit(contentHeight.value)
                }
              }
            }, {
              "default": function () {
                var _a4, _b, _c;
                return [createVNode("div", {
                  "class": "v-toolbar__content",
                  "style": {
                    height: convertToUnit(contentHeight.value)
                  }
                }, [slots.prepend && createVNode("div", {
                  "class": "v-toolbar__prepend"
                }, [(_a4 = slots.prepend) == null ? void 0 : _a4.call(slots)]), hasTitle && createVNode(VToolbarTitle, {
                  "key": "title",
                  "text": props.title
                }, {
                  text: slots.title
                }), (_b = slots.default) == null ? void 0 : _b.call(slots), slots.append && createVNode("div", {
                  "class": "v-toolbar__append"
                }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])])];
              }
            }), createVNode(VDefaultsProvider, {
              "defaults": {
                VTabs: {
                  height: convertToUnit(extensionHeight.value)
                }
              }
            }, {
              "default": function () {
                return [createVNode(VExpandTransition, null, {
                  "default": function () {
                    return [isExtended.value && createVNode("div", {
                      "class": "v-toolbar__extension",
                      "style": {
                        height: convertToUnit(extensionHeight.value)
                      }
                    }, [extension])];
                  }
                })];
              }
            })];
          }
        });
      });
      return {
        contentHeight: contentHeight,
        extensionHeight: extensionHeight
      };
    }
  });
  var makeScrollProps = propsFactory({
    scrollTarget: {
      type: String
    },
    scrollThreshold: {
      type: [String, Number],
      "default": 300
    }
  }, "scroll");
  function useScroll(props) {
    var args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var canScroll = args.canScroll;
    var previousScroll = 0;
    var previousScrollHeight = 0;
    var target = ref(null);
    var currentScroll = shallowRef(0);
    var savedScroll = shallowRef(0);
    var currentThreshold = shallowRef(0);
    var isScrollActive = shallowRef(false);
    var isScrollingUp = shallowRef(false);
    var scrollThreshold = computed(function () {
      return Number(props.scrollThreshold);
    });
    var scrollRatio = computed(function () {
      return clamp((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
    });
    var onScroll = function () {
      var targetEl = target.value;
      if (!targetEl || canScroll && !canScroll.value) return;
      previousScroll = currentScroll.value;
      currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
      var currentScrollHeight = targetEl instanceof Window ? document.documentElement.scrollHeight : targetEl.scrollHeight;
      if (previousScrollHeight !== currentScrollHeight) {
        previousScrollHeight = currentScrollHeight;
        return;
      }
      isScrollingUp.value = currentScroll.value < previousScroll;
      currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
    };
    watch(isScrollingUp, function () {
      savedScroll.value = savedScroll.value || currentScroll.value;
    });
    watch(isScrollActive, function () {
      savedScroll.value = 0;
    });
    onMounted(function () {
      watch(function () {
        return props.scrollTarget;
      }, function (scrollTarget) {
        var _a2;
        var newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
        if (!newTarget) {
          consoleWarn("Unable to locate element with identifier " + scrollTarget);
          return;
        }
        if (newTarget === target.value) return;
        (_a2 = target.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
        target.value = newTarget;
        target.value.addEventListener("scroll", onScroll, {
          passive: true
        });
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(function () {
      var _a2;
      (_a2 = target.value) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
    });
    canScroll && watch(canScroll, onScroll, {
      immediate: true
    });
    return {
      scrollThreshold: scrollThreshold,
      currentScroll: currentScroll,
      currentThreshold: currentThreshold,
      isScrollActive: isScrollActive,
      scrollRatio: scrollRatio,
      isScrollingUp: isScrollingUp,
      savedScroll: savedScroll
    };
  }
  function useSsrBoot() {
    var isBooted = shallowRef(false);
    onMounted(function () {
      window.requestAnimationFrame(function () {
        isBooted.value = true;
      });
    });
    var ssrBootStyles = computed(function () {
      return !isBooted.value ? {
        transition: "none !important"
      } : void 0;
    });
    return {
      ssrBootStyles: ssrBootStyles,
      isBooted: readonly(isBooted)
    };
  }
  var makeVAppBarProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    scrollBehavior: String,
    modelValue: {
      type: Boolean,
      "default": true
    },
    location: {
      type: String,
      "default": "top",
      validator: function (value) {
        return ["top", "bottom"].includes(value);
      }
    }
  }, makeVToolbarProps()), makeLayoutItemProps()), makeScrollProps()), {}, {
    height: {
      type: [Number, String],
      "default": 64
    }
  }), "VAppBar");
  var VAppBar = genericComponent()({
    name: "VAppBar",
    props: makeVAppBarProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var vToolbarRef = ref();
      var isActive2 = useProxiedModel(props, "modelValue");
      var scrollBehavior = computed(function () {
        var _a2, _b;
        var behavior = new Set((_b = (_a2 = props.scrollBehavior) == null ? void 0 : _a2.split(" ")) != null ? _b : []);
        return {
          hide: behavior.has("hide"),
          fullyHide: behavior.has("fully-hide"),
          inverted: behavior.has("inverted"),
          collapse: behavior.has("collapse"),
          elevate: behavior.has("elevate"),
          fadeImage: behavior.has("fade-image")
        };
      });
      var canScroll = computed(function () {
        var behavior = scrollBehavior.value;
        return behavior.hide || behavior.fullyHide || behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || !isActive2.value;
      });
      var _useScroll = useScroll(props, {
          canScroll: canScroll
        }),
        currentScroll = _useScroll.currentScroll,
        scrollThreshold = _useScroll.scrollThreshold,
        isScrollingUp = _useScroll.isScrollingUp,
        scrollRatio = _useScroll.scrollRatio;
      var canHide = computed(function () {
        return scrollBehavior.value.hide || scrollBehavior.value.fullyHide;
      });
      var isCollapsed = computed(function () {
        return props.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0);
      });
      var isFlat = computed(function () {
        return props.flat || scrollBehavior.value.fullyHide && !isActive2.value || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0);
      });
      var opacity = computed(function () {
        return scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : void 0;
      });
      var height = computed(function () {
        var _a2, _b, _c, _d;
        if (scrollBehavior.value.hide && scrollBehavior.value.inverted) return 0;
        var height2 = (_b = (_a2 = vToolbarRef.value) == null ? void 0 : _a2.contentHeight) != null ? _b : 0;
        var extensionHeight = (_d = (_c = vToolbarRef.value) == null ? void 0 : _c.extensionHeight) != null ? _d : 0;
        if (!canHide.value) return height2 + extensionHeight;
        return currentScroll.value < scrollThreshold.value || scrollBehavior.value.fullyHide ? height2 + extensionHeight : height2;
      });
      useToggleScope(computed(function () {
        return !!props.scrollBehavior;
      }), function () {
        watchEffect(function () {
          if (canHide.value) {
            if (scrollBehavior.value.inverted) {
              isActive2.value = currentScroll.value > scrollThreshold.value;
            } else {
              isActive2.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
            }
          } else {
            isActive2.value = true;
          }
        });
      });
      var _useSsrBoot = useSsrBoot(),
        ssrBootStyles = _useSsrBoot.ssrBootStyles;
      var _useLayoutItem = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: toRef(props, "location"),
          layoutSize: height,
          elementSize: shallowRef(void 0),
          active: isActive2,
          absolute: toRef(props, "absolute")
        }),
        layoutItemStyles = _useLayoutItem.layoutItemStyles;
      useRender(function () {
        var toolbarProps = VToolbar.filterProps(props);
        return createVNode(VToolbar, mergeProps({
          "ref": vToolbarRef,
          "class": ["v-app-bar", {
            "v-app-bar--bottom": props.location === "bottom"
          }, props.class],
          "style": [_objectSpread(_objectSpread({}, layoutItemStyles.value), {}, {
            "--v-toolbar-image-opacity": opacity.value,
            height: void 0
          }, ssrBootStyles.value), props.style]
        }, toolbarProps, {
          "collapse": isCollapsed.value,
          "flat": isFlat.value
        }), slots);
      });
      return {};
    }
  });
  var VBtn$1 = "";
  var VBtnToggle$1 = "";
  var VBtnGroup$1 = "";
  var allowedDensities = [null, "default", "comfortable", "compact"];
  var makeDensityProps = propsFactory({
    density: {
      type: String,
      "default": "default",
      validator: function (v) {
        return allowedDensities.includes(v);
      }
    }
  }, "density");
  function useDensity(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var densityClasses = computed(function () {
      return name + "--density-" + props.density;
    });
    return {
      densityClasses: densityClasses
    };
  }
  var allowedVariants$2 = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
  function genOverlays(isClickable, name) {
    return createVNode(Fragment$1, null, [isClickable && createVNode("span", {
      "key": "overlay",
      "class": name + "__overlay"
    }, null), createVNode("span", {
      "key": "underlay",
      "class": name + "__underlay"
    }, null)]);
  }
  var makeVariantProps = propsFactory({
    color: String,
    variant: {
      type: String,
      "default": "elevated",
      validator: function (v) {
        return allowedVariants$2.includes(v);
      }
    }
  }, "variant");
  function useVariant(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var variantClasses = computed(function () {
      var _unref = unref(props),
        variant = _unref.variant;
      return name + "--variant-" + variant;
    });
    var _useColor3 = useColor(computed(function () {
        var _ref259;
        var _unref2 = unref(props),
          variant = _unref2.variant,
          color = _unref2.color;
        return _ref259 = {}, _ref259[["elevated", "flat"].includes(variant) ? "background" : "text"] = color, _ref259;
      })),
      colorClasses = _useColor3.colorClasses,
      colorStyles = _useColor3.colorStyles;
    return {
      colorClasses: colorClasses,
      colorStyles: colorStyles,
      variantClasses: variantClasses
    };
  }
  var makeVBtnGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    baseColor: String,
    divided: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps()), "VBtnGroup");
  var VBtnGroup = genericComponent()({
    name: "VBtnGroup",
    props: makeVBtnGroupProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme2 = provideTheme(props),
        themeClasses = _provideTheme2.themeClasses;
      var _useDensity = useDensity(props),
        densityClasses = _useDensity.densityClasses;
      var _useBorder2 = useBorder(props),
        borderClasses = _useBorder2.borderClasses;
      var _useElevation2 = useElevation(props),
        elevationClasses = _useElevation2.elevationClasses;
      var _useRounded3 = useRounded(props),
        roundedClasses = _useRounded3.roundedClasses;
      provideDefaults({
        VBtn: {
          height: "auto",
          baseColor: toRef(props, "baseColor"),
          color: toRef(props, "color"),
          density: toRef(props, "density"),
          flat: true,
          variant: toRef(props, "variant")
        }
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-btn-group", {
            "v-btn-group--divided": props.divided
          }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": props.style
        }, slots);
      });
    }
  });
  var makeGroupProps = propsFactory({
    modelValue: {
      type: null,
      "default": void 0
    },
    multiple: Boolean,
    mandatory: [Boolean, String],
    max: Number,
    selectedClass: String,
    disabled: Boolean
  }, "group");
  var makeGroupItemProps = propsFactory({
    value: null,
    disabled: Boolean,
    selectedClass: String
  }, "group-item");
  function useGroupItem(props, injectKey) {
    var required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var vm = getCurrentInstance("useGroupItem");
    if (!vm) {
      throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
    }
    var id = getUid();
    provide(Symbol.for(injectKey.description + ":id"), id);
    var group = inject$1(injectKey, null);
    if (!group) {
      if (!required) return group;
      throw new Error("[Vuetify] Could not find useGroup injection with symbol " + injectKey.description);
    }
    var value = toRef(props, "value");
    var disabled = computed(function () {
      return !!(group.disabled.value || props.disabled);
    });
    group.register({
      id: id,
      value: value,
      disabled: disabled
    }, vm);
    onBeforeUnmount(function () {
      group.unregister(id);
    });
    var isSelected = computed(function () {
      return group.isSelected(id);
    });
    var isFirst = computed(function () {
      return group.items.value[0].id === id;
    });
    var isLast = computed(function () {
      return group.items.value[group.items.value.length - 1].id === id;
    });
    var selectedClass = computed(function () {
      return isSelected.value && [group.selectedClass.value, props.selectedClass];
    });
    watch(isSelected, function (value2) {
      vm.emit("group:selected", {
        value: value2
      });
    }, {
      flush: "sync"
    });
    return {
      id: id,
      isSelected: isSelected,
      isFirst: isFirst,
      isLast: isLast,
      toggle: function () {
        return group.select(id, !isSelected.value);
      },
      select: function (value2) {
        return group.select(id, value2);
      },
      selectedClass: selectedClass,
      value: value,
      disabled: disabled,
      group: group
    };
  }
  function useGroup(props, injectKey) {
    var isUnmounted = false;
    var items = reactive([]);
    var selected = useProxiedModel(props, "modelValue", [], function (v) {
      if (v == null) return [];
      return getIds(items, wrapInArray(v));
    }, function (v) {
      var arr = getValues(items, v);
      return props.multiple ? arr : arr[0];
    });
    var groupVm = getCurrentInstance("useGroup");
    function register(item, vm) {
      var unwrapped = item;
      var key = Symbol.for(injectKey.description + ":id");
      var children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
      var index = children.indexOf(vm);
      if (unref(unwrapped.value) == null) {
        unwrapped.value = index;
        unwrapped.useIndexAsValue = true;
      }
      if (index > -1) {
        items.splice(index, 0, unwrapped);
      } else {
        items.push(unwrapped);
      }
    }
    function unregister(id) {
      if (isUnmounted) return;
      forceMandatoryValue();
      var index = items.findIndex(function (item) {
        return item.id === id;
      });
      items.splice(index, 1);
    }
    function forceMandatoryValue() {
      var item = items.find(function (item2) {
        return !item2.disabled;
      });
      if (item && props.mandatory === "force" && !selected.value.length) {
        selected.value = [item.id];
      }
    }
    onMounted(function () {
      forceMandatoryValue();
    });
    onBeforeUnmount(function () {
      isUnmounted = true;
    });
    onUpdated(function () {
      for (var _i271 = 0; _i271 < items.length; _i271++) {
        if (items[_i271].useIndexAsValue) {
          items[_i271].value = _i271;
        }
      }
    });
    function select(id, value) {
      var item = items.find(function (item2) {
        return item2.id === id;
      });
      if (value && (item == null ? void 0 : item.disabled)) return;
      if (props.multiple) {
        var internalValue = selected.value.slice();
        var index = internalValue.findIndex(function (v) {
          return v === id;
        });
        var isSelected = ~index;
        value = value != null ? value : !isSelected;
        if (isSelected && props.mandatory && internalValue.length <= 1) return;
        if (!isSelected && props.max != null && internalValue.length + 1 > props.max) return;
        if (index < 0 && value) internalValue.push(id);else if (index >= 0 && !value) internalValue.splice(index, 1);
        selected.value = internalValue;
      } else {
        var _isSelected = selected.value.includes(id);
        if (props.mandatory && _isSelected) return;
        selected.value = (value != null ? value : !_isSelected) ? [id] : [];
      }
    }
    function step(offset) {
      if (props.multiple) consoleWarn('This method is not supported when using "multiple" prop');
      if (!selected.value.length) {
        var item = items.find(function (item2) {
          return !item2.disabled;
        });
        item && (selected.value = [item.id]);
      } else {
        var currentId = selected.value[0];
        var currentIndex = items.findIndex(function (i) {
          return i.id === currentId;
        });
        var newIndex = (currentIndex + offset) % items.length;
        var newItem = items[newIndex];
        while (newItem.disabled && newIndex !== currentIndex) {
          newIndex = (newIndex + offset) % items.length;
          newItem = items[newIndex];
        }
        if (newItem.disabled) return;
        selected.value = [items[newIndex].id];
      }
    }
    var state = {
      register: register,
      unregister: unregister,
      selected: selected,
      select: select,
      disabled: toRef(props, "disabled"),
      prev: function () {
        return step(items.length - 1);
      },
      next: function () {
        return step(1);
      },
      isSelected: function (id) {
        return selected.value.includes(id);
      },
      selectedClass: computed(function () {
        return props.selectedClass;
      }),
      items: computed(function () {
        return items;
      }),
      getItemIndex: function (value) {
        return getItemIndex(items, value);
      }
    };
    provide(injectKey, state);
    return state;
  }
  function getItemIndex(items, value) {
    var ids = getIds(items, [value]);
    if (!ids.length) return -1;
    return items.findIndex(function (item) {
      return item.id === ids[0];
    });
  }
  function getIds(items, modelValue) {
    var ids = [];
    modelValue.forEach(function (value) {
      var item = items.find(function (item2) {
        return deepEqual(value, item2.value);
      });
      var itemByIndex = items[value];
      if ((item == null ? void 0 : item.value) != null) {
        ids.push(item.id);
      } else if (itemByIndex != null) {
        ids.push(itemByIndex.id);
      }
    });
    return ids;
  }
  function getValues(items, ids) {
    var values = [];
    ids.forEach(function (id) {
      var itemIndex = items.findIndex(function (item) {
        return item.id === id;
      });
      if (~itemIndex) {
        var item = items[itemIndex];
        values.push(item.value != null ? item.value : itemIndex);
      }
    });
    return values;
  }
  var VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
  var makeVBtnToggleProps = propsFactory(_objectSpread(_objectSpread({}, makeVBtnGroupProps()), makeGroupProps()), "VBtnToggle");
  var VBtnToggle = genericComponent()({
    name: "VBtnToggle",
    props: makeVBtnToggleProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useGroup = useGroup(props, VBtnToggleSymbol),
        isSelected = _useGroup.isSelected,
        next = _useGroup.next,
        prev = _useGroup.prev,
        select = _useGroup.select,
        selected = _useGroup.selected;
      useRender(function () {
        var btnGroupProps = VBtnGroup.filterProps(props);
        return createVNode(VBtnGroup, mergeProps({
          "class": ["v-btn-toggle", props.class]
        }, btnGroupProps, {
          "style": props.style
        }), {
          "default": function () {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected: isSelected,
              next: next,
              prev: prev,
              select: select,
              selected: selected
            })];
          }
        });
      });
      return {
        next: next,
        prev: prev,
        select: select
      };
    }
  });
  var VIcon$1 = "";
  var predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
  var makeSizeProps = propsFactory({
    size: {
      type: [String, Number],
      "default": "default"
    }
  }, "size");
  function useSize(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    return destructComputed(function () {
      var sizeClasses;
      var sizeStyles;
      if (includes(predefinedSizes, props.size)) {
        sizeClasses = name + "--size-" + props.size;
      } else if (props.size) {
        sizeStyles = {
          width: convertToUnit(props.size),
          height: convertToUnit(props.size)
        };
      }
      return {
        sizeClasses: sizeClasses,
        sizeStyles: sizeStyles
      };
    });
  }
  var makeVIconProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    color: String,
    disabled: Boolean,
    start: Boolean,
    end: Boolean,
    icon: IconValue
  }, makeComponentProps()), makeSizeProps()), makeTagProps({
    tag: "i"
  })), makeThemeProps()), "VIcon");
  var VIcon = genericComponent()({
    name: "VIcon",
    props: makeVIconProps(),
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var slotIcon = ref();
      var _provideTheme3 = provideTheme(props),
        themeClasses = _provideTheme3.themeClasses;
      var _useIcon = useIcon(computed(function () {
          return slotIcon.value || props.icon;
        })),
        iconData = _useIcon.iconData;
      var _useSize = useSize(props),
        sizeClasses = _useSize.sizeClasses;
      var _useTextColor = useTextColor(toRef(props, "color")),
        textColorClasses = _useTextColor.textColorClasses,
        textColorStyles = _useTextColor.textColorStyles;
      useRender(function () {
        var _a2, _b;
        var slotValue = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        if (slotValue) {
          slotIcon.value = (_b = flattenFragments(slotValue).filter(function (node) {
            return node.type === Text$1 && node.children && typeof node.children === "string";
          })[0]) == null ? void 0 : _b.children;
        }
        var hasClick = !!(attrs.onClick || attrs.onClickOnce);
        return createVNode(iconData.value.component, {
          "tag": props.tag,
          "icon": iconData.value.icon,
          "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
            "v-icon--clickable": hasClick,
            "v-icon--disabled": props.disabled,
            "v-icon--start": props.start,
            "v-icon--end": props.end
          }, props.class],
          "style": [!sizeClasses.value ? {
            fontSize: convertToUnit(props.size),
            height: convertToUnit(props.size),
            width: convertToUnit(props.size)
          } : void 0, textColorStyles.value, props.style],
          "role": hasClick ? "button" : void 0,
          "aria-hidden": !hasClick,
          "tabindex": hasClick ? props.disabled ? -1 : 0 : void 0
        }, {
          "default": function () {
            return [slotValue];
          }
        });
      });
      return {};
    }
  });
  var VProgressCircular$1 = "";
  function useIntersectionObserver(callback, options) {
    var intersectionRef = ref();
    var isIntersecting = shallowRef(false);
    if (SUPPORTS_INTERSECTION) {
      var observer = new IntersectionObserver(function (entries) {
        callback == null ? void 0 : callback(entries, observer);
        isIntersecting.value = !!entries.find(function (entry) {
          return entry.isIntersecting;
        });
      }, options);
      onBeforeUnmount(function () {
        observer.disconnect();
      });
      watch(intersectionRef, function (newValue, oldValue) {
        if (oldValue) {
          observer.unobserve(oldValue);
          isIntersecting.value = false;
        }
        if (newValue) observer.observe(newValue);
      }, {
        flush: "post"
      });
    }
    return {
      intersectionRef: intersectionRef,
      isIntersecting: isIntersecting
    };
  }
  var makeVProgressCircularProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      "default": 0
    },
    rotate: {
      type: [Number, String],
      "default": 0
    },
    width: {
      type: [Number, String],
      "default": 4
    }
  }, makeComponentProps()), makeSizeProps()), makeTagProps({
    tag: "div"
  })), makeThemeProps()), "VProgressCircular");
  var VProgressCircular = genericComponent()({
    name: "VProgressCircular",
    props: makeVProgressCircularProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var MAGIC_RADIUS_CONSTANT = 20;
      var CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
      var root = ref();
      var _provideTheme4 = provideTheme(props),
        themeClasses = _provideTheme4.themeClasses;
      var _useSize2 = useSize(props),
        sizeClasses = _useSize2.sizeClasses,
        sizeStyles = _useSize2.sizeStyles;
      var _useTextColor2 = useTextColor(toRef(props, "color")),
        textColorClasses = _useTextColor2.textColorClasses,
        textColorStyles = _useTextColor2.textColorStyles;
      var _useTextColor3 = useTextColor(toRef(props, "bgColor")),
        underlayColorClasses = _useTextColor3.textColorClasses,
        underlayColorStyles = _useTextColor3.textColorStyles;
      var _useIntersectionObser = useIntersectionObserver(),
        intersectionRef = _useIntersectionObser.intersectionRef,
        isIntersecting = _useIntersectionObser.isIntersecting;
      var _useResizeObserver2 = useResizeObserver(),
        resizeRef = _useResizeObserver2.resizeRef,
        contentRect = _useResizeObserver2.contentRect;
      var normalizedValue = computed(function () {
        return Math.max(0, Math.min(100, parseFloat(props.modelValue)));
      });
      var width = computed(function () {
        return Number(props.width);
      });
      var size = computed(function () {
        return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
      });
      var diameter = computed(function () {
        return MAGIC_RADIUS_CONSTANT / (1 - width.value / size.value) * 2;
      });
      var strokeWidth = computed(function () {
        return width.value / size.value * diameter.value;
      });
      var strokeDashOffset = computed(function () {
        return convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE);
      });
      watchEffect(function () {
        intersectionRef.value = root.value;
        resizeRef.value = root.value;
      });
      useRender(function () {
        return createVNode(props.tag, {
          "ref": root,
          "class": ["v-progress-circular", {
            "v-progress-circular--indeterminate": !!props.indeterminate,
            "v-progress-circular--visible": isIntersecting.value,
            "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
          }, themeClasses.value, sizeClasses.value, textColorClasses.value, props.class],
          "style": [sizeStyles.value, textColorStyles.value, props.style],
          "role": "progressbar",
          "aria-valuemin": "0",
          "aria-valuemax": "100",
          "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
        }, {
          "default": function () {
            return [createVNode("svg", {
              "style": {
                transform: "rotate(calc(-90deg + " + Number(props.rotate) + "deg))"
              },
              "xmlns": "http://www.w3.org/2000/svg",
              "viewBox": "0 0 " + diameter.value + " " + diameter.value
            }, [createVNode("circle", {
              "class": ["v-progress-circular__underlay", underlayColorClasses.value],
              "style": underlayColorStyles.value,
              "fill": "transparent",
              "cx": "50%",
              "cy": "50%",
              "r": MAGIC_RADIUS_CONSTANT,
              "stroke-width": strokeWidth.value,
              "stroke-dasharray": CIRCUMFERENCE,
              "stroke-dashoffset": 0
            }, null), createVNode("circle", {
              "class": "v-progress-circular__overlay",
              "fill": "transparent",
              "cx": "50%",
              "cy": "50%",
              "r": MAGIC_RADIUS_CONSTANT,
              "stroke-width": strokeWidth.value,
              "stroke-dasharray": CIRCUMFERENCE,
              "stroke-dashoffset": strokeDashOffset.value
            }, null)]), slots.default && createVNode("div", {
              "class": "v-progress-circular__content"
            }, [slots.default({
              value: normalizedValue.value
            })])];
          }
        });
      });
      return {};
    }
  });
  var VProgressLinear$1 = "";
  var oppositeMap = {
    center: "center",
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  var makeLocationProps = propsFactory({
    location: String
  }, "location");
  function useLocation(props) {
    var opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var offset = arguments.length > 2 ? arguments[2] : void 0;
    var _useRtl4 = useRtl(),
      isRtl = _useRtl4.isRtl;
    var locationStyles = computed(function () {
      if (!props.location) return {};
      var _parseAnchor = parseAnchor(props.location.split(" ").length > 1 ? props.location : props.location + " center", isRtl.value),
        side = _parseAnchor.side,
        align = _parseAnchor.align;
      function getOffset2(side2) {
        return offset ? offset(side2) : 0;
      }
      var styles = {};
      if (side !== "center") {
        if (opposite) styles[oppositeMap[side]] = "calc(100% - " + getOffset2(side) + "px)";else styles[side] = 0;
      }
      if (align !== "center") {
        if (opposite) styles[oppositeMap[align]] = "calc(100% - " + getOffset2(align) + "px)";else styles[align] = 0;
      } else {
        if (side === "center") styles.top = styles.left = "50%";else {
          styles[{
            top: "left",
            bottom: "left",
            left: "top",
            right: "top"
          }[side]] = "50%";
        }
        styles.transform = {
          top: "translateX(-50%)",
          bottom: "translateX(-50%)",
          left: "translateY(-50%)",
          right: "translateY(-50%)",
          center: "translate(-50%, -50%)"
        }[side];
      }
      return styles;
    });
    return {
      locationStyles: locationStyles
    };
  }
  var makeVProgressLinearProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    absolute: Boolean,
    active: {
      type: Boolean,
      "default": true
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
      type: [Number, String],
      "default": 0
    },
    bufferColor: String,
    bufferOpacity: [Number, String],
    clickable: Boolean,
    color: String,
    height: {
      type: [Number, String],
      "default": 4
    },
    indeterminate: Boolean,
    max: {
      type: [Number, String],
      "default": 100
    },
    modelValue: {
      type: [Number, String],
      "default": 0
    },
    opacity: [Number, String],
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean
  }, makeComponentProps()), makeLocationProps({
    location: "top"
  })), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VProgressLinear");
  var VProgressLinear = genericComponent()({
    name: "VProgressLinear",
    props: makeVProgressLinearProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var _a2;
      var slots = _ref.slots;
      var progress = useProxiedModel(props, "modelValue");
      var _useRtl5 = useRtl(),
        isRtl = _useRtl5.isRtl,
        rtlClasses = _useRtl5.rtlClasses;
      var _provideTheme5 = provideTheme(props),
        themeClasses = _provideTheme5.themeClasses;
      var _useLocation = useLocation(props),
        locationStyles = _useLocation.locationStyles;
      var _useTextColor4 = useTextColor(props, "color"),
        textColorClasses = _useTextColor4.textColorClasses,
        textColorStyles = _useTextColor4.textColorStyles;
      var _useBackgroundColor3 = useBackgroundColor(computed(function () {
          return props.bgColor || props.color;
        })),
        backgroundColorClasses = _useBackgroundColor3.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor3.backgroundColorStyles;
      var _useBackgroundColor4 = useBackgroundColor(computed(function () {
          return props.bufferColor || props.bgColor || props.color;
        })),
        bufferColorClasses = _useBackgroundColor4.backgroundColorClasses,
        bufferColorStyles = _useBackgroundColor4.backgroundColorStyles;
      var _useBackgroundColor5 = useBackgroundColor(props, "color"),
        barColorClasses = _useBackgroundColor5.backgroundColorClasses,
        barColorStyles = _useBackgroundColor5.backgroundColorStyles;
      var _useRounded4 = useRounded(props),
        roundedClasses = _useRounded4.roundedClasses;
      var _useIntersectionObser2 = useIntersectionObserver(),
        intersectionRef = _useIntersectionObser2.intersectionRef,
        isIntersecting = _useIntersectionObser2.isIntersecting;
      var max = computed(function () {
        return parseFloat(props.max);
      });
      var height = computed(function () {
        return parseFloat(props.height);
      });
      var normalizedBuffer = computed(function () {
        return clamp(parseFloat(props.bufferValue) / max.value * 100, 0, 100);
      });
      var normalizedValue = computed(function () {
        return clamp(parseFloat(progress.value) / max.value * 100, 0, 100);
      });
      var isReversed = computed(function () {
        return isRtl.value !== props.reverse;
      });
      var transition = computed(function () {
        return props.indeterminate ? "fade-transition" : "slide-x-transition";
      });
      var isForcedColorsModeActive = IN_BROWSER && ((_a2 = window.matchMedia) == null ? void 0 : _a2.call(window, "(forced-colors: active)").matches);
      function handleClick2(e) {
        if (!intersectionRef.value) return;
        var _intersectionRef$valu = intersectionRef.value.getBoundingClientRect(),
          left = _intersectionRef$valu.left,
          right = _intersectionRef$valu.right,
          width = _intersectionRef$valu.width;
        var value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
        progress.value = Math.round(value / width * max.value);
      }
      useRender(function () {
        return createVNode(props.tag, {
          "ref": intersectionRef,
          "class": ["v-progress-linear", {
            "v-progress-linear--absolute": props.absolute,
            "v-progress-linear--active": props.active && isIntersecting.value,
            "v-progress-linear--reverse": isReversed.value,
            "v-progress-linear--rounded": props.rounded,
            "v-progress-linear--rounded-bar": props.roundedBar,
            "v-progress-linear--striped": props.striped
          }, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
          "style": [_objectSpread({
            bottom: props.location === "bottom" ? 0 : void 0,
            top: props.location === "top" ? 0 : void 0,
            height: props.active ? convertToUnit(height.value) : 0,
            "--v-progress-linear-height": convertToUnit(height.value)
          }, props.absolute ? locationStyles.value : {}), props.style],
          "role": "progressbar",
          "aria-hidden": props.active ? "false" : "true",
          "aria-valuemin": "0",
          "aria-valuemax": props.max,
          "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
          "onClick": props.clickable && handleClick2
        }, {
          "default": function () {
            var _objectSpread6;
            return [props.stream && createVNode("div", {
              "key": "stream",
              "class": ["v-progress-linear__stream", textColorClasses.value],
              "style": _objectSpread(_objectSpread({}, textColorStyles.value), {}, (_objectSpread6 = {}, _objectSpread6[isReversed.value ? "left" : "right"] = convertToUnit(-height.value), _objectSpread6.borderTop = convertToUnit(height.value / 2) + " dotted", _objectSpread6.opacity = parseFloat(props.bufferOpacity), _objectSpread6.top = "calc(50% - " + convertToUnit(height.value / 4) + ")", _objectSpread6.width = convertToUnit(100 - normalizedBuffer.value, "%"), _objectSpread6["--v-progress-linear-stream-to"] = convertToUnit(height.value * (isReversed.value ? 1 : -1)), _objectSpread6))
            }, null), createVNode("div", {
              "class": ["v-progress-linear__background", !isForcedColorsModeActive ? backgroundColorClasses.value : void 0],
              "style": [backgroundColorStyles.value, {
                opacity: parseFloat(props.bgOpacity),
                width: props.stream ? 0 : void 0
              }]
            }, null), createVNode("div", {
              "class": ["v-progress-linear__buffer", !isForcedColorsModeActive ? bufferColorClasses.value : void 0],
              "style": [bufferColorStyles.value, {
                opacity: parseFloat(props.bufferOpacity),
                width: convertToUnit(normalizedBuffer.value, "%")
              }]
            }, null), createVNode(Transition, {
              "name": transition.value
            }, {
              "default": function () {
                return [!props.indeterminate ? createVNode("div", {
                  "class": ["v-progress-linear__determinate", !isForcedColorsModeActive ? barColorClasses.value : void 0],
                  "style": [barColorStyles.value, {
                    width: convertToUnit(normalizedValue.value, "%")
                  }]
                }, null) : createVNode("div", {
                  "class": "v-progress-linear__indeterminate"
                }, [["long", "short"].map(function (bar) {
                  return createVNode("div", {
                    "key": bar,
                    "class": ["v-progress-linear__indeterminate", bar, !isForcedColorsModeActive ? barColorClasses.value : void 0],
                    "style": barColorStyles.value
                  }, null);
                })])];
              }
            }), slots.default && createVNode("div", {
              "class": "v-progress-linear__content"
            }, [slots.default({
              value: normalizedValue.value,
              buffer: normalizedBuffer.value
            })])];
          }
        });
      });
      return {};
    }
  });
  var makeLoaderProps = propsFactory({
    loading: [Boolean, String]
  }, "loader");
  function useLoader(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var loaderClasses = computed(function () {
      var _ref260;
      return _ref260 = {}, _ref260[name + "--loading"] = props.loading, _ref260;
    });
    return {
      loaderClasses: loaderClasses
    };
  }
  function LoaderSlot(props, _ref) {
    var _a2;
    var slots = _ref.slots;
    return createVNode("div", {
      "class": props.name + "__loader"
    }, [((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
      color: props.color,
      isActive: props.active
    })) || createVNode(VProgressLinear, {
      "absolute": props.absolute,
      "active": props.active,
      "color": props.color,
      "height": "2",
      "indeterminate": true
    }, null)]);
  }
  var positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
  var makePositionProps = propsFactory({
    position: {
      type: String,
      validator: function (v) {
        return positionValues.includes(v);
      }
    }
  }, "position");
  function usePosition(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var positionClasses = computed(function () {
      return props.position ? name + "--" + props.position : void 0;
    });
    return {
      positionClasses: positionClasses
    };
  }
  function useRoute() {
    var vm = getCurrentInstance("useRoute");
    return computed(function () {
      var _a2;
      return (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$route;
    });
  }
  function useRouter() {
    var _a2, _b;
    return (_b = (_a2 = getCurrentInstance("useRouter")) == null ? void 0 : _a2.proxy) == null ? void 0 : _b.$router;
  }
  function useLink(props, attrs) {
    var _a2, _b;
    var RouterLink2 = resolveDynamicComponent("RouterLink");
    var isLink = computed(function () {
      return !!(props.href || props.to);
    });
    var isClickable = computed(function () {
      return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props, "click");
    });
    if (typeof RouterLink2 === "string" || !("useLink" in RouterLink2)) {
      var href2 = toRef(props, "href");
      return {
        isLink: isLink,
        isClickable: isClickable,
        href: href2,
        linkProps: reactive({
          href: href2
        })
      };
    }
    var linkProps = computed(function () {
      return _objectSpread(_objectSpread({}, props), {}, {
        to: toRef(function () {
          return props.to || "";
        })
      });
    });
    var routerLink = RouterLink2.useLink(linkProps.value);
    var link = computed(function () {
      return props.to ? routerLink : void 0;
    });
    var route = useRoute();
    var isActive2 = computed(function () {
      var _a3, _b2, _c, _d, _e;
      if (!link.value) return false;
      if (!props.exact) return (_b2 = (_a3 = link.value.isActive) == null ? void 0 : _a3.value) != null ? _b2 : false;
      if (!route.value) return (_d = (_c = link.value.isExactActive) == null ? void 0 : _c.value) != null ? _d : false;
      return ((_e = link.value.isExactActive) == null ? void 0 : _e.value) && deepEqual(link.value.route.value.query, route.value.query);
    });
    var href = computed(function () {
      var _a3;
      return props.to ? (_a3 = link.value) == null ? void 0 : _a3.route.value.href : props.href;
    });
    return {
      isLink: isLink,
      isClickable: isClickable,
      isActive: isActive2,
      route: (_a2 = link.value) == null ? void 0 : _a2.route,
      navigate: (_b = link.value) == null ? void 0 : _b.navigate,
      href: href,
      linkProps: reactive({
        href: href,
        "aria-current": computed(function () {
          return isActive2.value ? "page" : void 0;
        })
      })
    };
  }
  var makeRouterProps = propsFactory({
    href: String,
    replace: Boolean,
    to: [String, Object],
    exact: Boolean
  }, "router");
  var inTransition = false;
  function useBackButton(router2, cb) {
    var popped = false;
    var removeBefore;
    var removeAfter;
    if (IN_BROWSER) {
      nextTick(function () {
        window.addEventListener("popstate", onPopstate);
        removeBefore = router2 == null ? void 0 : router2.beforeEach(function (to, from2, next) {
          if (!inTransition) {
            setTimeout(function () {
              return popped ? cb(next) : next();
            });
          } else {
            popped ? cb(next) : next();
          }
          inTransition = true;
        });
        removeAfter = router2 == null ? void 0 : router2.afterEach(function () {
          inTransition = false;
        });
      });
      onScopeDispose(function () {
        window.removeEventListener("popstate", onPopstate);
        removeBefore == null ? void 0 : removeBefore();
        removeAfter == null ? void 0 : removeAfter();
      });
    }
    function onPopstate(e) {
      var _a2;
      if ((_a2 = e.state) == null ? void 0 : _a2.replaced) return;
      popped = true;
      setTimeout(function () {
        return popped = false;
      });
    }
  }
  function useSelectLink(link, select) {
    watch(function () {
      var _a2;
      return (_a2 = link.isActive) == null ? void 0 : _a2.value;
    }, function (isActive2) {
      if (link.isLink.value && isActive2 && select) {
        nextTick(function () {
          select(true);
        });
      }
    }, {
      immediate: true
    });
  }
  var VRipple = "";
  var stopSymbol = Symbol("rippleStop");
  var DELAY_RIPPLE = 80;
  function transform(el, value) {
    el.style.transform = value;
    el.style.webkitTransform = value;
  }
  function isTouchEvent(e) {
    return e.constructor.name === "TouchEvent";
  }
  function isKeyboardEvent(e) {
    return e.constructor.name === "KeyboardEvent";
  }
  var calculate = function (e, el) {
    var _a2;
    var value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var localX = 0;
    var localY = 0;
    if (!isKeyboardEvent(e)) {
      var offset = el.getBoundingClientRect();
      var target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
      localX = target.clientX - offset.left;
      localY = target.clientY - offset.top;
    }
    var radius = 0;
    var scale = 0.3;
    if ((_a2 = el._ripple) == null ? void 0 : _a2.circle) {
      scale = 0.15;
      radius = el.clientWidth / 2;
      radius = value.center ? radius : radius + Math.sqrt(Math.pow(localX - radius, 2) + Math.pow(localY - radius, 2)) / 4;
    } else {
      radius = Math.sqrt(Math.pow(el.clientWidth, 2) + Math.pow(el.clientHeight, 2)) / 2;
    }
    var centerX = (el.clientWidth - radius * 2) / 2 + "px";
    var centerY = (el.clientHeight - radius * 2) / 2 + "px";
    var x = value.center ? centerX : localX - radius + "px";
    var y = value.center ? centerY : localY - radius + "px";
    return {
      radius: radius,
      scale: scale,
      x: x,
      y: y,
      centerX: centerX,
      centerY: centerY
    };
  };
  var ripples = {
    show: function (e, el) {
      var _a2;
      var value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!((_a2 = el == null ? void 0 : el._ripple) == null ? void 0 : _a2.enabled)) {
        return;
      }
      var container = document.createElement("span");
      var animation = document.createElement("span");
      container.appendChild(animation);
      container.className = "v-ripple__container";
      if (value.class) {
        container.className += " " + value.class;
      }
      var _calculate = calculate(e, el, value),
        radius = _calculate.radius,
        scale = _calculate.scale,
        x = _calculate.x,
        y = _calculate.y,
        centerX = _calculate.centerX,
        centerY = _calculate.centerY;
      var size = radius * 2 + "px";
      animation.className = "v-ripple__animation";
      animation.style.width = size;
      animation.style.height = size;
      el.appendChild(container);
      var computed2 = window.getComputedStyle(el);
      if (computed2 && computed2.position === "static") {
        el.style.position = "relative";
        el.dataset.previousPosition = "static";
      }
      animation.classList.add("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--visible");
      transform(animation, "translate(" + x + ", " + y + ") scale3d(" + scale + "," + scale + "," + scale + ")");
      animation.dataset.activated = String(performance.now());
      setTimeout(function () {
        animation.classList.remove("v-ripple__animation--enter");
        animation.classList.add("v-ripple__animation--in");
        transform(animation, "translate(" + centerX + ", " + centerY + ") scale3d(1,1,1)");
      }, 0);
    },
    hide: function (el) {
      var _a2;
      if (!((_a2 = el == null ? void 0 : el._ripple) == null ? void 0 : _a2.enabled)) return;
      var ripples2 = el.getElementsByClassName("v-ripple__animation");
      if (ripples2.length === 0) return;
      var animation = ripples2[ripples2.length - 1];
      if (animation.dataset.isHiding) return;else animation.dataset.isHiding = "true";
      var diff = performance.now() - Number(animation.dataset.activated);
      var delay = Math.max(250 - diff, 0);
      setTimeout(function () {
        animation.classList.remove("v-ripple__animation--in");
        animation.classList.add("v-ripple__animation--out");
        setTimeout(function () {
          var _a3;
          var ripples3 = el.getElementsByClassName("v-ripple__animation");
          if (ripples3.length === 1 && el.dataset.previousPosition) {
            el.style.position = el.dataset.previousPosition;
            delete el.dataset.previousPosition;
          }
          if (((_a3 = animation.parentNode) == null ? void 0 : _a3.parentNode) === el) el.removeChild(animation.parentNode);
        }, 300);
      }, delay);
    }
  };
  function isRippleEnabled(value) {
    return typeof value === "undefined" || !!value;
  }
  function rippleShow(e) {
    var value = {};
    var element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple) || element._ripple.touched || e[stopSymbol]) return;
    e[stopSymbol] = true;
    if (isTouchEvent(e)) {
      element._ripple.touched = true;
      element._ripple.isTouch = true;
    } else {
      if (element._ripple.isTouch) return;
    }
    value.center = element._ripple.centered || isKeyboardEvent(e);
    if (element._ripple.class) {
      value.class = element._ripple.class;
    }
    if (isTouchEvent(e)) {
      if (element._ripple.showTimerCommit) return;
      element._ripple.showTimerCommit = function () {
        ripples.show(e, element, value);
      };
      element._ripple.showTimer = window.setTimeout(function () {
        var _a2;
        if ((_a2 = element == null ? void 0 : element._ripple) == null ? void 0 : _a2.showTimerCommit) {
          element._ripple.showTimerCommit();
          element._ripple.showTimerCommit = null;
        }
      }, DELAY_RIPPLE);
    } else {
      ripples.show(e, element, value);
    }
  }
  function rippleStop(e) {
    e[stopSymbol] = true;
  }
  function rippleHide(e) {
    var element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple)) return;
    window.clearTimeout(element._ripple.showTimer);
    if (e.type === "touchend" && element._ripple.showTimerCommit) {
      element._ripple.showTimerCommit();
      element._ripple.showTimerCommit = null;
      element._ripple.showTimer = window.setTimeout(function () {
        rippleHide(e);
      });
      return;
    }
    window.setTimeout(function () {
      if (element._ripple) {
        element._ripple.touched = false;
      }
    });
    ripples.hide(element);
  }
  function rippleCancelShow(e) {
    var element = e.currentTarget;
    if (!(element == null ? void 0 : element._ripple)) return;
    if (element._ripple.showTimerCommit) {
      element._ripple.showTimerCommit = null;
    }
    window.clearTimeout(element._ripple.showTimer);
  }
  var keyboardRipple = false;
  function keyboardRippleShow(e) {
    if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
      keyboardRipple = true;
      rippleShow(e);
    }
  }
  function keyboardRippleHide(e) {
    keyboardRipple = false;
    rippleHide(e);
  }
  function focusRippleHide(e) {
    if (keyboardRipple) {
      keyboardRipple = false;
      rippleHide(e);
    }
  }
  function updateRipple(el, binding, wasEnabled) {
    var _a2;
    var value = binding.value,
      modifiers2 = binding.modifiers;
    var enabled = isRippleEnabled(value);
    if (!enabled) {
      ripples.hide(el);
    }
    el._ripple = (_a2 = el._ripple) != null ? _a2 : {};
    el._ripple.enabled = enabled;
    el._ripple.centered = modifiers2.center;
    el._ripple.circle = modifiers2.circle;
    if (isObject(value) && value.class) {
      el._ripple.class = value.class;
    }
    if (enabled && !wasEnabled) {
      if (modifiers2.stop) {
        el.addEventListener("touchstart", rippleStop, {
          passive: true
        });
        el.addEventListener("mousedown", rippleStop);
        return;
      }
      el.addEventListener("touchstart", rippleShow, {
        passive: true
      });
      el.addEventListener("touchend", rippleHide, {
        passive: true
      });
      el.addEventListener("touchmove", rippleCancelShow, {
        passive: true
      });
      el.addEventListener("touchcancel", rippleHide);
      el.addEventListener("mousedown", rippleShow);
      el.addEventListener("mouseup", rippleHide);
      el.addEventListener("mouseleave", rippleHide);
      el.addEventListener("keydown", keyboardRippleShow);
      el.addEventListener("keyup", keyboardRippleHide);
      el.addEventListener("blur", focusRippleHide);
      el.addEventListener("dragstart", rippleHide, {
        passive: true
      });
    } else if (!enabled && wasEnabled) {
      removeListeners(el);
    }
  }
  function removeListeners(el) {
    el.removeEventListener("mousedown", rippleShow);
    el.removeEventListener("touchstart", rippleShow);
    el.removeEventListener("touchend", rippleHide);
    el.removeEventListener("touchmove", rippleCancelShow);
    el.removeEventListener("touchcancel", rippleHide);
    el.removeEventListener("mouseup", rippleHide);
    el.removeEventListener("mouseleave", rippleHide);
    el.removeEventListener("keydown", keyboardRippleShow);
    el.removeEventListener("keyup", keyboardRippleHide);
    el.removeEventListener("dragstart", rippleHide);
    el.removeEventListener("blur", focusRippleHide);
  }
  function mounted$4(el, binding) {
    updateRipple(el, binding, false);
  }
  function unmounted$4(el) {
    delete el._ripple;
    removeListeners(el);
  }
  function updated$1(el, binding) {
    if (binding.value === binding.oldValue) {
      return;
    }
    var wasEnabled = isRippleEnabled(binding.oldValue);
    updateRipple(el, binding, wasEnabled);
  }
  var Ripple = {
    mounted: mounted$4,
    unmounted: unmounted$4,
    updated: updated$1
  };
  var makeVBtnProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    active: {
      type: Boolean,
      "default": void 0
    },
    activeColor: String,
    baseColor: String,
    symbol: {
      type: null,
      "default": VBtnToggleSymbol
    },
    flat: Boolean,
    icon: [Boolean, String, Function, Object],
    prependIcon: IconValue,
    appendIcon: IconValue,
    block: Boolean,
    readonly: Boolean,
    slim: Boolean,
    stacked: Boolean,
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeGroupItemProps()), makeLoaderProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "button"
  })), makeThemeProps()), makeVariantProps({
    variant: "elevated"
  })), "VBtn");
  var VBtn = genericComponent()({
    name: "VBtn",
    props: makeVBtnProps(),
    emits: {
      "group:selected": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _provideTheme6 = provideTheme(props),
        themeClasses = _provideTheme6.themeClasses;
      var _useBorder3 = useBorder(props),
        borderClasses = _useBorder3.borderClasses;
      var _useDensity2 = useDensity(props),
        densityClasses = _useDensity2.densityClasses;
      var _useDimension2 = useDimension(props),
        dimensionStyles = _useDimension2.dimensionStyles;
      var _useElevation3 = useElevation(props),
        elevationClasses = _useElevation3.elevationClasses;
      var _useLoader = useLoader(props),
        loaderClasses = _useLoader.loaderClasses;
      var _useLocation2 = useLocation(props),
        locationStyles = _useLocation2.locationStyles;
      var _usePosition = usePosition(props),
        positionClasses = _usePosition.positionClasses;
      var _useRounded5 = useRounded(props),
        roundedClasses = _useRounded5.roundedClasses;
      var _useSize3 = useSize(props),
        sizeClasses = _useSize3.sizeClasses,
        sizeStyles = _useSize3.sizeStyles;
      var group = useGroupItem(props, props.symbol, false);
      var link = useLink(props, attrs);
      var isActive2 = computed(function () {
        var _a2;
        if (props.active !== void 0) {
          return props.active;
        }
        if (link.isLink.value) {
          return (_a2 = link.isActive) == null ? void 0 : _a2.value;
        }
        return group == null ? void 0 : group.isSelected.value;
      });
      var color = computed(function () {
        var _a2;
        return isActive2.value ? (_a2 = props.activeColor) != null ? _a2 : props.color : props.color;
      });
      var variantProps = computed(function () {
        var _a2, _b, _c;
        var showColor = (group == null ? void 0 : group.isSelected.value) && (!link.isLink.value || ((_a2 = link.isActive) == null ? void 0 : _a2.value)) || !group || ((_b = link.isActive) == null ? void 0 : _b.value);
        return {
          color: showColor ? (_c = color.value) != null ? _c : props.baseColor : props.baseColor,
          variant: props.variant
        };
      });
      var _useVariant = useVariant(variantProps),
        colorClasses = _useVariant.colorClasses,
        colorStyles = _useVariant.colorStyles,
        variantClasses = _useVariant.variantClasses;
      var isDisabled = computed(function () {
        return (group == null ? void 0 : group.disabled.value) || props.disabled;
      });
      var isElevated = computed(function () {
        return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
      });
      var valueAttr = computed(function () {
        if (props.value === void 0 || _typeof(props.value) === "symbol") return void 0;
        return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
      });
      function onClick(e) {
        var _a2;
        if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank")) return;
        (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
        group == null ? void 0 : group.toggle();
      }
      useSelectLink(link, group == null ? void 0 : group.select);
      useRender(function () {
        var Tag = link.isLink.value ? "a" : props.tag;
        var hasPrepend = !!(props.prependIcon || slots.prepend);
        var hasAppend = !!(props.appendIcon || slots.append);
        var hasIcon = !!(props.icon && props.icon !== true);
        return withDirectives(createVNode(Tag, mergeProps({
          "type": Tag === "a" ? void 0 : "button",
          "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
            "v-btn--active": isActive2.value,
            "v-btn--block": props.block,
            "v-btn--disabled": isDisabled.value,
            "v-btn--elevated": isElevated.value,
            "v-btn--flat": props.flat,
            "v-btn--icon": !!props.icon,
            "v-btn--loading": props.loading,
            "v-btn--readonly": props.readonly,
            "v-btn--slim": props.slim,
            "v-btn--stacked": props.stacked
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, sizeStyles.value, props.style],
          "aria-busy": props.loading ? true : void 0,
          "disabled": isDisabled.value || void 0,
          "tabindex": props.loading || props.readonly ? -1 : void 0,
          "onClick": onClick,
          "value": valueAttr.value
        }, link.linkProps), {
          "default": function () {
            var _a2, _b;
            return [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createVNode("span", {
              "key": "prepend",
              "class": "v-btn__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "icon": props.prependIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !props.prependIcon,
              "defaults": {
                VIcon: {
                  icon: props.prependIcon
                }
              }
            }, slots.prepend)]), createVNode("span", {
              "class": "v-btn__content",
              "data-no-activator": ""
            }, [!slots.default && hasIcon ? createVNode(VIcon, {
              "key": "content-icon",
              "icon": props.icon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "content-defaults",
              "disabled": !hasIcon,
              "defaults": {
                VIcon: {
                  icon: props.icon
                }
              }
            }, {
              "default": function () {
                var _a3, _b2;
                return [(_b2 = (_a3 = slots.default) == null ? void 0 : _a3.call(slots)) != null ? _b2 : props.text];
              }
            })]), !props.icon && hasAppend && createVNode("span", {
              "key": "append",
              "class": "v-btn__append"
            }, [!slots.append ? createVNode(VIcon, {
              "key": "append-icon",
              "icon": props.appendIcon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !props.appendIcon,
              "defaults": {
                VIcon: {
                  icon: props.appendIcon
                }
              }
            }, slots.append)]), !!props.loading && createVNode("span", {
              "key": "loader",
              "class": "v-btn__loader"
            }, [(_b = (_a2 = slots.loader) == null ? void 0 : _a2.call(slots)) != null ? _b : createVNode(VProgressCircular, {
              "color": typeof props.loading === "boolean" ? void 0 : props.loading,
              "indeterminate": true,
              "width": "2"
            }, null)])];
          }
        }), [[Ripple, !isDisabled.value && props.ripple, "", {
          center: !!props.icon
        }]]);
      });
      return {
        group: group
      };
    }
  });
  var makeVAppBarNavIconProps = propsFactory(_objectSpread({}, makeVBtnProps({
    icon: "$menu",
    variant: "text"
  })), "VAppBarNavIcon");
  var VAppBarNavIcon = genericComponent()({
    name: "VAppBarNavIcon",
    props: makeVAppBarNavIconProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(VBtn, mergeProps(props, {
          "class": ["v-app-bar-nav-icon"]
        }), slots);
      });
      return {};
    }
  });
  var VAppBarTitle = genericComponent()({
    name: "VAppBarTitle",
    props: makeVToolbarTitleProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(VToolbarTitle, mergeProps(props, {
          "class": "v-app-bar-title"
        }), slots);
      });
      return {};
    }
  });
  var VAlert$1 = "";
  var VAlertTitle = createSimpleFunctional("v-alert-title");
  var allowedTypes = ["success", "info", "warning", "error"];
  var makeVAlertProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    border: {
      type: [Boolean, String],
      validator: function (val) {
        return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      "default": "$close"
    },
    closeLabel: {
      type: String,
      "default": "$vuetify.close"
    },
    icon: {
      type: [Boolean, String, Function, Object],
      "default": null
    },
    modelValue: {
      type: Boolean,
      "default": true
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
      type: String,
      validator: function (val) {
        return allowedTypes.includes(val);
      }
    }
  }, makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "flat"
  })), "VAlert");
  var VAlert = genericComponent()({
    name: "VAlert",
    props: makeVAlertProps(),
    emits: {
      "click:close": function (e) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var isActive2 = useProxiedModel(props, "modelValue");
      var icon = computed(function () {
        var _a2;
        if (props.icon === false) return void 0;
        if (!props.type) return props.icon;
        return (_a2 = props.icon) != null ? _a2 : "$" + props.type;
      });
      var variantProps = computed(function () {
        var _a2;
        return {
          color: (_a2 = props.color) != null ? _a2 : props.type,
          variant: props.variant
        };
      });
      var _provideTheme7 = provideTheme(props),
        themeClasses = _provideTheme7.themeClasses;
      var _useVariant2 = useVariant(variantProps),
        colorClasses = _useVariant2.colorClasses,
        colorStyles = _useVariant2.colorStyles,
        variantClasses = _useVariant2.variantClasses;
      var _useDensity3 = useDensity(props),
        densityClasses = _useDensity3.densityClasses;
      var _useDimension3 = useDimension(props),
        dimensionStyles = _useDimension3.dimensionStyles;
      var _useElevation4 = useElevation(props),
        elevationClasses = _useElevation4.elevationClasses;
      var _useLocation3 = useLocation(props),
        locationStyles = _useLocation3.locationStyles;
      var _usePosition2 = usePosition(props),
        positionClasses = _usePosition2.positionClasses;
      var _useRounded6 = useRounded(props),
        roundedClasses = _useRounded6.roundedClasses;
      var _useTextColor5 = useTextColor(toRef(props, "borderColor")),
        textColorClasses = _useTextColor5.textColorClasses,
        textColorStyles = _useTextColor5.textColorStyles;
      var _useLocale = useLocale(),
        t = _useLocale.t;
      var closeProps = computed(function () {
        return {
          "aria-label": t(props.closeLabel),
          onClick: function (e) {
            isActive2.value = false;
            emit2("click:close", e);
          }
        };
      });
      return function () {
        var _ref261;
        var hasPrepend = !!(slots.prepend || icon.value);
        var hasTitle = !!(slots.title || props.title);
        var hasClose = !!(slots.close || props.closable);
        return isActive2.value && createVNode(props.tag, {
          "class": ["v-alert", props.border && (_ref261 = {
            "v-alert--border": !!props.border
          }, _ref261["v-alert--border-" + (props.border === true ? "start" : props.border)] = true, _ref261), {
            "v-alert--prominent": props.prominent
          }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "role": "alert"
        }, {
          "default": function () {
            var _a2, _b, _c;
            return [genOverlays(false, "v-alert"), props.border && createVNode("div", {
              "key": "border",
              "class": ["v-alert__border", textColorClasses.value],
              "style": textColorStyles.value
            }, null), hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-alert__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "density": props.density,
              "icon": icon.value,
              "size": props.prominent ? 44 : 28
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !icon.value,
              "defaults": {
                VIcon: {
                  density: props.density,
                  icon: icon.value,
                  size: props.prominent ? 44 : 28
                }
              }
            }, slots.prepend)]), createVNode("div", {
              "class": "v-alert__content"
            }, [hasTitle && createVNode(VAlertTitle, {
              "key": "title"
            }, {
              "default": function () {
                var _a3, _b2;
                return [(_b2 = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b2 : props.title];
              }
            }), (_b = (_a2 = slots.text) == null ? void 0 : _a2.call(slots)) != null ? _b : props.text, (_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.append && createVNode("div", {
              "key": "append",
              "class": "v-alert__append"
            }, [slots.append()]), hasClose && createVNode("div", {
              "key": "close",
              "class": "v-alert__close"
            }, [!slots.close ? createVNode(VBtn, mergeProps({
              "key": "close-btn",
              "icon": props.closeIcon,
              "size": "x-small",
              "variant": "text"
            }, closeProps.value), null) : createVNode(VDefaultsProvider, {
              "key": "close-defaults",
              "defaults": {
                VBtn: {
                  icon: props.closeIcon,
                  size: "x-small",
                  variant: "text"
                }
              }
            }, {
              "default": function () {
                var _a3;
                return [(_a3 = slots.close) == null ? void 0 : _a3.call(slots, {
                  props: closeProps.value
                })];
              }
            })])];
          }
        });
      };
    }
  });
  var VAutocomplete$1 = "";
  var VAvatar$1 = "";
  var makeVAvatarProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    start: Boolean,
    end: Boolean,
    icon: IconValue,
    image: String,
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeRoundedProps()), makeSizeProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "flat"
  })), "VAvatar");
  var VAvatar = genericComponent()({
    name: "VAvatar",
    props: makeVAvatarProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme8 = provideTheme(props),
        themeClasses = _provideTheme8.themeClasses;
      var _useBorder4 = useBorder(props),
        borderClasses = _useBorder4.borderClasses;
      var _useVariant3 = useVariant(props),
        colorClasses = _useVariant3.colorClasses,
        colorStyles = _useVariant3.colorStyles,
        variantClasses = _useVariant3.variantClasses;
      var _useDensity4 = useDensity(props),
        densityClasses = _useDensity4.densityClasses;
      var _useRounded7 = useRounded(props),
        roundedClasses = _useRounded7.roundedClasses;
      var _useSize4 = useSize(props),
        sizeClasses = _useSize4.sizeClasses,
        sizeStyles = _useSize4.sizeStyles;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-avatar", {
            "v-avatar--start": props.start,
            "v-avatar--end": props.end
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, sizeStyles.value, props.style]
        }, {
          "default": function () {
            return [!slots.default ? props.image ? createVNode(VImg, {
              "key": "image",
              "src": props.image,
              "alt": "",
              "cover": true
            }, null) : props.icon ? createVNode(VIcon, {
              "key": "icon",
              "icon": props.icon
            }, null) : props.text : createVNode(VDefaultsProvider, {
              "key": "content-defaults",
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                },
                VIcon: {
                  icon: props.icon
                }
              }
            }, {
              "default": function () {
                return [slots.default()];
              }
            }), genOverlays(false, "v-avatar")];
          }
        });
      });
      return {};
    }
  });
  var VCheckbox$1 = "";
  var VSelectionControl$1 = "";
  var VLabel$1 = "";
  var makeVLabelProps = propsFactory(_objectSpread(_objectSpread({
    text: String,
    onClick: EventProp()
  }, makeComponentProps()), makeThemeProps()), "VLabel");
  var VLabel = genericComponent()({
    name: "VLabel",
    props: makeVLabelProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var _a2;
        return createVNode("label", {
          "class": ["v-label", {
            "v-label--clickable": !!props.onClick
          }, props.class],
          "style": props.style,
          "onClick": props.onClick
        }, [props.text, (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var VSelectionControlGroup$1 = "";
  var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
  var makeSelectionControlGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    color: String,
    disabled: {
      type: Boolean,
      "default": null
    },
    defaultsTarget: String,
    error: Boolean,
    id: String,
    inline: Boolean,
    falseIcon: IconValue,
    trueIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    multiple: {
      type: Boolean,
      "default": null
    },
    name: String,
    readonly: {
      type: Boolean,
      "default": null
    },
    modelValue: null,
    type: String,
    valueComparator: {
      type: Function,
      "default": deepEqual
    }
  }, makeComponentProps()), makeDensityProps()), makeThemeProps()), "SelectionControlGroup");
  var makeVSelectionControlGroupProps = propsFactory(_objectSpread({}, makeSelectionControlGroupProps({
    defaultsTarget: "VSelectionControl"
  })), "VSelectionControlGroup");
  var VSelectionControlGroup = genericComponent()({
    name: "VSelectionControlGroup",
    props: makeVSelectionControlGroupProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var _provideDefaults;
      var slots = _ref.slots;
      var modelValue = useProxiedModel(props, "modelValue");
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "v-selection-control-group-" + uid2;
      });
      var name = computed(function () {
        return props.name || id.value;
      });
      var updateHandlers = /* @__PURE__ */new Set();
      provide(VSelectionControlGroupSymbol, {
        modelValue: modelValue,
        forceUpdate: function () {
          updateHandlers.forEach(function (fn) {
            return fn();
          });
        },
        onForceUpdate: function (cb) {
          updateHandlers.add(cb);
          onScopeDispose(function () {
            updateHandlers.delete(cb);
          });
        }
      });
      provideDefaults((_provideDefaults = {}, _provideDefaults[props.defaultsTarget] = {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        density: toRef(props, "density"),
        error: toRef(props, "error"),
        inline: toRef(props, "inline"),
        modelValue: modelValue,
        multiple: computed(function () {
          return !!props.multiple || props.multiple == null && Array.isArray(modelValue.value);
        }),
        name: name,
        falseIcon: toRef(props, "falseIcon"),
        trueIcon: toRef(props, "trueIcon"),
        readonly: toRef(props, "readonly"),
        ripple: toRef(props, "ripple"),
        type: toRef(props, "type"),
        valueComparator: toRef(props, "valueComparator")
      }, _provideDefaults));
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-selection-control-group", {
            "v-selection-control-group--inline": props.inline
          }, props.class],
          "style": props.style,
          "role": props.type === "radio" ? "radiogroup" : void 0
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var makeVSelectionControlProps = propsFactory(_objectSpread(_objectSpread({
    label: String,
    baseColor: String,
    trueValue: null,
    falseValue: null,
    value: null
  }, makeComponentProps()), makeSelectionControlGroupProps()), "VSelectionControl");
  function useSelectionControl(props) {
    var group = inject$1(VSelectionControlGroupSymbol, void 0);
    var _useDensity5 = useDensity(props),
      densityClasses = _useDensity5.densityClasses;
    var modelValue = useProxiedModel(props, "modelValue");
    var trueValue = computed(function () {
      return props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true;
    });
    var falseValue = computed(function () {
      return props.falseValue !== void 0 ? props.falseValue : false;
    });
    var isMultiple = computed(function () {
      return !!props.multiple || props.multiple == null && Array.isArray(modelValue.value);
    });
    var model = computed({
      get: function () {
        var val = group ? group.modelValue.value : modelValue.value;
        return isMultiple.value ? wrapInArray(val).some(function (v) {
          return props.valueComparator(v, trueValue.value);
        }) : props.valueComparator(val, trueValue.value);
      },
      set: function (val) {
        if (props.readonly) return;
        var currentValue = val ? trueValue.value : falseValue.value;
        var newVal = currentValue;
        if (isMultiple.value) {
          newVal = val ? [].concat(_toConsumableArray(wrapInArray(modelValue.value)), [currentValue]) : wrapInArray(modelValue.value).filter(function (item) {
            return !props.valueComparator(item, trueValue.value);
          });
        }
        if (group) {
          group.modelValue.value = newVal;
        } else {
          modelValue.value = newVal;
        }
      }
    });
    var _useTextColor6 = useTextColor(computed(function () {
        if (props.error || props.disabled) return void 0;
        return model.value ? props.color : props.baseColor;
      })),
      textColorClasses = _useTextColor6.textColorClasses,
      textColorStyles = _useTextColor6.textColorStyles;
    var _useBackgroundColor6 = useBackgroundColor(computed(function () {
        return model.value && !props.error && !props.disabled ? props.color : props.baseColor;
      })),
      backgroundColorClasses = _useBackgroundColor6.backgroundColorClasses,
      backgroundColorStyles = _useBackgroundColor6.backgroundColorStyles;
    var icon = computed(function () {
      return model.value ? props.trueIcon : props.falseIcon;
    });
    return {
      group: group,
      densityClasses: densityClasses,
      trueValue: trueValue,
      falseValue: falseValue,
      model: model,
      textColorClasses: textColorClasses,
      textColorStyles: textColorStyles,
      backgroundColorClasses: backgroundColorClasses,
      backgroundColorStyles: backgroundColorStyles,
      icon: icon
    };
  }
  var VSelectionControl = genericComponent()({
    name: "VSelectionControl",
    directives: {
      Ripple: Ripple
    },
    inheritAttrs: false,
    props: makeVSelectionControlProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _useSelectionControl = useSelectionControl(props),
        group = _useSelectionControl.group,
        densityClasses = _useSelectionControl.densityClasses,
        icon = _useSelectionControl.icon,
        model = _useSelectionControl.model,
        textColorClasses = _useSelectionControl.textColorClasses,
        textColorStyles = _useSelectionControl.textColorStyles,
        backgroundColorClasses = _useSelectionControl.backgroundColorClasses,
        backgroundColorStyles = _useSelectionControl.backgroundColorStyles,
        trueValue = _useSelectionControl.trueValue;
      var uid2 = getUid();
      var isFocused = shallowRef(false);
      var isFocusVisible = shallowRef(false);
      var input = ref();
      var id = computed(function () {
        return props.id || "input-" + uid2;
      });
      var isInteractive = computed(function () {
        return !props.disabled && !props.readonly;
      });
      group == null ? void 0 : group.onForceUpdate(function () {
        if (input.value) {
          input.value.checked = model.value;
        }
      });
      function onFocus(e) {
        if (!isInteractive.value) return;
        isFocused.value = true;
        if (matchesSelector(e.target, ":focus-visible") !== false) {
          isFocusVisible.value = true;
        }
      }
      function onBlur() {
        isFocused.value = false;
        isFocusVisible.value = false;
      }
      function onClickLabel(e) {
        e.stopPropagation();
      }
      function onInput(e) {
        if (!isInteractive.value) {
          if (input.value) {
            input.value.checked = model.value;
          }
          return;
        }
        if (props.readonly && group) {
          nextTick(function () {
            return group.forceUpdate();
          });
        }
        model.value = e.target.checked;
      }
      useRender(function () {
        var _a2, _b, _c;
        var label = slots.label ? slots.label({
          label: props.label,
          props: {
            "for": id.value
          }
        }) : props.label;
        var _filterInputAttrs = filterInputAttrs(attrs),
          _filterInputAttrs2 = _slicedToArray(_filterInputAttrs, 2),
          rootAttrs = _filterInputAttrs2[0],
          inputAttrs = _filterInputAttrs2[1];
        var inputNode = createVNode("input", mergeProps({
          "ref": input,
          "checked": model.value,
          "disabled": !!props.disabled,
          "id": id.value,
          "onBlur": onBlur,
          "onFocus": onFocus,
          "onInput": onInput,
          "aria-disabled": !!props.disabled,
          "aria-label": props.label,
          "type": props.type,
          "value": trueValue.value,
          "name": props.name,
          "aria-checked": props.type === "checkbox" ? model.value : void 0
        }, inputAttrs), null);
        return createVNode("div", mergeProps({
          "class": ["v-selection-control", {
            "v-selection-control--dirty": model.value,
            "v-selection-control--disabled": props.disabled,
            "v-selection-control--error": props.error,
            "v-selection-control--focused": isFocused.value,
            "v-selection-control--focus-visible": isFocusVisible.value,
            "v-selection-control--inline": props.inline
          }, densityClasses.value, props.class]
        }, rootAttrs, {
          "style": props.style
        }), [createVNode("div", {
          "class": ["v-selection-control__wrapper", textColorClasses.value],
          "style": textColorStyles.value
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          backgroundColorClasses: backgroundColorClasses,
          backgroundColorStyles: backgroundColorStyles
        }), withDirectives(createVNode("div", {
          "class": ["v-selection-control__input"]
        }, [(_c = (_b = slots.input) == null ? void 0 : _b.call(slots, {
          model: model,
          textColorClasses: textColorClasses,
          textColorStyles: textColorStyles,
          backgroundColorClasses: backgroundColorClasses,
          backgroundColorStyles: backgroundColorStyles,
          inputNode: inputNode,
          icon: icon.value,
          props: {
            onFocus: onFocus,
            onBlur: onBlur,
            id: id.value
          }
        })) != null ? _c : createVNode(Fragment$1, null, [icon.value && createVNode(VIcon, {
          "key": "icon",
          "icon": icon.value
        }, null), inputNode])]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
          "for": id.value,
          "onClick": onClickLabel
        }, {
          "default": function () {
            return [label];
          }
        })]);
      });
      return {
        isFocused: isFocused,
        input: input
      };
    }
  });
  var makeVCheckboxBtnProps = propsFactory(_objectSpread({
    indeterminate: Boolean,
    indeterminateIcon: {
      type: IconValue,
      "default": "$checkboxIndeterminate"
    }
  }, makeVSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })), "VCheckboxBtn");
  var VCheckboxBtn = genericComponent()({
    name: "VCheckboxBtn",
    props: makeVCheckboxBtnProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      "update:indeterminate": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var indeterminate = useProxiedModel(props, "indeterminate");
      var model = useProxiedModel(props, "modelValue");
      function onChange(v) {
        if (indeterminate.value) {
          indeterminate.value = false;
        }
      }
      var falseIcon = computed(function () {
        return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
      });
      var trueIcon = computed(function () {
        return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
      });
      useRender(function () {
        var controlProps = omit(VSelectionControl.filterProps(props), ["modelValue"]);
        return createVNode(VSelectionControl, mergeProps(controlProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": [function ($event) {
            return model.value = $event;
          }, onChange],
          "class": ["v-checkbox-btn", props.class],
          "style": props.style,
          "type": "checkbox",
          "falseIcon": falseIcon.value,
          "trueIcon": trueIcon.value,
          "aria-checked": indeterminate.value ? "mixed" : void 0
        }), slots);
      });
      return {};
    }
  });
  var VInput$1 = "";
  function useInputIcon(props) {
    var _useLocale2 = useLocale(),
      t = _useLocale2.t;
    function InputIcon(_ref) {
      var _a2;
      var name = _ref.name;
      var localeKey = {
        prepend: "prependAction",
        prependInner: "prependAction",
        append: "appendAction",
        appendInner: "appendAction",
        clear: "clear"
      }[name];
      var listener = props["onClick:" + name];
      var label = listener && localeKey ? t("$vuetify.input." + localeKey, (_a2 = props.label) != null ? _a2 : "") : void 0;
      return createVNode(VIcon, {
        "icon": props[name + "Icon"],
        "aria-label": label,
        "onClick": listener
      }, null);
    }
    return {
      InputIcon: InputIcon
    };
  }
  var VMessages$1 = "";
  var makeVMessagesProps = propsFactory(_objectSpread(_objectSpread({
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      "default": function () {
        return [];
      }
    }
  }, makeComponentProps()), makeTransitionProps({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })), "VMessages");
  var VMessages = genericComponent()({
    name: "VMessages",
    props: makeVMessagesProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var messages = computed(function () {
        return wrapInArray(props.messages);
      });
      var _useTextColor7 = useTextColor(computed(function () {
          return props.color;
        })),
        textColorClasses = _useTextColor7.textColorClasses,
        textColorStyles = _useTextColor7.textColorStyles;
      useRender(function () {
        return createVNode(MaybeTransition, {
          "transition": props.transition,
          "tag": "div",
          "class": ["v-messages", textColorClasses.value, props.class],
          "style": [textColorStyles.value, props.style],
          "role": "alert",
          "aria-live": "polite"
        }, {
          "default": function () {
            return [props.active && messages.value.map(function (message, i) {
              return createVNode("div", {
                "class": "v-messages__message",
                "key": i + "-" + messages.value
              }, [slots.message ? slots.message({
                message: message
              }) : message]);
            })];
          }
        });
      });
      return {};
    }
  });
  var makeFocusProps = propsFactory({
    focused: Boolean,
    "onUpdate:focused": EventProp()
  }, "focus");
  function useFocus(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var isFocused = useProxiedModel(props, "focused");
    var focusClasses = computed(function () {
      var _ref262;
      return _ref262 = {}, _ref262[name + "--focused"] = isFocused.value, _ref262;
    });
    function focus2() {
      isFocused.value = true;
    }
    function blur2() {
      isFocused.value = false;
    }
    return {
      focusClasses: focusClasses,
      isFocused: isFocused,
      focus: focus2,
      blur: blur2
    };
  }
  var FormKey = Symbol.for("vuetify:form");
  var makeFormProps = propsFactory({
    disabled: Boolean,
    fastFail: Boolean,
    readonly: Boolean,
    modelValue: {
      type: Boolean,
      "default": null
    },
    validateOn: {
      type: String,
      "default": "input"
    }
  }, "form");
  function createForm(props) {
    var model = useProxiedModel(props, "modelValue");
    var isDisabled = computed(function () {
      return props.disabled;
    });
    var isReadonly2 = computed(function () {
      return props.readonly;
    });
    var isValidating = shallowRef(false);
    var items = ref([]);
    var errors = ref([]);
    function validate() {
      var results, valid, _iterator41, _step43, item, itemErrorMessages;
      return _regeneratorRuntime.async(function validate$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            results = [];
            valid = true;
            errors.value = [];
            isValidating.value = true;
            _iterator41 = _createForOfIteratorHelperLoose(items.value);
          case 5:
            if ((_step43 = _iterator41()).done) {
              _context7.next = 15;
              break;
            }
            item = _step43.value;
            _context7.next = 9;
            return _regeneratorRuntime.awrap(item.validate());
          case 9:
            itemErrorMessages = _context7.sent;
            if (itemErrorMessages.length > 0) {
              valid = false;
              results.push({
                id: item.id,
                errorMessages: itemErrorMessages
              });
            }
            if (!(!valid && props.fastFail)) {
              _context7.next = 13;
              break;
            }
            return _context7.abrupt("break", 15);
          case 13:
            _context7.next = 5;
            break;
          case 15:
            errors.value = results;
            isValidating.value = false;
            return _context7.abrupt("return", {
              valid: valid,
              errors: errors.value
            });
          case 18:
          case "end":
            return _context7.stop();
        }
      }, null, null, null, Promise);
    }
    function reset() {
      items.value.forEach(function (item) {
        return item.reset();
      });
    }
    function resetValidation() {
      items.value.forEach(function (item) {
        return item.resetValidation();
      });
    }
    watch(items, function () {
      var valid = 0;
      var invalid = 0;
      var results = [];
      for (var _iterator42 = _createForOfIteratorHelperLoose(items.value), _step44; !(_step44 = _iterator42()).done;) {
        var item = _step44.value;
        if (item.isValid === false) {
          invalid++;
          results.push({
            id: item.id,
            errorMessages: item.errorMessages
          });
        } else if (item.isValid === true) valid++;
      }
      errors.value = results;
      model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
    }, {
      deep: true,
      flush: "post"
    });
    provide(FormKey, {
      register: function (_ref) {
        var id = _ref.id,
          vm = _ref.vm,
          validate2 = _ref.validate,
          reset2 = _ref.reset,
          resetValidation2 = _ref.resetValidation;
        if (items.value.some(function (item) {
          return item.id === id;
        })) {
          consoleWarn("Duplicate input name \"" + id + "\"");
        }
        items.value.push({
          id: id,
          validate: validate2,
          reset: reset2,
          resetValidation: resetValidation2,
          vm: markRaw(vm),
          isValid: null,
          errorMessages: []
        });
      },
      unregister: function (id) {
        items.value = items.value.filter(function (item) {
          return item.id !== id;
        });
      },
      update: function (id, isValid2, errorMessages) {
        var found2 = items.value.find(function (item) {
          return item.id === id;
        });
        if (!found2) return;
        found2.isValid = isValid2;
        found2.errorMessages = errorMessages;
      },
      isDisabled: isDisabled,
      isReadonly: isReadonly2,
      isValidating: isValidating,
      isValid: model,
      items: items,
      validateOn: toRef(props, "validateOn")
    });
    return {
      errors: errors,
      isDisabled: isDisabled,
      isReadonly: isReadonly2,
      isValidating: isValidating,
      isValid: model,
      items: items,
      validate: validate,
      reset: reset,
      resetValidation: resetValidation
    };
  }
  function useForm() {
    return inject$1(FormKey, null);
  }
  var makeValidationProps = propsFactory(_objectSpread({
    disabled: {
      type: Boolean,
      "default": null
    },
    error: Boolean,
    errorMessages: {
      type: [Array, String],
      "default": function () {
        return [];
      }
    },
    maxErrors: {
      type: [Number, String],
      "default": 1
    },
    name: String,
    label: String,
    readonly: {
      type: Boolean,
      "default": null
    },
    rules: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    modelValue: null,
    validateOn: String,
    validationValue: null
  }, makeFocusProps()), "validation");
  function useValidation(props) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
    var id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
    var model = useProxiedModel(props, "modelValue");
    var validationModel = computed(function () {
      return props.validationValue === void 0 ? model.value : props.validationValue;
    });
    var form = useForm();
    var internalErrorMessages = ref([]);
    var isPristine = shallowRef(true);
    var isDirty2 = computed(function () {
      return !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length);
    });
    var isDisabled = computed(function () {
      var _a2;
      return !!((_a2 = props.disabled) != null ? _a2 : form == null ? void 0 : form.isDisabled.value);
    });
    var isReadonly2 = computed(function () {
      var _a2;
      return !!((_a2 = props.readonly) != null ? _a2 : form == null ? void 0 : form.isReadonly.value);
    });
    var errorMessages = computed(function () {
      var _a2;
      return ((_a2 = props.errorMessages) == null ? void 0 : _a2.length) ? wrapInArray(props.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
    });
    var validateOn = computed(function () {
      var _a2, _b;
      var value = ((_a2 = props.validateOn) != null ? _a2 : form == null ? void 0 : form.validateOn.value) || "input";
      if (value === "lazy") value = "input lazy";
      if (value === "eager") value = "input eager";
      var set = new Set((_b = value == null ? void 0 : value.split(" ")) != null ? _b : []);
      return {
        input: set.has("input"),
        blur: set.has("blur") || set.has("input") || set.has("invalid-input"),
        invalidInput: set.has("invalid-input"),
        lazy: set.has("lazy"),
        eager: set.has("eager")
      };
    });
    var isValid2 = computed(function () {
      var _a2;
      if (props.error || ((_a2 = props.errorMessages) == null ? void 0 : _a2.length)) return false;
      if (!props.rules.length) return true;
      if (isPristine.value) {
        return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
      } else {
        return !internalErrorMessages.value.length;
      }
    });
    var isValidating = shallowRef(false);
    var validationClasses = computed(function () {
      var _ref263;
      return _ref263 = {}, _ref263[name + "--error"] = isValid2.value === false, _ref263[name + "--dirty"] = isDirty2.value, _ref263[name + "--disabled"] = isDisabled.value, _ref263[name + "--readonly"] = isReadonly2.value, _ref263;
    });
    var vm = getCurrentInstance("validation");
    var uid2 = computed(function () {
      var _a2;
      return (_a2 = props.name) != null ? _a2 : unref(id);
    });
    onBeforeMount(function () {
      form == null ? void 0 : form.register({
        id: uid2.value,
        vm: vm,
        validate: validate,
        reset: reset,
        resetValidation: resetValidation
      });
    });
    onBeforeUnmount(function () {
      form == null ? void 0 : form.unregister(uid2.value);
    });
    onMounted(function _callee4() {
      return _regeneratorRuntime.async(function _callee4$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            if (validateOn.value.lazy) {
              _context8.next = 3;
              break;
            }
            _context8.next = 3;
            return _regeneratorRuntime.awrap(validate(!validateOn.value.eager));
          case 3:
            form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
          case 4:
          case "end":
            return _context8.stop();
        }
      }, null, null, null, Promise);
    });
    useToggleScope(function () {
      return validateOn.value.input || validateOn.value.invalidInput && isValid2.value === false;
    }, function () {
      watch(validationModel, function () {
        if (validationModel.value != null) {
          validate();
        } else if (props.focused) {
          var unwatch = watch(function () {
            return props.focused;
          }, function (val) {
            if (!val) validate();
            unwatch();
          });
        }
      });
    });
    useToggleScope(function () {
      return validateOn.value.blur;
    }, function () {
      watch(function () {
        return props.focused;
      }, function (val) {
        if (!val) validate();
      });
    });
    watch([isValid2, errorMessages], function () {
      form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
    });
    function reset() {
      return _regeneratorRuntime.async(function reset$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            model.value = null;
            _context9.next = 3;
            return _regeneratorRuntime.awrap(nextTick());
          case 3:
            _context9.next = 5;
            return _regeneratorRuntime.awrap(resetValidation());
          case 5:
          case "end":
            return _context9.stop();
        }
      }, null, null, null, Promise);
    }
    function resetValidation() {
      return _regeneratorRuntime.async(function resetValidation$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            isPristine.value = true;
            if (validateOn.value.lazy) {
              _context10.next = 6;
              break;
            }
            _context10.next = 4;
            return _regeneratorRuntime.awrap(validate(!validateOn.value.eager));
          case 4:
            _context10.next = 7;
            break;
          case 6:
            internalErrorMessages.value = [];
          case 7:
          case "end":
            return _context10.stop();
        }
      }, null, null, null, Promise);
    }
    function validate() {
      var _a2,
        silent,
        results,
        _loop26,
        _ret7,
        _iterator43,
        _step45,
        rule,
        _args12 = arguments;
      return _regeneratorRuntime.async(function validate$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            silent = _args12.length > 0 && _args12[0] !== void 0 ? _args12[0] : false;
            results = [];
            isValidating.value = true;
            _loop26 = function _callee5(rule) {
              var handler, result;
              return _regeneratorRuntime.async(function _callee5$(_context11) {
                while (1) switch (_context11.prev = _context11.next) {
                  case 0:
                    if (!(results.length >= +((_a2 = props.maxErrors) != null ? _a2 : 1))) {
                      _context11.next = 2;
                      break;
                    }
                    return _context11.abrupt("return", 0);
                  case 2:
                    handler = typeof rule === "function" ? rule : function () {
                      return rule;
                    };
                    _context11.next = 5;
                    return _regeneratorRuntime.awrap(handler(validationModel.value));
                  case 5:
                    result = _context11.sent;
                    if (!(result === true)) {
                      _context11.next = 8;
                      break;
                    }
                    return _context11.abrupt("return", 1);
                  case 8:
                    if (!(result !== false && typeof result !== "string")) {
                      _context11.next = 11;
                      break;
                    }
                    console.warn(result + " is not a valid value. Rule functions must return boolean true or a string.");
                    return _context11.abrupt("return", 1);
                  case 11:
                    results.push(result || "");
                  case 12:
                  case "end":
                    return _context11.stop();
                }
              }, null, null, null, Promise);
            };
            _iterator43 = _createForOfIteratorHelperLoose(props.rules);
          case 5:
            if ((_step45 = _iterator43()).done) {
              _context12.next = 16;
              break;
            }
            rule = _step45.value;
            _context12.next = 9;
            return _regeneratorRuntime.awrap(_loop26(rule));
          case 9:
            _ret7 = _context12.sent;
            if (!(_ret7 === 0)) {
              _context12.next = 12;
              break;
            }
            return _context12.abrupt("break", 16);
          case 12:
            if (!(_ret7 === 1)) {
              _context12.next = 14;
              break;
            }
            return _context12.abrupt("continue", 14);
          case 14:
            _context12.next = 5;
            break;
          case 16:
            internalErrorMessages.value = results;
            isValidating.value = false;
            isPristine.value = silent;
            return _context12.abrupt("return", internalErrorMessages.value);
          case 20:
          case "end":
            return _context12.stop();
        }
      }, null, null, null, Promise);
    }
    return {
      errorMessages: errorMessages,
      isDirty: isDirty2,
      isDisabled: isDisabled,
      isReadonly: isReadonly2,
      isPristine: isPristine,
      isValid: isValid2,
      isValidating: isValidating,
      reset: reset,
      resetValidation: resetValidation,
      validate: validate,
      validationClasses: validationClasses
    };
  }
  var makeVInputProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    id: String,
    appendIcon: IconValue,
    centerAffix: {
      type: Boolean,
      "default": true
    },
    prependIcon: IconValue,
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    persistentHint: Boolean,
    messages: {
      type: [Array, String],
      "default": function () {
        return [];
      }
    },
    direction: {
      type: String,
      "default": "horizontal",
      validator: function (v) {
        return ["horizontal", "vertical"].includes(v);
      }
    },
    "onClick:prepend": EventProp(),
    "onClick:append": EventProp()
  }, makeComponentProps()), makeDensityProps()), only(makeDimensionProps(), ["maxWidth", "minWidth", "width"])), makeThemeProps()), makeValidationProps()), "VInput");
  var VInput = genericComponent()({
    name: "VInput",
    props: _objectSpread({}, makeVInputProps()),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots,
        emit2 = _ref.emit;
      var _useDensity6 = useDensity(props),
        densityClasses = _useDensity6.densityClasses;
      var _useDimension4 = useDimension(props),
        dimensionStyles = _useDimension4.dimensionStyles;
      var _provideTheme9 = provideTheme(props),
        themeClasses = _provideTheme9.themeClasses;
      var _useRtl6 = useRtl(),
        rtlClasses = _useRtl6.rtlClasses;
      var _useInputIcon = useInputIcon(props),
        InputIcon = _useInputIcon.InputIcon;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "input-" + uid2;
      });
      var messagesId = computed(function () {
        return id.value + "-messages";
      });
      var _useValidation = useValidation(props, "v-input", id),
        errorMessages = _useValidation.errorMessages,
        isDirty2 = _useValidation.isDirty,
        isDisabled = _useValidation.isDisabled,
        isReadonly2 = _useValidation.isReadonly,
        isPristine = _useValidation.isPristine,
        isValid2 = _useValidation.isValid,
        isValidating = _useValidation.isValidating,
        reset = _useValidation.reset,
        resetValidation = _useValidation.resetValidation,
        validate = _useValidation.validate,
        validationClasses = _useValidation.validationClasses;
      var slotProps = computed(function () {
        return {
          id: id,
          messagesId: messagesId,
          isDirty: isDirty2,
          isDisabled: isDisabled,
          isReadonly: isReadonly2,
          isPristine: isPristine,
          isValid: isValid2,
          isValidating: isValidating,
          reset: reset,
          resetValidation: resetValidation,
          validate: validate
        };
      });
      var messages = computed(function () {
        var _a2;
        if (((_a2 = props.errorMessages) == null ? void 0 : _a2.length) || !isPristine.value && errorMessages.value.length) {
          return errorMessages.value;
        } else if (props.hint && (props.persistentHint || props.focused)) {
          return props.hint;
        } else {
          return props.messages;
        }
      });
      useRender(function () {
        var _a2, _b, _c, _d;
        var hasPrepend = !!(slots.prepend || props.prependIcon);
        var hasAppend = !!(slots.append || props.appendIcon);
        var hasMessages = messages.value.length > 0;
        var hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
        return createVNode("div", {
          "class": ["v-input", "v-input--" + props.direction, {
            "v-input--center-affix": props.centerAffix,
            "v-input--hide-spin-buttons": props.hideSpinButtons
          }, densityClasses.value, themeClasses.value, rtlClasses.value, validationClasses.value, props.class],
          "style": [dimensionStyles.value, props.style]
        }, [hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-input__prepend"
        }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots, slotProps.value), props.prependIcon && createVNode(InputIcon, {
          "key": "prepend-icon",
          "name": "prepend"
        }, null)]), slots.default && createVNode("div", {
          "class": "v-input__control"
        }, [(_b = slots.default) == null ? void 0 : _b.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-input__append"
        }, [props.appendIcon && createVNode(InputIcon, {
          "key": "append-icon",
          "name": "append"
        }, null), (_c = slots.append) == null ? void 0 : _c.call(slots, slotProps.value)]), hasDetails && createVNode("div", {
          "class": "v-input__details"
        }, [createVNode(VMessages, {
          "id": messagesId.value,
          "active": hasMessages,
          "messages": messages.value
        }, {
          message: slots.message
        }), (_d = slots.details) == null ? void 0 : _d.call(slots, slotProps.value)])]);
      });
      return {
        reset: reset,
        resetValidation: resetValidation,
        validate: validate,
        isValid: isValid2,
        errorMessages: errorMessages
      };
    }
  });
  var makeVCheckboxProps = propsFactory(_objectSpread(_objectSpread({}, makeVInputProps()), omit(makeVCheckboxBtnProps(), ["inline"])), "VCheckbox");
  var VCheckbox = genericComponent()({
    name: "VCheckbox",
    inheritAttrs: false,
    props: makeVCheckboxProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      "update:focused": function (focused) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var _useFocus = useFocus(props),
        isFocused = _useFocus.isFocused,
        focus2 = _useFocus.focus,
        blur2 = _useFocus.blur;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "checkbox-" + uid2;
      });
      useRender(function () {
        var _filterInputAttrs3 = filterInputAttrs(attrs),
          _filterInputAttrs4 = _slicedToArray(_filterInputAttrs3, 2),
          rootAttrs = _filterInputAttrs4[0],
          controlAttrs = _filterInputAttrs4[1];
        var inputProps = VInput.filterProps(props);
        var checkboxProps = VCheckboxBtn.filterProps(props);
        return createVNode(VInput, mergeProps({
          "class": ["v-checkbox", props.class]
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "id": id.value,
          "focused": isFocused.value,
          "style": props.style
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (_ref2) {
            var id2 = _ref2.id,
              messagesId = _ref2.messagesId,
              isDisabled = _ref2.isDisabled,
              isReadonly2 = _ref2.isReadonly,
              isValid2 = _ref2.isValid;
            return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value
            }, controlAttrs, {
              "error": isValid2.value === false,
              "modelValue": model.value,
              "onUpdate:modelValue": function ($event) {
                return model.value = $event;
              },
              "onFocus": focus2,
              "onBlur": blur2
            }), slots);
          }
        }));
      });
      return {};
    }
  });
  var VChip$1 = "";
  var VChipGroup$1 = "";
  var VSlideGroup$1 = "";
  function calculateUpdatedTarget(_ref) {
    var selectedElement = _ref.selectedElement,
      containerElement = _ref.containerElement,
      isRtl = _ref.isRtl,
      isHorizontal = _ref.isHorizontal;
    var containerSize = getOffsetSize(isHorizontal, containerElement);
    var scrollPosition = getScrollPosition(isHorizontal, isRtl, containerElement);
    var childrenSize = getOffsetSize(isHorizontal, selectedElement);
    var childrenStartPosition = getOffsetPosition(isHorizontal, selectedElement);
    var additionalOffset = childrenSize * 0.4;
    if (scrollPosition > childrenStartPosition) {
      return childrenStartPosition - additionalOffset;
    } else if (scrollPosition + containerSize < childrenStartPosition + childrenSize) {
      return childrenStartPosition - containerSize + childrenSize + additionalOffset;
    }
    return scrollPosition;
  }
  function calculateCenteredTarget(_ref2) {
    var selectedElement = _ref2.selectedElement,
      containerElement = _ref2.containerElement,
      isHorizontal = _ref2.isHorizontal;
    var containerOffsetSize = getOffsetSize(isHorizontal, containerElement);
    var childrenOffsetPosition = getOffsetPosition(isHorizontal, selectedElement);
    var childrenOffsetSize = getOffsetSize(isHorizontal, selectedElement);
    return childrenOffsetPosition - containerOffsetSize / 2 + childrenOffsetSize / 2;
  }
  function getScrollSize(isHorizontal, element) {
    var key = isHorizontal ? "scrollWidth" : "scrollHeight";
    return (element == null ? void 0 : element[key]) || 0;
  }
  function getClientSize(isHorizontal, element) {
    var key = isHorizontal ? "clientWidth" : "clientHeight";
    return (element == null ? void 0 : element[key]) || 0;
  }
  function getScrollPosition(isHorizontal, rtl, element) {
    if (!element) {
      return 0;
    }
    var scrollLeft = element.scrollLeft,
      offsetWidth = element.offsetWidth,
      scrollWidth = element.scrollWidth;
    if (isHorizontal) {
      return rtl ? scrollWidth - offsetWidth + scrollLeft : scrollLeft;
    }
    return element.scrollTop;
  }
  function getOffsetSize(isHorizontal, element) {
    var key = isHorizontal ? "offsetWidth" : "offsetHeight";
    return (element == null ? void 0 : element[key]) || 0;
  }
  function getOffsetPosition(isHorizontal, element) {
    var key = isHorizontal ? "offsetLeft" : "offsetTop";
    return (element == null ? void 0 : element[key]) || 0;
  }
  var VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
  var makeVSlideGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    centerActive: Boolean,
    direction: {
      type: String,
      "default": "horizontal"
    },
    symbol: {
      type: null,
      "default": VSlideGroupSymbol
    },
    nextIcon: {
      type: IconValue,
      "default": "$next"
    },
    prevIcon: {
      type: IconValue,
      "default": "$prev"
    },
    showArrows: {
      type: [Boolean, String],
      validator: function (v) {
        return typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v);
      }
    }
  }, makeComponentProps()), makeDisplayProps({
    mobile: null
  })), makeTagProps()), makeGroupProps({
    selectedClass: "v-slide-group-item--active"
  })), "VSlideGroup");
  var VSlideGroup = genericComponent()({
    name: "VSlideGroup",
    props: makeVSlideGroupProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useRtl7 = useRtl(),
        isRtl = _useRtl7.isRtl;
      var _useDisplay = useDisplay(props),
        displayClasses = _useDisplay.displayClasses,
        mobile = _useDisplay.mobile;
      var group = useGroup(props, props.symbol);
      var isOverflowing = shallowRef(false);
      var scrollOffset = shallowRef(0);
      var containerSize = shallowRef(0);
      var contentSize = shallowRef(0);
      var isHorizontal = computed(function () {
        return props.direction === "horizontal";
      });
      var _useResizeObserver3 = useResizeObserver(),
        containerRef = _useResizeObserver3.resizeRef,
        containerRect = _useResizeObserver3.contentRect;
      var _useResizeObserver4 = useResizeObserver(),
        contentRef = _useResizeObserver4.resizeRef,
        contentRect = _useResizeObserver4.contentRect;
      var goTo = useGoTo();
      var goToOptions = computed(function () {
        return {
          container: containerRef.el,
          duration: 200,
          easing: "easeOutQuart"
        };
      });
      var firstSelectedIndex = computed(function () {
        if (!group.selected.value.length) return -1;
        return group.items.value.findIndex(function (item) {
          return item.id === group.selected.value[0];
        });
      });
      var lastSelectedIndex = computed(function () {
        if (!group.selected.value.length) return -1;
        return group.items.value.findIndex(function (item) {
          return item.id === group.selected.value[group.selected.value.length - 1];
        });
      });
      if (IN_BROWSER) {
        var frame = -1;
        watch(function () {
          return [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value];
        }, function () {
          cancelAnimationFrame(frame);
          frame = requestAnimationFrame(function () {
            if (containerRect.value && contentRect.value) {
              var sizeProperty = isHorizontal.value ? "width" : "height";
              containerSize.value = containerRect.value[sizeProperty];
              contentSize.value = contentRect.value[sizeProperty];
              isOverflowing.value = containerSize.value + 1 < contentSize.value;
            }
            if (firstSelectedIndex.value >= 0 && contentRef.el) {
              var selectedElement = contentRef.el.children[lastSelectedIndex.value];
              scrollToChildren(selectedElement, props.centerActive);
            }
          });
        });
      }
      var isFocused = shallowRef(false);
      function scrollToChildren(children, center) {
        var target = 0;
        if (center) {
          target = calculateCenteredTarget({
            containerElement: containerRef.el,
            isHorizontal: isHorizontal.value,
            selectedElement: children
          });
        } else {
          target = calculateUpdatedTarget({
            containerElement: containerRef.el,
            isHorizontal: isHorizontal.value,
            isRtl: isRtl.value,
            selectedElement: children
          });
        }
        scrollToPosition2(target);
      }
      function scrollToPosition2(newPosition) {
        if (!IN_BROWSER || !containerRef.el) return;
        var offsetSize = getOffsetSize(isHorizontal.value, containerRef.el);
        var scrollPosition = getScrollPosition(isHorizontal.value, isRtl.value, containerRef.el);
        var scrollSize = getScrollSize(isHorizontal.value, containerRef.el);
        if (scrollSize <= offsetSize || Math.abs(newPosition - scrollPosition) < 16) return;
        if (isHorizontal.value && isRtl.value && containerRef.el) {
          var _containerRef$el = containerRef.el,
            scrollWidth = _containerRef$el.scrollWidth,
            containerWidth = _containerRef$el.offsetWidth;
          newPosition = scrollWidth - containerWidth - newPosition;
        }
        if (isHorizontal.value) {
          goTo.horizontal(newPosition, goToOptions.value);
        } else {
          goTo(newPosition, goToOptions.value);
        }
      }
      function onScroll(e) {
        var _e$target = e.target,
          scrollTop = _e$target.scrollTop,
          scrollLeft = _e$target.scrollLeft;
        scrollOffset.value = isHorizontal.value ? scrollLeft : scrollTop;
      }
      function onFocusin(e) {
        isFocused.value = true;
        if (!isOverflowing.value || !contentRef.el) return;
        for (var _iterator44 = _createForOfIteratorHelperLoose(e.composedPath()), _step46; !(_step46 = _iterator44()).done;) {
          var el = _step46.value;
          for (var _iterator45 = _createForOfIteratorHelperLoose(contentRef.el.children), _step47; !(_step47 = _iterator45()).done;) {
            var item = _step47.value;
            if (item === el) {
              scrollToChildren(item);
              return;
            }
          }
        }
      }
      function onFocusout(e) {
        isFocused.value = false;
      }
      var ignoreFocusEvent = false;
      function onFocus(e) {
        var _a2;
        if (!ignoreFocusEvent && !isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.el) == null ? void 0 : _a2.contains(e.relatedTarget)))) focus2();
        ignoreFocusEvent = false;
      }
      function onFocusAffixes() {
        ignoreFocusEvent = true;
      }
      function onKeydown(e) {
        if (!contentRef.el) return;
        function toFocus(location2) {
          e.preventDefault();
          focus2(location2);
        }
        if (isHorizontal.value) {
          if (e.key === "ArrowRight") {
            toFocus(isRtl.value ? "prev" : "next");
          } else if (e.key === "ArrowLeft") {
            toFocus(isRtl.value ? "next" : "prev");
          }
        } else {
          if (e.key === "ArrowDown") {
            toFocus("next");
          } else if (e.key === "ArrowUp") {
            toFocus("prev");
          }
        }
        if (e.key === "Home") {
          toFocus("first");
        } else if (e.key === "End") {
          toFocus("last");
        }
      }
      function focus2(location2) {
        var _a2, _b;
        if (!contentRef.el) return;
        var el;
        if (!location2) {
          var focusable = focusableChildren(contentRef.el);
          el = focusable[0];
        } else if (location2 === "next") {
          el = (_a2 = contentRef.el.querySelector(":focus")) == null ? void 0 : _a2.nextElementSibling;
          if (!el) return focus2("first");
        } else if (location2 === "prev") {
          el = (_b = contentRef.el.querySelector(":focus")) == null ? void 0 : _b.previousElementSibling;
          if (!el) return focus2("last");
        } else if (location2 === "first") {
          el = contentRef.el.firstElementChild;
        } else if (location2 === "last") {
          el = contentRef.el.lastElementChild;
        }
        if (el) {
          el.focus({
            preventScroll: true
          });
        }
      }
      function scrollTo2(location2) {
        var direction = isHorizontal.value && isRtl.value ? -1 : 1;
        var offsetStep = (location2 === "prev" ? -direction : direction) * containerSize.value;
        var newPosition = scrollOffset.value + offsetStep;
        if (isHorizontal.value && isRtl.value && containerRef.el) {
          var _containerRef$el2 = containerRef.el,
            scrollWidth = _containerRef$el2.scrollWidth,
            containerWidth = _containerRef$el2.offsetWidth;
          newPosition += scrollWidth - containerWidth;
        }
        scrollToPosition2(newPosition);
      }
      var slotProps = computed(function () {
        return {
          next: group.next,
          prev: group.prev,
          select: group.select,
          isSelected: group.isSelected
        };
      });
      var hasAffixes = computed(function () {
        switch (props.showArrows) {
          case "always":
            return true;
          case "desktop":
            return !mobile.value;
          case true:
            return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
          case "mobile":
            return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
          default:
            return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
        }
      });
      var hasPrev = computed(function () {
        return Math.abs(scrollOffset.value) > 1;
      });
      var hasNext = computed(function () {
        if (!containerRef.value) return false;
        var scrollSize = getScrollSize(isHorizontal.value, containerRef.el);
        var clientSize = getClientSize(isHorizontal.value, containerRef.el);
        var scrollSizeMax = scrollSize - clientSize;
        return scrollSizeMax - Math.abs(scrollOffset.value) > 1;
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-slide-group", {
            "v-slide-group--vertical": !isHorizontal.value,
            "v-slide-group--has-affixes": hasAffixes.value,
            "v-slide-group--is-overflowing": isOverflowing.value
          }, displayClasses.value, props.class],
          "style": props.style,
          "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
          "onFocus": onFocus
        }, {
          "default": function () {
            var _a2, _b, _c, _d, _e;
            return [hasAffixes.value && createVNode("div", {
              "key": "prev",
              "class": ["v-slide-group__prev", {
                "v-slide-group__prev--disabled": !hasPrev.value
              }],
              "onMousedown": onFocusAffixes,
              "onClick": function () {
                return hasPrev.value && scrollTo2("prev");
              }
            }, [(_b = (_a2 = slots.prev) == null ? void 0 : _a2.call(slots, slotProps.value)) != null ? _b : createVNode(VFadeTransition, null, {
              "default": function () {
                return [createVNode(VIcon, {
                  "icon": isRtl.value ? props.nextIcon : props.prevIcon
                }, null)];
              }
            })]), createVNode("div", {
              "key": "container",
              "ref": containerRef,
              "class": "v-slide-group__container",
              "onScroll": onScroll
            }, [createVNode("div", {
              "ref": contentRef,
              "class": "v-slide-group__content",
              "onFocusin": onFocusin,
              "onFocusout": onFocusout,
              "onKeydown": onKeydown
            }, [(_c = slots.default) == null ? void 0 : _c.call(slots, slotProps.value)])]), hasAffixes.value && createVNode("div", {
              "key": "next",
              "class": ["v-slide-group__next", {
                "v-slide-group__next--disabled": !hasNext.value
              }],
              "onMousedown": onFocusAffixes,
              "onClick": function () {
                return hasNext.value && scrollTo2("next");
              }
            }, [(_e = (_d = slots.next) == null ? void 0 : _d.call(slots, slotProps.value)) != null ? _e : createVNode(VFadeTransition, null, {
              "default": function () {
                return [createVNode(VIcon, {
                  "icon": isRtl.value ? props.prevIcon : props.nextIcon
                }, null)];
              }
            })])];
          }
        });
      });
      return {
        selected: group.selected,
        scrollTo: scrollTo2,
        scrollOffset: scrollOffset,
        focus: focus2,
        hasPrev: hasPrev,
        hasNext: hasNext
      };
    }
  });
  var VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
  var makeVChipGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      "default": deepEqual
    }
  }, makeVSlideGroupProps()), makeComponentProps()), makeGroupProps({
    selectedClass: "v-chip--selected"
  })), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "tonal"
  })), "VChipGroup");
  var VChipGroup = genericComponent()({
    name: "VChipGroup",
    props: makeVChipGroupProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme10 = provideTheme(props),
        themeClasses = _provideTheme10.themeClasses;
      var _useGroup2 = useGroup(props, VChipGroupSymbol),
        isSelected = _useGroup2.isSelected,
        select = _useGroup2.select,
        next = _useGroup2.next,
        prev = _useGroup2.prev,
        selected = _useGroup2.selected;
      provideDefaults({
        VChip: {
          color: toRef(props, "color"),
          disabled: toRef(props, "disabled"),
          filter: toRef(props, "filter"),
          variant: toRef(props, "variant")
        }
      });
      useRender(function () {
        var slideGroupProps = VSlideGroup.filterProps(props);
        return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
          "class": ["v-chip-group", {
            "v-chip-group--column": props.column
          }, themeClasses.value, props.class],
          "style": props.style
        }), {
          "default": function () {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected: isSelected,
              select: select,
              next: next,
              prev: prev,
              selected: selected.value
            })];
          }
        });
      });
      return {};
    }
  });
  var makeVChipProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    activeClass: String,
    appendAvatar: String,
    appendIcon: IconValue,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      "default": "$delete"
    },
    closeLabel: {
      type: String,
      "default": "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      "default": "$complete"
    },
    label: Boolean,
    link: {
      type: Boolean,
      "default": void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    text: String,
    modelValue: {
      type: Boolean,
      "default": true
    },
    onClick: EventProp(),
    onClickOnce: EventProp()
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeGroupItemProps()), makeRoundedProps()), makeRouterProps()), makeSizeProps()), makeTagProps({
    tag: "span"
  })), makeThemeProps()), makeVariantProps({
    variant: "tonal"
  })), "VChip");
  var VChip = genericComponent()({
    name: "VChip",
    directives: {
      Ripple: Ripple
    },
    props: makeVChipProps(),
    emits: {
      "click:close": function (e) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      "group:selected": function (val) {
        return true;
      },
      click: function (e) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var _useLocale3 = useLocale(),
        t = _useLocale3.t;
      var _useBorder5 = useBorder(props),
        borderClasses = _useBorder5.borderClasses;
      var _useVariant4 = useVariant(props),
        colorClasses = _useVariant4.colorClasses,
        colorStyles = _useVariant4.colorStyles,
        variantClasses = _useVariant4.variantClasses;
      var _useDensity7 = useDensity(props),
        densityClasses = _useDensity7.densityClasses;
      var _useElevation5 = useElevation(props),
        elevationClasses = _useElevation5.elevationClasses;
      var _useRounded8 = useRounded(props),
        roundedClasses = _useRounded8.roundedClasses;
      var _useSize5 = useSize(props),
        sizeClasses = _useSize5.sizeClasses;
      var _provideTheme11 = provideTheme(props),
        themeClasses = _provideTheme11.themeClasses;
      var isActive2 = useProxiedModel(props, "modelValue");
      var group = useGroupItem(props, VChipGroupSymbol, false);
      var link = useLink(props, attrs);
      var isLink = computed(function () {
        return props.link !== false && link.isLink.value;
      });
      var isClickable = computed(function () {
        return !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value);
      });
      var closeProps = computed(function () {
        return {
          "aria-label": t(props.closeLabel),
          onClick: function (e) {
            e.preventDefault();
            e.stopPropagation();
            isActive2.value = false;
            emit2("click:close", e);
          }
        };
      });
      function onClick(e) {
        var _a2;
        emit2("click", e);
        if (!isClickable.value) return;
        (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
        group == null ? void 0 : group.toggle();
      }
      function onKeyDown(e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick(e);
        }
      }
      return function () {
        var Tag = link.isLink.value ? "a" : props.tag;
        var hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
        var hasAppend = !!(hasAppendMedia || slots.append);
        var hasClose = !!(slots.close || props.closable);
        var hasFilter = !!(slots.filter || props.filter) && group;
        var hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
        var hasPrepend = !!(hasPrependMedia || slots.prepend);
        var hasColor = !group || group.isSelected.value;
        return isActive2.value && withDirectives(createVNode(Tag, mergeProps({
          "class": ["v-chip", {
            "v-chip--disabled": props.disabled,
            "v-chip--label": props.label,
            "v-chip--link": isClickable.value,
            "v-chip--filter": hasFilter,
            "v-chip--pill": props.pill
          }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value, props.class],
          "style": [hasColor ? colorStyles.value : void 0, props.style],
          "disabled": props.disabled || void 0,
          "draggable": props.draggable,
          "tabindex": isClickable.value ? 0 : void 0,
          "onClick": onClick,
          "onKeydown": isClickable.value && !isLink.value && onKeyDown
        }, link.linkProps), {
          "default": function () {
            var _a2, _b;
            return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
              "key": "filter"
            }, {
              "default": function () {
                return [withDirectives(createVNode("div", {
                  "class": "v-chip__filter"
                }, [!slots.filter ? createVNode(VIcon, {
                  "key": "filter-icon",
                  "icon": props.filterIcon
                }, null) : createVNode(VDefaultsProvider, {
                  "key": "filter-defaults",
                  "disabled": !props.filterIcon,
                  "defaults": {
                    VIcon: {
                      icon: props.filterIcon
                    }
                  }
                }, slots.filter)]), [[vShow, group.isSelected.value]])];
              }
            }), hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-chip__prepend"
            }, [!slots.prepend ? createVNode(Fragment$1, null, [props.prependIcon && createVNode(VIcon, {
              "key": "prepend-icon",
              "icon": props.prependIcon,
              "start": true
            }, null), props.prependAvatar && createVNode(VAvatar, {
              "key": "prepend-avatar",
              "image": props.prependAvatar,
              "start": true
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  image: props.prependAvatar,
                  start: true
                },
                VIcon: {
                  icon: props.prependIcon,
                  start: true
                }
              }
            }, slots.prepend)]), createVNode("div", {
              "class": "v-chip__content",
              "data-no-activator": ""
            }, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected: group == null ? void 0 : group.isSelected.value,
              selectedClass: group == null ? void 0 : group.selectedClass.value,
              select: group == null ? void 0 : group.select,
              toggle: group == null ? void 0 : group.toggle,
              value: group == null ? void 0 : group.value.value,
              disabled: props.disabled
            })) != null ? _b : props.text]), hasAppend && createVNode("div", {
              "key": "append",
              "class": "v-chip__append"
            }, [!slots.append ? createVNode(Fragment$1, null, [props.appendIcon && createVNode(VIcon, {
              "key": "append-icon",
              "end": true,
              "icon": props.appendIcon
            }, null), props.appendAvatar && createVNode(VAvatar, {
              "key": "append-avatar",
              "end": true,
              "image": props.appendAvatar
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !hasAppendMedia,
              "defaults": {
                VAvatar: {
                  end: true,
                  image: props.appendAvatar
                },
                VIcon: {
                  end: true,
                  icon: props.appendIcon
                }
              }
            }, slots.append)]), hasClose && createVNode("button", mergeProps({
              "key": "close",
              "class": "v-chip__close",
              "type": "button",
              "data-testid": "close-chip"
            }, closeProps.value), [!slots.close ? createVNode(VIcon, {
              "key": "close-icon",
              "icon": props.closeIcon,
              "size": "x-small"
            }, null) : createVNode(VDefaultsProvider, {
              "key": "close-defaults",
              "defaults": {
                VIcon: {
                  icon: props.closeIcon,
                  size: "x-small"
                }
              }
            }, slots.close)])];
          }
        }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
      };
    }
  });
  var VList$1 = "";
  var ListKey = Symbol.for("vuetify:list");
  function createList() {
    var parent = inject$1(ListKey, {
      hasPrepend: shallowRef(false),
      updateHasPrepend: function () {
        return null;
      }
    });
    var data = {
      hasPrepend: shallowRef(false),
      updateHasPrepend: function (value) {
        if (value) data.hasPrepend.value = value;
      }
    };
    provide(ListKey, data);
    return parent;
  }
  function useList() {
    return inject$1(ListKey, null);
  }
  var independentActiveStrategy = function (mandatory) {
    var strategy = {
      activate: function (_ref) {
        var id = _ref.id,
          value = _ref.value,
          activated = _ref.activated;
        id = toRaw(id);
        if (mandatory && !value && activated.size === 1 && activated.has(id)) return activated;
        if (value) {
          activated.add(id);
        } else {
          activated.delete(id);
        }
        return activated;
      },
      "in": function (v, children, parents) {
        var set = /* @__PURE__ */new Set();
        if (v != null) {
          for (var _iterator46 = _createForOfIteratorHelperLoose(wrapInArray(v)), _step48; !(_step48 = _iterator46()).done;) {
            var id = _step48.value;
            set = strategy.activate({
              id: id,
              value: true,
              activated: new Set(set),
              children: children,
              parents: parents
            });
          }
        }
        return set;
      },
      out: function (v) {
        return Array.from(v);
      }
    };
    return strategy;
  };
  var independentSingleActiveStrategy = function (mandatory) {
    var parentStrategy = independentActiveStrategy(mandatory);
    var strategy = {
      activate: function (_ref2) {
        var activated = _ref2.activated,
          id = _ref2.id,
          rest = _objectWithoutProperties(_ref2, _excluded5);
        id = toRaw(id);
        var singleSelected = activated.has(id) ? /* @__PURE__ */new Set([id]) : /* @__PURE__ */new Set();
        return parentStrategy.activate(_objectSpread(_objectSpread({}, rest), {}, {
          id: id,
          activated: singleSelected
        }));
      },
      "in": function (v, children, parents) {
        var set = /* @__PURE__ */new Set();
        if (v != null) {
          var arr = wrapInArray(v);
          if (arr.length) {
            set = parentStrategy.in(arr.slice(0, 1), children, parents);
          }
        }
        return set;
      },
      out: function (v, children, parents) {
        return parentStrategy.out(v, children, parents);
      }
    };
    return strategy;
  };
  var leafActiveStrategy = function (mandatory) {
    var parentStrategy = independentActiveStrategy(mandatory);
    var strategy = {
      activate: function (_ref3) {
        var id = _ref3.id,
          activated = _ref3.activated,
          children = _ref3.children,
          rest = _objectWithoutProperties(_ref3, _excluded6);
        id = toRaw(id);
        if (children.has(id)) return activated;
        return parentStrategy.activate(_objectSpread({
          id: id,
          activated: activated,
          children: children
        }, rest));
      },
      "in": parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var leafSingleActiveStrategy = function (mandatory) {
    var parentStrategy = independentSingleActiveStrategy(mandatory);
    var strategy = {
      activate: function (_ref4) {
        var id = _ref4.id,
          activated = _ref4.activated,
          children = _ref4.children,
          rest = _objectWithoutProperties(_ref4, _excluded7);
        id = toRaw(id);
        if (children.has(id)) return activated;
        return parentStrategy.activate(_objectSpread({
          id: id,
          activated: activated,
          children: children
        }, rest));
      },
      "in": parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var singleOpenStrategy = {
    open: function (_ref) {
      var id = _ref.id,
        value = _ref.value,
        opened = _ref.opened,
        parents = _ref.parents;
      if (value) {
        var newOpened = /* @__PURE__ */new Set();
        newOpened.add(id);
        var parent = parents.get(id);
        while (parent != null) {
          newOpened.add(parent);
          parent = parents.get(parent);
        }
        return newOpened;
      } else {
        opened.delete(id);
        return opened;
      }
    },
    select: function () {
      return null;
    }
  };
  var multipleOpenStrategy = {
    open: function (_ref2) {
      var id = _ref2.id,
        value = _ref2.value,
        opened = _ref2.opened,
        parents = _ref2.parents;
      if (value) {
        var parent = parents.get(id);
        opened.add(id);
        while (parent != null && parent !== id) {
          opened.add(parent);
          parent = parents.get(parent);
        }
        return opened;
      } else {
        opened.delete(id);
      }
      return opened;
    },
    select: function () {
      return null;
    }
  };
  var listOpenStrategy = {
    open: multipleOpenStrategy.open,
    select: function (_ref3) {
      var id = _ref3.id,
        value = _ref3.value,
        opened = _ref3.opened,
        parents = _ref3.parents;
      if (!value) return opened;
      var path = [];
      var parent = parents.get(id);
      while (parent != null) {
        path.push(parent);
        parent = parents.get(parent);
      }
      return new Set(path);
    }
  };
  var independentSelectStrategy = function (mandatory) {
    var strategy = {
      select: function (_ref) {
        var id = _ref.id,
          value = _ref.value,
          selected = _ref.selected;
        id = toRaw(id);
        if (mandatory && !value) {
          var on = Array.from(selected.entries()).reduce(function (arr, _ref2) {
            var _ref264 = _slicedToArray(_ref2, 2),
              key = _ref264[0],
              value2 = _ref264[1];
            if (value2 === "on") arr.push(key);
            return arr;
          }, []);
          if (on.length === 1 && on[0] === id) return selected;
        }
        selected.set(id, value ? "on" : "off");
        return selected;
      },
      "in": function (v, children, parents) {
        var map3 = /* @__PURE__ */new Map();
        for (var _iterator47 = _createForOfIteratorHelperLoose(v || []), _step49; !(_step49 = _iterator47()).done;) {
          var id = _step49.value;
          map3 = strategy.select({
            id: id,
            value: true,
            selected: new Map(map3),
            children: children,
            parents: parents
          });
        }
        return map3;
      },
      out: function (v) {
        var arr = [];
        for (var _iterator48 = _createForOfIteratorHelperLoose(v.entries()), _step50; !(_step50 = _iterator48()).done;) {
          var _ref265 = _step50.value;
          var _ref266 = _slicedToArray(_ref265, 2);
          var key = _ref266[0];
          var value = _ref266[1];
          if (value === "on") arr.push(key);
        }
        return arr;
      }
    };
    return strategy;
  };
  var independentSingleSelectStrategy = function (mandatory) {
    var parentStrategy = independentSelectStrategy(mandatory);
    var strategy = {
      select: function (_ref3) {
        var selected = _ref3.selected,
          id = _ref3.id,
          rest = _objectWithoutProperties(_ref3, _excluded8);
        id = toRaw(id);
        var singleSelected = selected.has(id) ? /* @__PURE__ */new Map([[id, selected.get(id)]]) : /* @__PURE__ */new Map();
        return parentStrategy.select(_objectSpread(_objectSpread({}, rest), {}, {
          id: id,
          selected: singleSelected
        }));
      },
      "in": function (v, children, parents) {
        var map3 = /* @__PURE__ */new Map();
        if (v == null ? void 0 : v.length) {
          map3 = parentStrategy.in(v.slice(0, 1), children, parents);
        }
        return map3;
      },
      out: function (v, children, parents) {
        return parentStrategy.out(v, children, parents);
      }
    };
    return strategy;
  };
  var leafSelectStrategy = function (mandatory) {
    var parentStrategy = independentSelectStrategy(mandatory);
    var strategy = {
      select: function (_ref4) {
        var id = _ref4.id,
          selected = _ref4.selected,
          children = _ref4.children,
          rest = _objectWithoutProperties(_ref4, _excluded9);
        id = toRaw(id);
        if (children.has(id)) return selected;
        return parentStrategy.select(_objectSpread({
          id: id,
          selected: selected,
          children: children
        }, rest));
      },
      "in": parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var leafSingleSelectStrategy = function (mandatory) {
    var parentStrategy = independentSingleSelectStrategy(mandatory);
    var strategy = {
      select: function (_ref5) {
        var id = _ref5.id,
          selected = _ref5.selected,
          children = _ref5.children,
          rest = _objectWithoutProperties(_ref5, _excluded10);
        id = toRaw(id);
        if (children.has(id)) return selected;
        return parentStrategy.select(_objectSpread({
          id: id,
          selected: selected,
          children: children
        }, rest));
      },
      "in": parentStrategy.in,
      out: parentStrategy.out
    };
    return strategy;
  };
  var classicSelectStrategy = function (mandatory) {
    var strategy = {
      select: function (_ref6) {
        var id = _ref6.id,
          value = _ref6.value,
          selected = _ref6.selected,
          children = _ref6.children,
          parents = _ref6.parents;
        id = toRaw(id);
        var original = new Map(selected);
        var items = [id];
        while (items.length) {
          var item = items.shift();
          selected.set(toRaw(item), value ? "on" : "off");
          if (children.has(item)) {
            items.push.apply(items, _toConsumableArray(children.get(item)));
          }
        }
        var parent = toRaw(parents.get(id));
        while (parent) {
          var childrenIds = children.get(parent);
          var everySelected = childrenIds.every(function (cid) {
            return selected.get(toRaw(cid)) === "on";
          });
          var noneSelected = childrenIds.every(function (cid) {
            return !selected.has(toRaw(cid)) || selected.get(toRaw(cid)) === "off";
          });
          selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
          parent = toRaw(parents.get(parent));
        }
        if (mandatory && !value) {
          var on = Array.from(selected.entries()).reduce(function (arr, _ref7) {
            var _ref267 = _slicedToArray(_ref7, 2),
              key = _ref267[0],
              value2 = _ref267[1];
            if (value2 === "on") arr.push(key);
            return arr;
          }, []);
          if (on.length === 0) return original;
        }
        return selected;
      },
      "in": function (v, children, parents) {
        var map3 = /* @__PURE__ */new Map();
        for (var _iterator49 = _createForOfIteratorHelperLoose(v || []), _step51; !(_step51 = _iterator49()).done;) {
          var id = _step51.value;
          map3 = strategy.select({
            id: id,
            value: true,
            selected: new Map(map3),
            children: children,
            parents: parents
          });
        }
        return map3;
      },
      out: function (v, children) {
        var arr = [];
        for (var _iterator50 = _createForOfIteratorHelperLoose(v.entries()), _step52; !(_step52 = _iterator50()).done;) {
          var _ref268 = _step52.value;
          var _ref269 = _slicedToArray(_ref268, 2);
          var key = _ref269[0];
          var value = _ref269[1];
          if (value === "on" && !children.has(key)) arr.push(key);
        }
        return arr;
      }
    };
    return strategy;
  };
  var VNestedSymbol = Symbol.for("vuetify:nested");
  var emptyNested = {
    id: shallowRef(),
    root: {
      register: function () {
        return null;
      },
      unregister: function () {
        return null;
      },
      parents: ref( /* @__PURE__ */new Map()),
      children: ref( /* @__PURE__ */new Map()),
      open: function () {
        return null;
      },
      openOnSelect: function () {
        return null;
      },
      activate: function () {
        return null;
      },
      select: function () {
        return null;
      },
      activatable: ref(false),
      selectable: ref(false),
      opened: ref( /* @__PURE__ */new Set()),
      activated: ref( /* @__PURE__ */new Set()),
      selected: ref( /* @__PURE__ */new Map()),
      selectedValues: ref([]),
      getPath: function () {
        return [];
      }
    }
  };
  var makeNestedProps = propsFactory({
    activatable: Boolean,
    selectable: Boolean,
    activeStrategy: [String, Function, Object],
    selectStrategy: [String, Function, Object],
    openStrategy: [String, Object],
    opened: null,
    activated: null,
    selected: null,
    mandatory: Boolean
  }, "nested");
  var useNested = function (props) {
    var isUnmounted = false;
    var children = ref( /* @__PURE__ */new Map());
    var parents = ref( /* @__PURE__ */new Map());
    var opened = useProxiedModel(props, "opened", props.opened, function (v) {
      return new Set(v);
    }, function (v) {
      return _toConsumableArray(v.values());
    });
    var activeStrategy = computed(function () {
      if (_typeof(props.activeStrategy) === "object") return props.activeStrategy;
      if (typeof props.activeStrategy === "function") return props.activeStrategy(props.mandatory);
      switch (props.activeStrategy) {
        case "leaf":
          return leafActiveStrategy(props.mandatory);
        case "single-leaf":
          return leafSingleActiveStrategy(props.mandatory);
        case "independent":
          return independentActiveStrategy(props.mandatory);
        case "single-independent":
        default:
          return independentSingleActiveStrategy(props.mandatory);
      }
    });
    var selectStrategy = computed(function () {
      if (_typeof(props.selectStrategy) === "object") return props.selectStrategy;
      if (typeof props.selectStrategy === "function") return props.selectStrategy(props.mandatory);
      switch (props.selectStrategy) {
        case "single-leaf":
          return leafSingleSelectStrategy(props.mandatory);
        case "leaf":
          return leafSelectStrategy(props.mandatory);
        case "independent":
          return independentSelectStrategy(props.mandatory);
        case "single-independent":
          return independentSingleSelectStrategy(props.mandatory);
        case "classic":
        default:
          return classicSelectStrategy(props.mandatory);
      }
    });
    var openStrategy = computed(function () {
      if (_typeof(props.openStrategy) === "object") return props.openStrategy;
      switch (props.openStrategy) {
        case "list":
          return listOpenStrategy;
        case "single":
          return singleOpenStrategy;
        case "multiple":
        default:
          return multipleOpenStrategy;
      }
    });
    var activated = useProxiedModel(props, "activated", props.activated, function (v) {
      return activeStrategy.value.in(v, children.value, parents.value);
    }, function (v) {
      return activeStrategy.value.out(v, children.value, parents.value);
    });
    var selected = useProxiedModel(props, "selected", props.selected, function (v) {
      return selectStrategy.value.in(v, children.value, parents.value);
    }, function (v) {
      return selectStrategy.value.out(v, children.value, parents.value);
    });
    onBeforeUnmount(function () {
      isUnmounted = true;
    });
    function getPath(id) {
      var path = [];
      var parent = id;
      while (parent != null) {
        path.unshift(parent);
        parent = parents.value.get(parent);
      }
      return path;
    }
    var vm = getCurrentInstance("nested");
    var nodeIds = /* @__PURE__ */new Set();
    var nested = {
      id: shallowRef(),
      root: {
        opened: opened,
        activatable: toRef(props, "activatable"),
        selectable: toRef(props, "selectable"),
        activated: activated,
        selected: selected,
        selectedValues: computed(function () {
          var arr = [];
          for (var _iterator51 = _createForOfIteratorHelperLoose(selected.value.entries()), _step53; !(_step53 = _iterator51()).done;) {
            var _ref270 = _step53.value;
            var _ref271 = _slicedToArray(_ref270, 2);
            var key = _ref271[0];
            var value = _ref271[1];
            if (value === "on") arr.push(key);
          }
          return arr;
        }),
        register: function (id, parentId, isGroup) {
          if (nodeIds.has(id)) {
            var path = getPath(id).map(String).join(" -> ");
            var newPath = getPath(parentId).concat(id).map(String).join(" -> ");
            consoleError("Multiple nodes with the same ID\n\t" + path + "\n\t" + newPath);
            return;
          } else {
            nodeIds.add(id);
          }
          parentId && id !== parentId && parents.value.set(id, parentId);
          isGroup && children.value.set(id, []);
          if (parentId != null) {
            children.value.set(parentId, [].concat(_toConsumableArray(children.value.get(parentId) || []), [id]));
          }
        },
        unregister: function (id) {
          var _a2;
          if (isUnmounted) return;
          nodeIds.delete(id);
          children.value.delete(id);
          var parent = parents.value.get(id);
          if (parent) {
            var list = (_a2 = children.value.get(parent)) != null ? _a2 : [];
            children.value.set(parent, list.filter(function (child) {
              return child !== id;
            }));
          }
          parents.value.delete(id);
        },
        open: function (id, value, event) {
          vm.emit("click:open", {
            id: id,
            value: value,
            path: getPath(id),
            event: event
          });
          var newOpened = openStrategy.value.open({
            id: id,
            value: value,
            opened: new Set(opened.value),
            children: children.value,
            parents: parents.value,
            event: event
          });
          newOpened && (opened.value = newOpened);
        },
        openOnSelect: function (id, value, event) {
          var newOpened = openStrategy.value.select({
            id: id,
            value: value,
            selected: new Map(selected.value),
            opened: new Set(opened.value),
            children: children.value,
            parents: parents.value,
            event: event
          });
          newOpened && (opened.value = newOpened);
        },
        select: function (id, value, event) {
          vm.emit("click:select", {
            id: id,
            value: value,
            path: getPath(id),
            event: event
          });
          var newSelected = selectStrategy.value.select({
            id: id,
            value: value,
            selected: new Map(selected.value),
            children: children.value,
            parents: parents.value,
            event: event
          });
          newSelected && (selected.value = newSelected);
          nested.root.openOnSelect(id, value, event);
        },
        activate: function (id, value, event) {
          if (!props.activatable) {
            return nested.root.select(id, true, event);
          }
          vm.emit("click:activate", {
            id: id,
            value: value,
            path: getPath(id),
            event: event
          });
          var newActivated = activeStrategy.value.activate({
            id: id,
            value: value,
            activated: new Set(activated.value),
            children: children.value,
            parents: parents.value,
            event: event
          });
          newActivated && (activated.value = newActivated);
        },
        children: children,
        parents: parents,
        getPath: getPath
      }
    };
    provide(VNestedSymbol, nested);
    return nested.root;
  };
  var useNestedItem = function (id, isGroup) {
    var parent = inject$1(VNestedSymbol, emptyNested);
    var uidSymbol = Symbol(getUid());
    var computedId = computed(function () {
      return id.value !== void 0 ? id.value : uidSymbol;
    });
    var item = _objectSpread(_objectSpread({}, parent), {}, {
      id: computedId,
      open: function (open, e) {
        return parent.root.open(computedId.value, open, e);
      },
      openOnSelect: function (open, e) {
        return parent.root.openOnSelect(computedId.value, open, e);
      },
      isOpen: computed(function () {
        return parent.root.opened.value.has(computedId.value);
      }),
      parent: computed(function () {
        return parent.root.parents.value.get(computedId.value);
      }),
      activate: function (activated, e) {
        return parent.root.activate(computedId.value, activated, e);
      },
      isActivated: computed(function () {
        return parent.root.activated.value.has(toRaw(computedId.value));
      }),
      select: function (selected, e) {
        return parent.root.select(computedId.value, selected, e);
      },
      isSelected: computed(function () {
        return parent.root.selected.value.get(toRaw(computedId.value)) === "on";
      }),
      isIndeterminate: computed(function () {
        return parent.root.selected.value.get(computedId.value) === "indeterminate";
      }),
      isLeaf: computed(function () {
        return !parent.root.children.value.get(computedId.value);
      }),
      isGroupActivator: parent.isGroupActivator
    });
    !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
    onBeforeUnmount(function () {
      !parent.isGroupActivator && parent.root.unregister(computedId.value);
    });
    isGroup && provide(VNestedSymbol, item);
    return item;
  };
  var useNestedGroupActivator = function () {
    var parent = inject$1(VNestedSymbol, emptyNested);
    provide(VNestedSymbol, _objectSpread(_objectSpread({}, parent), {}, {
      isGroupActivator: true
    }));
  };
  var VListGroupActivator = defineComponent({
    name: "VListGroupActivator",
    setup: function (_, _ref) {
      var slots = _ref.slots;
      useNestedGroupActivator();
      return function () {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      };
    }
  });
  var makeVListGroupProps = propsFactory(_objectSpread(_objectSpread({
    activeColor: String,
    baseColor: String,
    color: String,
    collapseIcon: {
      type: IconValue,
      "default": "$collapse"
    },
    expandIcon: {
      type: IconValue,
      "default": "$expand"
    },
    prependIcon: IconValue,
    appendIcon: IconValue,
    fluid: Boolean,
    subgroup: Boolean,
    title: String,
    value: null
  }, makeComponentProps()), makeTagProps()), "VListGroup");
  var VListGroup = genericComponent()({
    name: "VListGroup",
    props: makeVListGroupProps(),
    setup: function (props, _ref2) {
      var slots = _ref2.slots;
      var _useNestedItem = useNestedItem(toRef(props, "value"), true),
        isOpen = _useNestedItem.isOpen,
        open = _useNestedItem.open,
        _id = _useNestedItem.id;
      var id = computed(function () {
        return "v-list-group--id-" + String(_id.value);
      });
      var list = useList();
      var _useSsrBoot2 = useSsrBoot(),
        isBooted = _useSsrBoot2.isBooted;
      function onClick(e) {
        e.stopPropagation();
        open(!isOpen.value, e);
      }
      var activatorProps = computed(function () {
        return {
          onClick: onClick,
          "class": "v-list-group__header",
          id: id.value
        };
      });
      var toggleIcon = computed(function () {
        return isOpen.value ? props.collapseIcon : props.expandIcon;
      });
      var activatorDefaults = computed(function () {
        return {
          VListItem: {
            active: isOpen.value,
            activeColor: props.activeColor,
            baseColor: props.baseColor,
            color: props.color,
            prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
            appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
            title: props.title,
            value: props.value
          }
        };
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-list-group", {
            "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value,
            "v-list-group--fluid": props.fluid,
            "v-list-group--subgroup": props.subgroup,
            "v-list-group--open": isOpen.value
          }, props.class],
          "style": props.style
        }, {
          "default": function () {
            return [slots.activator && createVNode(VDefaultsProvider, {
              "defaults": activatorDefaults.value
            }, {
              "default": function () {
                return [createVNode(VListGroupActivator, null, {
                  "default": function () {
                    return [slots.activator({
                      props: activatorProps.value,
                      isOpen: isOpen.value
                    })];
                  }
                })];
              }
            }), createVNode(MaybeTransition, {
              "transition": {
                component: VExpandTransition
              },
              "disabled": !isBooted.value
            }, {
              "default": function () {
                var _a2;
                return [withDirectives(createVNode("div", {
                  "class": "v-list-group__items",
                  "role": "group",
                  "aria-labelledby": id.value
                }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, isOpen.value]])];
              }
            })];
          }
        });
      });
      return {
        isOpen: isOpen
      };
    }
  });
  var VListItem$1 = "";
  var makeVListItemSubtitleProps = propsFactory(_objectSpread(_objectSpread({
    opacity: [Number, String]
  }, makeComponentProps()), makeTagProps()), "VListItemSubtitle");
  var VListItemSubtitle = genericComponent()({
    name: "VListItemSubtitle",
    props: makeVListItemSubtitleProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-list-item-subtitle", props.class],
          "style": [{
            "--v-list-item-subtitle-opacity": props.opacity
          }, props.style]
        }, slots);
      });
      return {};
    }
  });
  var VListItemTitle = createSimpleFunctional("v-list-item-title");
  var makeVListItemProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    active: {
      type: Boolean,
      "default": void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: IconValue,
    baseColor: String,
    disabled: Boolean,
    lines: [Boolean, String],
    link: {
      type: Boolean,
      "default": void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    slim: Boolean,
    subtitle: [String, Number],
    title: [String, Number],
    value: null,
    onClick: EventProp(),
    onClickOnce: EventProp()
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VListItem");
  var VListItem = genericComponent()({
    name: "VListItem",
    directives: {
      Ripple: Ripple
    },
    props: makeVListItemProps(),
    emits: {
      click: function (e) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots,
        emit2 = _ref.emit;
      var link = useLink(props, attrs);
      var id = computed(function () {
        return props.value === void 0 ? link.href.value : props.value;
      });
      var _useNestedItem2 = useNestedItem(id, false),
        activate = _useNestedItem2.activate,
        isActivated = _useNestedItem2.isActivated,
        select = _useNestedItem2.select,
        isOpen = _useNestedItem2.isOpen,
        isSelected = _useNestedItem2.isSelected,
        isIndeterminate = _useNestedItem2.isIndeterminate,
        isGroupActivator = _useNestedItem2.isGroupActivator,
        root = _useNestedItem2.root,
        parent = _useNestedItem2.parent,
        openOnSelect = _useNestedItem2.openOnSelect,
        uid2 = _useNestedItem2.id;
      var list = useList();
      var isActive2 = computed(function () {
        var _a2;
        return props.active !== false && (props.active || ((_a2 = link.isActive) == null ? void 0 : _a2.value) || (root.activatable.value ? isActivated.value : isSelected.value));
      });
      var isLink = computed(function () {
        return props.link !== false && link.isLink.value;
      });
      var isClickable = computed(function () {
        return !props.disabled && props.link !== false && (props.link || link.isClickable.value || !!list && (root.selectable.value || root.activatable.value || props.value != null));
      });
      var roundedProps = computed(function () {
        return props.rounded || props.nav;
      });
      var color = computed(function () {
        var _a2;
        return (_a2 = props.color) != null ? _a2 : props.activeColor;
      });
      var variantProps = computed(function () {
        var _a2;
        return {
          color: isActive2.value ? (_a2 = color.value) != null ? _a2 : props.baseColor : props.baseColor,
          variant: props.variant
        };
      });
      watch(function () {
        var _a2;
        return (_a2 = link.isActive) == null ? void 0 : _a2.value;
      }, function (val) {
        if (val && parent.value != null) {
          root.open(parent.value, true);
        }
        if (val) {
          openOnSelect(val);
        }
      }, {
        immediate: true
      });
      var _provideTheme12 = provideTheme(props),
        themeClasses = _provideTheme12.themeClasses;
      var _useBorder6 = useBorder(props),
        borderClasses = _useBorder6.borderClasses;
      var _useVariant5 = useVariant(variantProps),
        colorClasses = _useVariant5.colorClasses,
        colorStyles = _useVariant5.colorStyles,
        variantClasses = _useVariant5.variantClasses;
      var _useDensity8 = useDensity(props),
        densityClasses = _useDensity8.densityClasses;
      var _useDimension5 = useDimension(props),
        dimensionStyles = _useDimension5.dimensionStyles;
      var _useElevation6 = useElevation(props),
        elevationClasses = _useElevation6.elevationClasses;
      var _useRounded9 = useRounded(roundedProps),
        roundedClasses = _useRounded9.roundedClasses;
      var lineClasses = computed(function () {
        return props.lines ? "v-list-item--" + props.lines + "-line" : void 0;
      });
      var slotProps = computed(function () {
        return {
          isActive: isActive2.value,
          select: select,
          isOpen: isOpen.value,
          isSelected: isSelected.value,
          isIndeterminate: isIndeterminate.value
        };
      });
      function onClick(e) {
        var _a2;
        emit2("click", e);
        if (!isClickable.value) return;
        (_a2 = link.navigate) == null ? void 0 : _a2.call(link, e);
        if (isGroupActivator) return;
        if (root.activatable.value) {
          activate(!isActivated.value, e);
        } else if (root.selectable.value) {
          select(!isSelected.value, e);
        } else if (props.value != null) {
          select(!isSelected.value, e);
        }
      }
      function onKeyDown(e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          e.target.dispatchEvent(new MouseEvent("click", e));
        }
      }
      useRender(function () {
        var _ref272;
        var Tag = isLink.value ? "a" : props.tag;
        var hasTitle = slots.title || props.title != null;
        var hasSubtitle = slots.subtitle || props.subtitle != null;
        var hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
        var hasAppend = !!(hasAppendMedia || slots.append);
        var hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
        var hasPrepend = !!(hasPrependMedia || slots.prepend);
        list == null ? void 0 : list.updateHasPrepend(hasPrepend);
        if (props.activeColor) {
          deprecate("active-color", ["color", "base-color"]);
        }
        return withDirectives(createVNode(Tag, mergeProps({
          "class": ["v-list-item", (_ref272 = {
            "v-list-item--active": isActive2.value,
            "v-list-item--disabled": props.disabled,
            "v-list-item--link": isClickable.value,
            "v-list-item--nav": props.nav,
            "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
            "v-list-item--slim": props.slim
          }, _ref272["" + props.activeClass] = props.activeClass && isActive2.value, _ref272), themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, props.style],
          "tabindex": isClickable.value ? list ? -2 : 0 : void 0,
          "aria-selected": root.activatable.value ? isActivated.value : isSelected.value,
          "onClick": onClick,
          "onKeydown": isClickable.value && !isLink.value && onKeyDown
        }, link.linkProps), {
          "default": function () {
            var _a2;
            return [genOverlays(isClickable.value || isActive2.value, "v-list-item"), hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-list-item__prepend"
            }, [!slots.prepend ? createVNode(Fragment$1, null, [props.prependAvatar && createVNode(VAvatar, {
              "key": "prepend-avatar",
              "density": props.density,
              "image": props.prependAvatar
            }, null), props.prependIcon && createVNode(VIcon, {
              "key": "prepend-icon",
              "density": props.density,
              "icon": props.prependIcon
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  density: props.density,
                  image: props.prependAvatar
                },
                VIcon: {
                  density: props.density,
                  icon: props.prependIcon
                },
                VListItemAction: {
                  start: true
                }
              }
            }, {
              "default": function () {
                var _a3;
                return [(_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, slotProps.value)];
              }
            }), createVNode("div", {
              "class": "v-list-item__spacer"
            }, null)]), createVNode("div", {
              "class": "v-list-item__content",
              "data-no-activator": ""
            }, [hasTitle && createVNode(VListItemTitle, {
              "key": "title"
            }, {
              "default": function () {
                var _a3, _b;
                return [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
                  title: props.title
                })) != null ? _b : props.title];
              }
            }), hasSubtitle && createVNode(VListItemSubtitle, {
              "key": "subtitle"
            }, {
              "default": function () {
                var _a3, _b;
                return [(_b = (_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots, {
                  subtitle: props.subtitle
                })) != null ? _b : props.subtitle];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
              "key": "append",
              "class": "v-list-item__append"
            }, [!slots.append ? createVNode(Fragment$1, null, [props.appendIcon && createVNode(VIcon, {
              "key": "append-icon",
              "density": props.density,
              "icon": props.appendIcon
            }, null), props.appendAvatar && createVNode(VAvatar, {
              "key": "append-avatar",
              "density": props.density,
              "image": props.appendAvatar
            }, null)]) : createVNode(VDefaultsProvider, {
              "key": "append-defaults",
              "disabled": !hasAppendMedia,
              "defaults": {
                VAvatar: {
                  density: props.density,
                  image: props.appendAvatar
                },
                VIcon: {
                  density: props.density,
                  icon: props.appendIcon
                },
                VListItemAction: {
                  end: true
                }
              }
            }, {
              "default": function () {
                var _a3;
                return [(_a3 = slots.append) == null ? void 0 : _a3.call(slots, slotProps.value)];
              }
            }), createVNode("div", {
              "class": "v-list-item__spacer"
            }, null)])];
          }
        }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
      });
      return {
        activate: activate,
        isActivated: isActivated,
        isGroupActivator: isGroupActivator,
        isSelected: isSelected,
        list: list,
        select: select,
        root: root,
        id: uid2
      };
    }
  });
  var makeVListSubheaderProps = propsFactory(_objectSpread(_objectSpread({
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String
  }, makeComponentProps()), makeTagProps()), "VListSubheader");
  var VListSubheader = genericComponent()({
    name: "VListSubheader",
    props: makeVListSubheaderProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useTextColor8 = useTextColor(toRef(props, "color")),
        textColorClasses = _useTextColor8.textColorClasses,
        textColorStyles = _useTextColor8.textColorStyles;
      useRender(function () {
        var hasText = !!(slots.default || props.title);
        return createVNode(props.tag, {
          "class": ["v-list-subheader", {
            "v-list-subheader--inset": props.inset,
            "v-list-subheader--sticky": props.sticky
          }, textColorClasses.value, props.class],
          "style": [{
            textColorStyles: textColorStyles
          }, props.style]
        }, {
          "default": function () {
            var _a2, _b;
            return [hasText && createVNode("div", {
              "class": "v-list-subheader__text"
            }, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.title])];
          }
        });
      });
      return {};
    }
  });
  var VDivider$1 = "";
  var makeVDividerProps = propsFactory(_objectSpread(_objectSpread({
    color: String,
    inset: Boolean,
    length: [Number, String],
    opacity: [Number, String],
    thickness: [Number, String],
    vertical: Boolean
  }, makeComponentProps()), makeThemeProps()), "VDivider");
  var VDivider = genericComponent()({
    name: "VDivider",
    props: makeVDividerProps(),
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _provideTheme13 = provideTheme(props),
        themeClasses = _provideTheme13.themeClasses;
      var _useTextColor9 = useTextColor(toRef(props, "color")),
        textColorClasses = _useTextColor9.textColorClasses,
        textColorStyles = _useTextColor9.textColorStyles;
      var dividerStyles = computed(function () {
        var styles = {};
        if (props.length) {
          styles[props.vertical ? "height" : "width"] = convertToUnit(props.length);
        }
        if (props.thickness) {
          styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
        }
        return styles;
      });
      useRender(function () {
        var divider = createVNode("hr", {
          "class": [{
            "v-divider": true,
            "v-divider--inset": props.inset,
            "v-divider--vertical": props.vertical
          }, themeClasses.value, textColorClasses.value, props.class],
          "style": [dividerStyles.value, textColorStyles.value, {
            "--v-border-opacity": props.opacity
          }, props.style],
          "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
          "role": "" + (attrs.role || "separator")
        }, null);
        if (!slots.default) return divider;
        return createVNode("div", {
          "class": ["v-divider__wrapper", {
            "v-divider__wrapper--vertical": props.vertical,
            "v-divider__wrapper--inset": props.inset
          }]
        }, [divider, createVNode("div", {
          "class": "v-divider__content"
        }, [slots.default()]), divider]);
      });
      return {};
    }
  });
  var makeVListChildrenProps = propsFactory({
    items: Array,
    returnObject: Boolean
  }, "VListChildren");
  var VListChildren = genericComponent()({
    name: "VListChildren",
    props: makeVListChildrenProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      createList();
      return function () {
        var _a2, _b, _c;
        return (_c = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _c : (_b = props.items) == null ? void 0 : _b.map(function (_ref2) {
          var _a3, _b2, _c2, _d;
          var children = _ref2.children,
            itemProps = _ref2.props,
            type = _ref2.type,
            item = _ref2.raw;
          if (type === "divider") {
            return (_b2 = (_a3 = slots.divider) == null ? void 0 : _a3.call(slots, {
              props: itemProps
            })) != null ? _b2 : createVNode(VDivider, itemProps, null);
          }
          if (type === "subheader") {
            return (_d = (_c2 = slots.subheader) == null ? void 0 : _c2.call(slots, {
              props: itemProps
            })) != null ? _d : createVNode(VListSubheader, itemProps, null);
          }
          var slotsWithItem = {
            subtitle: slots.subtitle ? function (slotProps) {
              var _a4;
              return (_a4 = slots.subtitle) == null ? void 0 : _a4.call(slots, _objectSpread(_objectSpread({}, slotProps), {}, {
                item: item
              }));
            } : void 0,
            prepend: slots.prepend ? function (slotProps) {
              var _a4;
              return (_a4 = slots.prepend) == null ? void 0 : _a4.call(slots, _objectSpread(_objectSpread({}, slotProps), {}, {
                item: item
              }));
            } : void 0,
            append: slots.append ? function (slotProps) {
              var _a4;
              return (_a4 = slots.append) == null ? void 0 : _a4.call(slots, _objectSpread(_objectSpread({}, slotProps), {}, {
                item: item
              }));
            } : void 0,
            title: slots.title ? function (slotProps) {
              var _a4;
              return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, _objectSpread(_objectSpread({}, slotProps), {}, {
                item: item
              }));
            } : void 0
          };
          var listGroupProps = VListGroup.filterProps(itemProps);
          return children ? createVNode(VListGroup, mergeProps({
            "value": itemProps == null ? void 0 : itemProps.value
          }, listGroupProps), {
            activator: function (_ref3) {
              var activatorProps = _ref3.props;
              var listItemProps = _objectSpread(_objectSpread(_objectSpread({}, itemProps), activatorProps), {}, {
                value: props.returnObject ? item : itemProps.value
              });
              return slots.header ? slots.header({
                props: listItemProps
              }) : createVNode(VListItem, listItemProps, slotsWithItem);
            },
            "default": function () {
              return createVNode(VListChildren, {
                "items": children,
                "returnObject": props.returnObject
              }, slots);
            }
          }) : slots.item ? slots.item({
            props: itemProps
          }) : createVNode(VListItem, mergeProps(itemProps, {
            "value": props.returnObject ? item : itemProps.value
          }), slotsWithItem);
        });
      };
    }
  });
  var makeItemsProps = propsFactory({
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    itemTitle: {
      type: [String, Array, Function],
      "default": "title"
    },
    itemValue: {
      type: [String, Array, Function],
      "default": "value"
    },
    itemChildren: {
      type: [Boolean, String, Array, Function],
      "default": "children"
    },
    itemProps: {
      type: [Boolean, String, Array, Function],
      "default": "props"
    },
    returnObject: Boolean,
    valueComparator: {
      type: Function,
      "default": deepEqual
    }
  }, "list-items");
  function transformItem$3(props, item) {
    var _a2;
    var title = getPropertyFromItem(item, props.itemTitle, item);
    var value = getPropertyFromItem(item, props.itemValue, title);
    var children = getPropertyFromItem(item, props.itemChildren);
    var itemProps = props.itemProps === true ? _typeof(item) === "object" && item != null && !Array.isArray(item) ? "children" in item ? omit(item, ["children"]) : item : void 0 : getPropertyFromItem(item, props.itemProps);
    var _props = _objectSpread({
      title: title,
      value: value
    }, itemProps);
    return {
      title: String((_a2 = _props.title) != null ? _a2 : ""),
      value: _props.value,
      props: _props,
      children: Array.isArray(children) ? transformItems$3(props, children) : void 0,
      raw: item
    };
  }
  function transformItems$3(props, items) {
    var array = [];
    for (var _iterator52 = _createForOfIteratorHelperLoose(items), _step54; !(_step54 = _iterator52()).done;) {
      var item = _step54.value;
      array.push(transformItem$3(props, item));
    }
    return array;
  }
  function useItems(props) {
    var items = computed(function () {
      return transformItems$3(props, props.items);
    });
    var hasNullItem = computed(function () {
      return items.value.some(function (item) {
        return item.value === null;
      });
    });
    function transformIn(value) {
      if (!hasNullItem.value) {
        value = value.filter(function (v) {
          return v !== null;
        });
      }
      return value.map(function (v) {
        if (props.returnObject && typeof v === "string") {
          return transformItem$3(props, v);
        }
        return items.value.find(function (item) {
          return props.valueComparator(v, item.value);
        }) || transformItem$3(props, v);
      });
    }
    function transformOut(value) {
      return props.returnObject ? value.map(function (_ref) {
        var raw = _ref.raw;
        return raw;
      }) : value.map(function (_ref2) {
        var value2 = _ref2.value;
        return value2;
      });
    }
    return {
      items: items,
      transformIn: transformIn,
      transformOut: transformOut
    };
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
  }
  function transformItem$2(props, item) {
    var type = getPropertyFromItem(item, props.itemType, "item");
    var title = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
    var value = getPropertyFromItem(item, props.itemValue, void 0);
    var children = getPropertyFromItem(item, props.itemChildren);
    var itemProps = props.itemProps === true ? omit(item, ["children"]) : getPropertyFromItem(item, props.itemProps);
    var _props = _objectSpread({
      title: title,
      value: value
    }, itemProps);
    return {
      type: type,
      title: _props.title,
      value: _props.value,
      props: _props,
      children: type === "item" && children ? transformItems$2(props, children) : void 0,
      raw: item
    };
  }
  function transformItems$2(props, items) {
    var array = [];
    for (var _iterator53 = _createForOfIteratorHelperLoose(items), _step55; !(_step55 = _iterator53()).done;) {
      var item = _step55.value;
      array.push(transformItem$2(props, item));
    }
    return array;
  }
  function useListItems(props) {
    var items = computed(function () {
      return transformItems$2(props, props.items);
    });
    return {
      items: items
    };
  }
  var makeVListProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    baseColor: String,
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    expandIcon: String,
    collapseIcon: String,
    lines: {
      type: [Boolean, String],
      "default": "one"
    },
    slim: Boolean,
    nav: Boolean,
    "onClick:open": EventProp(),
    "onClick:select": EventProp(),
    "onUpdate:opened": EventProp()
  }, makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  })), makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), {}, {
    itemType: {
      type: String,
      "default": "type"
    }
  }, makeItemsProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VList");
  var VList = genericComponent()({
    name: "VList",
    props: makeVListProps(),
    emits: {
      "update:selected": function (value) {
        return true;
      },
      "update:activated": function (value) {
        return true;
      },
      "update:opened": function (value) {
        return true;
      },
      "click:open": function (value) {
        return true;
      },
      "click:activate": function (value) {
        return true;
      },
      "click:select": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useListItems = useListItems(props),
        items = _useListItems.items;
      var _provideTheme14 = provideTheme(props),
        themeClasses = _provideTheme14.themeClasses;
      var _useBackgroundColor7 = useBackgroundColor(toRef(props, "bgColor")),
        backgroundColorClasses = _useBackgroundColor7.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor7.backgroundColorStyles;
      var _useBorder7 = useBorder(props),
        borderClasses = _useBorder7.borderClasses;
      var _useDensity9 = useDensity(props),
        densityClasses = _useDensity9.densityClasses;
      var _useDimension6 = useDimension(props),
        dimensionStyles = _useDimension6.dimensionStyles;
      var _useElevation7 = useElevation(props),
        elevationClasses = _useElevation7.elevationClasses;
      var _useRounded10 = useRounded(props),
        roundedClasses = _useRounded10.roundedClasses;
      var _useNested = useNested(props),
        children = _useNested.children,
        open = _useNested.open,
        parents = _useNested.parents,
        select = _useNested.select,
        getPath = _useNested.getPath;
      var lineClasses = computed(function () {
        return props.lines ? "v-list--" + props.lines + "-line" : void 0;
      });
      var activeColor = toRef(props, "activeColor");
      var baseColor = toRef(props, "baseColor");
      var color = toRef(props, "color");
      createList();
      provideDefaults({
        VListGroup: {
          activeColor: activeColor,
          baseColor: baseColor,
          color: color,
          expandIcon: toRef(props, "expandIcon"),
          collapseIcon: toRef(props, "collapseIcon")
        },
        VListItem: {
          activeClass: toRef(props, "activeClass"),
          activeColor: activeColor,
          baseColor: baseColor,
          color: color,
          density: toRef(props, "density"),
          disabled: toRef(props, "disabled"),
          lines: toRef(props, "lines"),
          nav: toRef(props, "nav"),
          slim: toRef(props, "slim"),
          variant: toRef(props, "variant")
        }
      });
      var isFocused = shallowRef(false);
      var contentRef = ref();
      function onFocusin(e) {
        isFocused.value = true;
      }
      function onFocusout(e) {
        isFocused.value = false;
      }
      function onFocus(e) {
        var _a2;
        if (!isFocused.value && !(e.relatedTarget && ((_a2 = contentRef.value) == null ? void 0 : _a2.contains(e.relatedTarget)))) focus2();
      }
      function onKeydown(e) {
        var target = e.target;
        if (!contentRef.value || ["INPUT", "TEXTAREA"].includes(target.tagName)) return;
        if (e.key === "ArrowDown") {
          focus2("next");
        } else if (e.key === "ArrowUp") {
          focus2("prev");
        } else if (e.key === "Home") {
          focus2("first");
        } else if (e.key === "End") {
          focus2("last");
        } else {
          return;
        }
        e.preventDefault();
      }
      function onMousedown(e) {
        isFocused.value = true;
      }
      function focus2(location2) {
        if (contentRef.value) {
          return focusChild(contentRef.value, location2);
        }
      }
      useRender(function () {
        return createVNode(props.tag, {
          "ref": contentRef,
          "class": ["v-list", {
            "v-list--disabled": props.disabled,
            "v-list--nav": props.nav,
            "v-list--slim": props.slim
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, props.style],
          "tabindex": props.disabled || isFocused.value ? -1 : 0,
          "role": "listbox",
          "aria-activedescendant": void 0,
          "onFocusin": onFocusin,
          "onFocusout": onFocusout,
          "onFocus": onFocus,
          "onKeydown": onKeydown,
          "onMousedown": onMousedown
        }, {
          "default": function () {
            return [createVNode(VListChildren, {
              "items": items.value,
              "returnObject": props.returnObject
            }, slots)];
          }
        });
      });
      return {
        open: open,
        select: select,
        focus: focus2,
        children: children,
        parents: parents,
        getPath: getPath
      };
    }
  });
  var VListImg = createSimpleFunctional("v-list-img");
  var makeVListItemActionProps = propsFactory(_objectSpread(_objectSpread({
    start: Boolean,
    end: Boolean
  }, makeComponentProps()), makeTagProps()), "VListItemAction");
  var VListItemAction = genericComponent()({
    name: "VListItemAction",
    props: makeVListItemActionProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-list-item-action", {
            "v-list-item-action--start": props.start,
            "v-list-item-action--end": props.end
          }, props.class],
          "style": props.style
        }, slots);
      });
      return {};
    }
  });
  var makeVListItemMediaProps = propsFactory(_objectSpread(_objectSpread({
    start: Boolean,
    end: Boolean
  }, makeComponentProps()), makeTagProps()), "VListItemMedia");
  var VListItemMedia = genericComponent()({
    name: "VListItemMedia",
    props: makeVListItemMediaProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-list-item-media", {
            "v-list-item-media--start": props.start,
            "v-list-item-media--end": props.end
          }, props.class],
          "style": props.style
        }, slots);
      });
      return {};
    }
  });
  var VMenu$1 = "";
  var VOverlay$1 = "";
  function elementToViewport(point, offset) {
    return {
      x: point.x + offset.x,
      y: point.y + offset.y
    };
  }
  function getOffset$1(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }
  function anchorToPoint(anchor, box) {
    if (anchor.side === "top" || anchor.side === "bottom") {
      var side = anchor.side,
        align = anchor.align;
      var x = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
      var y = side === "top" ? 0 : side === "bottom" ? box.height : side;
      return elementToViewport({
        x: x,
        y: y
      }, box);
    } else if (anchor.side === "left" || anchor.side === "right") {
      var _side = anchor.side,
        _align = anchor.align;
      var _x2 = _side === "left" ? 0 : _side === "right" ? box.width : _side;
      var _y2 = _align === "top" ? 0 : _align === "center" ? box.height / 2 : _align === "bottom" ? box.height : _align;
      return elementToViewport({
        x: _x2,
        y: _y2
      }, box);
    }
    return elementToViewport({
      x: box.width / 2,
      y: box.height / 2
    }, box);
  }
  var locationStrategies = {
    "static": staticLocationStrategy,
    connected: connectedLocationStrategy
  };
  var makeLocationStrategyProps = propsFactory({
    locationStrategy: {
      type: [String, Function],
      "default": "static",
      validator: function (val) {
        return typeof val === "function" || val in locationStrategies;
      }
    },
    location: {
      type: String,
      "default": "bottom"
    },
    origin: {
      type: String,
      "default": "auto"
    },
    offset: [Number, String, Array]
  }, "VOverlay-location-strategies");
  function useLocationStrategies(props, data) {
    var contentStyles = ref({});
    var updateLocation = ref();
    if (IN_BROWSER) {
      useToggleScope(function () {
        return !!(data.isActive.value && props.locationStrategy);
      }, function (reset) {
        var _a2, _b;
        watch(function () {
          return props.locationStrategy;
        }, reset);
        onScopeDispose(function () {
          window.removeEventListener("resize", onResize);
          updateLocation.value = void 0;
        });
        window.addEventListener("resize", onResize, {
          passive: true
        });
        if (typeof props.locationStrategy === "function") {
          updateLocation.value = (_a2 = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _a2.updateLocation;
        } else {
          updateLocation.value = (_b = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _b.updateLocation;
        }
      });
    }
    function onResize(e) {
      var _a2;
      (_a2 = updateLocation.value) == null ? void 0 : _a2.call(updateLocation, e);
    }
    return {
      contentStyles: contentStyles,
      updateLocation: updateLocation
    };
  }
  function staticLocationStrategy() {}
  function getIntrinsicSize(el, isRtl) {
    var contentBox = nullifyTransforms(el);
    if (isRtl) {
      contentBox.x += parseFloat(el.style.right || 0);
    } else {
      contentBox.x -= parseFloat(el.style.left || 0);
    }
    contentBox.y -= parseFloat(el.style.top || 0);
    return contentBox;
  }
  function connectedLocationStrategy(data, props, contentStyles) {
    var activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);
    if (activatorFixed) {
      var _Object$assign;
      Object.assign(contentStyles.value, (_Object$assign = {
        position: "fixed",
        top: 0
      }, _Object$assign[data.isRtl.value ? "right" : "left"] = 0, _Object$assign));
    }
    var _destructComputed = destructComputed(function () {
        var parsedAnchor = parseAnchor(props.location, data.isRtl.value);
        var parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);
        if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
          return {
            preferredAnchor: flipCorner(parsedAnchor),
            preferredOrigin: flipCorner(parsedOrigin)
          };
        } else {
          return {
            preferredAnchor: parsedAnchor,
            preferredOrigin: parsedOrigin
          };
        }
      }),
      preferredAnchor = _destructComputed.preferredAnchor,
      preferredOrigin = _destructComputed.preferredOrigin;
    var _map2 = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map(function (key) {
        return computed(function () {
          var val = parseFloat(props[key]);
          return isNaN(val) ? Infinity : val;
        });
      }),
      _map3 = _slicedToArray(_map2, 4),
      minWidth = _map3[0],
      minHeight = _map3[1],
      maxWidth = _map3[2],
      maxHeight = _map3[3];
    var offset = computed(function () {
      if (Array.isArray(props.offset)) {
        return props.offset;
      }
      if (typeof props.offset === "string") {
        var offset2 = props.offset.split(" ").map(parseFloat);
        if (offset2.length < 2) offset2.push(0);
        return offset2;
      }
      return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
    });
    var observe = false;
    var observer = new ResizeObserver(function () {
      if (observe) updateLocation();
    });
    watch([data.target, data.contentEl], function (_ref, _ref2) {
      var _ref273 = _slicedToArray(_ref, 2),
        newTarget = _ref273[0],
        newContentEl = _ref273[1];
      var _ref274 = _slicedToArray(_ref2, 2),
        oldTarget = _ref274[0],
        oldContentEl = _ref274[1];
      if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget);
      if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget);
      if (oldContentEl) observer.unobserve(oldContentEl);
      if (newContentEl) observer.observe(newContentEl);
    }, {
      immediate: true
    });
    onScopeDispose(function () {
      observer.disconnect();
    });
    function updateLocation() {
      observe = false;
      requestAnimationFrame(function () {
        return observe = true;
      });
      if (!data.target.value || !data.contentEl.value) return;
      var targetBox = getTargetBox(data.target.value);
      var contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
      var scrollParents = getScrollParents(data.contentEl.value);
      var viewportMargin = 12;
      if (!scrollParents.length) {
        scrollParents.push(document.documentElement);
        if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
          contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
          contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
        }
      }
      var viewport = scrollParents.reduce(function (box, el) {
        var rect = el.getBoundingClientRect();
        var scrollBox = new Box({
          x: el === document.documentElement ? 0 : rect.x,
          y: el === document.documentElement ? 0 : rect.y,
          width: el.clientWidth,
          height: el.clientHeight
        });
        if (box) {
          return new Box({
            x: Math.max(box.left, scrollBox.left),
            y: Math.max(box.top, scrollBox.top),
            width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
            height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
          });
        }
        return scrollBox;
      }, void 0);
      viewport.x += viewportMargin;
      viewport.y += viewportMargin;
      viewport.width -= viewportMargin * 2;
      viewport.height -= viewportMargin * 2;
      var placement = {
        anchor: preferredAnchor.value,
        origin: preferredOrigin.value
      };
      function checkOverflow(_placement) {
        var box = new Box(contentBox);
        var targetPoint = anchorToPoint(_placement.anchor, targetBox);
        var contentPoint = anchorToPoint(_placement.origin, box);
        var _getOffset$ = getOffset$1(targetPoint, contentPoint),
          x2 = _getOffset$.x,
          y2 = _getOffset$.y;
        switch (_placement.anchor.side) {
          case "top":
            y2 -= offset.value[0];
            break;
          case "bottom":
            y2 += offset.value[0];
            break;
          case "left":
            x2 -= offset.value[0];
            break;
          case "right":
            x2 += offset.value[0];
            break;
        }
        switch (_placement.anchor.align) {
          case "top":
            y2 -= offset.value[1];
            break;
          case "bottom":
            y2 += offset.value[1];
            break;
          case "left":
            x2 -= offset.value[1];
            break;
          case "right":
            x2 += offset.value[1];
            break;
        }
        box.x += x2;
        box.y += y2;
        box.width = Math.min(box.width, maxWidth.value);
        box.height = Math.min(box.height, maxHeight.value);
        var overflows = getOverflow(box, viewport);
        return {
          overflows: overflows,
          x: x2,
          y: y2
        };
      }
      var x = 0;
      var y = 0;
      var available = {
        x: 0,
        y: 0
      };
      var flipped = {
        x: false,
        y: false
      };
      var resets = -1;
      var _loop27 = function () {
          if (resets++ > 10) {
            consoleError("Infinite loop detected in connectedLocationStrategy");
            return 0; // break
          }
          var _checkOverflow = checkOverflow(placement),
            _x = _checkOverflow.x,
            _y = _checkOverflow.y,
            overflows = _checkOverflow.overflows;
          x += _x;
          y += _y;
          contentBox.x += _x;
          contentBox.y += _y;
          {
            var axis2 = getAxis(placement.anchor);
            var hasOverflowX = overflows.x.before || overflows.x.after;
            var hasOverflowY = overflows.y.before || overflows.y.after;
            var reset = false;
            ["x", "y"].forEach(function (key) {
              if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
                var newPlacement = {
                  anchor: _objectSpread({}, placement.anchor),
                  origin: _objectSpread({}, placement.origin)
                };
                var flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
                newPlacement.anchor = flip(newPlacement.anchor);
                newPlacement.origin = flip(newPlacement.origin);
                var _checkOverflow2 = checkOverflow(newPlacement),
                  newOverflows = _checkOverflow2.overflows;
                if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
                  placement = newPlacement;
                  reset = flipped[key] = true;
                }
              }
            });
            if (reset) return 1; // continue
          }
          if (overflows.x.before) {
            x += overflows.x.before;
            contentBox.x += overflows.x.before;
          }
          if (overflows.x.after) {
            x -= overflows.x.after;
            contentBox.x -= overflows.x.after;
          }
          if (overflows.y.before) {
            y += overflows.y.before;
            contentBox.y += overflows.y.before;
          }
          if (overflows.y.after) {
            y -= overflows.y.after;
            contentBox.y -= overflows.y.after;
          }
          {
            var overflows2 = getOverflow(contentBox, viewport);
            available.x = viewport.width - overflows2.x.before - overflows2.x.after;
            available.y = viewport.height - overflows2.y.before - overflows2.y.after;
            x += overflows2.x.before;
            contentBox.x += overflows2.x.before;
            y += overflows2.y.before;
            contentBox.y += overflows2.y.before;
          }
          return 0; // break
        },
        _ret8;
      while (true) {
        _ret8 = _loop27();
        if (_ret8 === 0) break;
        if (_ret8 === 1) continue;
      }
      var axis = getAxis(placement.anchor);
      Object.assign(contentStyles.value, {
        "--v-overlay-anchor-origin": placement.anchor.side + " " + placement.anchor.align,
        transformOrigin: placement.origin.side + " " + placement.origin.align,
        top: convertToUnit(pixelRound(y)),
        left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x)),
        right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : void 0,
        minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
        maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
        maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
      });
      return {
        available: available,
        contentBox: contentBox
      };
    }
    watch(function () {
      return [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight];
    }, function () {
      return updateLocation();
    });
    nextTick(function () {
      var result = updateLocation();
      if (!result) return;
      var available = result.available,
        contentBox = result.contentBox;
      if (contentBox.height > available.y) {
        requestAnimationFrame(function () {
          updateLocation();
          requestAnimationFrame(function () {
            updateLocation();
          });
        });
      }
    });
    return {
      updateLocation: updateLocation
    };
  }
  function pixelRound(val) {
    return Math.round(val * devicePixelRatio) / devicePixelRatio;
  }
  function pixelCeil(val) {
    return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
  }
  var clean = true;
  var frames = [];
  function requestNewFrame(cb) {
    if (!clean || frames.length) {
      frames.push(cb);
      run();
    } else {
      clean = false;
      cb();
      run();
    }
  }
  var raf = -1;
  function run() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(function () {
      var frame = frames.shift();
      if (frame) frame();
      if (frames.length) run();else clean = true;
    });
  }
  var scrollStrategies = {
    none: null,
    close: closeScrollStrategy,
    block: blockScrollStrategy,
    reposition: repositionScrollStrategy
  };
  var makeScrollStrategyProps = propsFactory({
    scrollStrategy: {
      type: [String, Function],
      "default": "block",
      validator: function (val) {
        return typeof val === "function" || val in scrollStrategies;
      }
    }
  }, "VOverlay-scroll-strategies");
  function useScrollStrategies(props, data) {
    if (!IN_BROWSER) return;
    var scope;
    watchEffect(function _callee6() {
      return _regeneratorRuntime.async(function _callee6$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            scope == null ? void 0 : scope.stop();
            if (data.isActive.value && props.scrollStrategy) {
              _context13.next = 3;
              break;
            }
            return _context13.abrupt("return");
          case 3:
            scope = effectScope();
            _context13.next = 6;
            return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
              return setTimeout(resolve2);
            }));
          case 6:
            scope.active && scope.run(function () {
              var _a2;
              if (typeof props.scrollStrategy === "function") {
                props.scrollStrategy(data, props, scope);
              } else {
                (_a2 = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _a2.call(scrollStrategies, data, props, scope);
              }
            });
          case 7:
          case "end":
            return _context13.stop();
        }
      }, null, null, null, Promise);
    });
    onScopeDispose(function () {
      scope == null ? void 0 : scope.stop();
    });
  }
  function closeScrollStrategy(data) {
    var _a2;
    function onScroll(e) {
      data.isActive.value = false;
    }
    bindScroll((_a2 = data.targetEl.value) != null ? _a2 : data.contentEl.value, onScroll);
  }
  function blockScrollStrategy(data, props) {
    var _a2;
    var offsetParent = (_a2 = data.root.value) == null ? void 0 : _a2.offsetParent;
    var scrollElements = _toConsumableArray( /* @__PURE__ */new Set([].concat(_toConsumableArray(getScrollParents(data.targetEl.value, props.contained ? offsetParent : void 0)), _toConsumableArray(getScrollParents(data.contentEl.value, props.contained ? offsetParent : void 0))))).filter(function (el) {
      return !el.classList.contains("v-overlay-scroll-blocked");
    });
    var scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    var scrollableParent = function (el) {
      return hasScrollbar(el) && el;
    }(offsetParent || document.documentElement);
    if (scrollableParent) {
      data.root.value.classList.add("v-overlay--scroll-blocked");
    }
    scrollElements.forEach(function (el, i) {
      el.style.setProperty("--v-body-scroll-x", convertToUnit(-el.scrollLeft));
      el.style.setProperty("--v-body-scroll-y", convertToUnit(-el.scrollTop));
      if (el !== document.documentElement) {
        el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
      }
      el.classList.add("v-overlay-scroll-blocked");
    });
    onScopeDispose(function () {
      scrollElements.forEach(function (el, i) {
        var x = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
        var y = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
        var scrollBehavior = el.style.scrollBehavior;
        el.style.scrollBehavior = "auto";
        el.style.removeProperty("--v-body-scroll-x");
        el.style.removeProperty("--v-body-scroll-y");
        el.style.removeProperty("--v-scrollbar-offset");
        el.classList.remove("v-overlay-scroll-blocked");
        el.scrollLeft = -x;
        el.scrollTop = -y;
        el.style.scrollBehavior = scrollBehavior;
      });
      if (scrollableParent) {
        data.root.value.classList.remove("v-overlay--scroll-blocked");
      }
    });
  }
  function repositionScrollStrategy(data, props, scope) {
    var slow = false;
    var raf2 = -1;
    var ric = -1;
    function update(e) {
      requestNewFrame(function () {
        var _a2, _b;
        var start = performance.now();
        (_b = (_a2 = data.updateLocation).value) == null ? void 0 : _b.call(_a2, e);
        var time = performance.now() - start;
        slow = time / (1e3 / 60) > 2;
      });
    }
    ric = (typeof requestIdleCallback === "undefined" ? function (cb) {
      return cb();
    } : requestIdleCallback)(function () {
      scope.run(function () {
        var _a2;
        bindScroll((_a2 = data.targetEl.value) != null ? _a2 : data.contentEl.value, function (e) {
          if (slow) {
            cancelAnimationFrame(raf2);
            raf2 = requestAnimationFrame(function () {
              raf2 = requestAnimationFrame(function () {
                update(e);
              });
            });
          } else {
            update(e);
          }
        });
      });
    });
    onScopeDispose(function () {
      typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
      cancelAnimationFrame(raf2);
    });
  }
  function bindScroll(el, onScroll) {
    var scrollElements = [document].concat(_toConsumableArray(getScrollParents(el)));
    scrollElements.forEach(function (el2) {
      el2.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    onScopeDispose(function () {
      scrollElements.forEach(function (el2) {
        el2.removeEventListener("scroll", onScroll);
      });
    });
  }
  var VMenuSymbol = Symbol.for("vuetify:v-menu");
  var makeDelayProps = propsFactory({
    closeDelay: [Number, String],
    openDelay: [Number, String]
  }, "delay");
  function useDelay(props, cb) {
    var clearDelay = function () {};
    function runDelay(isOpening) {
      clearDelay == null ? void 0 : clearDelay();
      var delay = Number(isOpening ? props.openDelay : props.closeDelay);
      return new Promise(function (resolve2) {
        clearDelay = defer(delay, function () {
          cb == null ? void 0 : cb(isOpening);
          resolve2(isOpening);
        });
      });
    }
    function runOpenDelay() {
      return runDelay(true);
    }
    function runCloseDelay() {
      return runDelay(false);
    }
    return {
      clearDelay: clearDelay,
      runOpenDelay: runOpenDelay,
      runCloseDelay: runCloseDelay
    };
  }
  var makeActivatorProps = propsFactory(_objectSpread({
    target: [String, Object],
    activator: [String, Object],
    activatorProps: {
      type: Object,
      "default": function () {
        return {};
      }
    },
    openOnClick: {
      type: Boolean,
      "default": void 0
    },
    openOnHover: Boolean,
    openOnFocus: {
      type: Boolean,
      "default": void 0
    },
    closeOnContentClick: Boolean
  }, makeDelayProps()), "VOverlay-activator");
  function useActivator(props, _ref) {
    var isActive2 = _ref.isActive,
      isTop = _ref.isTop,
      contentEl = _ref.contentEl;
    var vm = getCurrentInstance("useActivator");
    var activatorEl = ref();
    var isHovered = false;
    var isFocused = false;
    var firstEnter = true;
    var openOnFocus = computed(function () {
      return props.openOnFocus || props.openOnFocus == null && props.openOnHover;
    });
    var openOnClick = computed(function () {
      return props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value;
    });
    var _useDelay = useDelay(props, function (value) {
        if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive2.value && !isTop.value)) {
          if (isActive2.value !== value) {
            firstEnter = true;
          }
          isActive2.value = value;
        }
      }),
      runOpenDelay = _useDelay.runOpenDelay,
      runCloseDelay = _useDelay.runCloseDelay;
    var cursorTarget = ref();
    var availableEvents = {
      onClick: function (e) {
        e.stopPropagation();
        activatorEl.value = e.currentTarget || e.target;
        if (!isActive2.value) {
          cursorTarget.value = [e.clientX, e.clientY];
        }
        isActive2.value = !isActive2.value;
      },
      onMouseenter: function (e) {
        var _a2;
        if ((_a2 = e.sourceCapabilities) == null ? void 0 : _a2.firesTouchEvents) return;
        isHovered = true;
        activatorEl.value = e.currentTarget || e.target;
        runOpenDelay();
      },
      onMouseleave: function (e) {
        isHovered = false;
        runCloseDelay();
      },
      onFocus: function (e) {
        if (matchesSelector(e.target, ":focus-visible") === false) return;
        isFocused = true;
        e.stopPropagation();
        activatorEl.value = e.currentTarget || e.target;
        runOpenDelay();
      },
      onBlur: function (e) {
        isFocused = false;
        e.stopPropagation();
        runCloseDelay();
      }
    };
    var activatorEvents = computed(function () {
      var events = {};
      if (openOnClick.value) {
        events.onClick = availableEvents.onClick;
      }
      if (props.openOnHover) {
        events.onMouseenter = availableEvents.onMouseenter;
        events.onMouseleave = availableEvents.onMouseleave;
      }
      if (openOnFocus.value) {
        events.onFocus = availableEvents.onFocus;
        events.onBlur = availableEvents.onBlur;
      }
      return events;
    });
    var contentEvents = computed(function () {
      var events = {};
      if (props.openOnHover) {
        events.onMouseenter = function () {
          isHovered = true;
          runOpenDelay();
        };
        events.onMouseleave = function () {
          isHovered = false;
          runCloseDelay();
        };
      }
      if (openOnFocus.value) {
        events.onFocusin = function () {
          isFocused = true;
          runOpenDelay();
        };
        events.onFocusout = function () {
          isFocused = false;
          runCloseDelay();
        };
      }
      if (props.closeOnContentClick) {
        var menu = inject$1(VMenuSymbol, null);
        events.onClick = function () {
          isActive2.value = false;
          menu == null ? void 0 : menu.closeParents();
        };
      }
      return events;
    });
    var scrimEvents = computed(function () {
      var events = {};
      if (props.openOnHover) {
        events.onMouseenter = function () {
          if (firstEnter) {
            isHovered = true;
            firstEnter = false;
            runOpenDelay();
          }
        };
        events.onMouseleave = function () {
          isHovered = false;
          runCloseDelay();
        };
      }
      return events;
    });
    watch(isTop, function (val) {
      var _a2;
      if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered)) && !((_a2 = contentEl.value) == null ? void 0 : _a2.contains(document.activeElement))) {
        isActive2.value = false;
      }
    });
    watch(isActive2, function (val) {
      if (!val) {
        setTimeout(function () {
          cursorTarget.value = void 0;
        });
      }
    }, {
      flush: "post"
    });
    var activatorRef = templateRef();
    watchEffect(function () {
      if (!activatorRef.value) return;
      nextTick(function () {
        activatorEl.value = activatorRef.el;
      });
    });
    var targetRef = templateRef();
    var target = computed(function () {
      if (props.target === "cursor" && cursorTarget.value) return cursorTarget.value;
      if (targetRef.value) return targetRef.el;
      return getTarget(props.target, vm) || activatorEl.value;
    });
    var targetEl = computed(function () {
      return Array.isArray(target.value) ? void 0 : target.value;
    });
    var scope;
    watch(function () {
      return !!props.activator;
    }, function (val) {
      if (val && IN_BROWSER) {
        scope = effectScope();
        scope.run(function () {
          _useActivator(props, vm, {
            activatorEl: activatorEl,
            activatorEvents: activatorEvents
          });
        });
      } else if (scope) {
        scope.stop();
      }
    }, {
      flush: "post",
      immediate: true
    });
    onScopeDispose(function () {
      scope == null ? void 0 : scope.stop();
    });
    return {
      activatorEl: activatorEl,
      activatorRef: activatorRef,
      target: target,
      targetEl: targetEl,
      targetRef: targetRef,
      activatorEvents: activatorEvents,
      contentEvents: contentEvents,
      scrimEvents: scrimEvents
    };
  }
  function _useActivator(props, vm, _ref2) {
    var activatorEl = _ref2.activatorEl,
      activatorEvents = _ref2.activatorEvents;
    watch(function () {
      return props.activator;
    }, function (val, oldVal) {
      if (oldVal && val !== oldVal) {
        var activator = getActivator(oldVal);
        activator && unbindActivatorProps(activator);
      }
      if (val) {
        nextTick(function () {
          return bindActivatorProps();
        });
      }
    }, {
      immediate: true
    });
    watch(function () {
      return props.activatorProps;
    }, function () {
      bindActivatorProps();
    });
    onScopeDispose(function () {
      unbindActivatorProps();
    });
    function bindActivatorProps() {
      var el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
      var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
      if (!el) return;
      bindProps(el, mergeProps(activatorEvents.value, _props));
    }
    function unbindActivatorProps() {
      var el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
      var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
      if (!el) return;
      unbindProps(el, mergeProps(activatorEvents.value, _props));
    }
    function getActivator() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
      var activator = getTarget(selector, vm);
      activatorEl.value = (activator == null ? void 0 : activator.nodeType) === Node.ELEMENT_NODE ? activator : void 0;
      return activatorEl.value;
    }
  }
  function getTarget(selector, vm) {
    var _a2, _b;
    if (!selector) return;
    var target;
    if (selector === "parent") {
      var el = (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$el) == null ? void 0 : _b.parentNode;
      while (el == null ? void 0 : el.hasAttribute("data-no-activator")) {
        el = el.parentNode;
      }
      target = el;
    } else if (typeof selector === "string") {
      target = document.querySelector(selector);
    } else if ("$el" in selector) {
      target = selector.$el;
    } else {
      target = selector;
    }
    return target;
  }
  function useHydration() {
    if (!IN_BROWSER) return shallowRef(false);
    var _useDisplay2 = useDisplay(),
      ssr = _useDisplay2.ssr;
    if (ssr) {
      var isMounted = shallowRef(false);
      onMounted(function () {
        isMounted.value = true;
      });
      return isMounted;
    } else {
      return shallowRef(true);
    }
  }
  var makeLazyProps = propsFactory({
    eager: Boolean
  }, "lazy");
  function useLazy(props, active) {
    var isBooted = shallowRef(false);
    var hasContent = computed(function () {
      return isBooted.value || props.eager || active.value;
    });
    watch(active, function () {
      return isBooted.value = true;
    });
    function onAfterLeave() {
      if (!props.eager) isBooted.value = false;
    }
    return {
      isBooted: isBooted,
      hasContent: hasContent,
      onAfterLeave: onAfterLeave
    };
  }
  function useScopeId() {
    var _ref275;
    var vm = getCurrentInstance("useScopeId");
    var scopeId = vm.vnode.scopeId;
    return {
      scopeId: scopeId ? (_ref275 = {}, _ref275[scopeId] = "", _ref275) : void 0
    };
  }
  var StackSymbol = Symbol.for("vuetify:stack");
  var globalStack = reactive([]);
  function useStack(isActive2, zIndex, disableGlobalStack) {
    var vm = getCurrentInstance("useStack");
    var createStackEntry = !disableGlobalStack;
    var parent = inject$1(StackSymbol, void 0);
    var stack2 = reactive({
      activeChildren: /* @__PURE__ */new Set()
    });
    provide(StackSymbol, stack2);
    var _zIndex = shallowRef(+zIndex.value);
    useToggleScope(isActive2, function () {
      var _a2;
      var lastZIndex = (_a2 = globalStack.at(-1)) == null ? void 0 : _a2[1];
      _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
      if (createStackEntry) {
        globalStack.push([vm.uid, _zIndex.value]);
      }
      parent == null ? void 0 : parent.activeChildren.add(vm.uid);
      onScopeDispose(function () {
        if (createStackEntry) {
          var idx = toRaw(globalStack).findIndex(function (v) {
            return v[0] === vm.uid;
          });
          globalStack.splice(idx, 1);
        }
        parent == null ? void 0 : parent.activeChildren.delete(vm.uid);
      });
    });
    var globalTop = shallowRef(true);
    if (createStackEntry) {
      watchEffect(function () {
        var _a2;
        var _isTop = ((_a2 = globalStack.at(-1)) == null ? void 0 : _a2[0]) === vm.uid;
        setTimeout(function () {
          return globalTop.value = _isTop;
        });
      });
    }
    var localTop = computed(function () {
      return !stack2.activeChildren.size;
    });
    return {
      globalTop: readonly(globalTop),
      localTop: localTop,
      stackStyles: computed(function () {
        return {
          zIndex: _zIndex.value
        };
      })
    };
  }
  function useTeleport(target) {
    var teleportTarget = computed(function () {
      var _target = target();
      if (_target === true || !IN_BROWSER) return void 0;
      var targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
      if (targetElement == null) {
        warn$2("Unable to locate target " + _target);
        return void 0;
      }
      var container = _toConsumableArray(targetElement.children).find(function (el) {
        return el.matches(".v-overlay-container");
      });
      if (!container) {
        container = document.createElement("div");
        container.className = "v-overlay-container";
        targetElement.appendChild(container);
      }
      return container;
    });
    return {
      teleportTarget: teleportTarget
    };
  }
  function defaultConditional() {
    return true;
  }
  function checkEvent(e, el, binding) {
    if (!e || checkIsActive(e, binding) === false) return false;
    var root = attachedRoot(el);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target) return false;
    var elements = (_typeof(binding.value) === "object" && binding.value.include || function () {
      return [];
    })();
    elements.push(el);
    return !elements.some(function (el2) {
      return el2 == null ? void 0 : el2.contains(e.target);
    });
  }
  function checkIsActive(e, binding) {
    var isActive2 = _typeof(binding.value) === "object" && binding.value.closeConditional || defaultConditional;
    return isActive2(e);
  }
  function directive(e, el, binding) {
    var handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
    e.shadowTarget = e.target;
    el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(function () {
      checkIsActive(e, binding) && handler && handler(e);
    }, 0);
  }
  function handleShadow(el, callback) {
    var root = attachedRoot(el);
    callback(document);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
      callback(root);
    }
  }
  var ClickOutside = {
    mounted: function (el, binding) {
      var onClick = function (e) {
        return directive(e, el, binding);
      };
      var onMousedown = function (e) {
        el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
      };
      handleShadow(el, function (app) {
        app.addEventListener("click", onClick, true);
        app.addEventListener("mousedown", onMousedown, true);
      });
      if (!el._clickOutside) {
        el._clickOutside = {
          lastMousedownWasOutside: false
        };
      }
      el._clickOutside[binding.instance.$.uid] = {
        onClick: onClick,
        onMousedown: onMousedown
      };
    },
    beforeUnmount: function (el, binding) {
      if (!el._clickOutside) return;
      handleShadow(el, function (app) {
        var _a2;
        if (!app || !((_a2 = el._clickOutside) == null ? void 0 : _a2[binding.instance.$.uid])) return;
        var _el$_clickOutside$bin = el._clickOutside[binding.instance.$.uid],
          onClick = _el$_clickOutside$bin.onClick,
          onMousedown = _el$_clickOutside$bin.onMousedown;
        app.removeEventListener("click", onClick, true);
        app.removeEventListener("mousedown", onMousedown, true);
      });
      delete el._clickOutside[binding.instance.$.uid];
    }
  };
  function Scrim(props) {
    var modelValue = props.modelValue,
      color = props.color,
      rest = _objectWithoutProperties(props, _excluded11);
    return createVNode(Transition, {
      "name": "fade-transition",
      "appear": true
    }, {
      "default": function () {
        return [props.modelValue && createVNode("div", mergeProps({
          "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
          "style": props.color.backgroundColorStyles.value
        }, rest), null)];
      }
    });
  }
  var makeVOverlayProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    absolute: Boolean,
    attach: [Boolean, String, Object],
    closeOnBack: {
      type: Boolean,
      "default": true
    },
    contained: Boolean,
    contentClass: null,
    contentProps: null,
    disabled: Boolean,
    opacity: [Number, String],
    noClickAnimation: Boolean,
    modelValue: Boolean,
    persistent: Boolean,
    scrim: {
      type: [Boolean, String],
      "default": true
    },
    zIndex: {
      type: [Number, String],
      "default": 2e3
    }
  }, makeActivatorProps()), makeComponentProps()), makeDimensionProps()), makeLazyProps()), makeLocationStrategyProps()), makeScrollStrategyProps()), makeThemeProps()), makeTransitionProps()), "VOverlay");
  var VOverlay = genericComponent()({
    name: "VOverlay",
    directives: {
      ClickOutside: ClickOutside
    },
    inheritAttrs: false,
    props: _objectSpread({
      _disableGlobalStack: Boolean
    }, makeVOverlayProps()),
    emits: {
      "click:outside": function (e) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      afterEnter: function () {
        return true;
      },
      afterLeave: function () {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots,
        attrs = _ref.attrs,
        emit2 = _ref.emit;
      var vm = getCurrentInstance("VOverlay");
      var root = ref();
      var scrimEl = ref();
      var contentEl = ref();
      var model = useProxiedModel(props, "modelValue");
      var isActive2 = computed({
        get: function () {
          return model.value;
        },
        set: function (v) {
          if (!(v && props.disabled)) model.value = v;
        }
      });
      var _provideTheme15 = provideTheme(props),
        themeClasses = _provideTheme15.themeClasses;
      var _useRtl8 = useRtl(),
        rtlClasses = _useRtl8.rtlClasses,
        isRtl = _useRtl8.isRtl;
      var _useLazy = useLazy(props, isActive2),
        hasContent = _useLazy.hasContent,
        _onAfterLeave = _useLazy.onAfterLeave;
      var scrimColor = useBackgroundColor(computed(function () {
        return typeof props.scrim === "string" ? props.scrim : null;
      }));
      var _useStack = useStack(isActive2, toRef(props, "zIndex"), props._disableGlobalStack),
        globalTop = _useStack.globalTop,
        localTop = _useStack.localTop,
        stackStyles = _useStack.stackStyles;
      var _useActivator2 = useActivator(props, {
          isActive: isActive2,
          isTop: localTop,
          contentEl: contentEl
        }),
        activatorEl = _useActivator2.activatorEl,
        activatorRef = _useActivator2.activatorRef,
        target = _useActivator2.target,
        targetEl = _useActivator2.targetEl,
        targetRef = _useActivator2.targetRef,
        activatorEvents = _useActivator2.activatorEvents,
        contentEvents = _useActivator2.contentEvents,
        scrimEvents = _useActivator2.scrimEvents;
      var _useTeleport = useTeleport(function () {
          var _a2, _b, _c;
          var target2 = props.attach || props.contained;
          if (target2) return target2;
          var rootNode = ((_a2 = activatorEl == null ? void 0 : activatorEl.value) == null ? void 0 : _a2.getRootNode()) || ((_c = (_b = vm.proxy) == null ? void 0 : _b.$el) == null ? void 0 : _c.getRootNode());
          if (rootNode instanceof ShadowRoot) return rootNode;
          return false;
        }),
        teleportTarget = _useTeleport.teleportTarget;
      var _useDimension7 = useDimension(props),
        dimensionStyles = _useDimension7.dimensionStyles;
      var isMounted = useHydration();
      var _useScopeId = useScopeId(),
        scopeId = _useScopeId.scopeId;
      watch(function () {
        return props.disabled;
      }, function (v) {
        if (v) isActive2.value = false;
      });
      var _useLocationStrategie = useLocationStrategies(props, {
          isRtl: isRtl,
          contentEl: contentEl,
          target: target,
          isActive: isActive2
        }),
        contentStyles = _useLocationStrategie.contentStyles,
        updateLocation = _useLocationStrategie.updateLocation;
      useScrollStrategies(props, {
        root: root,
        contentEl: contentEl,
        targetEl: targetEl,
        isActive: isActive2,
        updateLocation: updateLocation
      });
      function onClickOutside(e) {
        emit2("click:outside", e);
        if (!props.persistent) isActive2.value = false;else animateClick();
      }
      function closeConditional(e) {
        return isActive2.value && globalTop.value && (!props.scrim || e.target === scrimEl.value || e instanceof MouseEvent && e.shadowTarget === scrimEl.value);
      }
      IN_BROWSER && watch(isActive2, function (val) {
        if (val) {
          window.addEventListener("keydown", onKeydown);
        } else {
          window.removeEventListener("keydown", onKeydown);
        }
      }, {
        immediate: true
      });
      onBeforeUnmount(function () {
        if (!IN_BROWSER) return;
        window.removeEventListener("keydown", onKeydown);
      });
      function onKeydown(e) {
        var _a2, _b;
        if (e.key === "Escape" && globalTop.value) {
          if (!props.persistent) {
            isActive2.value = false;
            if ((_a2 = contentEl.value) == null ? void 0 : _a2.contains(document.activeElement)) {
              (_b = activatorEl.value) == null ? void 0 : _b.focus();
            }
          } else animateClick();
        }
      }
      var router2 = useRouter();
      useToggleScope(function () {
        return props.closeOnBack;
      }, function () {
        useBackButton(router2, function (next) {
          if (globalTop.value && isActive2.value) {
            next(false);
            if (!props.persistent) isActive2.value = false;else animateClick();
          } else {
            next();
          }
        });
      });
      var top = ref();
      watch(function () {
        return isActive2.value && (props.absolute || props.contained) && teleportTarget.value == null;
      }, function (val) {
        if (val) {
          var scrollParent = getScrollParent(root.value);
          if (scrollParent && scrollParent !== document.scrollingElement) {
            top.value = scrollParent.scrollTop;
          }
        }
      });
      function animateClick() {
        if (props.noClickAnimation) return;
        contentEl.value && animate(contentEl.value, [{
          transformOrigin: "center"
        }, {
          transform: "scale(1.03)"
        }, {
          transformOrigin: "center"
        }], {
          duration: 150,
          easing: standardEasing
        });
      }
      function onAfterEnter() {
        emit2("afterEnter");
      }
      function onAfterLeave() {
        _onAfterLeave();
        emit2("afterLeave");
      }
      useRender(function () {
        var _a2;
        return createVNode(Fragment$1, null, [(_a2 = slots.activator) == null ? void 0 : _a2.call(slots, {
          isActive: isActive2.value,
          targetRef: targetRef,
          props: mergeProps({
            ref: activatorRef
          }, activatorEvents.value, props.activatorProps)
        }), isMounted.value && hasContent.value && createVNode(Teleport, {
          "disabled": !teleportTarget.value,
          "to": teleportTarget.value
        }, {
          "default": function () {
            return [createVNode("div", mergeProps({
              "class": ["v-overlay", {
                "v-overlay--absolute": props.absolute || props.contained,
                "v-overlay--active": isActive2.value,
                "v-overlay--contained": props.contained
              }, themeClasses.value, rtlClasses.value, props.class],
              "style": [stackStyles.value, {
                "--v-overlay-opacity": props.opacity,
                top: convertToUnit(top.value)
              }, props.style],
              "ref": root
            }, scopeId, attrs), [createVNode(Scrim, mergeProps({
              "color": scrimColor,
              "modelValue": isActive2.value && !!props.scrim,
              "ref": scrimEl
            }, scrimEvents.value), null), createVNode(MaybeTransition, {
              "appear": true,
              "persisted": true,
              "transition": props.transition,
              "target": target.value,
              "onAfterEnter": onAfterEnter,
              "onAfterLeave": onAfterLeave
            }, {
              "default": function () {
                var _a3;
                return [withDirectives(createVNode("div", mergeProps({
                  "ref": contentEl,
                  "class": ["v-overlay__content", props.contentClass],
                  "style": [dimensionStyles.value, contentStyles.value]
                }, contentEvents.value, props.contentProps), [(_a3 = slots.default) == null ? void 0 : _a3.call(slots, {
                  isActive: isActive2
                })]), [[vShow, isActive2.value], [resolveDirective("click-outside"), {
                  handler: onClickOutside,
                  closeConditional: closeConditional,
                  include: function () {
                    return [activatorEl.value];
                  }
                }]])];
              }
            })])];
          }
        })]);
      });
      return {
        activatorEl: activatorEl,
        scrimEl: scrimEl,
        target: target,
        animateClick: animateClick,
        contentEl: contentEl,
        globalTop: globalTop,
        localTop: localTop,
        updateLocation: updateLocation
      };
    }
  });
  var Refs = Symbol("Forwarded refs");
  function getDescriptor(obj, key) {
    var currentObj = obj;
    while (currentObj) {
      var descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
      if (descriptor) return descriptor;
      currentObj = Object.getPrototypeOf(currentObj);
    }
    return void 0;
  }
  function forwardRefs(target) {
    for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      refs[_key - 1] = arguments[_key];
    }
    target[Refs] = refs;
    return new Proxy(target, {
      get: function (target2, key) {
        if (Reflect.has(target2, key)) {
          return Reflect.get(target2, key);
        }
        if (_typeof(key) === "symbol" || key.startsWith("$") || key.startsWith("__")) return;
        for (var _i272 = 0, _refs = refs; _i272 < _refs.length; _i272++) {
          var ref2 = _refs[_i272];
          if (ref2.value && Reflect.has(ref2.value, key)) {
            var val = Reflect.get(ref2.value, key);
            return typeof val === "function" ? val.bind(ref2.value) : val;
          }
        }
      },
      has: function (target2, key) {
        if (Reflect.has(target2, key)) {
          return true;
        }
        if (_typeof(key) === "symbol" || key.startsWith("$") || key.startsWith("__")) return false;
        for (var _i273 = 0, _refs2 = refs; _i273 < _refs2.length; _i273++) {
          var ref2 = _refs2[_i273];
          if (ref2.value && Reflect.has(ref2.value, key)) {
            return true;
          }
        }
        return false;
      },
      set: function (target2, key, value) {
        if (Reflect.has(target2, key)) {
          return Reflect.set(target2, key, value);
        }
        if (_typeof(key) === "symbol" || key.startsWith("$") || key.startsWith("__")) return false;
        for (var _i274 = 0, _refs3 = refs; _i274 < _refs3.length; _i274++) {
          var ref2 = _refs3[_i274];
          if (ref2.value && Reflect.has(ref2.value, key)) {
            return Reflect.set(ref2.value, key, value);
          }
        }
        return false;
      },
      getOwnPropertyDescriptor: function (target2, key) {
        var _a2, _b;
        var descriptor = Reflect.getOwnPropertyDescriptor(target2, key);
        if (descriptor) return descriptor;
        if (_typeof(key) === "symbol" || key.startsWith("$") || key.startsWith("__")) return;
        for (var _i275 = 0, _refs4 = refs; _i275 < _refs4.length; _i275++) {
          var ref2 = _refs4[_i275];
          if (!ref2.value) continue;
          var descriptor2 = (_b = getDescriptor(ref2.value, key)) != null ? _b : "_" in ref2.value ? getDescriptor((_a2 = ref2.value._) == null ? void 0 : _a2.setupState, key) : void 0;
          if (descriptor2) return descriptor2;
        }
        for (var _i276 = 0, _refs5 = refs; _i276 < _refs5.length; _i276++) {
          var _ref276 = _refs5[_i276];
          var childRefs = _ref276.value && _ref276.value[Refs];
          if (!childRefs) continue;
          var queue2 = childRefs.slice();
          while (queue2.length) {
            var ref3 = queue2.shift();
            var _descriptor = getDescriptor(ref3.value, key);
            if (_descriptor) return _descriptor;
            var childRefs2 = ref3.value && ref3.value[Refs];
            if (childRefs2) queue2.push.apply(queue2, _toConsumableArray(childRefs2));
          }
        }
        return void 0;
      }
    });
  }
  var makeVMenuProps = propsFactory(_objectSpread({
    id: String,
    submenu: Boolean
  }, omit(makeVOverlayProps({
    closeDelay: 250,
    closeOnContentClick: true,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: false,
    scrollStrategy: "reposition",
    transition: {
      component: VDialogTransition
    }
  }), ["absolute"])), "VMenu");
  var VMenu = genericComponent()({
    name: "VMenu",
    props: makeVMenuProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var isActive2 = useProxiedModel(props, "modelValue");
      var _useScopeId2 = useScopeId(),
        scopeId = _useScopeId2.scopeId;
      var _useRtl9 = useRtl(),
        isRtl = _useRtl9.isRtl;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "v-menu-" + uid2;
      });
      var overlay = ref();
      var parent = inject$1(VMenuSymbol, null);
      var openChildren = shallowRef( /* @__PURE__ */new Set());
      provide(VMenuSymbol, {
        register: function () {
          openChildren.value.add(uid2);
        },
        unregister: function () {
          openChildren.value.delete(uid2);
        },
        closeParents: function (e) {
          setTimeout(function () {
            var _a2;
            if (!openChildren.value.size && !props.persistent && (e == null || ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && !isClickInsideElement(e, overlay.value.contentEl))) {
              isActive2.value = false;
              parent == null ? void 0 : parent.closeParents();
            }
          }, 40);
        }
      });
      onBeforeUnmount(function () {
        return parent == null ? void 0 : parent.unregister();
      });
      onDeactivated(function () {
        return isActive2.value = false;
      });
      function onFocusIn(e) {
        var _a2, _b, _c, before, after, focusable;
        return _regeneratorRuntime.async(function onFocusIn$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              before = e.relatedTarget;
              after = e.target;
              _context14.next = 4;
              return _regeneratorRuntime.awrap(nextTick());
            case 4:
              if (isActive2.value && before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && ((_b = overlay.value) == null ? void 0 : _b.globalTop) && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
                focusable = focusableChildren(overlay.value.contentEl);
                (_c = focusable[0]) == null ? void 0 : _c.focus();
              }
            case 5:
            case "end":
              return _context14.stop();
          }
        }, null, null, null, Promise);
      }
      watch(isActive2, function (val) {
        if (val) {
          parent == null ? void 0 : parent.register();
          document.addEventListener("focusin", onFocusIn, {
            once: true
          });
        } else {
          parent == null ? void 0 : parent.unregister();
          document.removeEventListener("focusin", onFocusIn);
        }
      });
      function onClickOutside(e) {
        parent == null ? void 0 : parent.closeParents(e);
      }
      function onKeydown(e) {
        var _a2, _b, _c, _d, _e;
        if (props.disabled) return;
        if (e.key === "Tab" || e.key === "Enter" && !props.closeOnContentClick) {
          if (e.key === "Enter" && (e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLInputElement && !!e.target.closest("form"))) return;
          if (e.key === "Enter") e.preventDefault();
          var nextElement = getNextElement(focusableChildren((_a2 = overlay.value) == null ? void 0 : _a2.contentEl, false), e.shiftKey ? "prev" : "next", function (el) {
            return el.tabIndex >= 0;
          });
          if (!nextElement) {
            isActive2.value = false;
            (_c = (_b = overlay.value) == null ? void 0 : _b.activatorEl) == null ? void 0 : _c.focus();
          }
        } else if (props.submenu && e.key === (isRtl.value ? "ArrowRight" : "ArrowLeft")) {
          isActive2.value = false;
          (_e = (_d = overlay.value) == null ? void 0 : _d.activatorEl) == null ? void 0 : _e.focus();
        }
      }
      function onActivatorKeydown(e) {
        var _a2;
        if (props.disabled) return;
        var el = (_a2 = overlay.value) == null ? void 0 : _a2.contentEl;
        if (el && isActive2.value) {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            e.stopImmediatePropagation();
            focusChild(el, "next");
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            e.stopImmediatePropagation();
            focusChild(el, "prev");
          } else if (props.submenu) {
            if (e.key === (isRtl.value ? "ArrowRight" : "ArrowLeft")) {
              isActive2.value = false;
            } else if (e.key === (isRtl.value ? "ArrowLeft" : "ArrowRight")) {
              e.preventDefault();
              focusChild(el, "first");
            }
          }
        } else if (props.submenu ? e.key === (isRtl.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(e.key)) {
          isActive2.value = true;
          e.preventDefault();
          setTimeout(function () {
            return setTimeout(function () {
              return onActivatorKeydown(e);
            });
          });
        }
      }
      var activatorProps = computed(function () {
        return mergeProps({
          "aria-haspopup": "menu",
          "aria-expanded": String(isActive2.value),
          "aria-owns": id.value,
          onKeydown: onActivatorKeydown
        }, props.activatorProps);
      });
      useRender(function () {
        var _a2;
        var overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "id": id.value,
          "class": ["v-menu", props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive2.value,
          "onUpdate:modelValue": function ($event) {
            return isActive2.value = $event;
          },
          "absolute": true,
          "activatorProps": activatorProps.value,
          "location": (_a2 = props.location) != null ? _a2 : props.submenu ? "end" : "bottom",
          "onClick:outside": onClickOutside,
          "onKeydown": onKeydown
        }, scopeId), {
          activator: slots.activator,
          "default": function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(VDefaultsProvider, {
              "root": "VMenu"
            }, {
              "default": function () {
                var _a7;
                var _a3;
                return [(_a3 = slots.default) == null ? void 0 : (_a7 = _a3).call.apply(_a7, [slots].concat(args))];
              }
            });
          }
        });
      });
      return forwardRefs({
        id: id,
        openChildren: openChildren
      }, overlay);
    }
  });
  var VSelect$1 = "";
  var VTextField$1 = "";
  var VCounter$1 = "";
  var makeVCounterProps = propsFactory(_objectSpread(_objectSpread({
    active: Boolean,
    disabled: Boolean,
    max: [Number, String],
    value: {
      type: [Number, String],
      "default": 0
    }
  }, makeComponentProps()), makeTransitionProps({
    transition: {
      component: VSlideYTransition
    }
  })), "VCounter");
  var VCounter = genericComponent()({
    name: "VCounter",
    functional: true,
    props: makeVCounterProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var counter = computed(function () {
        return props.max ? props.value + " / " + props.max : String(props.value);
      });
      useRender(function () {
        return createVNode(MaybeTransition, {
          "transition": props.transition
        }, {
          "default": function () {
            return [withDirectives(createVNode("div", {
              "class": ["v-counter", {
                "text-error": props.max && !props.disabled && parseFloat(props.value) > parseFloat(props.max)
              }, props.class],
              "style": props.style
            }, [slots.default ? slots.default({
              counter: counter.value,
              max: props.max,
              value: props.value
            }) : counter.value]), [[vShow, props.active]])];
          }
        });
      });
      return {};
    }
  });
  var VField$1 = "";
  var makeVFieldLabelProps = propsFactory(_objectSpread({
    floating: Boolean
  }, makeComponentProps()), "VFieldLabel");
  var VFieldLabel = genericComponent()({
    name: "VFieldLabel",
    props: makeVFieldLabelProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(VLabel, {
          "class": ["v-field-label", {
            "v-field-label--floating": props.floating
          }, props.class],
          "style": props.style,
          "aria-hidden": props.floating || void 0
        }, slots);
      });
      return {};
    }
  });
  var allowedVariants$1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
  var makeVFieldProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    appendInnerIcon: IconValue,
    bgColor: String,
    clearable: Boolean,
    clearIcon: {
      type: IconValue,
      "default": "$clear"
    },
    active: Boolean,
    centerAffix: {
      type: Boolean,
      "default": void 0
    },
    color: String,
    baseColor: String,
    dirty: Boolean,
    disabled: {
      type: Boolean,
      "default": null
    },
    error: Boolean,
    flat: Boolean,
    label: String,
    persistentClear: Boolean,
    prependInnerIcon: IconValue,
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
      type: String,
      "default": "filled",
      validator: function (v) {
        return allowedVariants$1.includes(v);
      }
    },
    "onClick:clear": EventProp(),
    "onClick:appendInner": EventProp(),
    "onClick:prependInner": EventProp()
  }, makeComponentProps()), makeLoaderProps()), makeRoundedProps()), makeThemeProps()), "VField");
  var VField = genericComponent()({
    name: "VField",
    inheritAttrs: false,
    props: _objectSpread(_objectSpread({
      id: String
    }, makeFocusProps()), makeVFieldProps()),
    emits: {
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var _provideTheme16 = provideTheme(props),
        themeClasses = _provideTheme16.themeClasses;
      var _useLoader2 = useLoader(props),
        loaderClasses = _useLoader2.loaderClasses;
      var _useFocus2 = useFocus(props),
        focusClasses = _useFocus2.focusClasses,
        isFocused = _useFocus2.isFocused,
        focus2 = _useFocus2.focus,
        blur2 = _useFocus2.blur;
      var _useInputIcon2 = useInputIcon(props),
        InputIcon = _useInputIcon2.InputIcon;
      var _useRounded11 = useRounded(props),
        roundedClasses = _useRounded11.roundedClasses;
      var _useRtl10 = useRtl(),
        rtlClasses = _useRtl10.rtlClasses;
      var isActive2 = computed(function () {
        return props.dirty || props.active;
      });
      var hasLabel = computed(function () {
        return !props.singleLine && !!(props.label || slots.label);
      });
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "input-" + uid2;
      });
      var messagesId = computed(function () {
        return id.value + "-messages";
      });
      var labelRef = ref();
      var floatingLabelRef = ref();
      var controlRef = ref();
      var isPlainOrUnderlined = computed(function () {
        return ["plain", "underlined"].includes(props.variant);
      });
      var _useBackgroundColor8 = useBackgroundColor(toRef(props, "bgColor")),
        backgroundColorClasses = _useBackgroundColor8.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor8.backgroundColorStyles;
      var _useTextColor10 = useTextColor(computed(function () {
          return props.error || props.disabled ? void 0 : isActive2.value && isFocused.value ? props.color : props.baseColor;
        })),
        textColorClasses = _useTextColor10.textColorClasses,
        textColorStyles = _useTextColor10.textColorStyles;
      watch(isActive2, function (val) {
        if (hasLabel.value) {
          var el = labelRef.value.$el;
          var targetEl = floatingLabelRef.value.$el;
          requestAnimationFrame(function () {
            var rect = nullifyTransforms(el);
            var targetRect = targetEl.getBoundingClientRect();
            var x = targetRect.x - rect.x;
            var y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
            var targetWidth = targetRect.width / 0.75;
            var width = Math.abs(targetWidth - rect.width) > 1 ? {
              maxWidth: convertToUnit(targetWidth)
            } : void 0;
            var style2 = getComputedStyle(el);
            var targetStyle = getComputedStyle(targetEl);
            var duration = parseFloat(style2.transitionDuration) * 1e3 || 150;
            var scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
            var color = targetStyle.getPropertyValue("color");
            el.style.visibility = "visible";
            targetEl.style.visibility = "hidden";
            animate(el, _objectSpread({
              transform: "translate(" + x + "px, " + y + "px) scale(" + scale + ")",
              color: color
            }, width), {
              duration: duration,
              easing: standardEasing,
              direction: val ? "normal" : "reverse"
            }).finished.then(function () {
              el.style.removeProperty("visibility");
              targetEl.style.removeProperty("visibility");
            });
          });
        }
      }, {
        flush: "post"
      });
      var slotProps = computed(function () {
        return {
          isActive: isActive2,
          isFocused: isFocused,
          controlRef: controlRef,
          blur: blur2,
          focus: focus2
        };
      });
      function onClick(e) {
        if (e.target !== document.activeElement) {
          e.preventDefault();
        }
      }
      function onKeydownClear(e) {
        var _a2;
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        e.stopPropagation();
        (_a2 = props["onClick:clear"]) == null ? void 0 : _a2.call(props, new MouseEvent("click"));
      }
      useRender(function () {
        var _ref277;
        var _a2, _b, _c, _d;
        var isOutlined = props.variant === "outlined";
        var hasPrepend = !!(slots["prepend-inner"] || props.prependInnerIcon);
        var hasClear = !!(props.clearable || slots.clear);
        var hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
        var label = function () {
          return slots.label ? slots.label(_objectSpread(_objectSpread({}, slotProps.value), {}, {
            label: props.label,
            props: {
              "for": id.value
            }
          })) : props.label;
        };
        return createVNode("div", mergeProps({
          "class": ["v-field", (_ref277 = {
            "v-field--active": isActive2.value,
            "v-field--appended": hasAppend,
            "v-field--center-affix": (_a2 = props.centerAffix) != null ? _a2 : !isPlainOrUnderlined.value,
            "v-field--disabled": props.disabled,
            "v-field--dirty": props.dirty,
            "v-field--error": props.error,
            "v-field--flat": props.flat,
            "v-field--has-background": !!props.bgColor,
            "v-field--persistent-clear": props.persistentClear,
            "v-field--prepended": hasPrepend,
            "v-field--reverse": props.reverse,
            "v-field--single-line": props.singleLine,
            "v-field--no-label": !label()
          }, _ref277["v-field--variant-" + props.variant] = true, _ref277), themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style],
          "onClick": onClick
        }, attrs), [createVNode("div", {
          "class": "v-field__overlay"
        }, null), createVNode(LoaderSlot, {
          "name": "v-field",
          "active": !!props.loading,
          "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
        }, {
          "default": slots.loader
        }), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-field__prepend-inner"
        }, [props.prependInnerIcon && createVNode(InputIcon, {
          "key": "prepend-icon",
          "name": "prependInner"
        }, null), (_b = slots["prepend-inner"]) == null ? void 0 : _b.call(slots, slotProps.value)]), createVNode("div", {
          "class": "v-field__field",
          "data-no-activator": ""
        }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
          "key": "floating-label",
          "ref": floatingLabelRef,
          "class": [textColorClasses.value],
          "floating": true,
          "for": id.value,
          "style": textColorStyles.value
        }, {
          "default": function () {
            return [label()];
          }
        }), createVNode(VFieldLabel, {
          "ref": labelRef,
          "for": id.value
        }, {
          "default": function () {
            return [label()];
          }
        }), (_c = slots.default) == null ? void 0 : _c.call(slots, _objectSpread(_objectSpread({}, slotProps.value), {}, {
          props: {
            id: id.value,
            "class": "v-field__input",
            "aria-describedby": messagesId.value
          },
          focus: focus2,
          blur: blur2
        }))]), hasClear && createVNode(VExpandXTransition, {
          "key": "clear"
        }, {
          "default": function () {
            return [withDirectives(createVNode("div", {
              "class": "v-field__clearable",
              "onMousedown": function (e) {
                e.preventDefault();
                e.stopPropagation();
              }
            }, [createVNode(VDefaultsProvider, {
              "defaults": {
                VIcon: {
                  icon: props.clearIcon
                }
              }
            }, {
              "default": function () {
                return [slots.clear ? slots.clear(_objectSpread(_objectSpread({}, slotProps.value), {}, {
                  props: {
                    onKeydown: onKeydownClear,
                    onFocus: focus2,
                    onBlur: blur2,
                    onClick: props["onClick:clear"]
                  }
                })) : createVNode(InputIcon, {
                  "name": "clear",
                  "onKeydown": onKeydownClear,
                  "onFocus": focus2,
                  "onBlur": blur2
                }, null)];
              }
            })]), [[vShow, props.dirty]])];
          }
        }), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-field__append-inner"
        }, [(_d = slots["append-inner"]) == null ? void 0 : _d.call(slots, slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
          "key": "append-icon",
          "name": "appendInner"
        }, null)]), createVNode("div", {
          "class": ["v-field__outline", textColorClasses.value],
          "style": textColorStyles.value
        }, [isOutlined && createVNode(Fragment$1, null, [createVNode("div", {
          "class": "v-field__outline__start"
        }, null), hasLabel.value && createVNode("div", {
          "class": "v-field__outline__notch"
        }, [createVNode(VFieldLabel, {
          "ref": floatingLabelRef,
          "floating": true,
          "for": id.value
        }, {
          "default": function () {
            return [label()];
          }
        })]), createVNode("div", {
          "class": "v-field__outline__end"
        }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
          "ref": floatingLabelRef,
          "floating": true,
          "for": id.value
        }, {
          "default": function () {
            return [label()];
          }
        })])]);
      });
      return {
        controlRef: controlRef
      };
    }
  });
  function filterFieldProps(attrs) {
    var keys2 = Object.keys(VField.props).filter(function (k) {
      return !isOn(k) && k !== "class" && k !== "style";
    });
    return pick(attrs, keys2);
  }
  var activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
  var makeVTextFieldProps = propsFactory(_objectSpread(_objectSpread({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: [Number, Function],
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    role: String,
    type: {
      type: String,
      "default": "text"
    },
    modelModifiers: Object
  }, makeVInputProps()), makeVFieldProps()), "VTextField");
  var VTextField = genericComponent()({
    name: "VTextField",
    directives: {
      Intersect: Intersect
    },
    inheritAttrs: false,
    props: makeVTextFieldProps(),
    emits: {
      "click:control": function (e) {
        return true;
      },
      "mousedown:control": function (e) {
        return true;
      },
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var _useFocus3 = useFocus(props),
        isFocused = _useFocus3.isFocused,
        focus2 = _useFocus3.focus,
        blur2 = _useFocus3.blur;
      var counterValue = computed(function () {
        var _a2;
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : ((_a2 = model.value) != null ? _a2 : "").toString().length;
      });
      var max = computed(function () {
        if (attrs.maxlength) return attrs.maxlength;
        if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string") return void 0;
        return props.counter;
      });
      var isPlainOrUnderlined = computed(function () {
        return ["plain", "underlined"].includes(props.variant);
      });
      function onIntersect(isIntersecting, entries) {
        var _a2, _b;
        if (!props.autofocus || !isIntersecting) return;
        (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
      }
      var vInputRef = ref();
      var vFieldRef = ref();
      var inputRef = ref();
      var isActive2 = computed(function () {
        return activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active;
      });
      function onFocus() {
        var _a2;
        if (inputRef.value !== document.activeElement) {
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        }
        if (!isFocused.value) focus2();
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
        if (e.target === inputRef.value) return;
        onFocus();
        e.preventDefault();
      }
      function onControlClick(e) {
        onFocus();
        emit2("click:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(function () {
          model.value = null;
          callEvent(props["onClick:clear"], e);
        });
      }
      function onInput(e) {
        var _a2;
        var el = e.target;
        model.value = el.value;
        if (((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) && ["text", "search", "password", "tel", "url"].includes(props.type)) {
          var caretPosition = [el.selectionStart, el.selectionEnd];
          nextTick(function () {
            el.selectionStart = caretPosition[0];
            el.selectionEnd = caretPosition[1];
          });
        }
      }
      useRender(function () {
        var hasCounter = !!(slots.counter || props.counter !== false && props.counter != null);
        var hasDetails = !!(hasCounter || slots.details);
        var _filterInputAttrs5 = filterInputAttrs(attrs),
          _filterInputAttrs6 = _slicedToArray(_filterInputAttrs5, 2),
          rootAttrs = _filterInputAttrs6[0],
          inputAttrs = _filterInputAttrs6[1];
        var _VInput$filterProps = VInput.filterProps(props),
          _ = _VInput$filterProps.modelValue,
          inputProps = _objectWithoutProperties(_VInput$filterProps, _excluded12);
        var fieldProps = filterFieldProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-text-field", {
            "v-text-field--prefixed": props.prefix,
            "v-text-field--suffixed": props.suffix,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "centerAffix": !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (_ref2) {
            var id = _ref2.id,
              isDisabled = _ref2.isDisabled,
              isDirty2 = _ref2.isDirty,
              isReadonly2 = _ref2.isReadonly,
              isValid2 = _ref2.isValid;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "onMousedown": onControlMousedown,
              "onClick": onControlClick,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"],
              "role": props.role
            }, fieldProps, {
              "id": id.value,
              "active": isActive2.value || isDirty2.value,
              "dirty": isDirty2.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid2.value === false
            }), _objectSpread(_objectSpread({}, slots), {}, {
              "default": function (_ref3) {
                var _ref3$props = _ref3.props,
                  fieldClass = _ref3$props.class,
                  slotProps = _objectWithoutProperties(_ref3$props, _excluded13);
                var inputNode = withDirectives(createVNode("input", mergeProps({
                  "ref": inputRef,
                  "value": model.value,
                  "onInput": onInput,
                  "autofocus": props.autofocus,
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "name": props.name,
                  "placeholder": props.placeholder,
                  "size": 1,
                  "type": props.type,
                  "onFocus": onFocus,
                  "onBlur": blur2
                }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                  handler: onIntersect
                }, null, {
                  once: true
                }]]);
                return createVNode(Fragment$1, null, [props.prefix && createVNode("span", {
                  "class": "v-text-field__prefix"
                }, [createVNode("span", {
                  "class": "v-text-field__prefix__text"
                }, [props.prefix])]), slots.default ? createVNode("div", {
                  "class": fieldClass,
                  "data-no-activator": ""
                }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                  "class": fieldClass
                }), props.suffix && createVNode("span", {
                  "class": "v-text-field__suffix"
                }, [createVNode("span", {
                  "class": "v-text-field__suffix__text"
                }, [props.suffix])])]);
              }
            }));
          },
          details: hasDetails ? function (slotProps) {
            var _a2;
            return createVNode(Fragment$1, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment$1, null, [createVNode("span", null, null), createVNode(VCounter, {
              "active": props.persistentCounter || isFocused.value,
              "value": counterValue.value,
              "max": max.value,
              "disabled": props.disabled
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, inputRef);
    }
  });
  var VVirtualScroll$1 = "";
  var makeVVirtualScrollItemProps = propsFactory(_objectSpread({
    renderless: Boolean
  }, makeComponentProps()), "VVirtualScrollItem");
  var VVirtualScrollItem = genericComponent()({
    name: "VVirtualScrollItem",
    inheritAttrs: false,
    props: makeVVirtualScrollItemProps(),
    emits: {
      "update:height": function (height) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var _useResizeObserver5 = useResizeObserver(void 0, "border"),
        resizeRef = _useResizeObserver5.resizeRef,
        contentRect = _useResizeObserver5.contentRect;
      watch(function () {
        var _a2;
        return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
      }, function (height) {
        if (height != null) emit2("update:height", height);
      });
      useRender(function () {
        var _a2, _b;
        return props.renderless ? createVNode(Fragment$1, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          itemRef: resizeRef
        })]) : createVNode("div", mergeProps({
          "ref": resizeRef,
          "class": ["v-virtual-scroll__item", props.class],
          "style": props.style
        }, attrs), [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
      });
    }
  });
  var UP = -1;
  var DOWN = 1;
  var BUFFER_PX = 100;
  var makeVirtualProps = propsFactory({
    itemHeight: {
      type: [Number, String],
      "default": null
    },
    height: [Number, String]
  }, "virtual");
  function useVirtual(props, items) {
    var display = useDisplay();
    var itemHeight = shallowRef(0);
    watchEffect(function () {
      itemHeight.value = parseFloat(props.itemHeight || 0);
    });
    var first2 = shallowRef(0);
    var last = shallowRef(Math.ceil((parseInt(props.height) || display.height.value) / (itemHeight.value || 16)) || 1);
    var paddingTop = shallowRef(0);
    var paddingBottom = shallowRef(0);
    var containerRef = ref();
    var markerRef = ref();
    var markerOffset = 0;
    var _useResizeObserver6 = useResizeObserver(),
      resizeRef = _useResizeObserver6.resizeRef,
      contentRect = _useResizeObserver6.contentRect;
    watchEffect(function () {
      resizeRef.value = containerRef.value;
    });
    var viewportHeight = computed(function () {
      var _a2;
      return containerRef.value === document.documentElement ? display.height.value : ((_a2 = contentRect.value) == null ? void 0 : _a2.height) || parseInt(props.height) || 0;
    });
    var hasInitialRender = computed(function () {
      return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);
    });
    var sizes = Array.from({
      length: items.value.length
    });
    var offsets = Array.from({
      length: items.value.length
    });
    var updateTime = shallowRef(0);
    var targetScrollIndex = -1;
    function getSize(index) {
      return sizes[index] || itemHeight.value;
    }
    var updateOffsets = debounce(function () {
      var start = performance.now();
      offsets[0] = 0;
      var length = items.value.length;
      for (var _i277 = 1; _i277 <= length - 1; _i277++) {
        offsets[_i277] = (offsets[_i277 - 1] || 0) + getSize(_i277 - 1);
      }
      updateTime.value = Math.max(updateTime.value, performance.now() - start);
    }, updateTime);
    var unwatch = watch(hasInitialRender, function (v) {
      if (!v) return;
      unwatch();
      markerOffset = markerRef.value.offsetTop;
      updateOffsets.immediate();
      calculateVisibleItems();
      if (!~targetScrollIndex) return;
      nextTick(function () {
        IN_BROWSER && window.requestAnimationFrame(function () {
          scrollToIndex(targetScrollIndex);
          targetScrollIndex = -1;
        });
      });
    });
    onScopeDispose(function () {
      updateOffsets.clear();
    });
    function handleItemResize(index, height) {
      var prevHeight = sizes[index];
      var prevMinHeight = itemHeight.value;
      itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;
      if (prevHeight !== height || prevMinHeight !== itemHeight.value) {
        sizes[index] = height;
        updateOffsets();
      }
    }
    function calculateOffset(index) {
      index = clamp(index, 0, items.value.length - 1);
      return offsets[index] || 0;
    }
    function calculateIndex(scrollTop) {
      return binaryClosest(offsets, scrollTop);
    }
    var lastScrollTop = 0;
    var scrollVelocity = 0;
    var lastScrollTime = 0;
    watch(viewportHeight, function (val, oldVal) {
      if (oldVal) {
        calculateVisibleItems();
        if (val < oldVal) {
          requestAnimationFrame(function () {
            scrollVelocity = 0;
            calculateVisibleItems();
          });
        }
      }
    });
    function handleScroll() {
      if (!containerRef.value || !markerRef.value) return;
      var scrollTop = containerRef.value.scrollTop;
      var scrollTime = performance.now();
      var scrollDeltaT = scrollTime - lastScrollTime;
      if (scrollDeltaT > 500) {
        scrollVelocity = Math.sign(scrollTop - lastScrollTop);
        markerOffset = markerRef.value.offsetTop;
      } else {
        scrollVelocity = scrollTop - lastScrollTop;
      }
      lastScrollTop = scrollTop;
      lastScrollTime = scrollTime;
      calculateVisibleItems();
    }
    function handleScrollend() {
      if (!containerRef.value || !markerRef.value) return;
      scrollVelocity = 0;
      lastScrollTime = 0;
      calculateVisibleItems();
    }
    var raf2 = -1;
    function calculateVisibleItems() {
      cancelAnimationFrame(raf2);
      raf2 = requestAnimationFrame(_calculateVisibleItems);
    }
    function _calculateVisibleItems() {
      if (!containerRef.value || !viewportHeight.value) return;
      var scrollTop = lastScrollTop - markerOffset;
      var direction = Math.sign(scrollVelocity);
      var startPx = Math.max(0, scrollTop - BUFFER_PX);
      var start = clamp(calculateIndex(startPx), 0, items.value.length);
      var endPx = scrollTop + viewportHeight.value + BUFFER_PX;
      var end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);
      if ((direction !== UP || start < first2.value) && (direction !== DOWN || end > last.value)) {
        var topOverflow = calculateOffset(first2.value) - calculateOffset(start);
        var bottomOverflow = calculateOffset(end) - calculateOffset(last.value);
        var bufferOverflow = Math.max(topOverflow, bottomOverflow);
        if (bufferOverflow > BUFFER_PX) {
          first2.value = start;
          last.value = end;
        } else {
          if (start <= 0) first2.value = start;
          if (end >= items.value.length) last.value = end;
        }
      }
      paddingTop.value = calculateOffset(first2.value);
      paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);
    }
    function scrollToIndex(index) {
      var offset = calculateOffset(index);
      if (!containerRef.value || index && !offset) {
        targetScrollIndex = index;
      } else {
        containerRef.value.scrollTop = offset;
      }
    }
    var computedItems = computed(function () {
      return items.value.slice(first2.value, last.value).map(function (item, index) {
        return {
          raw: item,
          index: index + first2.value
        };
      });
    });
    watch(items, function () {
      sizes = Array.from({
        length: items.value.length
      });
      offsets = Array.from({
        length: items.value.length
      });
      updateOffsets.immediate();
      calculateVisibleItems();
    }, {
      deep: true
    });
    return {
      calculateVisibleItems: calculateVisibleItems,
      containerRef: containerRef,
      markerRef: markerRef,
      computedItems: computedItems,
      paddingTop: paddingTop,
      paddingBottom: paddingBottom,
      scrollToIndex: scrollToIndex,
      handleScroll: handleScroll,
      handleScrollend: handleScrollend,
      handleItemResize: handleItemResize
    };
  }
  function binaryClosest(arr, val) {
    var high = arr.length - 1;
    var low = 0;
    var mid = 0;
    var item = null;
    var target = -1;
    if (arr[high] < val) {
      return high;
    }
    while (low <= high) {
      mid = low + high >> 1;
      item = arr[mid];
      if (item > val) {
        high = mid - 1;
      } else if (item < val) {
        target = mid;
        low = mid + 1;
      } else if (item === val) {
        return mid;
      } else {
        return low;
      }
    }
    return target;
  }
  var makeVVirtualScrollProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    renderless: Boolean
  }, makeVirtualProps()), makeComponentProps()), makeDimensionProps()), "VVirtualScroll");
  var VVirtualScroll = genericComponent()({
    name: "VVirtualScroll",
    props: makeVVirtualScrollProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var vm = getCurrentInstance("VVirtualScroll");
      var _useDimension8 = useDimension(props),
        dimensionStyles = _useDimension8.dimensionStyles;
      var _useVirtual = useVirtual(props, toRef(props, "items")),
        calculateVisibleItems = _useVirtual.calculateVisibleItems,
        containerRef = _useVirtual.containerRef,
        markerRef = _useVirtual.markerRef,
        handleScroll = _useVirtual.handleScroll,
        handleScrollend = _useVirtual.handleScrollend,
        handleItemResize = _useVirtual.handleItemResize,
        scrollToIndex = _useVirtual.scrollToIndex,
        paddingTop = _useVirtual.paddingTop,
        paddingBottom = _useVirtual.paddingBottom,
        computedItems = _useVirtual.computedItems;
      useToggleScope(function () {
        return props.renderless;
      }, function () {
        function handleListeners() {
          var _a2, _b;
          var add = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var method = add ? "addEventListener" : "removeEventListener";
          if (containerRef.value === document.documentElement) {
            document[method]("scroll", handleScroll, {
              passive: true
            });
            document[method]("scrollend", handleScrollend);
          } else {
            (_a2 = containerRef.value) == null ? void 0 : _a2[method]("scroll", handleScroll, {
              passive: true
            });
            (_b = containerRef.value) == null ? void 0 : _b[method]("scrollend", handleScrollend);
          }
        }
        onMounted(function () {
          containerRef.value = getScrollParent(vm.vnode.el, true);
          handleListeners(true);
        });
        onScopeDispose(handleListeners);
      });
      useRender(function () {
        var children = computedItems.value.map(function (item) {
          return createVNode(VVirtualScrollItem, {
            "key": item.index,
            "renderless": props.renderless,
            "onUpdate:height": function (height) {
              return handleItemResize(item.index, height);
            }
          }, {
            "default": function (slotProps) {
              var _a2;
              return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, _objectSpread({
                item: item.raw,
                index: item.index
              }, slotProps));
            }
          });
        });
        return props.renderless ? createVNode(Fragment$1, null, [createVNode("div", {
          "ref": markerRef,
          "class": "v-virtual-scroll__spacer",
          "style": {
            paddingTop: convertToUnit(paddingTop.value)
          }
        }, null), children, createVNode("div", {
          "class": "v-virtual-scroll__spacer",
          "style": {
            paddingBottom: convertToUnit(paddingBottom.value)
          }
        }, null)]) : createVNode("div", {
          "ref": containerRef,
          "class": ["v-virtual-scroll", props.class],
          "onScrollPassive": handleScroll,
          "onScrollend": handleScrollend,
          "style": [dimensionStyles.value, props.style]
        }, [createVNode("div", {
          "ref": markerRef,
          "class": "v-virtual-scroll__container",
          "style": {
            paddingTop: convertToUnit(paddingTop.value),
            paddingBottom: convertToUnit(paddingBottom.value)
          }
        }, [children])]);
      });
      return {
        calculateVisibleItems: calculateVisibleItems,
        scrollToIndex: scrollToIndex
      };
    }
  });
  function useScrolling(listRef, textFieldRef) {
    var isScrolling = shallowRef(false);
    var scrollTimeout;
    function onListScroll(e) {
      cancelAnimationFrame(scrollTimeout);
      isScrolling.value = true;
      scrollTimeout = requestAnimationFrame(function () {
        scrollTimeout = requestAnimationFrame(function () {
          isScrolling.value = false;
        });
      });
    }
    function finishScrolling() {
      return _regeneratorRuntime.async(function finishScrolling$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
              return requestAnimationFrame(resolve2);
            }));
          case 2:
            _context15.next = 4;
            return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
              return requestAnimationFrame(resolve2);
            }));
          case 4:
            _context15.next = 6;
            return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
              return requestAnimationFrame(resolve2);
            }));
          case 6:
            _context15.next = 8;
            return _regeneratorRuntime.awrap(new Promise(function (resolve2) {
              if (isScrolling.value) {
                var stop = watch(isScrolling, function () {
                  stop();
                  resolve2();
                });
              } else resolve2();
            }));
          case 8:
          case "end":
            return _context15.stop();
        }
      }, null, null, null, Promise);
    }
    function onListKeydown(e) {
      var _a2, _b, el, children, top, _iterator54, _step56, child, bottom, _iterator55, _step57, _child4;
      return _regeneratorRuntime.async(function onListKeydown$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            if (e.key === "Tab") {
              (_a2 = textFieldRef.value) == null ? void 0 : _a2.focus();
            }
            if (["PageDown", "PageUp", "Home", "End"].includes(e.key)) {
              _context16.next = 3;
              break;
            }
            return _context16.abrupt("return");
          case 3:
            el = (_b = listRef.value) == null ? void 0 : _b.$el;
            if (el) {
              _context16.next = 6;
              break;
            }
            return _context16.abrupt("return");
          case 6:
            if (e.key === "Home" || e.key === "End") {
              el.scrollTo({
                top: e.key === "Home" ? 0 : el.scrollHeight,
                behavior: "smooth"
              });
            }
            _context16.next = 9;
            return _regeneratorRuntime.awrap(finishScrolling());
          case 9:
            children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
            if (!(e.key === "PageDown" || e.key === "Home")) {
              _context16.next = 22;
              break;
            }
            top = el.getBoundingClientRect().top;
            _iterator54 = _createForOfIteratorHelperLoose(children);
          case 13:
            if ((_step56 = _iterator54()).done) {
              _context16.next = 20;
              break;
            }
            child = _step56.value;
            if (!(child.getBoundingClientRect().top >= top)) {
              _context16.next = 18;
              break;
            }
            child.focus();
            return _context16.abrupt("break", 20);
          case 18:
            _context16.next = 13;
            break;
          case 20:
            _context16.next = 31;
            break;
          case 22:
            bottom = el.getBoundingClientRect().bottom;
            _iterator55 = _createForOfIteratorHelperLoose(_toConsumableArray(children).reverse());
          case 24:
            if ((_step57 = _iterator55()).done) {
              _context16.next = 31;
              break;
            }
            _child4 = _step57.value;
            if (!(_child4.getBoundingClientRect().bottom <= bottom)) {
              _context16.next = 29;
              break;
            }
            _child4.focus();
            return _context16.abrupt("break", 31);
          case 29:
            _context16.next = 24;
            break;
          case 31:
          case "end":
            return _context16.stop();
        }
      }, null, null, null, Promise);
    }
    return {
      onScrollPassive: onListScroll,
      onKeydown: onListKeydown
    };
  }
  var makeSelectProps = propsFactory(_objectSpread({
    chips: Boolean,
    closableChips: Boolean,
    closeText: {
      type: String,
      "default": "$vuetify.close"
    },
    openText: {
      type: String,
      "default": "$vuetify.open"
    },
    eager: Boolean,
    hideNoData: Boolean,
    hideSelected: Boolean,
    listProps: {
      type: Object
    },
    menu: Boolean,
    menuIcon: {
      type: IconValue,
      "default": "$dropdown"
    },
    menuProps: {
      type: Object
    },
    multiple: Boolean,
    noDataText: {
      type: String,
      "default": "$vuetify.noDataText"
    },
    openOnClear: Boolean,
    itemColor: String
  }, makeItemsProps({
    itemChildren: false
  })), "Select");
  var makeVSelectProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({}, makeSelectProps()), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps({
    transition: {
      component: VDialogTransition
    }
  })), "VSelect");
  var VSelect = genericComponent()({
    name: "VSelect",
    props: makeVSelectProps(),
    emits: {
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      "update:menu": function (ue) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useLocale4 = useLocale(),
        t = _useLocale4.t;
      var vTextFieldRef = ref();
      var vMenuRef = ref();
      var vVirtualScrollRef = ref();
      var _menu = useProxiedModel(props, "menu");
      var menu = computed({
        get: function () {
          return _menu.value;
        },
        set: function (v) {
          var _a2;
          if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.openChildren.size)) return;
          _menu.value = v;
        }
      });
      var _useItems = useItems(props),
        items = _useItems.items,
        transformIn = _useItems.transformIn,
        transformOut = _useItems.transformOut;
      var model = useProxiedModel(props, "modelValue", [], function (v) {
        return transformIn(v === null ? [null] : wrapInArray(v));
      }, function (v) {
        var _a2;
        var transformed = transformOut(v);
        return props.multiple ? transformed : (_a2 = transformed[0]) != null ? _a2 : null;
      });
      var counterValue = computed(function () {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
      });
      var form = useForm();
      var selectedValues = computed(function () {
        return model.value.map(function (selection) {
          return selection.value;
        });
      });
      var isFocused = shallowRef(false);
      var label = computed(function () {
        return menu.value ? props.closeText : props.openText;
      });
      var keyboardLookupPrefix = "";
      var keyboardLookupLastTime;
      var displayItems = computed(function () {
        if (props.hideSelected) {
          return items.value.filter(function (item) {
            return !model.value.some(function (s) {
              return props.valueComparator(s, item);
            });
          });
        }
        return items.value;
      });
      var menuDisabled = computed(function () {
        return props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value);
      });
      var computedMenuProps = computed(function () {
        var _a2;
        return _objectSpread(_objectSpread({}, props.menuProps), {}, {
          activatorProps: _objectSpread(_objectSpread({}, ((_a2 = props.menuProps) == null ? void 0 : _a2.activatorProps) || {}), {}, {
            "aria-haspopup": "listbox"
          })
        });
      });
      var listRef = ref();
      var listEvents = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        if (props.openOnClear) {
          menu.value = true;
        }
      }
      function onMousedownControl() {
        if (menuDisabled.value) return;
        menu.value = !menu.value;
      }
      function onListKeydown(e) {
        if (checkPrintable(e)) {
          onKeydown(e);
        }
      }
      function onKeydown(e) {
        var _a2, _b;
        if (!e.key || props.readonly || (form == null ? void 0 : form.isReadonly.value)) return;
        if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown", " "].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape", "Tab"].includes(e.key)) {
          menu.value = false;
        }
        if (e.key === "Home") {
          (_a2 = listRef.value) == null ? void 0 : _a2.focus("first");
        } else if (e.key === "End") {
          (_b = listRef.value) == null ? void 0 : _b.focus("last");
        }
        var KEYBOARD_LOOKUP_THRESHOLD = 1e3;
        if (props.multiple || !checkPrintable(e)) return;
        var now2 = performance.now();
        if (now2 - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
          keyboardLookupPrefix = "";
        }
        keyboardLookupPrefix += e.key.toLowerCase();
        keyboardLookupLastTime = now2;
        var item = items.value.find(function (item2) {
          return item2.title.toLowerCase().startsWith(keyboardLookupPrefix);
        });
        if (item !== void 0) {
          model.value = [item];
          var index = displayItems.value.indexOf(item);
          IN_BROWSER && window.requestAnimationFrame(function () {
            var _a3;
            index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
          });
        }
      }
      function select(item) {
        var set = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (item.props.disabled) return;
        if (props.multiple) {
          var index = model.value.findIndex(function (selection) {
            return props.valueComparator(selection.value, item.value);
          });
          var add = set == null ? !~index : set;
          if (~index) {
            var value = add ? [].concat(_toConsumableArray(model.value), [item]) : _toConsumableArray(model.value);
            value.splice(index, 1);
            model.value = value;
          } else if (add) {
            model.value = [].concat(_toConsumableArray(model.value), [item]);
          }
        } else {
          var _add = set !== false;
          model.value = _add ? [item] : [];
          nextTick(function () {
            menu.value = false;
          });
        }
      }
      function onBlur(e) {
        var _a2;
        if (!((_a2 = listRef.value) == null ? void 0 : _a2.$el.contains(e.relatedTarget))) {
          menu.value = false;
        }
      }
      function onAfterEnter() {
        var _a2;
        if (props.eager) {
          (_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.calculateVisibleItems();
        }
      }
      function onAfterLeave() {
        var _a2;
        if (isFocused.value) {
          (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
      }
      function onModelUpdate(v) {
        if (v == null) model.value = [];else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
          var item = items.value.find(function (item2) {
            return item2.title === v;
          });
          if (item) {
            select(item);
          }
        } else if (vTextFieldRef.value) {
          vTextFieldRef.value.value = "";
        }
      }
      watch(menu, function () {
        if (!props.hideSelected && menu.value && model.value.length) {
          var index = displayItems.value.findIndex(function (item) {
            return model.value.some(function (s) {
              return props.valueComparator(s.value, item.value);
            });
          });
          IN_BROWSER && window.requestAnimationFrame(function () {
            var _a2;
            index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
          });
        }
      });
      watch(function () {
        return props.items;
      }, function (newVal, oldVal) {
        if (menu.value) return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(function () {
        var _ref278;
        var hasChips = !!(props.chips || slots.chip);
        var hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        var isDirty2 = model.value.length > 0;
        var textFieldProps = VTextField.filterProps(props);
        var placeholder = isDirty2 || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": model.value.map(function (v) {
            return v.props.value;
          }).join(", "),
          "onUpdate:modelValue": onModelUpdate,
          "focused": isFocused.value,
          "onUpdate:focused": function ($event) {
            return isFocused.value = $event;
          },
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty2,
          "class": ["v-select", (_ref278 = {
            "v-select--active-menu": menu.value,
            "v-select--chips": !!props.chips
          }, _ref278["v-select--" + (props.multiple ? "multiple" : "single")] = true, _ref278["v-select--selected"] = model.value.length, _ref278["v-select--selection-slot"] = !!slots.selection, _ref278), props.class],
          "style": props.style,
          "inputmode": "none",
          "placeholder": placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onBlur": onBlur,
          "onKeydown": onKeydown,
          "aria-label": t(label.value),
          "title": t(label.value)
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function () {
            return createVNode(Fragment$1, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": function ($event) {
                return menu.value = $event;
              },
              "activator": "parent",
              "contentClass": "v-select__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterEnter": onAfterEnter,
              "onAfterLeave": onAfterLeave
            }, computedMenuProps.value), {
              "default": function () {
                var _a2;
                return [hasList && createVNode(VList, mergeProps({
                  "ref": listRef,
                  "selected": selectedValues.value,
                  "selectStrategy": props.multiple ? "independent" : "single-independent",
                  "onMousedown": function (e) {
                    return e.preventDefault();
                  },
                  "onKeydown": onListKeydown,
                  "onFocusin": onFocusin,
                  "tabindex": "-1",
                  "aria-live": "polite",
                  "color": (_a2 = props.itemColor) != null ? _a2 : props.color
                }, listEvents, props.listProps), {
                  "default": function () {
                    var _a3, _b, _c, _d;
                    return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) != null ? _c : createVNode(VListItem, {
                      "title": t(props.noDataText)
                    }, null)), createVNode(VVirtualScroll, {
                      "ref": vVirtualScrollRef,
                      "renderless": true,
                      "items": displayItems.value
                    }, {
                      "default": function (_ref2) {
                        var _a4, _b2;
                        var item = _ref2.item,
                          index = _ref2.index,
                          itemRef = _ref2.itemRef;
                        var itemProps = mergeProps(item.props, {
                          ref: itemRef,
                          key: index,
                          onClick: function () {
                            return select(item, null);
                          }
                        });
                        return (_b2 = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                          item: item,
                          index: index,
                          props: itemProps
                        })) != null ? _b2 : createVNode(VListItem, mergeProps(itemProps, {
                          "role": "option"
                        }), {
                          prepend: function (_ref3) {
                            var isSelected = _ref3.isSelected;
                            return createVNode(Fragment$1, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                              "key": item.value,
                              "modelValue": isSelected,
                              "ripple": false,
                              "tabindex": "-1"
                            }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                              "image": item.props.prependAvatar
                            }, null), item.props.prependIcon && createVNode(VIcon, {
                              "icon": item.props.prependIcon
                            }, null)]);
                          }
                        });
                      }
                    }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                  }
                })];
              }
            }), model.value.map(function (item, index) {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              var slotProps = {
                "onClick:close": onChipClose,
                onKeydown: function (e) {
                  if (e.key !== "Enter" && e.key !== " ") return;
                  e.preventDefault();
                  e.stopPropagation();
                  onChipClose(e);
                },
                onMousedown: function (e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              var hasSlot = hasChips ? !!slots.chip : !!slots.selection;
              var slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
                item: item,
                index: index,
                props: slotProps
              }) : slots.selection({
                item: item,
                index: index
              })) : void 0;
              if (hasSlot && !slotContent) return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": "v-select__selection"
              }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                "default": function () {
                  return [slotContent];
                }
              }) : slotContent != null ? slotContent : createVNode("span", {
                "class": "v-select__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-select__selection-comma"
              }, [createTextVNode(",")])])]);
            })]);
          },
          "append-inner": function () {
            var _a8;
            var _a2;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(Fragment$1, null, [(_a2 = slots["append-inner"]) == null ? void 0 : (_a8 = _a2).call.apply(_a8, [slots].concat(args)), props.menuIcon ? createVNode(VIcon, {
              "class": "v-select__menu-icon",
              "icon": props.menuIcon
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused: isFocused,
        menu: menu,
        select: select
      }, vTextFieldRef);
    }
  });
  var defaultFilter = function (value, query, item) {
    if (value == null || query == null) return -1;
    return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
  };
  var makeFilterProps = propsFactory({
    customFilter: Function,
    customKeyFilter: Object,
    filterKeys: [Array, String],
    filterMode: {
      type: String,
      "default": "intersection"
    },
    noFilter: Boolean
  }, "filter");
  function filterItems(items, query, options) {
    var _a2, _b, _c;
    var array = [];
    var filter = (_a2 = options == null ? void 0 : options.default) != null ? _a2 : defaultFilter;
    var keys2 = (options == null ? void 0 : options.filterKeys) ? wrapInArray(options.filterKeys) : false;
    var customFiltersLength = Object.keys((_b = options == null ? void 0 : options.customKeyFilter) != null ? _b : {}).length;
    if (!(items == null ? void 0 : items.length)) return array;
    loop: for (var _i278 = 0; _i278 < items.length; _i278++) {
      var _wrapInArray = wrapInArray(items[_i278]),
        _wrapInArray2 = _slicedToArray(_wrapInArray, 2),
        item = _wrapInArray2[0],
        _wrapInArray2$ = _wrapInArray2[1],
        transformed = _wrapInArray2$ === void 0 ? item : _wrapInArray2$;
      var customMatches = {};
      var defaultMatches = {};
      var match = -1;
      if ((query || customFiltersLength > 0) && !(options == null ? void 0 : options.noFilter)) {
        if (_typeof(item) === "object") {
          var filterKeys = keys2 || Object.keys(transformed);
          for (var _iterator56 = _createForOfIteratorHelperLoose(filterKeys), _step58; !(_step58 = _iterator56()).done;) {
            var key = _step58.value;
            var value = getPropertyFromItem(transformed, key);
            var keyFilter = (_c = options == null ? void 0 : options.customKeyFilter) == null ? void 0 : _c[key];
            match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
            if (match !== -1 && match !== false) {
              if (keyFilter) customMatches[key] = match;else defaultMatches[key] = match;
            } else if ((options == null ? void 0 : options.filterMode) === "every") {
              continue loop;
            }
          }
        } else {
          match = filter(item, query, item);
          if (match !== -1 && match !== false) {
            defaultMatches.title = match;
          }
        }
        var defaultMatchesLength = Object.keys(defaultMatches).length;
        var customMatchesLength = Object.keys(customMatches).length;
        if (!defaultMatchesLength && !customMatchesLength) continue;
        if ((options == null ? void 0 : options.filterMode) === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength) continue;
        if ((options == null ? void 0 : options.filterMode) === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength)) continue;
      }
      array.push({
        index: _i278,
        matches: _objectSpread(_objectSpread({}, defaultMatches), customMatches)
      });
    }
    return array;
  }
  function useFilter(props, items, query, options) {
    var filteredItems = ref([]);
    var filteredMatches = ref( /* @__PURE__ */new Map());
    var transformedItems = computed(function () {
      return (options == null ? void 0 : options.transform) ? unref(items).map(function (item) {
        return [item, options.transform(item)];
      }) : unref(items);
    });
    watchEffect(function () {
      var _query = typeof query === "function" ? query() : unref(query);
      var strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
      var results = filterItems(transformedItems.value, strQuery, {
        customKeyFilter: _objectSpread(_objectSpread({}, props.customKeyFilter), unref(options == null ? void 0 : options.customKeyFilter)),
        "default": props.customFilter,
        filterKeys: props.filterKeys,
        filterMode: props.filterMode,
        noFilter: props.noFilter
      });
      var originalItems = unref(items);
      var _filteredItems = [];
      var _filteredMatches = /* @__PURE__ */new Map();
      results.forEach(function (_ref) {
        var index = _ref.index,
          matches2 = _ref.matches;
        var item = originalItems[index];
        _filteredItems.push(item);
        _filteredMatches.set(item.value, matches2);
      });
      filteredItems.value = _filteredItems;
      filteredMatches.value = _filteredMatches;
    });
    function getMatches(item) {
      return filteredMatches.value.get(item.value);
    }
    return {
      filteredItems: filteredItems,
      filteredMatches: filteredMatches,
      getMatches: getMatches
    };
  }
  function highlightResult$1(text, matches2, length) {
    if (matches2 == null) return text;
    if (Array.isArray(matches2)) throw new Error("Multiple matches is not implemented");
    return typeof matches2 === "number" && ~matches2 ? createVNode(Fragment$1, null, [createVNode("span", {
      "class": "v-autocomplete__unmask"
    }, [text.substr(0, matches2)]), createVNode("span", {
      "class": "v-autocomplete__mask"
    }, [text.substr(matches2, length)]), createVNode("span", {
      "class": "v-autocomplete__unmask"
    }, [text.substr(matches2 + length)])]) : text;
  }
  var makeVAutocompleteProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    autoSelectFirst: {
      type: [Boolean, String]
    },
    clearOnSelect: Boolean,
    search: String
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps()), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps({
    transition: false
  })), "VAutocomplete");
  var VAutocomplete = genericComponent()({
    name: "VAutocomplete",
    props: makeVAutocompleteProps(),
    emits: {
      "update:focused": function (focused) {
        return true;
      },
      "update:search": function (value) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      "update:menu": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useLocale5 = useLocale(),
        t = _useLocale5.t;
      var vTextFieldRef = ref();
      var isFocused = shallowRef(false);
      var isPristine = shallowRef(true);
      var listHasFocus = shallowRef(false);
      var vMenuRef = ref();
      var vVirtualScrollRef = ref();
      var _menu = useProxiedModel(props, "menu");
      var menu = computed({
        get: function () {
          return _menu.value;
        },
        set: function (v) {
          var _a2;
          if (_menu.value && !v && ((_a2 = vMenuRef.value) == null ? void 0 : _a2.openChildren.size)) return;
          _menu.value = v;
        }
      });
      var selectionIndex = shallowRef(-1);
      var color = computed(function () {
        var _a2;
        return (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.color;
      });
      var label = computed(function () {
        return menu.value ? props.closeText : props.openText;
      });
      var _useItems2 = useItems(props),
        items = _useItems2.items,
        transformIn = _useItems2.transformIn,
        transformOut = _useItems2.transformOut;
      var _useTextColor11 = useTextColor(color),
        textColorClasses = _useTextColor11.textColorClasses,
        textColorStyles = _useTextColor11.textColorStyles;
      var search = useProxiedModel(props, "search", "");
      var model = useProxiedModel(props, "modelValue", [], function (v) {
        return transformIn(v === null ? [null] : wrapInArray(v));
      }, function (v) {
        var _a2;
        var transformed = transformOut(v);
        return props.multiple ? transformed : (_a2 = transformed[0]) != null ? _a2 : null;
      });
      var counterValue = computed(function () {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : model.value.length;
      });
      var form = useForm();
      var _useFilter = useFilter(props, items, function () {
          return isPristine.value ? "" : search.value;
        }),
        filteredItems = _useFilter.filteredItems,
        getMatches = _useFilter.getMatches;
      var displayItems = computed(function () {
        if (props.hideSelected) {
          return filteredItems.value.filter(function (filteredItem) {
            return !model.value.some(function (s) {
              return s.value === filteredItem.value;
            });
          });
        }
        return filteredItems.value;
      });
      var hasChips = computed(function () {
        return !!(props.chips || slots.chip);
      });
      var hasSelectionSlot = computed(function () {
        return hasChips.value || !!slots.selection;
      });
      var selectedValues = computed(function () {
        return model.value.map(function (selection) {
          return selection.props.value;
        });
      });
      var highlightFirst = computed(function () {
        var _a2;
        var selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a2 = displayItems.value[0]) == null ? void 0 : _a2.title);
        return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
      });
      var menuDisabled = computed(function () {
        return props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value);
      });
      var listRef = ref();
      var listEvents = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        if (props.openOnClear) {
          menu.value = true;
        }
        search.value = "";
      }
      function onMousedownControl() {
        if (menuDisabled.value) return;
        menu.value = true;
      }
      function onMousedownMenuIcon(e) {
        if (menuDisabled.value) return;
        if (isFocused.value) {
          e.preventDefault();
          e.stopPropagation();
        }
        menu.value = !menu.value;
      }
      function onListKeydown(e) {
        var _a2;
        if (checkPrintable(e)) {
          (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
        }
      }
      function onKeydown(e) {
        var _a2, _b, _c;
        if (props.readonly || (form == null ? void 0 : form.isReadonly.value)) return;
        var selectionStart = vTextFieldRef.value.selectionStart;
        var length = model.value.length;
        if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown"].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape"].includes(e.key)) {
          menu.value = false;
        }
        if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some(function (_ref2) {
          var value = _ref2.value;
          return value === displayItems.value[0].value;
        })) {
          select(displayItems.value[0]);
        }
        if (e.key === "ArrowDown" && highlightFirst.value) {
          (_a2 = listRef.value) == null ? void 0 : _a2.focus("next");
        }
        if (["Backspace", "Delete"].includes(e.key)) {
          if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value) return select(model.value[0], false);
          if (~selectionIndex.value) {
            var originalSelectionIndex = selectionIndex.value;
            select(model.value[selectionIndex.value], false);
            selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
          } else if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
        }
        if (!props.multiple) return;
        if (e.key === "ArrowLeft") {
          if (selectionIndex.value < 0 && selectionStart > 0) return;
          var prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
          if (model.value[prev]) {
            selectionIndex.value = prev;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange((_b = search.value) == null ? void 0 : _b.length, (_c = search.value) == null ? void 0 : _c.length);
          }
        }
        if (e.key === "ArrowRight") {
          if (selectionIndex.value < 0) return;
          var next = selectionIndex.value + 1;
          if (model.value[next]) {
            selectionIndex.value = next;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange(0, 0);
          }
        }
      }
      function onChange(e) {
        if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
          var item = items.value.find(function (item2) {
            return item2.title === e.target.value;
          });
          if (item) {
            select(item);
          }
        }
      }
      function onAfterEnter() {
        var _a2;
        if (props.eager) {
          (_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.calculateVisibleItems();
        }
      }
      function onAfterLeave() {
        var _a2;
        if (isFocused.value) {
          isPristine.value = true;
          (_a2 = vTextFieldRef.value) == null ? void 0 : _a2.focus();
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
        setTimeout(function () {
          listHasFocus.value = true;
        });
      }
      function onFocusout(e) {
        listHasFocus.value = false;
      }
      function onUpdateModelValue(v) {
        if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value) model.value = [];
      }
      var isSelecting = shallowRef(false);
      function select(item) {
        var set = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (!item || item.props.disabled) return;
        if (props.multiple) {
          var index = model.value.findIndex(function (selection) {
            return props.valueComparator(selection.value, item.value);
          });
          var add = set == null ? !~index : set;
          if (~index) {
            var value = add ? [].concat(_toConsumableArray(model.value), [item]) : _toConsumableArray(model.value);
            value.splice(index, 1);
            model.value = value;
          } else if (add) {
            model.value = [].concat(_toConsumableArray(model.value), [item]);
          }
          if (props.clearOnSelect) {
            search.value = "";
          }
        } else {
          var _add2 = set !== false;
          model.value = _add2 ? [item] : [];
          search.value = _add2 && !hasSelectionSlot.value ? item.title : "";
          nextTick(function () {
            menu.value = false;
            isPristine.value = true;
          });
        }
      }
      watch(isFocused, function (val, oldVal) {
        var _a2, _b;
        if (val === oldVal) return;
        if (val) {
          isSelecting.value = true;
          search.value = props.multiple || hasSelectionSlot.value ? "" : String((_b = (_a2 = model.value.at(-1)) == null ? void 0 : _a2.props.title) != null ? _b : "");
          isPristine.value = true;
          nextTick(function () {
            return isSelecting.value = false;
          });
        } else {
          if (!props.multiple && search.value == null) model.value = [];
          menu.value = false;
          if (!model.value.some(function (_ref3) {
            var title = _ref3.title;
            return title === search.value;
          })) search.value = "";
          selectionIndex.value = -1;
        }
      });
      watch(search, function (val) {
        if (!isFocused.value || isSelecting.value) return;
        if (val) menu.value = true;
        isPristine.value = !val;
      });
      watch(menu, function () {
        if (!props.hideSelected && menu.value && model.value.length) {
          var index = displayItems.value.findIndex(function (item) {
            return model.value.some(function (s) {
              return item.value === s.value;
            });
          });
          IN_BROWSER && window.requestAnimationFrame(function () {
            var _a2;
            index >= 0 && ((_a2 = vVirtualScrollRef.value) == null ? void 0 : _a2.scrollToIndex(index));
          });
        }
      });
      watch(function () {
        return props.items;
      }, function (newVal, oldVal) {
        if (menu.value) return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(function () {
        var hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        var isDirty2 = model.value.length > 0;
        var textFieldProps = VTextField.filterProps(props);
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": search.value,
          "onUpdate:modelValue": [function ($event) {
            return search.value = $event;
          }, onUpdateModelValue],
          "focused": isFocused.value,
          "onUpdate:focused": function ($event) {
            return isFocused.value = $event;
          },
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty2,
          "onChange": onChange,
          "class": ["v-autocomplete", "v-autocomplete--" + (props.multiple ? "multiple" : "single"), {
            "v-autocomplete--active-menu": menu.value,
            "v-autocomplete--chips": !!props.chips,
            "v-autocomplete--selection-slot": !!hasSelectionSlot.value,
            "v-autocomplete--selecting-index": selectionIndex.value > -1
          }, props.class],
          "style": props.style,
          "readonly": props.readonly,
          "placeholder": isDirty2 ? void 0 : props.placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onKeydown": onKeydown
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function () {
            return createVNode(Fragment$1, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": function ($event) {
                return menu.value = $event;
              },
              "activator": "parent",
              "contentClass": "v-autocomplete__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterEnter": onAfterEnter,
              "onAfterLeave": onAfterLeave
            }, props.menuProps), {
              "default": function () {
                var _a2;
                return [hasList && createVNode(VList, mergeProps({
                  "ref": listRef,
                  "selected": selectedValues.value,
                  "selectStrategy": props.multiple ? "independent" : "single-independent",
                  "onMousedown": function (e) {
                    return e.preventDefault();
                  },
                  "onKeydown": onListKeydown,
                  "onFocusin": onFocusin,
                  "onFocusout": onFocusout,
                  "tabindex": "-1",
                  "aria-live": "polite",
                  "color": (_a2 = props.itemColor) != null ? _a2 : props.color
                }, listEvents, props.listProps), {
                  "default": function () {
                    var _a3, _b, _c, _d;
                    return [(_a3 = slots["prepend-item"]) == null ? void 0 : _a3.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b = slots["no-data"]) == null ? void 0 : _b.call(slots)) != null ? _c : createVNode(VListItem, {
                      "title": t(props.noDataText)
                    }, null)), createVNode(VVirtualScroll, {
                      "ref": vVirtualScrollRef,
                      "renderless": true,
                      "items": displayItems.value
                    }, {
                      "default": function (_ref4) {
                        var _a4, _b2;
                        var item = _ref4.item,
                          index = _ref4.index,
                          itemRef = _ref4.itemRef;
                        var itemProps = mergeProps(item.props, {
                          ref: itemRef,
                          key: index,
                          active: highlightFirst.value && index === 0 ? true : void 0,
                          onClick: function () {
                            return select(item, null);
                          }
                        });
                        return (_b2 = (_a4 = slots.item) == null ? void 0 : _a4.call(slots, {
                          item: item,
                          index: index,
                          props: itemProps
                        })) != null ? _b2 : createVNode(VListItem, mergeProps(itemProps, {
                          "role": "option"
                        }), {
                          prepend: function (_ref5) {
                            var isSelected = _ref5.isSelected;
                            return createVNode(Fragment$1, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                              "key": item.value,
                              "modelValue": isSelected,
                              "ripple": false,
                              "tabindex": "-1"
                            }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                              "image": item.props.prependAvatar
                            }, null), item.props.prependIcon && createVNode(VIcon, {
                              "icon": item.props.prependIcon
                            }, null)]);
                          },
                          title: function () {
                            var _a5, _b3, _c2;
                            return isPristine.value ? item.title : highlightResult$1(item.title, (_a5 = getMatches(item)) == null ? void 0 : _a5.title, (_c2 = (_b3 = search.value) == null ? void 0 : _b3.length) != null ? _c2 : 0);
                          }
                        });
                      }
                    }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                  }
                })];
              }
            }), model.value.map(function (item, index) {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              var slotProps = {
                "onClick:close": onChipClose,
                onKeydown: function (e) {
                  if (e.key !== "Enter" && e.key !== " ") return;
                  e.preventDefault();
                  e.stopPropagation();
                  onChipClose(e);
                },
                onMousedown: function (e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              var hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
              var slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
                item: item,
                index: index,
                props: slotProps
              }) : slots.selection({
                item: item,
                index: index
              })) : void 0;
              if (hasSlot && !slotContent) return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": ["v-autocomplete__selection", index === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]],
                "style": index === selectionIndex.value ? textColorStyles.value : {}
              }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                "default": function () {
                  return [slotContent];
                }
              }) : slotContent != null ? slotContent : createVNode("span", {
                "class": "v-autocomplete__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-autocomplete__selection-comma"
              }, [createTextVNode(",")])])]);
            })]);
          },
          "append-inner": function () {
            var _a9;
            var _a2;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(Fragment$1, null, [(_a2 = slots["append-inner"]) == null ? void 0 : (_a9 = _a2).call.apply(_a9, [slots].concat(args)), props.menuIcon ? createVNode(VIcon, {
              "class": "v-autocomplete__menu-icon",
              "icon": props.menuIcon,
              "onMousedown": onMousedownMenuIcon,
              "onClick": noop,
              "aria-label": t(label.value),
              "title": t(label.value),
              "tabindex": "-1"
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused: isFocused,
        isPristine: isPristine,
        menu: menu,
        search: search,
        filteredItems: filteredItems,
        select: select
      }, vTextFieldRef);
    }
  });
  var VBadge$1 = "";
  var makeVBadgeProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    bordered: Boolean,
    color: String,
    content: [Number, String],
    dot: Boolean,
    floating: Boolean,
    icon: IconValue,
    inline: Boolean,
    label: {
      type: String,
      "default": "$vuetify.badge"
    },
    max: [Number, String],
    modelValue: {
      type: Boolean,
      "default": true
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String
  }, makeComponentProps()), makeLocationProps({
    location: "top end"
  })), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeTransitionProps({
    transition: "scale-rotate-transition"
  })), "VBadge");
  var VBadge = genericComponent()({
    name: "VBadge",
    inheritAttrs: false,
    props: makeVBadgeProps(),
    setup: function (props, ctx) {
      var _useBackgroundColor9 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor9.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor9.backgroundColorStyles;
      var _useRounded12 = useRounded(props),
        roundedClasses = _useRounded12.roundedClasses;
      var _useLocale6 = useLocale(),
        t = _useLocale6.t;
      var _useTextColor12 = useTextColor(toRef(props, "textColor")),
        textColorClasses = _useTextColor12.textColorClasses,
        textColorStyles = _useTextColor12.textColorStyles;
      var _useTheme = useTheme(),
        themeClasses = _useTheme.themeClasses;
      var _useLocation4 = useLocation(props, true, function (side) {
          var _a2, _b;
          var base2 = props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
          return base2 + (["top", "bottom"].includes(side) ? +((_a2 = props.offsetY) != null ? _a2 : 0) : ["left", "right"].includes(side) ? +((_b = props.offsetX) != null ? _b : 0) : 0);
        }),
        locationStyles = _useLocation4.locationStyles;
      useRender(function () {
        var value = Number(props.content);
        var content = !props.max || isNaN(value) ? props.content : value <= +props.max ? value : props.max + "+";
        var _pickWithRest5 = pickWithRest(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]),
          _pickWithRest6 = _slicedToArray(_pickWithRest5, 2),
          badgeAttrs = _pickWithRest6[0],
          attrs = _pickWithRest6[1];
        return createVNode(props.tag, mergeProps({
          "class": ["v-badge", {
            "v-badge--bordered": props.bordered,
            "v-badge--dot": props.dot,
            "v-badge--floating": props.floating,
            "v-badge--inline": props.inline
          }, props.class]
        }, attrs, {
          "style": props.style
        }), {
          "default": function () {
            var _a2, _b;
            return [createVNode("div", {
              "class": "v-badge__wrapper"
            }, [(_b = (_a2 = ctx.slots).default) == null ? void 0 : _b.call(_a2), createVNode(MaybeTransition, {
              "transition": props.transition
            }, {
              "default": function () {
                var _a3, _b2;
                return [withDirectives(createVNode("span", mergeProps({
                  "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
                  "style": [backgroundColorStyles.value, textColorStyles.value, props.inline ? {} : locationStyles.value],
                  "aria-atomic": "true",
                  "aria-label": t(props.label, value),
                  "aria-live": "polite",
                  "role": "status"
                }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_b2 = (_a3 = ctx.slots).badge) == null ? void 0 : _b2.call(_a3) : props.icon ? createVNode(VIcon, {
                  "icon": props.icon
                }, null) : content]), [[vShow, props.modelValue]])];
              }
            })])];
          }
        });
      });
      return {};
    }
  });
  var VBanner$1 = "";
  var makeVBannerActionsProps = propsFactory(_objectSpread({
    color: String,
    density: String
  }, makeComponentProps()), "VBannerActions");
  var VBannerActions = genericComponent()({
    name: "VBannerActions",
    props: makeVBannerActionsProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      provideDefaults({
        VBtn: {
          color: props.color,
          density: props.density,
          slim: true,
          variant: "text"
        }
      });
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-banner-actions", props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var VBannerText = createSimpleFunctional("v-banner-text");
  var makeVBannerProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    avatar: String,
    bgColor: String,
    color: String,
    icon: IconValue,
    lines: String,
    stacked: Boolean,
    sticky: Boolean,
    text: String
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeDisplayProps({
    mobile: null
  })), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VBanner");
  var VBanner = genericComponent()({
    name: "VBanner",
    props: makeVBannerProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useBackgroundColor10 = useBackgroundColor(props, "bgColor"),
        backgroundColorClasses = _useBackgroundColor10.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor10.backgroundColorStyles;
      var _useBorder8 = useBorder(props),
        borderClasses = _useBorder8.borderClasses;
      var _useDensity10 = useDensity(props),
        densityClasses = _useDensity10.densityClasses;
      var _useDisplay3 = useDisplay(props),
        displayClasses = _useDisplay3.displayClasses,
        mobile = _useDisplay3.mobile;
      var _useDimension9 = useDimension(props),
        dimensionStyles = _useDimension9.dimensionStyles;
      var _useElevation8 = useElevation(props),
        elevationClasses = _useElevation8.elevationClasses;
      var _useLocation5 = useLocation(props),
        locationStyles = _useLocation5.locationStyles;
      var _usePosition3 = usePosition(props),
        positionClasses = _usePosition3.positionClasses;
      var _useRounded13 = useRounded(props),
        roundedClasses = _useRounded13.roundedClasses;
      var _provideTheme17 = provideTheme(props),
        themeClasses = _provideTheme17.themeClasses;
      var color = toRef(props, "color");
      var density = toRef(props, "density");
      provideDefaults({
        VBannerActions: {
          color: color,
          density: density
        }
      });
      useRender(function () {
        var _ref279;
        var hasText = !!(props.text || slots.text);
        var hasPrependMedia = !!(props.avatar || props.icon);
        var hasPrepend = !!(hasPrependMedia || slots.prepend);
        return createVNode(props.tag, {
          "class": ["v-banner", (_ref279 = {
            "v-banner--stacked": props.stacked || mobile.value,
            "v-banner--sticky": props.sticky
          }, _ref279["v-banner--" + props.lines + "-line"] = !!props.lines, _ref279), themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, displayClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "role": "banner"
        }, {
          "default": function () {
            var _a2;
            return [hasPrepend && createVNode("div", {
              "key": "prepend",
              "class": "v-banner__prepend"
            }, [!slots.prepend ? createVNode(VAvatar, {
              "key": "prepend-avatar",
              "color": color.value,
              "density": density.value,
              "icon": props.icon,
              "image": props.avatar
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !hasPrependMedia,
              "defaults": {
                VAvatar: {
                  color: color.value,
                  density: density.value,
                  icon: props.icon,
                  image: props.avatar
                }
              }
            }, slots.prepend)]), createVNode("div", {
              "class": "v-banner__content"
            }, [hasText && createVNode(VBannerText, {
              "key": "text"
            }, {
              "default": function () {
                var _a3, _b;
                return [(_b = (_a3 = slots.text) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VBannerActions, {
              "key": "actions"
            }, slots.actions)];
          }
        });
      });
    }
  });
  var VBottomNavigation$1 = "";
  var makeVBottomNavigationProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    baseColor: String,
    bgColor: String,
    color: String,
    grow: Boolean,
    mode: {
      type: String,
      validator: function (v) {
        return !v || ["horizontal", "shift"].includes(v);
      }
    },
    height: {
      type: [Number, String],
      "default": 56
    },
    active: {
      type: Boolean,
      "default": true
    }
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeLayoutItemProps({
    name: "bottom-navigation"
  })), makeTagProps({
    tag: "header"
  })), makeGroupProps({
    selectedClass: "v-btn--selected"
  })), makeThemeProps()), "VBottomNavigation");
  var VBottomNavigation = genericComponent()({
    name: "VBottomNavigation",
    props: makeVBottomNavigationProps(),
    emits: {
      "update:active": function (value) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useTheme2 = useTheme(),
        themeClasses = _useTheme2.themeClasses;
      var _useBorder9 = useBorder(props),
        borderClasses = _useBorder9.borderClasses;
      var _useBackgroundColor11 = useBackgroundColor(toRef(props, "bgColor")),
        backgroundColorClasses = _useBackgroundColor11.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor11.backgroundColorStyles;
      var _useDensity11 = useDensity(props),
        densityClasses = _useDensity11.densityClasses;
      var _useElevation9 = useElevation(props),
        elevationClasses = _useElevation9.elevationClasses;
      var _useRounded14 = useRounded(props),
        roundedClasses = _useRounded14.roundedClasses;
      var _useSsrBoot3 = useSsrBoot(),
        ssrBootStyles = _useSsrBoot3.ssrBootStyles;
      var height = computed(function () {
        return Number(props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0);
      });
      var isActive2 = useProxiedModel(props, "active", props.active);
      var _useLayoutItem2 = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: computed(function () {
            return "bottom";
          }),
          layoutSize: computed(function () {
            return isActive2.value ? height.value : 0;
          }),
          elementSize: height,
          active: isActive2,
          absolute: toRef(props, "absolute")
        }),
        layoutItemStyles = _useLayoutItem2.layoutItemStyles;
      useGroup(props, VBtnToggleSymbol);
      provideDefaults({
        VBtn: {
          baseColor: toRef(props, "baseColor"),
          color: toRef(props, "color"),
          density: toRef(props, "density"),
          stacked: computed(function () {
            return props.mode !== "horizontal";
          }),
          variant: "text"
        }
      }, {
        scoped: true
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-bottom-navigation", {
            "v-bottom-navigation--active": isActive2.value,
            "v-bottom-navigation--grow": props.grow,
            "v-bottom-navigation--shift": props.mode === "shift"
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, layoutItemStyles.value, {
            height: convertToUnit(height.value)
          }, ssrBootStyles.value, props.style]
        }, {
          "default": function () {
            return [slots.default && createVNode("div", {
              "class": "v-bottom-navigation__content"
            }, [slots.default()])];
          }
        });
      });
      return {};
    }
  });
  var VBottomSheet$1 = "";
  var VDialog$1 = "";
  var makeVDialogProps = propsFactory(_objectSpread({
    fullscreen: Boolean,
    retainFocus: {
      type: Boolean,
      "default": true
    },
    scrollable: Boolean
  }, makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })), "VDialog");
  var VDialog = genericComponent()({
    name: "VDialog",
    props: makeVDialogProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      afterEnter: function () {
        return true;
      },
      afterLeave: function () {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var isActive2 = useProxiedModel(props, "modelValue");
      var _useScopeId3 = useScopeId(),
        scopeId = _useScopeId3.scopeId;
      var overlay = ref();
      function onFocusin(e) {
        var _a2, _b;
        var before = e.relatedTarget;
        var after = e.target;
        if (before !== after && ((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && ((_b = overlay.value) == null ? void 0 : _b.globalTop) && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
          var focusable = focusableChildren(overlay.value.contentEl);
          if (!focusable.length) return;
          var firstElement = focusable[0];
          var lastElement = focusable[focusable.length - 1];
          if (before === firstElement) {
            lastElement.focus();
          } else {
            firstElement.focus();
          }
        }
      }
      if (IN_BROWSER) {
        watch(function () {
          return isActive2.value && props.retainFocus;
        }, function (val) {
          val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
        }, {
          immediate: true
        });
      }
      function onAfterEnter() {
        var _a2;
        emit2("afterEnter");
        if (((_a2 = overlay.value) == null ? void 0 : _a2.contentEl) && !overlay.value.contentEl.contains(document.activeElement)) {
          overlay.value.contentEl.focus({
            preventScroll: true
          });
        }
      }
      function onAfterLeave() {
        emit2("afterLeave");
      }
      watch(isActive2, function _callee7(val) {
        var _a2;
        return _regeneratorRuntime.async(function _callee7$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              if (val) {
                _context17.next = 4;
                break;
              }
              _context17.next = 3;
              return _regeneratorRuntime.awrap(nextTick());
            case 3:
              (_a2 = overlay.value.activatorEl) == null ? void 0 : _a2.focus({
                preventScroll: true
              });
            case 4:
            case "end":
              return _context17.stop();
          }
        }, null, null, null, Promise);
      });
      useRender(function () {
        var overlayProps = VOverlay.filterProps(props);
        var activatorProps = mergeProps({
          "aria-haspopup": "dialog"
        }, props.activatorProps);
        var contentProps = mergeProps({
          tabindex: -1
        }, props.contentProps);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-dialog", {
            "v-dialog--fullscreen": props.fullscreen,
            "v-dialog--scrollable": props.scrollable
          }, props.class],
          "style": props.style
        }, overlayProps, {
          "modelValue": isActive2.value,
          "onUpdate:modelValue": function ($event) {
            return isActive2.value = $event;
          },
          "aria-modal": "true",
          "activatorProps": activatorProps,
          "contentProps": contentProps,
          "role": "dialog",
          "onAfterEnter": onAfterEnter,
          "onAfterLeave": onAfterLeave
        }, scopeId), {
          activator: slots.activator,
          "default": function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(VDefaultsProvider, {
              "root": "VDialog"
            }, {
              "default": function () {
                var _a10;
                var _a2;
                return [(_a2 = slots.default) == null ? void 0 : (_a10 = _a2).call.apply(_a10, [slots].concat(args))];
              }
            });
          }
        });
      });
      return forwardRefs({}, overlay);
    }
  });
  var makeVBottomSheetProps = propsFactory(_objectSpread({
    inset: Boolean
  }, makeVDialogProps({
    transition: "bottom-sheet-transition"
  })), "VBottomSheet");
  var VBottomSheet = genericComponent()({
    name: "VBottomSheet",
    props: makeVBottomSheetProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var isActive2 = useProxiedModel(props, "modelValue");
      useRender(function () {
        var dialogProps = VDialog.filterProps(props);
        return createVNode(VDialog, mergeProps(dialogProps, {
          "contentClass": ["v-bottom-sheet__content", props.contentClass],
          "modelValue": isActive2.value,
          "onUpdate:modelValue": function ($event) {
            return isActive2.value = $event;
          },
          "class": ["v-bottom-sheet", {
            "v-bottom-sheet--inset": props.inset
          }, props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });
  var VBreadcrumbs$1 = "";
  var makeVBreadcrumbsDividerProps = propsFactory(_objectSpread({
    divider: [Number, String]
  }, makeComponentProps()), "VBreadcrumbsDivider");
  var VBreadcrumbsDivider = genericComponent()({
    name: "VBreadcrumbsDivider",
    props: makeVBreadcrumbsDividerProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var _a2, _b;
        return createVNode("li", {
          "class": ["v-breadcrumbs-divider", props.class],
          "style": props.style
        }, [(_b = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.divider]);
      });
      return {};
    }
  });
  var makeVBreadcrumbsItemProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    title: String
  }, makeComponentProps()), makeRouterProps()), makeTagProps({
    tag: "li"
  })), "VBreadcrumbsItem");
  var VBreadcrumbsItem = genericComponent()({
    name: "VBreadcrumbsItem",
    props: makeVBreadcrumbsItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots,
        attrs = _ref.attrs;
      var link = useLink(props, attrs);
      var isActive2 = computed(function () {
        var _a2;
        return props.active || ((_a2 = link.isActive) == null ? void 0 : _a2.value);
      });
      var color = computed(function () {
        return isActive2.value ? props.activeColor : props.color;
      });
      var _useTextColor13 = useTextColor(color),
        textColorClasses = _useTextColor13.textColorClasses,
        textColorStyles = _useTextColor13.textColorStyles;
      useRender(function () {
        var _ref280;
        return createVNode(props.tag, {
          "class": ["v-breadcrumbs-item", (_ref280 = {
            "v-breadcrumbs-item--active": isActive2.value,
            "v-breadcrumbs-item--disabled": props.disabled
          }, _ref280["" + props.activeClass] = isActive2.value && props.activeClass, _ref280), textColorClasses.value, props.class],
          "style": [textColorStyles.value, props.style],
          "aria-current": isActive2.value ? "page" : void 0
        }, {
          "default": function () {
            var _a2, _b, _c, _d;
            return [!link.isLink.value ? (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.title : createVNode("a", mergeProps({
              "class": "v-breadcrumbs-item--link",
              "onClick": link.navigate
            }, link.linkProps), [(_d = (_c = slots.default) == null ? void 0 : _c.call(slots)) != null ? _d : props.title])];
          }
        });
      });
      return {};
    }
  });
  var makeVBreadcrumbsProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    activeClass: String,
    activeColor: String,
    bgColor: String,
    color: String,
    disabled: Boolean,
    divider: {
      type: String,
      "default": "/"
    },
    icon: IconValue,
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    }
  }, makeComponentProps()), makeDensityProps()), makeRoundedProps()), makeTagProps({
    tag: "ul"
  })), "VBreadcrumbs");
  var VBreadcrumbs = genericComponent()({
    name: "VBreadcrumbs",
    props: makeVBreadcrumbsProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useBackgroundColor12 = useBackgroundColor(toRef(props, "bgColor")),
        backgroundColorClasses = _useBackgroundColor12.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor12.backgroundColorStyles;
      var _useDensity12 = useDensity(props),
        densityClasses = _useDensity12.densityClasses;
      var _useRounded15 = useRounded(props),
        roundedClasses = _useRounded15.roundedClasses;
      provideDefaults({
        VBreadcrumbsDivider: {
          divider: toRef(props, "divider")
        },
        VBreadcrumbsItem: {
          activeClass: toRef(props, "activeClass"),
          activeColor: toRef(props, "activeColor"),
          color: toRef(props, "color"),
          disabled: toRef(props, "disabled")
        }
      });
      var items = computed(function () {
        return props.items.map(function (item) {
          return typeof item === "string" ? {
            item: {
              title: item
            },
            raw: item
          } : {
            item: item,
            raw: item
          };
        });
      });
      useRender(function () {
        var hasPrepend = !!(slots.prepend || props.icon);
        return createVNode(props.tag, {
          "class": ["v-breadcrumbs", backgroundColorClasses.value, densityClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style]
        }, {
          "default": function () {
            var _a2;
            return [hasPrepend && createVNode("li", {
              "key": "prepend",
              "class": "v-breadcrumbs__prepend"
            }, [!slots.prepend ? createVNode(VIcon, {
              "key": "prepend-icon",
              "start": true,
              "icon": props.icon
            }, null) : createVNode(VDefaultsProvider, {
              "key": "prepend-defaults",
              "disabled": !props.icon,
              "defaults": {
                VIcon: {
                  icon: props.icon,
                  start: true
                }
              }
            }, slots.prepend)]), items.value.map(function (_ref2, index, array) {
              var _a3, _b;
              var item = _ref2.item,
                raw = _ref2.raw;
              return createVNode(Fragment$1, null, [(_b = (_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                item: item,
                index: index
              })) != null ? _b : createVNode(VBreadcrumbsItem, mergeProps({
                "key": index,
                "disabled": index >= array.length - 1
              }, typeof item === "string" ? {
                title: item
              } : item), {
                "default": slots.title ? function () {
                  var _a4;
                  return (_a4 = slots.title) == null ? void 0 : _a4.call(slots, {
                    item: item,
                    index: index
                  });
                } : void 0
              }), index < array.length - 1 && createVNode(VBreadcrumbsDivider, null, {
                "default": slots.divider ? function () {
                  var _a4;
                  return (_a4 = slots.divider) == null ? void 0 : _a4.call(slots, {
                    item: raw,
                    index: index
                  });
                } : void 0
              })]);
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
          }
        });
      });
      return {};
    }
  });
  var VCard$1 = "";
  var VCardActions = genericComponent()({
    name: "VCardActions",
    props: makeComponentProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      provideDefaults({
        VBtn: {
          slim: true,
          variant: "text"
        }
      });
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-card-actions", props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var makeVCardSubtitleProps = propsFactory(_objectSpread(_objectSpread({
    opacity: [Number, String]
  }, makeComponentProps()), makeTagProps()), "VCardSubtitle");
  var VCardSubtitle = genericComponent()({
    name: "VCardSubtitle",
    props: makeVCardSubtitleProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-card-subtitle", props.class],
          "style": [{
            "--v-card-subtitle-opacity": props.opacity
          }, props.style]
        }, slots);
      });
      return {};
    }
  });
  var VCardTitle = createSimpleFunctional("v-card-title");
  var makeCardItemProps = propsFactory(_objectSpread(_objectSpread({
    appendAvatar: String,
    appendIcon: IconValue,
    prependAvatar: String,
    prependIcon: IconValue,
    subtitle: [String, Number],
    title: [String, Number]
  }, makeComponentProps()), makeDensityProps()), "VCardItem");
  var VCardItem = genericComponent()({
    name: "VCardItem",
    props: makeCardItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var _a2;
        var hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
        var hasPrepend = !!(hasPrependMedia || slots.prepend);
        var hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
        var hasAppend = !!(hasAppendMedia || slots.append);
        var hasTitle = !!(props.title != null || slots.title);
        var hasSubtitle = !!(props.subtitle != null || slots.subtitle);
        return createVNode("div", {
          "class": ["v-card-item", props.class],
          "style": props.style
        }, [hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-card-item__prepend"
        }, [!slots.prepend ? createVNode(Fragment$1, null, [props.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "density": props.density,
          "image": props.prependAvatar
        }, null), props.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props.density,
          "icon": props.prependIcon
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.prependAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.prependIcon
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-card-item__content"
        }, [hasTitle && createVNode(VCardTitle, {
          "key": "title"
        }, {
          "default": function () {
            var _a3, _b;
            return [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b : props.title];
          }
        }), hasSubtitle && createVNode(VCardSubtitle, {
          "key": "subtitle"
        }, {
          "default": function () {
            var _a3, _b;
            return [(_b = (_a3 = slots.subtitle) == null ? void 0 : _a3.call(slots)) != null ? _b : props.subtitle];
          }
        }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-card-item__append"
        }, [!slots.append ? createVNode(Fragment$1, null, [props.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "density": props.density,
          "icon": props.appendIcon
        }, null), props.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "density": props.density,
          "image": props.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.appendAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.appendIcon
            }
          }
        }, slots.append)])]);
      });
      return {};
    }
  });
  var makeVCardTextProps = propsFactory(_objectSpread(_objectSpread({
    opacity: [Number, String]
  }, makeComponentProps()), makeTagProps()), "VCardText");
  var VCardText = genericComponent()({
    name: "VCardText",
    props: makeVCardTextProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-card-text", props.class],
          "style": [{
            "--v-card-text-opacity": props.opacity
          }, props.style]
        }, slots);
      });
      return {};
    }
  });
  var makeVCardProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    appendAvatar: String,
    appendIcon: IconValue,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
      type: Boolean,
      "default": void 0
    },
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    subtitle: [String, Number],
    text: [String, Number],
    title: [String, Number]
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeLoaderProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "elevated"
  })), "VCard");
  var VCard = genericComponent()({
    name: "VCard",
    directives: {
      Ripple: Ripple
    },
    props: makeVCardProps(),
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _provideTheme18 = provideTheme(props),
        themeClasses = _provideTheme18.themeClasses;
      var _useBorder10 = useBorder(props),
        borderClasses = _useBorder10.borderClasses;
      var _useVariant6 = useVariant(props),
        colorClasses = _useVariant6.colorClasses,
        colorStyles = _useVariant6.colorStyles,
        variantClasses = _useVariant6.variantClasses;
      var _useDensity13 = useDensity(props),
        densityClasses = _useDensity13.densityClasses;
      var _useDimension10 = useDimension(props),
        dimensionStyles = _useDimension10.dimensionStyles;
      var _useElevation10 = useElevation(props),
        elevationClasses = _useElevation10.elevationClasses;
      var _useLoader3 = useLoader(props),
        loaderClasses = _useLoader3.loaderClasses;
      var _useLocation6 = useLocation(props),
        locationStyles = _useLocation6.locationStyles;
      var _usePosition4 = usePosition(props),
        positionClasses = _usePosition4.positionClasses;
      var _useRounded16 = useRounded(props),
        roundedClasses = _useRounded16.roundedClasses;
      var link = useLink(props, attrs);
      var isLink = computed(function () {
        return props.link !== false && link.isLink.value;
      });
      var isClickable = computed(function () {
        return !props.disabled && props.link !== false && (props.link || link.isClickable.value);
      });
      useRender(function () {
        var Tag = isLink.value ? "a" : props.tag;
        var hasTitle = !!(slots.title || props.title != null);
        var hasSubtitle = !!(slots.subtitle || props.subtitle != null);
        var hasHeader = hasTitle || hasSubtitle;
        var hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
        var hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
        var hasImage = !!(slots.image || props.image);
        var hasCardItem = hasHeader || hasPrepend || hasAppend;
        var hasText = !!(slots.text || props.text != null);
        return withDirectives(createVNode(Tag, mergeProps({
          "class": ["v-card", {
            "v-card--disabled": props.disabled,
            "v-card--flat": props.flat,
            "v-card--hover": props.hover && !(props.disabled || props.flat),
            "v-card--link": isClickable.value
          }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
          "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
          "onClick": isClickable.value && link.navigate,
          "tabindex": props.disabled ? -1 : void 0
        }, link.linkProps), {
          "default": function () {
            var _a2;
            return [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-card__image"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "cover": true,
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  cover: true,
                  src: props.image
                }
              }
            }, slots.image)]), createVNode(LoaderSlot, {
              "name": "v-card",
              "active": !!props.loading,
              "color": typeof props.loading === "boolean" ? void 0 : props.loading
            }, {
              "default": slots.loader
            }), hasCardItem && createVNode(VCardItem, {
              "key": "item",
              "prependAvatar": props.prependAvatar,
              "prependIcon": props.prependIcon,
              "title": props.title,
              "subtitle": props.subtitle,
              "appendAvatar": props.appendAvatar,
              "appendIcon": props.appendIcon
            }, {
              "default": slots.item,
              prepend: slots.prepend,
              title: slots.title,
              subtitle: slots.subtitle,
              append: slots.append
            }), hasText && createVNode(VCardText, {
              "key": "text"
            }, {
              "default": function () {
                var _a3, _b;
                return [(_b = (_a3 = slots.text) == null ? void 0 : _a3.call(slots)) != null ? _b : props.text];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), slots.actions && createVNode(VCardActions, null, {
              "default": slots.actions
            }), genOverlays(isClickable.value, "v-card")];
          }
        }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
      });
      return {};
    }
  });
  var VCarousel$1 = "";
  var VWindow$1 = "";
  var handleGesture = function (wrapper) {
    var touchstartX = wrapper.touchstartX,
      touchendX = wrapper.touchendX,
      touchstartY = wrapper.touchstartY,
      touchendY = wrapper.touchendY;
    var dirRatio = 0.5;
    var minDistance = 16;
    wrapper.offsetX = touchendX - touchstartX;
    wrapper.offsetY = touchendY - touchstartY;
    if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
      wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
      wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
    }
    if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
      wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
      wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
    }
  };
  function touchstart(event, wrapper) {
    var _a2;
    var touch = event.changedTouches[0];
    wrapper.touchstartX = touch.clientX;
    wrapper.touchstartY = touch.clientY;
    (_a2 = wrapper.start) == null ? void 0 : _a2.call(wrapper, _objectSpread({
      originalEvent: event
    }, wrapper));
  }
  function touchend(event, wrapper) {
    var _a2;
    var touch = event.changedTouches[0];
    wrapper.touchendX = touch.clientX;
    wrapper.touchendY = touch.clientY;
    (_a2 = wrapper.end) == null ? void 0 : _a2.call(wrapper, _objectSpread({
      originalEvent: event
    }, wrapper));
    handleGesture(wrapper);
  }
  function touchmove(event, wrapper) {
    var _a2;
    var touch = event.changedTouches[0];
    wrapper.touchmoveX = touch.clientX;
    wrapper.touchmoveY = touch.clientY;
    (_a2 = wrapper.move) == null ? void 0 : _a2.call(wrapper, _objectSpread({
      originalEvent: event
    }, wrapper));
  }
  function createHandlers() {
    var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var wrapper = {
      touchstartX: 0,
      touchstartY: 0,
      touchendX: 0,
      touchendY: 0,
      touchmoveX: 0,
      touchmoveY: 0,
      offsetX: 0,
      offsetY: 0,
      left: value.left,
      right: value.right,
      up: value.up,
      down: value.down,
      start: value.start,
      move: value.move,
      end: value.end
    };
    return {
      touchstart: function (e) {
        return touchstart(e, wrapper);
      },
      touchend: function (e) {
        return touchend(e, wrapper);
      },
      touchmove: function (e) {
        return touchmove(e, wrapper);
      }
    };
  }
  function mounted$3(el, binding) {
    var _a2, _b, _c;
    var value = binding.value;
    var target = (value == null ? void 0 : value.parent) ? el.parentElement : el;
    var options = (_a2 = value == null ? void 0 : value.options) != null ? _a2 : {
      passive: true
    };
    var uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
    if (!target || !uid2) return;
    var handlers2 = createHandlers(binding.value);
    target._touchHandlers = (_c = target._touchHandlers) != null ? _c : /* @__PURE__ */Object.create(null);
    target._touchHandlers[uid2] = handlers2;
    keys(handlers2).forEach(function (eventName2) {
      target.addEventListener(eventName2, handlers2[eventName2], options);
    });
  }
  function unmounted$3(el, binding) {
    var _a2, _b;
    var target = ((_a2 = binding.value) == null ? void 0 : _a2.parent) ? el.parentElement : el;
    var uid2 = (_b = binding.instance) == null ? void 0 : _b.$.uid;
    if (!(target == null ? void 0 : target._touchHandlers) || !uid2) return;
    var handlers2 = target._touchHandlers[uid2];
    keys(handlers2).forEach(function (eventName2) {
      target.removeEventListener(eventName2, handlers2[eventName2]);
    });
    delete target._touchHandlers[uid2];
  }
  var Touch = {
    mounted: mounted$3,
    unmounted: unmounted$3
  };
  var VWindowSymbol = Symbol.for("vuetify:v-window");
  var VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
  var makeVWindowProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    continuous: Boolean,
    nextIcon: {
      type: [Boolean, String, Function, Object],
      "default": "$next"
    },
    prevIcon: {
      type: [Boolean, String, Function, Object],
      "default": "$prev"
    },
    reverse: Boolean,
    showArrows: {
      type: [Boolean, String],
      validator: function (v) {
        return typeof v === "boolean" || v === "hover";
      }
    },
    touch: {
      type: [Object, Boolean],
      "default": void 0
    },
    direction: {
      type: String,
      "default": "horizontal"
    },
    modelValue: null,
    disabled: Boolean,
    selectedClass: {
      type: String,
      "default": "v-window-item--active"
    },
    mandatory: {
      type: [Boolean, String],
      "default": "force"
    }
  }, makeComponentProps()), makeTagProps()), makeThemeProps()), "VWindow");
  var VWindow = genericComponent()({
    name: "VWindow",
    directives: {
      Touch: Touch
    },
    props: makeVWindowProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme19 = provideTheme(props),
        themeClasses = _provideTheme19.themeClasses;
      var _useRtl11 = useRtl(),
        isRtl = _useRtl11.isRtl;
      var _useLocale7 = useLocale(),
        t = _useLocale7.t;
      var group = useGroup(props, VWindowGroupSymbol);
      var rootRef = ref();
      var isRtlReverse = computed(function () {
        return isRtl.value ? !props.reverse : props.reverse;
      });
      var isReversed = shallowRef(false);
      var transition = computed(function () {
        var axis = props.direction === "vertical" ? "y" : "x";
        var reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
        var direction = reverse ? "-reverse" : "";
        return "v-window-" + axis + direction + "-transition";
      });
      var transitionCount = shallowRef(0);
      var transitionHeight = ref(void 0);
      var activeIndex = computed(function () {
        return group.items.value.findIndex(function (item) {
          return group.selected.value.includes(item.id);
        });
      });
      watch(activeIndex, function (newVal, oldVal) {
        var itemsLength = group.items.value.length;
        var lastIndex = itemsLength - 1;
        if (itemsLength <= 2) {
          isReversed.value = newVal < oldVal;
        } else if (newVal === lastIndex && oldVal === 0) {
          isReversed.value = true;
        } else if (newVal === 0 && oldVal === lastIndex) {
          isReversed.value = false;
        } else {
          isReversed.value = newVal < oldVal;
        }
      });
      provide(VWindowSymbol, {
        transition: transition,
        isReversed: isReversed,
        transitionCount: transitionCount,
        transitionHeight: transitionHeight,
        rootRef: rootRef
      });
      var canMoveBack = computed(function () {
        return props.continuous || activeIndex.value !== 0;
      });
      var canMoveForward = computed(function () {
        return props.continuous || activeIndex.value !== group.items.value.length - 1;
      });
      function prev() {
        canMoveBack.value && group.prev();
      }
      function next() {
        canMoveForward.value && group.next();
      }
      var arrows = computed(function () {
        var arrows2 = [];
        var prevProps = {
          icon: isRtl.value ? props.nextIcon : props.prevIcon,
          "class": "v-window__" + (isRtlReverse.value ? "right" : "left"),
          onClick: group.prev,
          "aria-label": t("$vuetify.carousel.prev")
        };
        arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
          props: prevProps
        }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
        var nextProps = {
          icon: isRtl.value ? props.prevIcon : props.nextIcon,
          "class": "v-window__" + (isRtlReverse.value ? "left" : "right"),
          onClick: group.next,
          "aria-label": t("$vuetify.carousel.next")
        };
        arrows2.push(canMoveForward.value ? slots.next ? slots.next({
          props: nextProps
        }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
        return arrows2;
      });
      var touchOptions = computed(function () {
        if (props.touch === false) return props.touch;
        var options = {
          left: function () {
            isRtlReverse.value ? prev() : next();
          },
          right: function () {
            isRtlReverse.value ? next() : prev();
          },
          start: function (_ref2) {
            var originalEvent = _ref2.originalEvent;
            originalEvent.stopPropagation();
          }
        };
        return _objectSpread(_objectSpread({}, options), props.touch === true ? {} : props.touch);
      });
      useRender(function () {
        return withDirectives(createVNode(props.tag, {
          "ref": rootRef,
          "class": ["v-window", {
            "v-window--show-arrows-on-hover": props.showArrows === "hover"
          }, themeClasses.value, props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a2, _b;
            return [createVNode("div", {
              "class": "v-window__container",
              "style": {
                height: transitionHeight.value
              }
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              group: group
            }), props.showArrows !== false && createVNode("div", {
              "class": "v-window__controls"
            }, [arrows.value])]), (_b = slots.additional) == null ? void 0 : _b.call(slots, {
              group: group
            })];
          }
        }), [[resolveDirective("touch"), touchOptions.value]]);
      });
      return {
        group: group
      };
    }
  });
  var makeVCarouselProps = propsFactory(_objectSpread({
    color: String,
    cycle: Boolean,
    delimiterIcon: {
      type: IconValue,
      "default": "$delimiter"
    },
    height: {
      type: [Number, String],
      "default": 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
      type: [Number, String],
      "default": 6e3,
      validator: function (value) {
        return Number(value) > 0;
      }
    },
    progress: [Boolean, String],
    verticalDelimiters: [Boolean, String]
  }, makeVWindowProps({
    continuous: true,
    mandatory: "force",
    showArrows: true
  })), "VCarousel");
  var VCarousel = genericComponent()({
    name: "VCarousel",
    props: makeVCarouselProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var _useLocale8 = useLocale(),
        t = _useLocale8.t;
      var windowRef = ref();
      var slideTimeout = -1;
      watch(model, restartTimeout);
      watch(function () {
        return props.interval;
      }, restartTimeout);
      watch(function () {
        return props.cycle;
      }, function (val) {
        if (val) restartTimeout();else window.clearTimeout(slideTimeout);
      });
      onMounted(startTimeout);
      function startTimeout() {
        if (!props.cycle || !windowRef.value) return;
        slideTimeout = window.setTimeout(windowRef.value.group.next, +props.interval > 0 ? +props.interval : 6e3);
      }
      function restartTimeout() {
        window.clearTimeout(slideTimeout);
        window.requestAnimationFrame(startTimeout);
      }
      useRender(function () {
        var windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "ref": windowRef
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-carousel", {
            "v-carousel--hide-delimiter-background": props.hideDelimiterBackground,
            "v-carousel--vertical-delimiters": props.verticalDelimiters
          }, props.class],
          "style": [{
            height: convertToUnit(props.height)
          }, props.style]
        }), {
          "default": slots.default,
          additional: function (_ref2) {
            var group = _ref2.group;
            return createVNode(Fragment$1, null, [!props.hideDelimiters && createVNode("div", {
              "class": "v-carousel__controls",
              "style": {
                left: props.verticalDelimiters === "left" && props.verticalDelimiters ? 0 : "auto",
                right: props.verticalDelimiters === "right" ? 0 : "auto"
              }
            }, [group.items.value.length > 0 && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  color: props.color,
                  icon: props.delimiterIcon,
                  size: "x-small",
                  variant: "text"
                }
              },
              "scoped": true
            }, {
              "default": function () {
                return [group.items.value.map(function (item, index) {
                  var props2 = {
                    id: "carousel-item-" + item.id,
                    "aria-label": t("$vuetify.carousel.ariaLabel.delimiter", index + 1, group.items.value.length),
                    "class": ["v-carousel__controls__item", group.isSelected(item.id) && "v-btn--active"],
                    onClick: function () {
                      return group.select(item.id, true);
                    }
                  };
                  return slots.item ? slots.item({
                    props: props2,
                    item: item
                  }) : createVNode(VBtn, mergeProps(item, props2), null);
                })];
              }
            })]), props.progress && createVNode(VProgressLinear, {
              "class": "v-carousel__progress",
              "color": typeof props.progress === "string" ? props.progress : void 0,
              "modelValue": (group.getItemIndex(model.value) + 1) / group.items.value.length * 100
            }, null)]);
          },
          prev: slots.prev,
          next: slots.next
        });
      });
      return {};
    }
  });
  var makeVWindowItemProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    reverseTransition: {
      type: [Boolean, String],
      "default": void 0
    },
    transition: {
      type: [Boolean, String],
      "default": void 0
    }
  }, makeComponentProps()), makeGroupItemProps()), makeLazyProps()), "VWindowItem");
  var VWindowItem = genericComponent()({
    name: "VWindowItem",
    directives: {
      Touch: Touch
    },
    props: makeVWindowItemProps(),
    emits: {
      "group:selected": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var window2 = inject$1(VWindowSymbol);
      var groupItem = useGroupItem(props, VWindowGroupSymbol);
      var _useSsrBoot4 = useSsrBoot(),
        isBooted = _useSsrBoot4.isBooted;
      if (!window2 || !groupItem) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
      var isTransitioning = shallowRef(false);
      var hasTransition = computed(function () {
        return isBooted.value && (window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false);
      });
      function onAfterTransition() {
        if (!isTransitioning.value || !window2) {
          return;
        }
        isTransitioning.value = false;
        if (window2.transitionCount.value > 0) {
          window2.transitionCount.value -= 1;
          if (window2.transitionCount.value === 0) {
            window2.transitionHeight.value = void 0;
          }
        }
      }
      function onBeforeTransition() {
        var _a2;
        if (isTransitioning.value || !window2) {
          return;
        }
        isTransitioning.value = true;
        if (window2.transitionCount.value === 0) {
          window2.transitionHeight.value = convertToUnit((_a2 = window2.rootRef.value) == null ? void 0 : _a2.clientHeight);
        }
        window2.transitionCount.value += 1;
      }
      function onTransitionCancelled() {
        onAfterTransition();
      }
      function onEnterTransition(el) {
        if (!isTransitioning.value) {
          return;
        }
        nextTick(function () {
          if (!hasTransition.value || !isTransitioning.value || !window2) {
            return;
          }
          window2.transitionHeight.value = convertToUnit(el.clientHeight);
        });
      }
      var transition = computed(function () {
        var name = window2.isReversed.value ? props.reverseTransition : props.transition;
        return !hasTransition.value ? false : {
          name: typeof name !== "string" ? window2.transition.value : name,
          onBeforeEnter: onBeforeTransition,
          onAfterEnter: onAfterTransition,
          onEnterCancelled: onTransitionCancelled,
          onBeforeLeave: onBeforeTransition,
          onAfterLeave: onAfterTransition,
          onLeaveCancelled: onTransitionCancelled,
          onEnter: onEnterTransition
        };
      });
      var _useLazy2 = useLazy(props, groupItem.isSelected),
        hasContent = _useLazy2.hasContent;
      useRender(function () {
        return createVNode(MaybeTransition, {
          "transition": transition.value,
          "disabled": !isBooted.value
        }, {
          "default": function () {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": ["v-window-item", groupItem.selectedClass.value, props.class],
              "style": props.style
            }, [hasContent.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots))]), [[vShow, groupItem.isSelected.value]])];
          }
        });
      });
      return {
        groupItem: groupItem
      };
    }
  });
  var makeVCarouselItemProps = propsFactory(_objectSpread(_objectSpread({}, makeVImgProps()), makeVWindowItemProps()), "VCarouselItem");
  var VCarouselItem = genericComponent()({
    name: "VCarouselItem",
    inheritAttrs: false,
    props: makeVCarouselItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots,
        attrs = _ref.attrs;
      useRender(function () {
        var imgProps = VImg.filterProps(props);
        var windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "class": ["v-carousel-item", props.class]
        }, windowItemProps), {
          "default": function () {
            return [createVNode(VImg, mergeProps(attrs, imgProps), slots)];
          }
        });
      });
    }
  });
  var VCode$1 = "";
  var VCode = createSimpleFunctional("v-code");
  var VColorPicker$1 = "";
  var VColorPickerCanvas$1 = "";
  var makeVColorPickerCanvasProps = propsFactory(_objectSpread({
    color: {
      type: Object
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      "default": 10
    },
    height: {
      type: [Number, String],
      "default": 150
    },
    width: {
      type: [Number, String],
      "default": 300
    }
  }, makeComponentProps()), "VColorPickerCanvas");
  var VColorPickerCanvas = defineComponent({
    name: "VColorPickerCanvas",
    props: makeVColorPickerCanvasProps(),
    emits: {
      "update:color": function (color) {
        return true;
      },
      "update:position": function (hue) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit;
      var isInteracting = shallowRef(false);
      var canvasRef = ref();
      var canvasWidth = shallowRef(parseFloat(props.width));
      var canvasHeight = shallowRef(parseFloat(props.height));
      var _dotPosition = ref({
        x: 0,
        y: 0
      });
      var dotPosition = computed({
        get: function () {
          return _dotPosition.value;
        },
        set: function (val) {
          var _a2, _b, _c, _d;
          if (!canvasRef.value) return;
          var x = val.x,
            y = val.y;
          _dotPosition.value = val;
          emit2("update:color", {
            h: (_b = (_a2 = props.color) == null ? void 0 : _a2.h) != null ? _b : 0,
            s: clamp(x, 0, canvasWidth.value) / canvasWidth.value,
            v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,
            a: (_d = (_c = props.color) == null ? void 0 : _c.a) != null ? _d : 1
          });
        }
      });
      var dotStyles = computed(function () {
        var _dotPosition$value = dotPosition.value,
          x = _dotPosition$value.x,
          y = _dotPosition$value.y;
        var radius = parseInt(props.dotSize, 10) / 2;
        return {
          width: convertToUnit(props.dotSize),
          height: convertToUnit(props.dotSize),
          transform: "translate(" + convertToUnit(x - radius) + ", " + convertToUnit(y - radius) + ")"
        };
      });
      var _useResizeObserver7 = useResizeObserver(function (entries) {
          var _a2;
          if (!((_a2 = resizeRef.el) == null ? void 0 : _a2.offsetParent)) return;
          var _entries$0$contentRec = entries[0].contentRect,
            width = _entries$0$contentRec.width,
            height = _entries$0$contentRec.height;
          canvasWidth.value = width;
          canvasHeight.value = height;
        }),
        resizeRef = _useResizeObserver7.resizeRef;
      function updateDotPosition(x, y, rect) {
        var left = rect.left,
          top = rect.top,
          width = rect.width,
          height = rect.height;
        dotPosition.value = {
          x: clamp(x - left, 0, width),
          y: clamp(y - top, 0, height)
        };
      }
      function handleMouseDown(e) {
        if (e.type === "mousedown") {
          e.preventDefault();
        }
        if (props.disabled) return;
        handleMouseMove(e);
        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp);
        window.addEventListener("touchmove", handleMouseMove);
        window.addEventListener("touchend", handleMouseUp);
      }
      function handleMouseMove(e) {
        if (props.disabled || !canvasRef.value) return;
        isInteracting.value = true;
        var coords = getEventCoordinates(e);
        updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
      }
      function handleMouseUp() {
        window.removeEventListener("mousemove", handleMouseMove);
        window.removeEventListener("mouseup", handleMouseUp);
        window.removeEventListener("touchmove", handleMouseMove);
        window.removeEventListener("touchend", handleMouseUp);
      }
      function updateCanvas() {
        var _a2, _b;
        if (!canvasRef.value) return;
        var canvas = canvasRef.value;
        var ctx = canvas.getContext("2d");
        if (!ctx) return;
        var saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
        saturationGradient.addColorStop(1, "hsla(" + ((_b = (_a2 = props.color) == null ? void 0 : _a2.h) != null ? _b : 0) + ", 100%, 50%, 1)");
        ctx.fillStyle = saturationGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        var valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        valueGradient.addColorStop(0, "hsla(0, 0%, 0%, 0)");
        valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
        ctx.fillStyle = valueGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      watch(function () {
        var _a2;
        return (_a2 = props.color) == null ? void 0 : _a2.h;
      }, updateCanvas, {
        immediate: true
      });
      watch(function () {
        return [canvasWidth.value, canvasHeight.value];
      }, function (newVal, oldVal) {
        updateCanvas();
        _dotPosition.value = {
          x: dotPosition.value.x * newVal[0] / oldVal[0],
          y: dotPosition.value.y * newVal[1] / oldVal[1]
        };
      }, {
        flush: "post"
      });
      watch(function () {
        return props.color;
      }, function () {
        if (isInteracting.value) {
          isInteracting.value = false;
          return;
        }
        _dotPosition.value = props.color ? {
          x: props.color.s * canvasWidth.value,
          y: (1 - props.color.v) * canvasHeight.value
        } : {
          x: 0,
          y: 0
        };
      }, {
        deep: true,
        immediate: true
      });
      onMounted(function () {
        return updateCanvas();
      });
      useRender(function () {
        return createVNode("div", {
          "ref": resizeRef,
          "class": ["v-color-picker-canvas", props.class],
          "style": props.style,
          "onMousedown": handleMouseDown,
          "onTouchstartPassive": handleMouseDown
        }, [createVNode("canvas", {
          "ref": canvasRef,
          "width": canvasWidth.value,
          "height": canvasHeight.value
        }, null), props.color && createVNode("div", {
          "class": ["v-color-picker-canvas__dot", {
            "v-color-picker-canvas__dot--disabled": props.disabled
          }],
          "style": dotStyles.value
        }, null)]);
      });
      return {};
    }
  });
  var VColorPickerEdit$1 = "";
  function stripAlpha(color, stripAlpha2) {
    if (stripAlpha2) {
      var a = color.a,
        rest = _objectWithoutProperties(color, _excluded14);
      return rest;
    }
    return color;
  }
  function extractColor(color, input) {
    if (input == null || typeof input === "string") {
      var hex2 = HSVtoHex(color);
      if (color.a === 1) return hex2.slice(0, 7);else return hex2;
    }
    if (_typeof(input) === "object") {
      var converted;
      if (has(input, ["r", "g", "b"])) converted = HSVtoRGB(color);else if (has(input, ["h", "s", "l"])) converted = HSVtoHSL(color);else if (has(input, ["h", "s", "v"])) converted = color;
      return stripAlpha(converted, !has(input, ["a"]) && color.a === 1);
    }
    return color;
  }
  var nullColor = {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  var rgba = {
    inputProps: {
      type: "number",
      min: 0
    },
    inputs: [{
      label: "R",
      max: 255,
      step: 1,
      getValue: function (c) {
        return Math.round(c.r);
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          r: Number(v)
        });
      }
    }, {
      label: "G",
      max: 255,
      step: 1,
      getValue: function (c) {
        return Math.round(c.g);
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          g: Number(v)
        });
      }
    }, {
      label: "B",
      max: 255,
      step: 1,
      getValue: function (c) {
        return Math.round(c.b);
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          b: Number(v)
        });
      }
    }, {
      label: "A",
      max: 1,
      step: 0.01,
      getValue: function (_ref) {
        var a = _ref.a;
        return a != null ? Math.round(a * 100) / 100 : 1;
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          a: Number(v)
        });
      }
    }],
    to: HSVtoRGB,
    from: RGBtoHSV
  };
  var rgb = _objectSpread(_objectSpread({}, rgba), {}, {
    inputs: (_a = rgba.inputs) == null ? void 0 : _a.slice(0, 3)
  });
  var hsla = {
    inputProps: {
      type: "number",
      min: 0
    },
    inputs: [{
      label: "H",
      max: 360,
      step: 1,
      getValue: function (c) {
        return Math.round(c.h);
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          h: Number(v)
        });
      }
    }, {
      label: "S",
      max: 1,
      step: 0.01,
      getValue: function (c) {
        return Math.round(c.s * 100) / 100;
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          s: Number(v)
        });
      }
    }, {
      label: "L",
      max: 1,
      step: 0.01,
      getValue: function (c) {
        return Math.round(c.l * 100) / 100;
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          l: Number(v)
        });
      }
    }, {
      label: "A",
      max: 1,
      step: 0.01,
      getValue: function (_ref2) {
        var a = _ref2.a;
        return a != null ? Math.round(a * 100) / 100 : 1;
      },
      getColor: function (c, v) {
        return _objectSpread(_objectSpread({}, c), {}, {
          a: Number(v)
        });
      }
    }],
    to: HSVtoHSL,
    from: HSLtoHSV
  };
  var hsl = _objectSpread(_objectSpread({}, hsla), {}, {
    inputs: hsla.inputs.slice(0, 3)
  });
  var hexa = {
    inputProps: {
      type: "text"
    },
    inputs: [{
      label: "HEXA",
      getValue: function (c) {
        return c;
      },
      getColor: function (c, v) {
        return v;
      }
    }],
    to: HSVtoHex,
    from: HexToHSV
  };
  var hex = _objectSpread(_objectSpread({}, hexa), {}, {
    inputs: [{
      label: "HEX",
      getValue: function (c) {
        return c.slice(0, 7);
      },
      getColor: function (c, v) {
        return v;
      }
    }]
  });
  var modes = {
    rgb: rgb,
    rgba: rgba,
    hsl: hsl,
    hsla: hsla,
    hex: hex,
    hexa: hexa
  };
  var VColorPickerInput = function (_ref) {
    var label = _ref.label,
      rest = _objectWithoutProperties(_ref, _excluded15);
    return createVNode("div", {
      "class": "v-color-picker-edit__input"
    }, [createVNode("input", rest, null), createVNode("span", null, [label])]);
  };
  var makeVColorPickerEditProps = propsFactory(_objectSpread({
    color: Object,
    disabled: Boolean,
    mode: {
      type: String,
      "default": "rgba",
      validator: function (v) {
        return Object.keys(modes).includes(v);
      }
    },
    modes: {
      type: Array,
      "default": function () {
        return Object.keys(modes);
      },
      validator: function (v) {
        return Array.isArray(v) && v.every(function (m3) {
          return Object.keys(modes).includes(m3);
        });
      }
    }
  }, makeComponentProps()), "VColorPickerEdit");
  var VColorPickerEdit = defineComponent({
    name: "VColorPickerEdit",
    props: makeVColorPickerEditProps(),
    emits: {
      "update:color": function (color) {
        return true;
      },
      "update:mode": function (mode) {
        return true;
      }
    },
    setup: function (props, _ref2) {
      var emit2 = _ref2.emit;
      var enabledModes = computed(function () {
        return props.modes.map(function (key) {
          return _objectSpread(_objectSpread({}, modes[key]), {}, {
            name: key
          });
        });
      });
      var inputs = computed(function () {
        var _a2;
        var mode = enabledModes.value.find(function (m3) {
          return m3.name === props.mode;
        });
        if (!mode) return [];
        var color = props.color ? mode.to(props.color) : null;
        return (_a2 = mode.inputs) == null ? void 0 : _a2.map(function (_ref3) {
          var getValue = _ref3.getValue,
            getColor = _ref3.getColor,
            inputProps = _objectWithoutProperties(_ref3, _excluded16);
          return _objectSpread(_objectSpread(_objectSpread({}, mode.inputProps), inputProps), {}, {
            disabled: props.disabled,
            value: color && getValue(color),
            onChange: function (e) {
              var target = e.target;
              if (!target) return;
              emit2("update:color", mode.from(getColor(color != null ? color : mode.to(nullColor), target.value)));
            }
          });
        });
      });
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-color-picker-edit", props.class],
          "style": props.style
        }, [(_a2 = inputs.value) == null ? void 0 : _a2.map(function (props2) {
          return createVNode(VColorPickerInput, props2, null);
        }), enabledModes.value.length > 1 && createVNode(VBtn, {
          "icon": "$unfold",
          "size": "x-small",
          "variant": "plain",
          "onClick": function () {
            var mi = enabledModes.value.findIndex(function (m3) {
              return m3.name === props.mode;
            });
            emit2("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
          }
        }, null)]);
      });
      return {};
    }
  });
  var VColorPickerPreview$1 = "";
  var VSlider$1 = "";
  var VSliderThumb$1 = "";
  var VSliderSymbol = Symbol.for("vuetify:v-slider");
  function getOffset(e, el, direction) {
    var vertical = direction === "vertical";
    var rect = el.getBoundingClientRect();
    var touch = "touches" in e ? e.touches[0] : e;
    return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);
  }
  function getPosition(e, position) {
    if ("touches" in e && e.touches.length) return e.touches[0][position];else if ("changedTouches" in e && e.changedTouches.length) return e.changedTouches[0][position];else return e[position];
  }
  var makeSliderProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    disabled: {
      type: Boolean,
      "default": null
    },
    error: Boolean,
    readonly: {
      type: Boolean,
      "default": null
    },
    max: {
      type: [Number, String],
      "default": 100
    },
    min: {
      type: [Number, String],
      "default": 0
    },
    step: {
      type: [Number, String],
      "default": 0
    },
    thumbColor: String,
    thumbLabel: {
      type: [Boolean, String],
      "default": void 0,
      validator: function (v) {
        return typeof v === "boolean" || v === "always";
      }
    },
    thumbSize: {
      type: [Number, String],
      "default": 20
    },
    showTicks: {
      type: [Boolean, String],
      "default": false,
      validator: function (v) {
        return typeof v === "boolean" || v === "always";
      }
    },
    ticks: {
      type: [Array, Object]
    },
    tickSize: {
      type: [Number, String],
      "default": 2
    },
    color: String,
    trackColor: String,
    trackFillColor: String,
    trackSize: {
      type: [Number, String],
      "default": 4
    },
    direction: {
      type: String,
      "default": "horizontal",
      validator: function (v) {
        return ["vertical", "horizontal"].includes(v);
      }
    },
    reverse: Boolean
  }, makeRoundedProps()), makeElevationProps({
    elevation: 2
  })), {}, {
    ripple: {
      type: Boolean,
      "default": true
    }
  }), "Slider");
  var useSteps = function (props) {
    var min = computed(function () {
      return parseFloat(props.min);
    });
    var max = computed(function () {
      return parseFloat(props.max);
    });
    var step = computed(function () {
      return +props.step > 0 ? parseFloat(props.step) : 0;
    });
    var decimals = computed(function () {
      return Math.max(getDecimals(step.value), getDecimals(min.value));
    });
    function roundValue(value) {
      value = parseFloat(value);
      if (step.value <= 0) return value;
      var clamped = clamp(value, min.value, max.value);
      var offset = min.value % step.value;
      var newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
      return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
    }
    return {
      min: min,
      max: max,
      step: step,
      decimals: decimals,
      roundValue: roundValue
    };
  };
  var useSlider = function (_ref) {
    var props = _ref.props,
      steps = _ref.steps,
      onSliderStart = _ref.onSliderStart,
      onSliderMove = _ref.onSliderMove,
      onSliderEnd = _ref.onSliderEnd,
      getActiveThumb = _ref.getActiveThumb;
    var _useRtl12 = useRtl(),
      isRtl = _useRtl12.isRtl;
    var isReversed = toRef(props, "reverse");
    var vertical = computed(function () {
      return props.direction === "vertical";
    });
    var indexFromEnd = computed(function () {
      return vertical.value !== isReversed.value;
    });
    var min = steps.min,
      max = steps.max,
      step = steps.step,
      decimals = steps.decimals,
      roundValue = steps.roundValue;
    var thumbSize = computed(function () {
      return parseInt(props.thumbSize, 10);
    });
    var tickSize = computed(function () {
      return parseInt(props.tickSize, 10);
    });
    var trackSize = computed(function () {
      return parseInt(props.trackSize, 10);
    });
    var numTicks = computed(function () {
      return (max.value - min.value) / step.value;
    });
    var disabled = toRef(props, "disabled");
    var thumbColor = computed(function () {
      var _a2;
      return props.error || props.disabled ? void 0 : (_a2 = props.thumbColor) != null ? _a2 : props.color;
    });
    var trackColor = computed(function () {
      var _a2;
      return props.error || props.disabled ? void 0 : (_a2 = props.trackColor) != null ? _a2 : props.color;
    });
    var trackFillColor = computed(function () {
      var _a2;
      return props.error || props.disabled ? void 0 : (_a2 = props.trackFillColor) != null ? _a2 : props.color;
    });
    var mousePressed = shallowRef(false);
    var startOffset = shallowRef(0);
    var trackContainerRef = ref();
    var activeThumbRef = ref();
    function parseMouseMove(e) {
      var _a2;
      var vertical2 = props.direction === "vertical";
      var start = vertical2 ? "top" : "left";
      var length = vertical2 ? "height" : "width";
      var position2 = vertical2 ? "clientY" : "clientX";
      var _ref281 = (_a2 = trackContainerRef.value) == null ? void 0 : _a2.$el.getBoundingClientRect(),
        trackStart = _ref281[start],
        trackLength = _ref281[length];
      var clickOffset = getPosition(e, position2);
      var clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
      if (vertical2 ? indexFromEnd.value : indexFromEnd.value !== isRtl.value) clickPos = 1 - clickPos;
      return roundValue(min.value + clickPos * (max.value - min.value));
    }
    var handleStop = function (e) {
      onSliderEnd({
        value: parseMouseMove(e)
      });
      mousePressed.value = false;
      startOffset.value = 0;
    };
    var handleStart = function (e) {
      activeThumbRef.value = getActiveThumb(e);
      if (!activeThumbRef.value) return;
      activeThumbRef.value.focus();
      mousePressed.value = true;
      if (activeThumbRef.value.contains(e.target)) {
        startOffset.value = getOffset(e, activeThumbRef.value, props.direction);
      } else {
        startOffset.value = 0;
        onSliderMove({
          value: parseMouseMove(e)
        });
      }
      onSliderStart({
        value: parseMouseMove(e)
      });
    };
    var moveListenerOptions = {
      passive: true,
      capture: true
    };
    function onMouseMove(e) {
      onSliderMove({
        value: parseMouseMove(e)
      });
    }
    function onSliderMouseUp(e) {
      e.stopPropagation();
      e.preventDefault();
      handleStop(e);
      window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
      window.removeEventListener("mouseup", onSliderMouseUp);
    }
    function onSliderTouchend(e) {
      var _a2;
      handleStop(e);
      window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
      (_a2 = e.target) == null ? void 0 : _a2.removeEventListener("touchend", onSliderTouchend);
    }
    function onSliderTouchstart(e) {
      var _a2;
      handleStart(e);
      window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
      (_a2 = e.target) == null ? void 0 : _a2.addEventListener("touchend", onSliderTouchend, {
        passive: false
      });
    }
    function onSliderMousedown(e) {
      e.preventDefault();
      handleStart(e);
      window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
      window.addEventListener("mouseup", onSliderMouseUp, {
        passive: false
      });
    }
    var position = function (val) {
      var percentage = (val - min.value) / (max.value - min.value) * 100;
      return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);
    };
    var showTicks = toRef(props, "showTicks");
    var parsedTicks = computed(function () {
      if (!showTicks.value) return [];
      if (!props.ticks) {
        return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map(function (t) {
          var value = min.value + t * step.value;
          return {
            value: value,
            position: position(value)
          };
        }) : [];
      }
      if (Array.isArray(props.ticks)) return props.ticks.map(function (t) {
        return {
          value: t,
          position: position(t),
          label: t.toString()
        };
      });
      return Object.keys(props.ticks).map(function (key) {
        return {
          value: parseFloat(key),
          position: position(parseFloat(key)),
          label: props.ticks[key]
        };
      });
    });
    var hasLabels = computed(function () {
      return parsedTicks.value.some(function (_ref2) {
        var label = _ref2.label;
        return !!label;
      });
    });
    var data = {
      activeThumbRef: activeThumbRef,
      color: toRef(props, "color"),
      decimals: decimals,
      disabled: disabled,
      direction: toRef(props, "direction"),
      elevation: toRef(props, "elevation"),
      hasLabels: hasLabels,
      isReversed: isReversed,
      indexFromEnd: indexFromEnd,
      min: min,
      max: max,
      mousePressed: mousePressed,
      numTicks: numTicks,
      onSliderMousedown: onSliderMousedown,
      onSliderTouchstart: onSliderTouchstart,
      parsedTicks: parsedTicks,
      parseMouseMove: parseMouseMove,
      position: position,
      readonly: toRef(props, "readonly"),
      rounded: toRef(props, "rounded"),
      roundValue: roundValue,
      showTicks: showTicks,
      startOffset: startOffset,
      step: step,
      thumbSize: thumbSize,
      thumbColor: thumbColor,
      thumbLabel: toRef(props, "thumbLabel"),
      ticks: toRef(props, "ticks"),
      tickSize: tickSize,
      trackColor: trackColor,
      trackContainerRef: trackContainerRef,
      trackFillColor: trackFillColor,
      trackSize: trackSize,
      vertical: vertical
    };
    provide(VSliderSymbol, data);
    return data;
  };
  var makeVSliderThumbProps = propsFactory(_objectSpread({
    focused: Boolean,
    max: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    modelValue: {
      type: Number,
      required: true
    },
    position: {
      type: Number,
      required: true
    },
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    name: String
  }, makeComponentProps()), "VSliderThumb");
  var VSliderThumb = genericComponent()({
    name: "VSliderThumb",
    directives: {
      Ripple: Ripple
    },
    props: makeVSliderThumbProps(),
    emits: {
      "update:modelValue": function (v) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots,
        emit2 = _ref.emit;
      var slider = inject$1(VSliderSymbol);
      var _useRtl13 = useRtl(),
        isRtl = _useRtl13.isRtl,
        rtlClasses = _useRtl13.rtlClasses;
      if (!slider) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
      var thumbColor = slider.thumbColor,
        step = slider.step,
        disabled = slider.disabled,
        thumbSize = slider.thumbSize,
        thumbLabel = slider.thumbLabel,
        direction = slider.direction,
        isReversed = slider.isReversed,
        vertical = slider.vertical,
        readonly2 = slider.readonly,
        elevation = slider.elevation,
        mousePressed = slider.mousePressed,
        decimals = slider.decimals,
        indexFromEnd = slider.indexFromEnd;
      var elevationProps = computed(function () {
        return !disabled.value ? elevation.value : void 0;
      });
      var _useElevation11 = useElevation(elevationProps),
        elevationClasses = _useElevation11.elevationClasses;
      var _useTextColor14 = useTextColor(thumbColor),
        textColorClasses = _useTextColor14.textColorClasses,
        textColorStyles = _useTextColor14.textColorStyles;
      var pageup = keyValues.pageup,
        pagedown = keyValues.pagedown,
        end = keyValues.end,
        home = keyValues.home,
        left = keyValues.left,
        right = keyValues.right,
        down = keyValues.down,
        up = keyValues.up;
      var relevantKeys = [pageup, pagedown, end, home, left, right, down, up];
      var multipliers = computed(function () {
        if (step.value) return [1, 2, 3];else return [1, 5, 10];
      });
      function parseKeydown(e, value) {
        if (!relevantKeys.includes(e.key)) return;
        e.preventDefault();
        var _step = step.value || 0.1;
        var steps = (props.max - props.min) / _step;
        if ([left, right, down, up].includes(e.key)) {
          var increase = vertical.value ? [isRtl.value ? left : right, isReversed.value ? down : up] : indexFromEnd.value !== isRtl.value ? [left, up] : [right, up];
          var direction2 = increase.includes(e.key) ? 1 : -1;
          var multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
          value = value + direction2 * _step * multipliers.value[multiplier];
        } else if (e.key === home) {
          value = props.min;
        } else if (e.key === end) {
          value = props.max;
        } else {
          var _direction = e.key === pagedown ? 1 : -1;
          value = value - _direction * _step * (steps > 100 ? steps / 10 : 10);
        }
        return Math.max(props.min, Math.min(props.max, value));
      }
      function onKeydown(e) {
        var newValue = parseKeydown(e, props.modelValue);
        newValue != null && emit2("update:modelValue", newValue);
      }
      useRender(function () {
        var positionPercentage = convertToUnit(indexFromEnd.value ? 100 - props.position : props.position, "%");
        return createVNode("div", {
          "class": ["v-slider-thumb", {
            "v-slider-thumb--focused": props.focused,
            "v-slider-thumb--pressed": props.focused && mousePressed.value
          }, props.class, rtlClasses.value],
          "style": [{
            "--v-slider-thumb-position": positionPercentage,
            "--v-slider-thumb-size": convertToUnit(thumbSize.value)
          }, props.style],
          "role": "slider",
          "tabindex": disabled.value ? -1 : 0,
          "aria-label": props.name,
          "aria-valuemin": props.min,
          "aria-valuemax": props.max,
          "aria-valuenow": props.modelValue,
          "aria-readonly": !!readonly2.value,
          "aria-orientation": direction.value,
          "onKeydown": !readonly2.value ? onKeydown : void 0
        }, [createVNode("div", {
          "class": ["v-slider-thumb__surface", textColorClasses.value, elevationClasses.value],
          "style": _objectSpread({}, textColorStyles.value)
        }, null), withDirectives(createVNode("div", {
          "class": ["v-slider-thumb__ripple", textColorClasses.value],
          "style": textColorStyles.value
        }, null), [[resolveDirective("ripple"), props.ripple, null, {
          circle: true,
          center: true
        }]]), createVNode(VScaleTransition, {
          "origin": "bottom center"
        }, {
          "default": function () {
            var _a2, _b;
            return [withDirectives(createVNode("div", {
              "class": "v-slider-thumb__label-container"
            }, [createVNode("div", {
              "class": ["v-slider-thumb__label"]
            }, [createVNode("div", null, [(_b = (_a2 = slots["thumb-label"]) == null ? void 0 : _a2.call(slots, {
              modelValue: props.modelValue
            })) != null ? _b : props.modelValue.toFixed(step.value ? decimals.value : 1)])])]), [[vShow, thumbLabel.value && props.focused || thumbLabel.value === "always"]])];
          }
        })]);
      });
      return {};
    }
  });
  var VSliderTrack$1 = "";
  var makeVSliderTrackProps = propsFactory(_objectSpread({
    start: {
      type: Number,
      required: true
    },
    stop: {
      type: Number,
      required: true
    }
  }, makeComponentProps()), "VSliderTrack");
  var VSliderTrack = genericComponent()({
    name: "VSliderTrack",
    props: makeVSliderTrackProps(),
    emits: {},
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var slider = inject$1(VSliderSymbol);
      if (!slider) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
      var color = slider.color,
        parsedTicks = slider.parsedTicks,
        rounded = slider.rounded,
        showTicks = slider.showTicks,
        tickSize = slider.tickSize,
        trackColor = slider.trackColor,
        trackFillColor = slider.trackFillColor,
        trackSize = slider.trackSize,
        vertical = slider.vertical,
        min = slider.min,
        max = slider.max,
        indexFromEnd = slider.indexFromEnd;
      var _useRounded17 = useRounded(rounded),
        roundedClasses = _useRounded17.roundedClasses;
      var _useBackgroundColor13 = useBackgroundColor(trackFillColor),
        trackFillColorClasses = _useBackgroundColor13.backgroundColorClasses,
        trackFillColorStyles = _useBackgroundColor13.backgroundColorStyles;
      var _useBackgroundColor14 = useBackgroundColor(trackColor),
        trackColorClasses = _useBackgroundColor14.backgroundColorClasses,
        trackColorStyles = _useBackgroundColor14.backgroundColorStyles;
      var startDir = computed(function () {
        return "inset-" + (vertical.value ? "block" : "inline") + "-" + (indexFromEnd.value ? "end" : "start");
      });
      var endDir = computed(function () {
        return vertical.value ? "height" : "width";
      });
      var backgroundStyles = computed(function () {
        var _ref282;
        return _ref282 = {}, _ref282[startDir.value] = "0%", _ref282[endDir.value] = "100%", _ref282;
      });
      var trackFillWidth = computed(function () {
        return props.stop - props.start;
      });
      var trackFillStyles = computed(function () {
        var _ref283;
        return _ref283 = {}, _ref283[startDir.value] = convertToUnit(props.start, "%"), _ref283[endDir.value] = convertToUnit(trackFillWidth.value, "%"), _ref283;
      });
      var computedTicks = computed(function () {
        if (!showTicks.value) return [];
        var ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
        return ticks.map(function (tick, index) {
          var _style;
          var _a2, _b;
          var directionValue = tick.value !== min.value && tick.value !== max.value ? convertToUnit(tick.position, "%") : void 0;
          return createVNode("div", {
            "key": tick.value,
            "class": ["v-slider-track__tick", {
              "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop,
              "v-slider-track__tick--first": tick.value === min.value,
              "v-slider-track__tick--last": tick.value === max.value
            }],
            "style": (_style = {}, _style[startDir.value] = directionValue, _style)
          }, [(tick.label || slots["tick-label"]) && createVNode("div", {
            "class": "v-slider-track__tick-label"
          }, [(_b = (_a2 = slots["tick-label"]) == null ? void 0 : _a2.call(slots, {
            tick: tick,
            index: index
          })) != null ? _b : tick.label])]);
        });
      });
      useRender(function () {
        return createVNode("div", {
          "class": ["v-slider-track", roundedClasses.value, props.class],
          "style": [{
            "--v-slider-track-size": convertToUnit(trackSize.value),
            "--v-slider-tick-size": convertToUnit(tickSize.value)
          }, props.style]
        }, [createVNode("div", {
          "class": ["v-slider-track__background", trackColorClasses.value, {
            "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
          }],
          "style": _objectSpread(_objectSpread({}, backgroundStyles.value), trackColorStyles.value)
        }, null), createVNode("div", {
          "class": ["v-slider-track__fill", trackFillColorClasses.value],
          "style": _objectSpread(_objectSpread({}, trackFillStyles.value), trackFillColorStyles.value)
        }, null), showTicks.value && createVNode("div", {
          "class": ["v-slider-track__ticks", {
            "v-slider-track__ticks--always-show": showTicks.value === "always"
          }]
        }, [computedTicks.value])]);
      });
      return {};
    }
  });
  var makeVSliderProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeFocusProps()), makeSliderProps()), makeVInputProps()), {}, {
    modelValue: {
      type: [Number, String],
      "default": 0
    }
  }), "VSlider");
  var VSlider = genericComponent()({
    name: "VSlider",
    props: makeVSliderProps(),
    emits: {
      "update:focused": function (value) {
        return true;
      },
      "update:modelValue": function (v) {
        return true;
      },
      start: function (value) {
        return true;
      },
      end: function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots,
        emit2 = _ref.emit;
      var thumbContainerRef = ref();
      var _useRtl14 = useRtl(),
        rtlClasses = _useRtl14.rtlClasses;
      var steps = useSteps(props);
      var model = useProxiedModel(props, "modelValue", void 0, function (value) {
        return steps.roundValue(value == null ? steps.min.value : value);
      });
      var _useSlider = useSlider({
          props: props,
          steps: steps,
          onSliderStart: function () {
            emit2("start", model.value);
          },
          onSliderEnd: function (_ref2) {
            var value = _ref2.value;
            var roundedValue = roundValue(value);
            model.value = roundedValue;
            emit2("end", roundedValue);
          },
          onSliderMove: function (_ref3) {
            var value = _ref3.value;
            return model.value = roundValue(value);
          },
          getActiveThumb: function () {
            var _a2;
            return (_a2 = thumbContainerRef.value) == null ? void 0 : _a2.$el;
          }
        }),
        min = _useSlider.min,
        max = _useSlider.max,
        mousePressed = _useSlider.mousePressed,
        roundValue = _useSlider.roundValue,
        onSliderMousedown = _useSlider.onSliderMousedown,
        onSliderTouchstart = _useSlider.onSliderTouchstart,
        trackContainerRef = _useSlider.trackContainerRef,
        position = _useSlider.position,
        hasLabels = _useSlider.hasLabels,
        readonly2 = _useSlider.readonly;
      var _useFocus4 = useFocus(props),
        isFocused = _useFocus4.isFocused,
        focus2 = _useFocus4.focus,
        blur2 = _useFocus4.blur;
      var trackStop = computed(function () {
        return position(model.value);
      });
      useRender(function () {
        var inputProps = VInput.filterProps(props);
        var hasPrepend = !!(props.label || slots.label || slots.prepend);
        return createVNode(VInput, mergeProps({
          "class": ["v-slider", {
            "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
            "v-slider--focused": isFocused.value,
            "v-slider--pressed": mousePressed.value,
            "v-slider--disabled": props.disabled
          }, rtlClasses.value, props.class],
          "style": props.style
        }, inputProps, {
          "focused": isFocused.value
        }), _objectSpread(_objectSpread({}, slots), {}, {
          prepend: hasPrepend ? function (slotProps) {
            var _a2, _b, _c;
            return createVNode(Fragment$1, null, [(_b = (_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) != null ? _b : props.label ? createVNode(VLabel, {
              "id": slotProps.id.value,
              "class": "v-slider__label",
              "text": props.label
            }, null) : void 0, (_c = slots.prepend) == null ? void 0 : _c.call(slots, slotProps)]);
          } : void 0,
          "default": function (_ref4) {
            var id = _ref4.id,
              messagesId = _ref4.messagesId;
            return createVNode("div", {
              "class": "v-slider__container",
              "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
              "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
            }, [createVNode("input", {
              "id": id.value,
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value
            }, null), createVNode(VSliderTrack, {
              "ref": trackContainerRef,
              "start": 0,
              "stop": trackStop.value
            }, {
              "tick-label": slots["tick-label"]
            }), createVNode(VSliderThumb, {
              "ref": thumbContainerRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused.value,
              "min": min.value,
              "max": max.value,
              "modelValue": model.value,
              "onUpdate:modelValue": function (v) {
                return model.value = v;
              },
              "position": trackStop.value,
              "elevation": props.elevation,
              "onFocus": focus2,
              "onBlur": blur2,
              "ripple": props.ripple,
              "name": props.name
            }, {
              "thumb-label": slots["thumb-label"]
            })]);
          }
        }));
      });
      return {};
    }
  });
  var makeVColorPickerPreviewProps = propsFactory(_objectSpread({
    color: {
      type: Object
    },
    disabled: Boolean,
    hideAlpha: Boolean
  }, makeComponentProps()), "VColorPickerPreview");
  var VColorPickerPreview = defineComponent({
    name: "VColorPickerPreview",
    props: makeVColorPickerPreviewProps(),
    emits: {
      "update:color": function (color) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit;
      var abortController = new AbortController();
      onUnmounted(function () {
        return abortController.abort();
      });
      function openEyeDropper() {
        var _a2, eyeDropper, result, colorHexValue;
        return _regeneratorRuntime.async(function openEyeDropper$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              if (SUPPORTS_EYE_DROPPER) {
                _context18.next = 2;
                break;
              }
              return _context18.abrupt("return");
            case 2:
              eyeDropper = new window.EyeDropper();
              _context18.prev = 3;
              _context18.next = 6;
              return _regeneratorRuntime.awrap(eyeDropper.open({
                signal: abortController.signal
              }));
            case 6:
              result = _context18.sent;
              colorHexValue = HexToHSV(result.sRGBHex);
              emit2("update:color", _objectSpread(_objectSpread({}, (_a2 = props.color) != null ? _a2 : nullColor), colorHexValue));
              _context18.next = 13;
              break;
            case 11:
              _context18.prev = 11;
              _context18.t0 = _context18["catch"](3);
            case 13:
            case "end":
              return _context18.stop();
          }
        }, null, null, [[3, 11]], Promise);
      }
      useRender(function () {
        var _a2, _b, _c, _d;
        return createVNode("div", {
          "class": ["v-color-picker-preview", {
            "v-color-picker-preview--hide-alpha": props.hideAlpha
          }, props.class],
          "style": props.style
        }, [SUPPORTS_EYE_DROPPER && createVNode("div", {
          "class": "v-color-picker-preview__eye-dropper",
          "key": "eyeDropper"
        }, [createVNode(VBtn, {
          "onClick": openEyeDropper,
          "icon": "$eyeDropper",
          "variant": "plain",
          "density": "comfortable"
        }, null)]), createVNode("div", {
          "class": "v-color-picker-preview__dot"
        }, [createVNode("div", {
          "style": {
            background: HSVtoCSS((_a2 = props.color) != null ? _a2 : nullColor)
          }
        }, null)]), createVNode("div", {
          "class": "v-color-picker-preview__sliders"
        }, [createVNode(VSlider, {
          "class": "v-color-picker-preview__track v-color-picker-preview__hue",
          "modelValue": (_b = props.color) == null ? void 0 : _b.h,
          "onUpdate:modelValue": function (h2) {
            var _a3;
            return emit2("update:color", _objectSpread(_objectSpread({}, (_a3 = props.color) != null ? _a3 : nullColor), {}, {
              h: h2
            }));
          },
          "step": 0,
          "min": 0,
          "max": 360,
          "disabled": props.disabled,
          "thumbSize": 14,
          "trackSize": 8,
          "trackFillColor": "white",
          "hideDetails": true
        }, null), !props.hideAlpha && createVNode(VSlider, {
          "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
          "modelValue": (_d = (_c = props.color) == null ? void 0 : _c.a) != null ? _d : 1,
          "onUpdate:modelValue": function (a) {
            var _a3;
            return emit2("update:color", _objectSpread(_objectSpread({}, (_a3 = props.color) != null ? _a3 : nullColor), {}, {
              a: a
            }));
          },
          "step": 1 / 256,
          "min": 0,
          "max": 1,
          "disabled": props.disabled,
          "thumbSize": 14,
          "trackSize": 8,
          "trackFillColor": "white",
          "hideDetails": true
        }, null)])]);
      });
      return {};
    }
  });
  var VColorPickerSwatches$1 = "";
  var red = {
    base: "#f44336",
    lighten5: "#ffebee",
    lighten4: "#ffcdd2",
    lighten3: "#ef9a9a",
    lighten2: "#e57373",
    lighten1: "#ef5350",
    darken1: "#e53935",
    darken2: "#d32f2f",
    darken3: "#c62828",
    darken4: "#b71c1c",
    accent1: "#ff8a80",
    accent2: "#ff5252",
    accent3: "#ff1744",
    accent4: "#d50000"
  };
  var pink = {
    base: "#e91e63",
    lighten5: "#fce4ec",
    lighten4: "#f8bbd0",
    lighten3: "#f48fb1",
    lighten2: "#f06292",
    lighten1: "#ec407a",
    darken1: "#d81b60",
    darken2: "#c2185b",
    darken3: "#ad1457",
    darken4: "#880e4f",
    accent1: "#ff80ab",
    accent2: "#ff4081",
    accent3: "#f50057",
    accent4: "#c51162"
  };
  var purple = {
    base: "#9c27b0",
    lighten5: "#f3e5f5",
    lighten4: "#e1bee7",
    lighten3: "#ce93d8",
    lighten2: "#ba68c8",
    lighten1: "#ab47bc",
    darken1: "#8e24aa",
    darken2: "#7b1fa2",
    darken3: "#6a1b9a",
    darken4: "#4a148c",
    accent1: "#ea80fc",
    accent2: "#e040fb",
    accent3: "#d500f9",
    accent4: "#aa00ff"
  };
  var deepPurple = {
    base: "#673ab7",
    lighten5: "#ede7f6",
    lighten4: "#d1c4e9",
    lighten3: "#b39ddb",
    lighten2: "#9575cd",
    lighten1: "#7e57c2",
    darken1: "#5e35b1",
    darken2: "#512da8",
    darken3: "#4527a0",
    darken4: "#311b92",
    accent1: "#b388ff",
    accent2: "#7c4dff",
    accent3: "#651fff",
    accent4: "#6200ea"
  };
  var indigo = {
    base: "#3f51b5",
    lighten5: "#e8eaf6",
    lighten4: "#c5cae9",
    lighten3: "#9fa8da",
    lighten2: "#7986cb",
    lighten1: "#5c6bc0",
    darken1: "#3949ab",
    darken2: "#303f9f",
    darken3: "#283593",
    darken4: "#1a237e",
    accent1: "#8c9eff",
    accent2: "#536dfe",
    accent3: "#3d5afe",
    accent4: "#304ffe"
  };
  var blue = {
    base: "#2196f3",
    lighten5: "#e3f2fd",
    lighten4: "#bbdefb",
    lighten3: "#90caf9",
    lighten2: "#64b5f6",
    lighten1: "#42a5f5",
    darken1: "#1e88e5",
    darken2: "#1976d2",
    darken3: "#1565c0",
    darken4: "#0d47a1",
    accent1: "#82b1ff",
    accent2: "#448aff",
    accent3: "#2979ff",
    accent4: "#2962ff"
  };
  var lightBlue = {
    base: "#03a9f4",
    lighten5: "#e1f5fe",
    lighten4: "#b3e5fc",
    lighten3: "#81d4fa",
    lighten2: "#4fc3f7",
    lighten1: "#29b6f6",
    darken1: "#039be5",
    darken2: "#0288d1",
    darken3: "#0277bd",
    darken4: "#01579b",
    accent1: "#80d8ff",
    accent2: "#40c4ff",
    accent3: "#00b0ff",
    accent4: "#0091ea"
  };
  var cyan = {
    base: "#00bcd4",
    lighten5: "#e0f7fa",
    lighten4: "#b2ebf2",
    lighten3: "#80deea",
    lighten2: "#4dd0e1",
    lighten1: "#26c6da",
    darken1: "#00acc1",
    darken2: "#0097a7",
    darken3: "#00838f",
    darken4: "#006064",
    accent1: "#84ffff",
    accent2: "#18ffff",
    accent3: "#00e5ff",
    accent4: "#00b8d4"
  };
  var teal = {
    base: "#009688",
    lighten5: "#e0f2f1",
    lighten4: "#b2dfdb",
    lighten3: "#80cbc4",
    lighten2: "#4db6ac",
    lighten1: "#26a69a",
    darken1: "#00897b",
    darken2: "#00796b",
    darken3: "#00695c",
    darken4: "#004d40",
    accent1: "#a7ffeb",
    accent2: "#64ffda",
    accent3: "#1de9b6",
    accent4: "#00bfa5"
  };
  var green = {
    base: "#4caf50",
    lighten5: "#e8f5e9",
    lighten4: "#c8e6c9",
    lighten3: "#a5d6a7",
    lighten2: "#81c784",
    lighten1: "#66bb6a",
    darken1: "#43a047",
    darken2: "#388e3c",
    darken3: "#2e7d32",
    darken4: "#1b5e20",
    accent1: "#b9f6ca",
    accent2: "#69f0ae",
    accent3: "#00e676",
    accent4: "#00c853"
  };
  var lightGreen = {
    base: "#8bc34a",
    lighten5: "#f1f8e9",
    lighten4: "#dcedc8",
    lighten3: "#c5e1a5",
    lighten2: "#aed581",
    lighten1: "#9ccc65",
    darken1: "#7cb342",
    darken2: "#689f38",
    darken3: "#558b2f",
    darken4: "#33691e",
    accent1: "#ccff90",
    accent2: "#b2ff59",
    accent3: "#76ff03",
    accent4: "#64dd17"
  };
  var lime = {
    base: "#cddc39",
    lighten5: "#f9fbe7",
    lighten4: "#f0f4c3",
    lighten3: "#e6ee9c",
    lighten2: "#dce775",
    lighten1: "#d4e157",
    darken1: "#c0ca33",
    darken2: "#afb42b",
    darken3: "#9e9d24",
    darken4: "#827717",
    accent1: "#f4ff81",
    accent2: "#eeff41",
    accent3: "#c6ff00",
    accent4: "#aeea00"
  };
  var yellow = {
    base: "#ffeb3b",
    lighten5: "#fffde7",
    lighten4: "#fff9c4",
    lighten3: "#fff59d",
    lighten2: "#fff176",
    lighten1: "#ffee58",
    darken1: "#fdd835",
    darken2: "#fbc02d",
    darken3: "#f9a825",
    darken4: "#f57f17",
    accent1: "#ffff8d",
    accent2: "#ffff00",
    accent3: "#ffea00",
    accent4: "#ffd600"
  };
  var amber = {
    base: "#ffc107",
    lighten5: "#fff8e1",
    lighten4: "#ffecb3",
    lighten3: "#ffe082",
    lighten2: "#ffd54f",
    lighten1: "#ffca28",
    darken1: "#ffb300",
    darken2: "#ffa000",
    darken3: "#ff8f00",
    darken4: "#ff6f00",
    accent1: "#ffe57f",
    accent2: "#ffd740",
    accent3: "#ffc400",
    accent4: "#ffab00"
  };
  var orange = {
    base: "#ff9800",
    lighten5: "#fff3e0",
    lighten4: "#ffe0b2",
    lighten3: "#ffcc80",
    lighten2: "#ffb74d",
    lighten1: "#ffa726",
    darken1: "#fb8c00",
    darken2: "#f57c00",
    darken3: "#ef6c00",
    darken4: "#e65100",
    accent1: "#ffd180",
    accent2: "#ffab40",
    accent3: "#ff9100",
    accent4: "#ff6d00"
  };
  var deepOrange = {
    base: "#ff5722",
    lighten5: "#fbe9e7",
    lighten4: "#ffccbc",
    lighten3: "#ffab91",
    lighten2: "#ff8a65",
    lighten1: "#ff7043",
    darken1: "#f4511e",
    darken2: "#e64a19",
    darken3: "#d84315",
    darken4: "#bf360c",
    accent1: "#ff9e80",
    accent2: "#ff6e40",
    accent3: "#ff3d00",
    accent4: "#dd2c00"
  };
  var brown = {
    base: "#795548",
    lighten5: "#efebe9",
    lighten4: "#d7ccc8",
    lighten3: "#bcaaa4",
    lighten2: "#a1887f",
    lighten1: "#8d6e63",
    darken1: "#6d4c41",
    darken2: "#5d4037",
    darken3: "#4e342e",
    darken4: "#3e2723"
  };
  var blueGrey = {
    base: "#607d8b",
    lighten5: "#eceff1",
    lighten4: "#cfd8dc",
    lighten3: "#b0bec5",
    lighten2: "#90a4ae",
    lighten1: "#78909c",
    darken1: "#546e7a",
    darken2: "#455a64",
    darken3: "#37474f",
    darken4: "#263238"
  };
  var grey = {
    base: "#9e9e9e",
    lighten5: "#fafafa",
    lighten4: "#f5f5f5",
    lighten3: "#eeeeee",
    lighten2: "#e0e0e0",
    lighten1: "#bdbdbd",
    darken1: "#757575",
    darken2: "#616161",
    darken3: "#424242",
    darken4: "#212121"
  };
  var shades = {
    black: "#000000",
    white: "#ffffff",
    transparent: "#ffffff00"
  };
  var colors = {
    red: red,
    pink: pink,
    purple: purple,
    deepPurple: deepPurple,
    indigo: indigo,
    blue: blue,
    lightBlue: lightBlue,
    cyan: cyan,
    teal: teal,
    green: green,
    lightGreen: lightGreen,
    lime: lime,
    yellow: yellow,
    amber: amber,
    orange: orange,
    deepOrange: deepOrange,
    brown: brown,
    blueGrey: blueGrey,
    grey: grey,
    shades: shades
  };
  var makeVColorPickerSwatchesProps = propsFactory(_objectSpread({
    swatches: {
      type: Array,
      "default": function () {
        return parseDefaultColors(colors);
      }
    },
    disabled: Boolean,
    color: Object,
    maxHeight: [Number, String]
  }, makeComponentProps()), "VColorPickerSwatches");
  function parseDefaultColors(colors2) {
    return Object.keys(colors2).map(function (key) {
      var color = colors2[key];
      return color.base ? [color.base, color.darken4, color.darken3, color.darken2, color.darken1, color.lighten1, color.lighten2, color.lighten3, color.lighten4, color.lighten5] : [color.black, color.white, color.transparent];
    });
  }
  var VColorPickerSwatches = defineComponent({
    name: "VColorPickerSwatches",
    props: makeVColorPickerSwatchesProps(),
    emits: {
      "update:color": function (color) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit;
      useRender(function () {
        return createVNode("div", {
          "class": ["v-color-picker-swatches", props.class],
          "style": [{
            maxHeight: convertToUnit(props.maxHeight)
          }, props.style]
        }, [createVNode("div", null, [props.swatches.map(function (swatch) {
          return createVNode("div", {
            "class": "v-color-picker-swatches__swatch"
          }, [swatch.map(function (color) {
            var rgba2 = parseColor(color);
            var hsva = RGBtoHSV(rgba2);
            var background = RGBtoCSS(rgba2);
            return createVNode("div", {
              "class": "v-color-picker-swatches__color",
              "onClick": function () {
                return hsva && emit2("update:color", hsva);
              }
            }, [createVNode("div", {
              "style": {
                background: background
              }
            }, [props.color && deepEqual(props.color, hsva) ? createVNode(VIcon, {
              "size": "x-small",
              "icon": "$success",
              "color": getContrast(color, "#FFFFFF") > 2 ? "white" : "black"
            }, null) : void 0])]);
          })]);
        })])]);
      });
      return {};
    }
  });
  var VSheet$1 = "";
  var makeVSheetProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    color: String
  }, makeBorderProps()), makeComponentProps()), makeDimensionProps()), makeElevationProps()), makeLocationProps()), makePositionProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VSheet");
  var VSheet = genericComponent()({
    name: "VSheet",
    props: makeVSheetProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme20 = provideTheme(props),
        themeClasses = _provideTheme20.themeClasses;
      var _useBackgroundColor15 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor15.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor15.backgroundColorStyles;
      var _useBorder11 = useBorder(props),
        borderClasses = _useBorder11.borderClasses;
      var _useDimension11 = useDimension(props),
        dimensionStyles = _useDimension11.dimensionStyles;
      var _useElevation12 = useElevation(props),
        elevationClasses = _useElevation12.elevationClasses;
      var _useLocation7 = useLocation(props),
        locationStyles = _useLocation7.locationStyles;
      var _usePosition5 = usePosition(props),
        positionClasses = _usePosition5.positionClasses;
      var _useRounded18 = useRounded(props),
        roundedClasses = _useRounded18.roundedClasses;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style]
        }, slots);
      });
      return {};
    }
  });
  var makeVColorPickerProps = propsFactory(_objectSpread({
    canvasHeight: {
      type: [String, Number],
      "default": 150
    },
    disabled: Boolean,
    dotSize: {
      type: [Number, String],
      "default": 10
    },
    hideCanvas: Boolean,
    hideSliders: Boolean,
    hideInputs: Boolean,
    mode: {
      type: String,
      "default": "rgba",
      validator: function (v) {
        return Object.keys(modes).includes(v);
      }
    },
    modes: {
      type: Array,
      "default": function () {
        return Object.keys(modes);
      },
      validator: function (v) {
        return Array.isArray(v) && v.every(function (m3) {
          return Object.keys(modes).includes(m3);
        });
      }
    },
    showSwatches: Boolean,
    swatches: Array,
    swatchesMaxHeight: {
      type: [Number, String],
      "default": 150
    },
    modelValue: {
      type: [Object, String]
    }
  }, omit(makeVSheetProps({
    width: 300
  }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])), "VColorPicker");
  var VColorPicker = defineComponent({
    name: "VColorPicker",
    props: makeVColorPickerProps(),
    emits: {
      "update:modelValue": function (color) {
        return true;
      },
      "update:mode": function (mode) {
        return true;
      }
    },
    setup: function (props) {
      var mode = useProxiedModel(props, "mode");
      var hue = ref(null);
      var model = useProxiedModel(props, "modelValue", void 0, function (v) {
        if (v == null || v === "") return null;
        var c;
        try {
          c = RGBtoHSV(parseColor(v));
        } catch (err) {
          consoleWarn(err);
          return null;
        }
        return c;
      }, function (v) {
        if (!v) return null;
        return extractColor(v, props.modelValue);
      });
      var currentColor = computed(function () {
        var _a2;
        return model.value ? _objectSpread(_objectSpread({}, model.value), {}, {
          h: (_a2 = hue.value) != null ? _a2 : model.value.h
        }) : null;
      });
      var _useRtl15 = useRtl(),
        rtlClasses = _useRtl15.rtlClasses;
      var externalChange = true;
      watch(model, function (v) {
        if (!externalChange) {
          externalChange = true;
          return;
        }
        if (!v) return;
        hue.value = v.h;
      }, {
        immediate: true
      });
      var updateColor = function (hsva) {
        externalChange = false;
        hue.value = hsva.h;
        model.value = hsva;
      };
      onBeforeMount(function () {
        if (!props.modes.includes(mode.value)) mode.value = props.modes[0];
      });
      provideDefaults({
        VSlider: {
          color: void 0,
          trackColor: void 0,
          trackFillColor: void 0
        }
      });
      useRender(function () {
        var _a2;
        var sheetProps = VSheet.filterProps(props);
        return createVNode(VSheet, mergeProps({
          "rounded": props.rounded,
          "elevation": props.elevation,
          "theme": props.theme,
          "class": ["v-color-picker", rtlClasses.value, props.class],
          "style": [{
            "--v-color-picker-color-hsv": HSVtoCSS(_objectSpread(_objectSpread({}, (_a2 = currentColor.value) != null ? _a2 : nullColor), {}, {
              a: 1
            }))
          }, props.style]
        }, sheetProps, {
          "maxWidth": props.width
        }), {
          "default": function () {
            return [!props.hideCanvas && createVNode(VColorPickerCanvas, {
              "key": "canvas",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "disabled": props.disabled,
              "dotSize": props.dotSize,
              "width": props.width,
              "height": props.canvasHeight
            }, null), (!props.hideSliders || !props.hideInputs) && createVNode("div", {
              "key": "controls",
              "class": "v-color-picker__controls"
            }, [!props.hideSliders && createVNode(VColorPickerPreview, {
              "key": "preview",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "hideAlpha": !mode.value.endsWith("a"),
              "disabled": props.disabled
            }, null), !props.hideInputs && createVNode(VColorPickerEdit, {
              "key": "edit",
              "modes": props.modes,
              "mode": mode.value,
              "onUpdate:mode": function (m3) {
                return mode.value = m3;
              },
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "disabled": props.disabled
            }, null)]), props.showSwatches && createVNode(VColorPickerSwatches, {
              "key": "swatches",
              "color": currentColor.value,
              "onUpdate:color": updateColor,
              "maxHeight": props.swatchesMaxHeight,
              "swatches": props.swatches,
              "disabled": props.disabled
            }, null)];
          }
        });
      });
      return {};
    }
  });
  var VCombobox$1 = "";
  function highlightResult(text, matches2, length) {
    if (matches2 == null) return text;
    if (Array.isArray(matches2)) throw new Error("Multiple matches is not implemented");
    return typeof matches2 === "number" && ~matches2 ? createVNode(Fragment$1, null, [createVNode("span", {
      "class": "v-combobox__unmask"
    }, [text.substr(0, matches2)]), createVNode("span", {
      "class": "v-combobox__mask"
    }, [text.substr(matches2, length)]), createVNode("span", {
      "class": "v-combobox__unmask"
    }, [text.substr(matches2 + length)])]) : text;
  }
  var makeVComboboxProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    autoSelectFirst: {
      type: [Boolean, String]
    },
    clearOnSelect: {
      type: Boolean,
      "default": true
    },
    delimiters: Array
  }, makeFilterProps({
    filterKeys: ["title"]
  })), makeSelectProps({
    hideNoData: true,
    returnObject: true
  })), omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"])), makeTransitionProps({
    transition: false
  })), "VCombobox");
  var VCombobox = genericComponent()({
    name: "VCombobox",
    props: makeVComboboxProps(),
    emits: {
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      "update:search": function (value) {
        return true;
      },
      "update:menu": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var _a2, _b;
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var _useLocale9 = useLocale(),
        t = _useLocale9.t;
      var vTextFieldRef = ref();
      var isFocused = shallowRef(false);
      var isPristine = shallowRef(true);
      var listHasFocus = shallowRef(false);
      var vMenuRef = ref();
      var vVirtualScrollRef = ref();
      var _menu = useProxiedModel(props, "menu");
      var menu = computed({
        get: function () {
          return _menu.value;
        },
        set: function (v) {
          var _a3;
          if (_menu.value && !v && ((_a3 = vMenuRef.value) == null ? void 0 : _a3.openChildren.size)) return;
          _menu.value = v;
        }
      });
      var selectionIndex = shallowRef(-1);
      var cleared = false;
      var color = computed(function () {
        var _a3;
        return (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.color;
      });
      var label = computed(function () {
        return menu.value ? props.closeText : props.openText;
      });
      var _useItems3 = useItems(props),
        items = _useItems3.items,
        transformIn = _useItems3.transformIn,
        transformOut = _useItems3.transformOut;
      var _useTextColor15 = useTextColor(color),
        textColorClasses = _useTextColor15.textColorClasses,
        textColorStyles = _useTextColor15.textColorStyles;
      var model = useProxiedModel(props, "modelValue", [], function (v) {
        return transformIn(wrapInArray(v));
      }, function (v) {
        var _a3;
        var transformed = transformOut(v);
        return props.multiple ? transformed : (_a3 = transformed[0]) != null ? _a3 : null;
      });
      var form = useForm();
      var hasChips = computed(function () {
        return !!(props.chips || slots.chip);
      });
      var hasSelectionSlot = computed(function () {
        return hasChips.value || !!slots.selection;
      });
      var _search = shallowRef(!props.multiple && !hasSelectionSlot.value ? (_b = (_a2 = model.value[0]) == null ? void 0 : _a2.title) != null ? _b : "" : "");
      var search = computed({
        get: function () {
          return _search.value;
        },
        set: function (val) {
          var _a3;
          _search.value = val != null ? val : "";
          if (!props.multiple && !hasSelectionSlot.value) {
            model.value = [transformItem$3(props, val)];
          }
          if (val && props.multiple && ((_a3 = props.delimiters) == null ? void 0 : _a3.length)) {
            var values = val.split(new RegExp("(?:" + props.delimiters.join("|") + ")+"));
            if (values.length > 1) {
              values.forEach(function (v) {
                v = v.trim();
                if (v) select(transformItem$3(props, v));
              });
              _search.value = "";
            }
          }
          if (!val) selectionIndex.value = -1;
          isPristine.value = !val;
        }
      });
      var counterValue = computed(function () {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : typeof props.counterValue === "number" ? props.counterValue : props.multiple ? model.value.length : search.value.length;
      });
      watch(_search, function (value) {
        if (cleared) {
          nextTick(function () {
            return cleared = false;
          });
        } else if (isFocused.value && !menu.value) {
          menu.value = true;
        }
        emit2("update:search", value);
      });
      watch(model, function (value) {
        var _a3, _b2;
        if (!props.multiple && !hasSelectionSlot.value) {
          _search.value = (_b2 = (_a3 = value[0]) == null ? void 0 : _a3.title) != null ? _b2 : "";
        }
      });
      var _useFilter2 = useFilter(props, items, function () {
          return isPristine.value ? "" : search.value;
        }),
        filteredItems = _useFilter2.filteredItems,
        getMatches = _useFilter2.getMatches;
      var displayItems = computed(function () {
        if (props.hideSelected) {
          return filteredItems.value.filter(function (filteredItem) {
            return !model.value.some(function (s) {
              return s.value === filteredItem.value;
            });
          });
        }
        return filteredItems.value;
      });
      var selectedValues = computed(function () {
        return model.value.map(function (selection) {
          return selection.value;
        });
      });
      var highlightFirst = computed(function () {
        var _a3;
        var selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === ((_a3 = displayItems.value[0]) == null ? void 0 : _a3.title);
        return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
      });
      var menuDisabled = computed(function () {
        return props.hideNoData && !displayItems.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value);
      });
      var listRef = ref();
      var listEvents = useScrolling(listRef, vTextFieldRef);
      function onClear(e) {
        cleared = true;
        if (props.openOnClear) {
          menu.value = true;
        }
      }
      function onMousedownControl() {
        if (menuDisabled.value) return;
        menu.value = true;
      }
      function onMousedownMenuIcon(e) {
        if (menuDisabled.value) return;
        if (isFocused.value) {
          e.preventDefault();
          e.stopPropagation();
        }
        menu.value = !menu.value;
      }
      function onListKeydown(e) {
        var _a3;
        if (checkPrintable(e)) {
          (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
        }
      }
      function onKeydown(e) {
        var _a3;
        if (isComposingIgnoreKey(e) || props.readonly || (form == null ? void 0 : form.isReadonly.value)) return;
        var selectionStart = vTextFieldRef.value.selectionStart;
        var length = model.value.length;
        if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
          e.preventDefault();
        }
        if (["Enter", "ArrowDown"].includes(e.key)) {
          menu.value = true;
        }
        if (["Escape"].includes(e.key)) {
          menu.value = false;
        }
        if (["Enter", "Escape", "Tab"].includes(e.key)) {
          if (highlightFirst.value && ["Enter", "Tab"].includes(e.key) && !model.value.some(function (_ref2) {
            var value = _ref2.value;
            return value === displayItems.value[0].value;
          })) {
            select(filteredItems.value[0]);
          }
          isPristine.value = true;
        }
        if (e.key === "ArrowDown" && highlightFirst.value) {
          (_a3 = listRef.value) == null ? void 0 : _a3.focus("next");
        }
        if (e.key === "Enter" && search.value) {
          select(transformItem$3(props, search.value));
          if (hasSelectionSlot.value) _search.value = "";
        }
        if (["Backspace", "Delete"].includes(e.key)) {
          if (!props.multiple && hasSelectionSlot.value && model.value.length > 0 && !search.value) return select(model.value[0], false);
          if (~selectionIndex.value) {
            var originalSelectionIndex = selectionIndex.value;
            select(model.value[selectionIndex.value], false);
            selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
          } else if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
        }
        if (!props.multiple) return;
        if (e.key === "ArrowLeft") {
          if (selectionIndex.value < 0 && selectionStart > 0) return;
          var prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
          if (model.value[prev]) {
            selectionIndex.value = prev;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
          }
        }
        if (e.key === "ArrowRight") {
          if (selectionIndex.value < 0) return;
          var next = selectionIndex.value + 1;
          if (model.value[next]) {
            selectionIndex.value = next;
          } else {
            selectionIndex.value = -1;
            vTextFieldRef.value.setSelectionRange(0, 0);
          }
        }
      }
      function onAfterEnter() {
        var _a3;
        if (props.eager) {
          (_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.calculateVisibleItems();
        }
      }
      function onAfterLeave() {
        var _a3;
        if (isFocused.value) {
          isPristine.value = true;
          (_a3 = vTextFieldRef.value) == null ? void 0 : _a3.focus();
        }
      }
      function select(item) {
        var set = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (!item || item.props.disabled) return;
        if (props.multiple) {
          var index = model.value.findIndex(function (selection) {
            return props.valueComparator(selection.value, item.value);
          });
          var add = set == null ? !~index : set;
          if (~index) {
            var value = add ? [].concat(_toConsumableArray(model.value), [item]) : _toConsumableArray(model.value);
            value.splice(index, 1);
            model.value = value;
          } else if (add) {
            model.value = [].concat(_toConsumableArray(model.value), [item]);
          }
          if (props.clearOnSelect) {
            search.value = "";
          }
        } else {
          var _add3 = set !== false;
          model.value = _add3 ? [item] : [];
          _search.value = _add3 && !hasSelectionSlot.value ? item.title : "";
          nextTick(function () {
            menu.value = false;
            isPristine.value = true;
          });
        }
      }
      function onFocusin(e) {
        isFocused.value = true;
        setTimeout(function () {
          listHasFocus.value = true;
        });
      }
      function onFocusout(e) {
        listHasFocus.value = false;
      }
      function onUpdateModelValue(v) {
        if (v == null || v === "" && !props.multiple && !hasSelectionSlot.value) model.value = [];
      }
      watch(isFocused, function (val, oldVal) {
        if (val || val === oldVal) return;
        selectionIndex.value = -1;
        menu.value = false;
        if (search.value) {
          if (props.multiple) {
            select(transformItem$3(props, search.value));
            return;
          }
          if (!hasSelectionSlot.value) return;
          if (model.value.some(function (_ref3) {
            var title = _ref3.title;
            return title === search.value;
          })) {
            _search.value = "";
          } else {
            select(transformItem$3(props, search.value));
          }
        }
      });
      watch(menu, function () {
        if (!props.hideSelected && menu.value && model.value.length) {
          var index = displayItems.value.findIndex(function (item) {
            return model.value.some(function (s) {
              return props.valueComparator(s.value, item.value);
            });
          });
          IN_BROWSER && window.requestAnimationFrame(function () {
            var _a3;
            index >= 0 && ((_a3 = vVirtualScrollRef.value) == null ? void 0 : _a3.scrollToIndex(index));
          });
        }
      });
      watch(function () {
        return props.items;
      }, function (newVal, oldVal) {
        if (menu.value) return;
        if (isFocused.value && !oldVal.length && newVal.length) {
          menu.value = true;
        }
      });
      useRender(function () {
        var _ref284;
        var hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
        var isDirty2 = model.value.length > 0;
        var textFieldProps = VTextField.filterProps(props);
        return createVNode(VTextField, mergeProps({
          "ref": vTextFieldRef
        }, textFieldProps, {
          "modelValue": search.value,
          "onUpdate:modelValue": [function ($event) {
            return search.value = $event;
          }, onUpdateModelValue],
          "focused": isFocused.value,
          "onUpdate:focused": function ($event) {
            return isFocused.value = $event;
          },
          "validationValue": model.externalValue,
          "counterValue": counterValue.value,
          "dirty": isDirty2,
          "class": ["v-combobox", (_ref284 = {
            "v-combobox--active-menu": menu.value,
            "v-combobox--chips": !!props.chips,
            "v-combobox--selection-slot": !!hasSelectionSlot.value,
            "v-combobox--selecting-index": selectionIndex.value > -1
          }, _ref284["v-combobox--" + (props.multiple ? "multiple" : "single")] = true, _ref284), props.class],
          "style": props.style,
          "readonly": props.readonly,
          "placeholder": isDirty2 ? void 0 : props.placeholder,
          "onClick:clear": onClear,
          "onMousedown:control": onMousedownControl,
          "onKeydown": onKeydown
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function () {
            return createVNode(Fragment$1, null, [createVNode(VMenu, mergeProps({
              "ref": vMenuRef,
              "modelValue": menu.value,
              "onUpdate:modelValue": function ($event) {
                return menu.value = $event;
              },
              "activator": "parent",
              "contentClass": "v-combobox__content",
              "disabled": menuDisabled.value,
              "eager": props.eager,
              "maxHeight": 310,
              "openOnClick": false,
              "closeOnContentClick": false,
              "transition": props.transition,
              "onAfterEnter": onAfterEnter,
              "onAfterLeave": onAfterLeave
            }, props.menuProps), {
              "default": function () {
                var _a3;
                return [hasList && createVNode(VList, mergeProps({
                  "ref": listRef,
                  "selected": selectedValues.value,
                  "selectStrategy": props.multiple ? "independent" : "single-independent",
                  "onMousedown": function (e) {
                    return e.preventDefault();
                  },
                  "onKeydown": onListKeydown,
                  "onFocusin": onFocusin,
                  "onFocusout": onFocusout,
                  "tabindex": "-1",
                  "aria-live": "polite",
                  "color": (_a3 = props.itemColor) != null ? _a3 : props.color
                }, listEvents, props.listProps), {
                  "default": function () {
                    var _a4, _b2, _c, _d;
                    return [(_a4 = slots["prepend-item"]) == null ? void 0 : _a4.call(slots), !displayItems.value.length && !props.hideNoData && ((_c = (_b2 = slots["no-data"]) == null ? void 0 : _b2.call(slots)) != null ? _c : createVNode(VListItem, {
                      "title": t(props.noDataText)
                    }, null)), createVNode(VVirtualScroll, {
                      "ref": vVirtualScrollRef,
                      "renderless": true,
                      "items": displayItems.value
                    }, {
                      "default": function (_ref4) {
                        var _a5, _b3;
                        var item = _ref4.item,
                          index = _ref4.index,
                          itemRef = _ref4.itemRef;
                        var itemProps = mergeProps(item.props, {
                          ref: itemRef,
                          key: index,
                          active: highlightFirst.value && index === 0 ? true : void 0,
                          onClick: function () {
                            return select(item, null);
                          }
                        });
                        return (_b3 = (_a5 = slots.item) == null ? void 0 : _a5.call(slots, {
                          item: item,
                          index: index,
                          props: itemProps
                        })) != null ? _b3 : createVNode(VListItem, mergeProps(itemProps, {
                          "role": "option"
                        }), {
                          prepend: function (_ref5) {
                            var isSelected = _ref5.isSelected;
                            return createVNode(Fragment$1, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                              "key": item.value,
                              "modelValue": isSelected,
                              "ripple": false,
                              "tabindex": "-1"
                            }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                              "image": item.props.prependAvatar
                            }, null), item.props.prependIcon && createVNode(VIcon, {
                              "icon": item.props.prependIcon
                            }, null)]);
                          },
                          title: function () {
                            var _a6, _b4, _c2;
                            return isPristine.value ? item.title : highlightResult(item.title, (_a6 = getMatches(item)) == null ? void 0 : _a6.title, (_c2 = (_b4 = search.value) == null ? void 0 : _b4.length) != null ? _c2 : 0);
                          }
                        });
                      }
                    }), (_d = slots["append-item"]) == null ? void 0 : _d.call(slots)];
                  }
                })];
              }
            }), model.value.map(function (item, index) {
              function onChipClose(e) {
                e.stopPropagation();
                e.preventDefault();
                select(item, false);
              }
              var slotProps = {
                "onClick:close": onChipClose,
                onKeydown: function (e) {
                  if (e.key !== "Enter" && e.key !== " ") return;
                  e.preventDefault();
                  e.stopPropagation();
                  onChipClose(e);
                },
                onMousedown: function (e) {
                  e.preventDefault();
                  e.stopPropagation();
                },
                modelValue: true,
                "onUpdate:modelValue": void 0
              };
              var hasSlot = hasChips.value ? !!slots.chip : !!slots.selection;
              var slotContent = hasSlot ? ensureValidVNode(hasChips.value ? slots.chip({
                item: item,
                index: index,
                props: slotProps
              }) : slots.selection({
                item: item,
                index: index
              })) : void 0;
              if (hasSlot && !slotContent) return void 0;
              return createVNode("div", {
                "key": item.value,
                "class": ["v-combobox__selection", index === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]],
                "style": index === selectionIndex.value ? textColorStyles.value : {}
              }, [hasChips.value ? !slots.chip ? createVNode(VChip, mergeProps({
                "key": "chip",
                "closable": props.closableChips,
                "size": "small",
                "text": item.title,
                "disabled": item.props.disabled
              }, slotProps), null) : createVNode(VDefaultsProvider, {
                "key": "chip-defaults",
                "defaults": {
                  VChip: {
                    closable: props.closableChips,
                    size: "small",
                    text: item.title
                  }
                }
              }, {
                "default": function () {
                  return [slotContent];
                }
              }) : slotContent != null ? slotContent : createVNode("span", {
                "class": "v-combobox__selection-text"
              }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
                "class": "v-combobox__selection-comma"
              }, [createTextVNode(",")])])]);
            })]);
          },
          "append-inner": function () {
            var _a11;
            var _a3;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return createVNode(Fragment$1, null, [(_a3 = slots["append-inner"]) == null ? void 0 : (_a11 = _a3).call.apply(_a11, [slots].concat(args)), (!props.hideNoData || props.items.length) && props.menuIcon ? createVNode(VIcon, {
              "class": "v-combobox__menu-icon",
              "icon": props.menuIcon,
              "onMousedown": onMousedownMenuIcon,
              "onClick": noop,
              "aria-label": t(label.value),
              "title": t(label.value),
              "tabindex": "-1"
            }, null) : void 0]);
          }
        }));
      });
      return forwardRefs({
        isFocused: isFocused,
        isPristine: isPristine,
        menu: menu,
        search: search,
        selectionIndex: selectionIndex,
        filteredItems: filteredItems,
        select: select
      }, vTextFieldRef);
    }
  });
  var makeVConfirmEditProps = propsFactory({
    modelValue: null,
    color: String,
    cancelText: {
      type: String,
      "default": "$vuetify.confirmEdit.cancel"
    },
    okText: {
      type: String,
      "default": "$vuetify.confirmEdit.ok"
    }
  }, "VConfirmEdit");
  var VConfirmEdit = genericComponent()({
    name: "VConfirmEdit",
    props: makeVConfirmEditProps(),
    emits: {
      cancel: function () {
        return true;
      },
      save: function (value) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var internalModel = ref();
      watchEffect(function () {
        internalModel.value = structuredClone(toRaw(model.value));
      });
      var _useLocale10 = useLocale(),
        t = _useLocale10.t;
      var isPristine = computed(function () {
        return deepEqual(model.value, internalModel.value);
      });
      function save() {
        model.value = internalModel.value;
        emit2("save", internalModel.value);
      }
      function cancel() {
        internalModel.value = structuredClone(toRaw(model.value));
        emit2("cancel");
      }
      var actionsUsed = false;
      useRender(function () {
        var _a2;
        var actions = createVNode(Fragment$1, null, [createVNode(VBtn, {
          "disabled": isPristine.value,
          "variant": "text",
          "color": props.color,
          "onClick": cancel,
          "text": t(props.cancelText)
        }, null), createVNode(VBtn, {
          "disabled": isPristine.value,
          "variant": "text",
          "color": props.color,
          "onClick": save,
          "text": t(props.okText)
        }, null)]);
        return createVNode(Fragment$1, null, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          model: internalModel,
          save: save,
          cancel: cancel,
          isPristine: isPristine.value,
          get actions() {
            actionsUsed = true;
            return actions;
          }
        }), !actionsUsed && actions]);
      });
      return {
        save: save,
        cancel: cancel,
        isPristine: isPristine
      };
    }
  });
  var makeDataTableExpandProps = propsFactory({
    expandOnClick: Boolean,
    showExpand: Boolean,
    expanded: {
      type: Array,
      "default": function () {
        return [];
      }
    }
  }, "DataTable-expand");
  var VDataTableExpandedKey = Symbol.for("vuetify:datatable:expanded");
  function provideExpanded(props) {
    var expandOnClick = toRef(props, "expandOnClick");
    var expanded = useProxiedModel(props, "expanded", props.expanded, function (v) {
      return new Set(v);
    }, function (v) {
      return _toConsumableArray(v.values());
    });
    function expand(item, value) {
      var newExpanded = new Set(expanded.value);
      if (!value) {
        newExpanded.delete(item.value);
      } else {
        newExpanded.add(item.value);
      }
      expanded.value = newExpanded;
    }
    function isExpanded(item) {
      return expanded.value.has(item.value);
    }
    function toggleExpand(item) {
      expand(item, !isExpanded(item));
    }
    var data = {
      expand: expand,
      expanded: expanded,
      expandOnClick: expandOnClick,
      isExpanded: isExpanded,
      toggleExpand: toggleExpand
    };
    provide(VDataTableExpandedKey, data);
    return data;
  }
  function useExpanded() {
    var data = inject$1(VDataTableExpandedKey);
    if (!data) throw new Error("foo");
    return data;
  }
  var makeDataTableGroupProps = propsFactory({
    groupBy: {
      type: Array,
      "default": function () {
        return [];
      }
    }
  }, "DataTable-group");
  var VDataTableGroupSymbol = Symbol.for("vuetify:data-table-group");
  function createGroupBy(props) {
    var groupBy = useProxiedModel(props, "groupBy");
    return {
      groupBy: groupBy
    };
  }
  function provideGroupBy(options) {
    var disableSort = options.disableSort,
      groupBy = options.groupBy,
      sortBy = options.sortBy;
    var opened = ref( /* @__PURE__ */new Set());
    var sortByWithGroups = computed(function () {
      return groupBy.value.map(function (val) {
        var _a2;
        return _objectSpread(_objectSpread({}, val), {}, {
          order: (_a2 = val.order) != null ? _a2 : false
        });
      }).concat((disableSort == null ? void 0 : disableSort.value) ? [] : sortBy.value);
    });
    function isGroupOpen(group) {
      return opened.value.has(group.id);
    }
    function toggleGroup(group) {
      var newOpened = new Set(opened.value);
      if (!isGroupOpen(group)) newOpened.add(group.id);else newOpened.delete(group.id);
      opened.value = newOpened;
    }
    function extractRows(items) {
      function dive(group) {
        var arr = [];
        for (var _iterator57 = _createForOfIteratorHelperLoose(group.items), _step59; !(_step59 = _iterator57()).done;) {
          var item = _step59.value;
          if ("type" in item && item.type === "group") {
            arr.push.apply(arr, _toConsumableArray(dive(item)));
          } else {
            arr.push(item);
          }
        }
        return arr;
      }
      return dive({
        type: "group",
        items: items,
        id: "dummy",
        key: "dummy",
        value: "dummy",
        depth: 0
      });
    }
    var data = {
      sortByWithGroups: sortByWithGroups,
      toggleGroup: toggleGroup,
      opened: opened,
      groupBy: groupBy,
      extractRows: extractRows,
      isGroupOpen: isGroupOpen
    };
    provide(VDataTableGroupSymbol, data);
    return data;
  }
  function useGroupBy() {
    var data = inject$1(VDataTableGroupSymbol);
    if (!data) throw new Error("Missing group!");
    return data;
  }
  function groupItemsByProperty(items, groupBy) {
    if (!items.length) return [];
    var groups = /* @__PURE__ */new Map();
    for (var _iterator58 = _createForOfIteratorHelperLoose(items), _step60; !(_step60 = _iterator58()).done;) {
      var item = _step60.value;
      var value = getObjectValueByPath(item.raw, groupBy);
      if (!groups.has(value)) {
        groups.set(value, []);
      }
      groups.get(value).push(item);
    }
    return groups;
  }
  function groupItems(items, groupBy) {
    var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
    if (!groupBy.length) return [];
    var groupedItems = groupItemsByProperty(items, groupBy[0]);
    var groups = [];
    var rest = groupBy.slice(1);
    groupedItems.forEach(function (items2, value) {
      var key = groupBy[0];
      var id = prefix + "_" + key + "_" + value;
      groups.push({
        depth: depth,
        id: id,
        key: key,
        value: value,
        items: rest.length ? groupItems(items2, rest, depth + 1, id) : items2,
        type: "group"
      });
    });
    return groups;
  }
  function flattenItems(items, opened) {
    var flatItems = [];
    for (var _iterator59 = _createForOfIteratorHelperLoose(items), _step61; !(_step61 = _iterator59()).done;) {
      var item = _step61.value;
      if ("type" in item && item.type === "group") {
        if (item.value != null) {
          flatItems.push(item);
        }
        if (opened.has(item.id) || item.value == null) {
          flatItems.push.apply(flatItems, _toConsumableArray(flattenItems(item.items, opened)));
        }
      } else {
        flatItems.push(item);
      }
    }
    return flatItems;
  }
  function useGroupedItems(items, groupBy, opened) {
    var flatItems = computed(function () {
      if (!groupBy.value.length) return items.value;
      var groupedItems = groupItems(items.value, groupBy.value.map(function (item) {
        return item.key;
      }));
      return flattenItems(groupedItems, opened.value);
    });
    return {
      flatItems: flatItems
    };
  }
  function useOptions(_ref) {
    var page = _ref.page,
      itemsPerPage = _ref.itemsPerPage,
      sortBy = _ref.sortBy,
      groupBy = _ref.groupBy,
      search = _ref.search;
    var vm = getCurrentInstance("VDataTable");
    var options = computed(function () {
      return {
        page: page.value,
        itemsPerPage: itemsPerPage.value,
        sortBy: sortBy.value,
        groupBy: groupBy.value,
        search: search.value
      };
    });
    var oldOptions = null;
    watch(options, function () {
      if (deepEqual(oldOptions, options.value)) return;
      if (oldOptions && oldOptions.search !== options.value.search) {
        page.value = 1;
      }
      vm.emit("update:options", options.value);
      oldOptions = options.value;
    }, {
      deep: true,
      immediate: true
    });
  }
  var makeDataTablePaginateProps = propsFactory({
    page: {
      type: [Number, String],
      "default": 1
    },
    itemsPerPage: {
      type: [Number, String],
      "default": 10
    }
  }, "DataTable-paginate");
  var VDataTablePaginationSymbol = Symbol.for("vuetify:data-table-pagination");
  function createPagination(props) {
    var page = useProxiedModel(props, "page", void 0, function (value) {
      return +(value != null ? value : 1);
    });
    var itemsPerPage = useProxiedModel(props, "itemsPerPage", void 0, function (value) {
      return +(value != null ? value : 10);
    });
    return {
      page: page,
      itemsPerPage: itemsPerPage
    };
  }
  function providePagination(options) {
    var page = options.page,
      itemsPerPage = options.itemsPerPage,
      itemsLength = options.itemsLength;
    var startIndex = computed(function () {
      if (itemsPerPage.value === -1) return 0;
      return itemsPerPage.value * (page.value - 1);
    });
    var stopIndex = computed(function () {
      if (itemsPerPage.value === -1) return itemsLength.value;
      return Math.min(itemsLength.value, startIndex.value + itemsPerPage.value);
    });
    var pageCount = computed(function () {
      if (itemsPerPage.value === -1 || itemsLength.value === 0) return 1;
      return Math.ceil(itemsLength.value / itemsPerPage.value);
    });
    watch([page, pageCount], function () {
      if (page.value > pageCount.value) {
        page.value = pageCount.value;
      }
    });
    function setItemsPerPage(value) {
      itemsPerPage.value = value;
      page.value = 1;
    }
    function nextPage() {
      page.value = clamp(page.value + 1, 1, pageCount.value);
    }
    function prevPage() {
      page.value = clamp(page.value - 1, 1, pageCount.value);
    }
    function setPage(value) {
      page.value = clamp(value, 1, pageCount.value);
    }
    var data = {
      page: page,
      itemsPerPage: itemsPerPage,
      startIndex: startIndex,
      stopIndex: stopIndex,
      pageCount: pageCount,
      itemsLength: itemsLength,
      nextPage: nextPage,
      prevPage: prevPage,
      setPage: setPage,
      setItemsPerPage: setItemsPerPage
    };
    provide(VDataTablePaginationSymbol, data);
    return data;
  }
  function usePagination() {
    var data = inject$1(VDataTablePaginationSymbol);
    if (!data) throw new Error("Missing pagination!");
    return data;
  }
  function usePaginatedItems(options) {
    var vm = getCurrentInstance("usePaginatedItems");
    var items = options.items,
      startIndex = options.startIndex,
      stopIndex = options.stopIndex,
      itemsPerPage = options.itemsPerPage;
    var paginatedItems = computed(function () {
      if (itemsPerPage.value <= 0) return items.value;
      return items.value.slice(startIndex.value, stopIndex.value);
    });
    watch(paginatedItems, function (val) {
      vm.emit("update:currentItems", val);
    });
    return {
      paginatedItems: paginatedItems
    };
  }
  var singleSelectStrategy = {
    showSelectAll: false,
    allSelected: function () {
      return [];
    },
    select: function (_ref) {
      var _a2;
      var items = _ref.items,
        value = _ref.value;
      return new Set(value ? [(_a2 = items[0]) == null ? void 0 : _a2.value] : []);
    },
    selectAll: function (_ref2) {
      var selected = _ref2.selected;
      return selected;
    }
  };
  var pageSelectStrategy = {
    showSelectAll: true,
    allSelected: function (_ref3) {
      var currentPage = _ref3.currentPage;
      return currentPage;
    },
    select: function (_ref4) {
      var items = _ref4.items,
        value = _ref4.value,
        selected = _ref4.selected;
      for (var _iterator60 = _createForOfIteratorHelperLoose(items), _step62; !(_step62 = _iterator60()).done;) {
        var item = _step62.value;
        if (value) selected.add(item.value);else selected.delete(item.value);
      }
      return selected;
    },
    selectAll: function (_ref5) {
      var value = _ref5.value,
        currentPage = _ref5.currentPage,
        selected = _ref5.selected;
      return pageSelectStrategy.select({
        items: currentPage,
        value: value,
        selected: selected
      });
    }
  };
  var allSelectStrategy = {
    showSelectAll: true,
    allSelected: function (_ref6) {
      var allItems = _ref6.allItems;
      return allItems;
    },
    select: function (_ref7) {
      var items = _ref7.items,
        value = _ref7.value,
        selected = _ref7.selected;
      for (var _iterator61 = _createForOfIteratorHelperLoose(items), _step63; !(_step63 = _iterator61()).done;) {
        var item = _step63.value;
        if (value) selected.add(item.value);else selected.delete(item.value);
      }
      return selected;
    },
    selectAll: function (_ref8) {
      var value = _ref8.value,
        allItems = _ref8.allItems,
        selected = _ref8.selected;
      return allSelectStrategy.select({
        items: allItems,
        value: value,
        selected: selected
      });
    }
  };
  var makeDataTableSelectProps = propsFactory({
    showSelect: Boolean,
    selectStrategy: {
      type: [String, Object],
      "default": "page"
    },
    modelValue: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    valueComparator: {
      type: Function,
      "default": deepEqual
    }
  }, "DataTable-select");
  var VDataTableSelectionSymbol = Symbol.for("vuetify:data-table-selection");
  function provideSelection(props, _ref9) {
    var allItems = _ref9.allItems,
      currentPage = _ref9.currentPage;
    var selected = useProxiedModel(props, "modelValue", props.modelValue, function (v) {
      return new Set(wrapInArray(v).map(function (v2) {
        var _a2, _b;
        return (_b = (_a2 = allItems.value.find(function (item) {
          return props.valueComparator(v2, item.value);
        })) == null ? void 0 : _a2.value) != null ? _b : v2;
      }));
    }, function (v) {
      return _toConsumableArray(v.values());
    });
    var allSelectable = computed(function () {
      return allItems.value.filter(function (item) {
        return item.selectable;
      });
    });
    var currentPageSelectable = computed(function () {
      return currentPage.value.filter(function (item) {
        return item.selectable;
      });
    });
    var selectStrategy = computed(function () {
      if (_typeof(props.selectStrategy) === "object") return props.selectStrategy;
      switch (props.selectStrategy) {
        case "single":
          return singleSelectStrategy;
        case "all":
          return allSelectStrategy;
        case "page":
        default:
          return pageSelectStrategy;
      }
    });
    function isSelected(items) {
      return wrapInArray(items).every(function (item) {
        return selected.value.has(item.value);
      });
    }
    function isSomeSelected(items) {
      return wrapInArray(items).some(function (item) {
        return selected.value.has(item.value);
      });
    }
    function select(items, value) {
      var newSelected = selectStrategy.value.select({
        items: items,
        value: value,
        selected: new Set(selected.value)
      });
      selected.value = newSelected;
    }
    function toggleSelect(item) {
      select([item], !isSelected([item]));
    }
    function selectAll2(value) {
      var newSelected = selectStrategy.value.selectAll({
        value: value,
        allItems: allSelectable.value,
        currentPage: currentPageSelectable.value,
        selected: new Set(selected.value)
      });
      selected.value = newSelected;
    }
    var someSelected = computed(function () {
      return selected.value.size > 0;
    });
    var allSelected = computed(function () {
      var items = selectStrategy.value.allSelected({
        allItems: allSelectable.value,
        currentPage: currentPageSelectable.value
      });
      return !!items.length && isSelected(items);
    });
    var showSelectAll = computed(function () {
      return selectStrategy.value.showSelectAll;
    });
    var data = {
      toggleSelect: toggleSelect,
      select: select,
      selectAll: selectAll2,
      isSelected: isSelected,
      isSomeSelected: isSomeSelected,
      someSelected: someSelected,
      allSelected: allSelected,
      showSelectAll: showSelectAll
    };
    provide(VDataTableSelectionSymbol, data);
    return data;
  }
  function useSelection() {
    var data = inject$1(VDataTableSelectionSymbol);
    if (!data) throw new Error("Missing selection!");
    return data;
  }
  var makeDataTableSortProps = propsFactory({
    sortBy: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    customKeySort: Object,
    multiSort: Boolean,
    mustSort: Boolean
  }, "DataTable-sort");
  var VDataTableSortSymbol = Symbol.for("vuetify:data-table-sort");
  function createSort(props) {
    var sortBy = useProxiedModel(props, "sortBy");
    var mustSort = toRef(props, "mustSort");
    var multiSort = toRef(props, "multiSort");
    return {
      sortBy: sortBy,
      mustSort: mustSort,
      multiSort: multiSort
    };
  }
  function provideSort(options) {
    var sortBy = options.sortBy,
      mustSort = options.mustSort,
      multiSort = options.multiSort,
      page = options.page;
    var toggleSort = function (column) {
      var _a2;
      if (column.key == null) return;
      var newSortBy = (_a2 = sortBy.value.map(function (x) {
        return _objectSpread({}, x);
      })) != null ? _a2 : [];
      var item = newSortBy.find(function (x) {
        return x.key === column.key;
      });
      if (!item) {
        if (multiSort.value) newSortBy = [].concat(_toConsumableArray(newSortBy), [{
          key: column.key,
          order: "asc"
        }]);else newSortBy = [{
          key: column.key,
          order: "asc"
        }];
      } else if (item.order === "desc") {
        if (mustSort.value) {
          item.order = "asc";
        } else {
          newSortBy = newSortBy.filter(function (x) {
            return x.key !== column.key;
          });
        }
      } else {
        item.order = "desc";
      }
      sortBy.value = newSortBy;
      if (page) page.value = 1;
    };
    function isSorted(column) {
      return !!sortBy.value.find(function (item) {
        return item.key === column.key;
      });
    }
    var data = {
      sortBy: sortBy,
      toggleSort: toggleSort,
      isSorted: isSorted
    };
    provide(VDataTableSortSymbol, data);
    return data;
  }
  function useSort() {
    var data = inject$1(VDataTableSortSymbol);
    if (!data) throw new Error("Missing sort!");
    return data;
  }
  function useSortedItems(props, items, sortBy, options) {
    var locale = useLocale();
    var sortedItems = computed(function () {
      var _a2, _b;
      if (!sortBy.value.length) return items.value;
      return sortItems(items.value, sortBy.value, locale.current.value, {
        transform: options == null ? void 0 : options.transform,
        sortFunctions: _objectSpread(_objectSpread({}, props.customKeySort), (_a2 = options == null ? void 0 : options.sortFunctions) == null ? void 0 : _a2.value),
        sortRawFunctions: (_b = options == null ? void 0 : options.sortRawFunctions) == null ? void 0 : _b.value
      });
    });
    return {
      sortedItems: sortedItems
    };
  }
  function sortItems(items, sortByItems, locale, options) {
    var stringCollator = new Intl.Collator(locale, {
      sensitivity: "accent",
      usage: "sort"
    });
    var transformedItems = items.map(function (item) {
      return [item, (options == null ? void 0 : options.transform) ? options.transform(item) : item];
    });
    return transformedItems.sort(function (a, b) {
      var _a2, _b, _c;
      for (var _i279 = 0; _i279 < sortByItems.length; _i279++) {
        var hasCustomResult = false;
        var sortKey = sortByItems[_i279].key;
        var sortOrder = (_a2 = sortByItems[_i279].order) != null ? _a2 : "asc";
        if (sortOrder === false) continue;
        var sortA = getObjectValueByPath(a[1], sortKey);
        var sortB = getObjectValueByPath(b[1], sortKey);
        var sortARaw = a[0].raw;
        var sortBRaw = b[0].raw;
        if (sortOrder === "desc") {
          var _ref285 = [sortB, sortA];
          sortA = _ref285[0];
          sortB = _ref285[1];
          var _ref286 = [sortBRaw, sortARaw];
          sortARaw = _ref286[0];
          sortBRaw = _ref286[1];
        }
        if ((_b = options == null ? void 0 : options.sortRawFunctions) == null ? void 0 : _b[sortKey]) {
          var customResult = options.sortRawFunctions[sortKey](sortARaw, sortBRaw);
          if (customResult == null) continue;
          hasCustomResult = true;
          if (customResult) return customResult;
        }
        if ((_c = options == null ? void 0 : options.sortFunctions) == null ? void 0 : _c[sortKey]) {
          var _customResult = options.sortFunctions[sortKey](sortA, sortB);
          if (_customResult == null) continue;
          hasCustomResult = true;
          if (_customResult) return _customResult;
        }
        if (hasCustomResult) continue;
        if (sortA instanceof Date && sortB instanceof Date) {
          return sortA.getTime() - sortB.getTime();
        }
        var _map4 = [sortA, sortB].map(function (s) {
          return s != null ? s.toString().toLocaleLowerCase() : s;
        });
        var _map5 = _slicedToArray(_map4, 2);
        sortA = _map5[0];
        sortB = _map5[1];
        if (sortA !== sortB) {
          if (isEmpty(sortA) && isEmpty(sortB)) return 0;
          if (isEmpty(sortA)) return -1;
          if (isEmpty(sortB)) return 1;
          if (!isNaN(sortA) && !isNaN(sortB)) return Number(sortA) - Number(sortB);
          return stringCollator.compare(sortA, sortB);
        }
      }
      return 0;
    }).map(function (_ref) {
      var _ref287 = _slicedToArray(_ref, 1),
        item = _ref287[0];
      return item;
    });
  }
  var makeDataIteratorItemsProps = propsFactory({
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    itemValue: {
      type: [String, Array, Function],
      "default": "id"
    },
    itemSelectable: {
      type: [String, Array, Function],
      "default": null
    },
    returnObject: Boolean
  }, "DataIterator-items");
  function transformItem$1(props, item) {
    var value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue);
    var selectable = getPropertyFromItem(item, props.itemSelectable, true);
    return {
      type: "item",
      value: value,
      selectable: selectable,
      raw: item
    };
  }
  function transformItems$1(props, items) {
    var array = [];
    for (var _iterator62 = _createForOfIteratorHelperLoose(items), _step64; !(_step64 = _iterator62()).done;) {
      var item = _step64.value;
      array.push(transformItem$1(props, item));
    }
    return array;
  }
  function useDataIteratorItems(props) {
    var items = computed(function () {
      return transformItems$1(props, props.items);
    });
    return {
      items: items
    };
  }
  var makeVDataIteratorProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    search: String,
    loading: Boolean
  }, makeComponentProps()), makeDataIteratorItemsProps()), makeDataTableSelectProps()), makeDataTableSortProps()), makeDataTablePaginateProps({
    itemsPerPage: 5
  })), makeDataTableExpandProps()), makeDataTableGroupProps()), makeFilterProps()), makeTagProps()), makeTransitionProps({
    transition: {
      component: VFadeTransition,
      hideOnLeave: true
    }
  })), "VDataIterator");
  var VDataIterator = genericComponent()({
    name: "VDataIterator",
    props: makeVDataIteratorProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      "update:groupBy": function (value) {
        return true;
      },
      "update:page": function (value) {
        return true;
      },
      "update:itemsPerPage": function (value) {
        return true;
      },
      "update:sortBy": function (value) {
        return true;
      },
      "update:options": function (value) {
        return true;
      },
      "update:expanded": function (value) {
        return true;
      },
      "update:currentItems": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var groupBy = useProxiedModel(props, "groupBy");
      var search = toRef(props, "search");
      var _useDataIteratorItems = useDataIteratorItems(props),
        items = _useDataIteratorItems.items;
      var _useFilter3 = useFilter(props, items, search, {
          transform: function (item) {
            return item.raw;
          }
        }),
        filteredItems = _useFilter3.filteredItems;
      var _createSort = createSort(props),
        sortBy = _createSort.sortBy,
        multiSort = _createSort.multiSort,
        mustSort = _createSort.mustSort;
      var _createPagination = createPagination(props),
        page = _createPagination.page,
        itemsPerPage = _createPagination.itemsPerPage;
      var _provideSort = provideSort({
          sortBy: sortBy,
          multiSort: multiSort,
          mustSort: mustSort,
          page: page
        }),
        toggleSort = _provideSort.toggleSort;
      var _provideGroupBy = provideGroupBy({
          groupBy: groupBy,
          sortBy: sortBy
        }),
        sortByWithGroups = _provideGroupBy.sortByWithGroups,
        opened = _provideGroupBy.opened,
        extractRows = _provideGroupBy.extractRows,
        isGroupOpen = _provideGroupBy.isGroupOpen,
        toggleGroup = _provideGroupBy.toggleGroup;
      var _useSortedItems = useSortedItems(props, filteredItems, sortByWithGroups, {
          transform: function (item) {
            return item.raw;
          }
        }),
        sortedItems = _useSortedItems.sortedItems;
      var _useGroupedItems = useGroupedItems(sortedItems, groupBy, opened),
        flatItems = _useGroupedItems.flatItems;
      var itemsLength = computed(function () {
        return flatItems.value.length;
      });
      var _providePagination = providePagination({
          page: page,
          itemsPerPage: itemsPerPage,
          itemsLength: itemsLength
        }),
        startIndex = _providePagination.startIndex,
        stopIndex = _providePagination.stopIndex,
        pageCount = _providePagination.pageCount,
        prevPage = _providePagination.prevPage,
        nextPage = _providePagination.nextPage,
        setItemsPerPage = _providePagination.setItemsPerPage,
        setPage = _providePagination.setPage;
      var _usePaginatedItems = usePaginatedItems({
          items: flatItems,
          startIndex: startIndex,
          stopIndex: stopIndex,
          itemsPerPage: itemsPerPage
        }),
        paginatedItems = _usePaginatedItems.paginatedItems;
      var paginatedItemsWithoutGroups = computed(function () {
        return extractRows(paginatedItems.value);
      });
      var _provideSelection = provideSelection(props, {
          allItems: items,
          currentPage: paginatedItemsWithoutGroups
        }),
        isSelected = _provideSelection.isSelected,
        select = _provideSelection.select,
        selectAll2 = _provideSelection.selectAll,
        toggleSelect = _provideSelection.toggleSelect;
      var _provideExpanded = provideExpanded(props),
        isExpanded = _provideExpanded.isExpanded,
        toggleExpand = _provideExpanded.toggleExpand;
      useOptions({
        page: page,
        itemsPerPage: itemsPerPage,
        sortBy: sortBy,
        groupBy: groupBy,
        search: search
      });
      var slotProps = computed(function () {
        return {
          page: page.value,
          itemsPerPage: itemsPerPage.value,
          sortBy: sortBy.value,
          pageCount: pageCount.value,
          toggleSort: toggleSort,
          prevPage: prevPage,
          nextPage: nextPage,
          setPage: setPage,
          setItemsPerPage: setItemsPerPage,
          isSelected: isSelected,
          select: select,
          selectAll: selectAll2,
          toggleSelect: toggleSelect,
          isExpanded: isExpanded,
          toggleExpand: toggleExpand,
          isGroupOpen: isGroupOpen,
          toggleGroup: toggleGroup,
          items: paginatedItemsWithoutGroups.value,
          groupedItems: paginatedItems.value
        };
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-data-iterator", {
            "v-data-iterator--loading": props.loading
          }, props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a2, _b;
            return [(_a2 = slots.header) == null ? void 0 : _a2.call(slots, slotProps.value), createVNode(MaybeTransition, {
              "transition": props.transition
            }, {
              "default": function () {
                var _a3, _b2;
                return [props.loading ? createVNode(LoaderSlot, {
                  "key": "loader",
                  "name": "v-data-iterator",
                  "active": true
                }, {
                  "default": function (slotProps2) {
                    var _a4;
                    return (_a4 = slots.loader) == null ? void 0 : _a4.call(slots, slotProps2);
                  }
                }) : createVNode("div", {
                  "key": "items"
                }, [!paginatedItems.value.length ? (_a3 = slots["no-data"]) == null ? void 0 : _a3.call(slots) : (_b2 = slots.default) == null ? void 0 : _b2.call(slots, slotProps.value)])];
              }
            }), (_b = slots.footer) == null ? void 0 : _b.call(slots, slotProps.value)];
          }
        });
      });
      return {};
    }
  });
  var VDataTable$1 = "";
  var VDataTableFooter$1 = "";
  var VPagination$1 = "";
  function useRefs() {
    var refs = ref([]);
    onBeforeUpdate(function () {
      return refs.value = [];
    });
    function updateRef(e, i) {
      refs.value[i] = e;
    }
    return {
      refs: refs,
      updateRef: updateRef
    };
  }
  var makeVPaginationProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    activeColor: String,
    start: {
      type: [Number, String],
      "default": 1
    },
    modelValue: {
      type: Number,
      "default": function (props) {
        return props.start;
      }
    },
    disabled: Boolean,
    length: {
      type: [Number, String],
      "default": 1,
      validator: function (val) {
        return val % 1 === 0;
      }
    },
    totalVisible: [Number, String],
    firstIcon: {
      type: IconValue,
      "default": "$first"
    },
    prevIcon: {
      type: IconValue,
      "default": "$prev"
    },
    nextIcon: {
      type: IconValue,
      "default": "$next"
    },
    lastIcon: {
      type: IconValue,
      "default": "$last"
    },
    ariaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
      type: String,
      "default": "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
      type: String,
      "default": "..."
    },
    showFirstLastPage: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDensityProps()), makeElevationProps()), makeRoundedProps()), makeSizeProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), makeVariantProps({
    variant: "text"
  })), "VPagination");
  var VPagination = genericComponent()({
    name: "VPagination",
    props: makeVPaginationProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      first: function (value) {
        return true;
      },
      prev: function (value) {
        return true;
      },
      next: function (value) {
        return true;
      },
      last: function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots,
        emit2 = _ref.emit;
      var page = useProxiedModel(props, "modelValue");
      var _useLocale11 = useLocale(),
        t = _useLocale11.t,
        n = _useLocale11.n;
      var _useRtl16 = useRtl(),
        isRtl = _useRtl16.isRtl;
      var _provideTheme21 = provideTheme(props),
        themeClasses = _provideTheme21.themeClasses;
      var _useDisplay4 = useDisplay(),
        width = _useDisplay4.width;
      var maxButtons = shallowRef(-1);
      provideDefaults(void 0, {
        scoped: true
      });
      var _useResizeObserver8 = useResizeObserver(function (entries) {
          if (!entries.length) return;
          var _entries$ = entries[0],
            target = _entries$.target,
            contentRect = _entries$.contentRect;
          var firstItem = target.querySelector(".v-pagination__list > *");
          if (!firstItem) return;
          var totalWidth = contentRect.width;
          var itemWidth = firstItem.offsetWidth + parseFloat(getComputedStyle(firstItem).marginRight) * 2;
          maxButtons.value = getMax(totalWidth, itemWidth);
        }),
        resizeRef = _useResizeObserver8.resizeRef;
      var length = computed(function () {
        return parseInt(props.length, 10);
      });
      var start = computed(function () {
        return parseInt(props.start, 10);
      });
      var totalVisible = computed(function () {
        if (props.totalVisible != null) return parseInt(props.totalVisible, 10);else if (maxButtons.value >= 0) return maxButtons.value;
        return getMax(width.value, 58);
      });
      function getMax(totalWidth, itemWidth) {
        var minButtons = props.showFirstLastPage ? 5 : 3;
        return Math.max(0, Math.floor(+((totalWidth - itemWidth * minButtons) / itemWidth).toFixed(2)));
      }
      var range = computed(function () {
        if (length.value <= 0 || isNaN(length.value) || length.value > Number.MAX_SAFE_INTEGER) return [];
        if (totalVisible.value <= 0) return [];else if (totalVisible.value === 1) return [page.value];
        if (length.value <= totalVisible.value) {
          return createRange(length.value, start.value);
        }
        var even = totalVisible.value % 2 === 0;
        var middle = even ? totalVisible.value / 2 : Math.floor(totalVisible.value / 2);
        var left = even ? middle : middle + 1;
        var right = length.value - middle;
        if (left - page.value >= 0) {
          return [].concat(_toConsumableArray(createRange(Math.max(1, totalVisible.value - 1), start.value)), [props.ellipsis, length.value]);
        } else if (page.value - right >= (even ? 1 : 0)) {
          var rangeLength = totalVisible.value - 1;
          var rangeStart = length.value - rangeLength + start.value;
          return [start.value, props.ellipsis].concat(_toConsumableArray(createRange(rangeLength, rangeStart)));
        } else {
          var _rangeLength = Math.max(1, totalVisible.value - 3);
          var _rangeStart = _rangeLength === 1 ? page.value : page.value - Math.ceil(_rangeLength / 2) + start.value;
          return [start.value, props.ellipsis].concat(_toConsumableArray(createRange(_rangeLength, _rangeStart)), [props.ellipsis, length.value]);
        }
      });
      function setValue(e, value, event) {
        e.preventDefault();
        page.value = value;
        event && emit2(event, value);
      }
      var _useRefs = useRefs(),
        refs = _useRefs.refs,
        updateRef = _useRefs.updateRef;
      provideDefaults({
        VPaginationBtn: {
          color: toRef(props, "color"),
          border: toRef(props, "border"),
          density: toRef(props, "density"),
          size: toRef(props, "size"),
          variant: toRef(props, "variant"),
          rounded: toRef(props, "rounded"),
          elevation: toRef(props, "elevation")
        }
      });
      var items = computed(function () {
        return range.value.map(function (item, index) {
          var ref2 = function (e) {
            return updateRef(e, index);
          };
          if (typeof item === "string") {
            return {
              isActive: false,
              key: "ellipsis-" + index,
              page: item,
              props: {
                ref: ref2,
                ellipsis: true,
                icon: true,
                disabled: true
              }
            };
          } else {
            var isActive2 = item === page.value;
            return {
              isActive: isActive2,
              key: item,
              page: n(item),
              props: {
                ref: ref2,
                ellipsis: false,
                icon: true,
                disabled: !!props.disabled || +props.length < 2,
                color: isActive2 ? props.activeColor : props.color,
                "aria-current": isActive2,
                "aria-label": t(isActive2 ? props.currentPageAriaLabel : props.pageAriaLabel, item),
                onClick: function (e) {
                  return setValue(e, item);
                }
              }
            };
          }
        });
      });
      var controls = computed(function () {
        var prevDisabled = !!props.disabled || page.value <= start.value;
        var nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
        return {
          first: props.showFirstLastPage ? {
            icon: isRtl.value ? props.lastIcon : props.firstIcon,
            onClick: function (e) {
              return setValue(e, start.value, "first");
            },
            disabled: prevDisabled,
            "aria-label": t(props.firstAriaLabel),
            "aria-disabled": prevDisabled
          } : void 0,
          prev: {
            icon: isRtl.value ? props.nextIcon : props.prevIcon,
            onClick: function (e) {
              return setValue(e, page.value - 1, "prev");
            },
            disabled: prevDisabled,
            "aria-label": t(props.previousAriaLabel),
            "aria-disabled": prevDisabled
          },
          next: {
            icon: isRtl.value ? props.prevIcon : props.nextIcon,
            onClick: function (e) {
              return setValue(e, page.value + 1, "next");
            },
            disabled: nextDisabled,
            "aria-label": t(props.nextAriaLabel),
            "aria-disabled": nextDisabled
          },
          last: props.showFirstLastPage ? {
            icon: isRtl.value ? props.firstIcon : props.lastIcon,
            onClick: function (e) {
              return setValue(e, start.value + length.value - 1, "last");
            },
            disabled: nextDisabled,
            "aria-label": t(props.lastAriaLabel),
            "aria-disabled": nextDisabled
          } : void 0
        };
      });
      function updateFocus() {
        var _a2;
        var currentIndex = page.value - start.value;
        (_a2 = refs.value[currentIndex]) == null ? void 0 : _a2.$el.focus();
      }
      function onKeydown(e) {
        if (e.key === keyValues.left && !props.disabled && page.value > +props.start) {
          page.value = page.value - 1;
          nextTick(updateFocus);
        } else if (e.key === keyValues.right && !props.disabled && page.value < start.value + length.value - 1) {
          page.value = page.value + 1;
          nextTick(updateFocus);
        }
      }
      useRender(function () {
        return createVNode(props.tag, {
          "ref": resizeRef,
          "class": ["v-pagination", themeClasses.value, props.class],
          "style": props.style,
          "role": "navigation",
          "aria-label": t(props.ariaLabel),
          "onKeydown": onKeydown,
          "data-test": "v-pagination-root"
        }, {
          "default": function () {
            return [createVNode("ul", {
              "class": "v-pagination__list"
            }, [props.showFirstLastPage && createVNode("li", {
              "key": "first",
              "class": "v-pagination__first",
              "data-test": "v-pagination-first"
            }, [slots.first ? slots.first(controls.value.first) : createVNode(VBtn, mergeProps({
              "_as": "VPaginationBtn"
            }, controls.value.first), null)]), createVNode("li", {
              "key": "prev",
              "class": "v-pagination__prev",
              "data-test": "v-pagination-prev"
            }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VBtn, mergeProps({
              "_as": "VPaginationBtn"
            }, controls.value.prev), null)]), items.value.map(function (item, index) {
              return createVNode("li", {
                "key": item.key,
                "class": ["v-pagination__item", {
                  "v-pagination__item--is-active": item.isActive
                }],
                "data-test": "v-pagination-item"
              }, [slots.item ? slots.item(item) : createVNode(VBtn, mergeProps({
                "_as": "VPaginationBtn"
              }, item.props), {
                "default": function () {
                  return [item.page];
                }
              })]);
            }), createVNode("li", {
              "key": "next",
              "class": "v-pagination__next",
              "data-test": "v-pagination-next"
            }, [slots.next ? slots.next(controls.value.next) : createVNode(VBtn, mergeProps({
              "_as": "VPaginationBtn"
            }, controls.value.next), null)]), props.showFirstLastPage && createVNode("li", {
              "key": "last",
              "class": "v-pagination__last",
              "data-test": "v-pagination-last"
            }, [slots.last ? slots.last(controls.value.last) : createVNode(VBtn, mergeProps({
              "_as": "VPaginationBtn"
            }, controls.value.last), null)])])];
          }
        });
      });
      return {};
    }
  });
  var makeVDataTableFooterProps = propsFactory({
    prevIcon: {
      type: IconValue,
      "default": "$prev"
    },
    nextIcon: {
      type: IconValue,
      "default": "$next"
    },
    firstIcon: {
      type: IconValue,
      "default": "$first"
    },
    lastIcon: {
      type: IconValue,
      "default": "$last"
    },
    itemsPerPageText: {
      type: String,
      "default": "$vuetify.dataFooter.itemsPerPageText"
    },
    pageText: {
      type: String,
      "default": "$vuetify.dataFooter.pageText"
    },
    firstPageLabel: {
      type: String,
      "default": "$vuetify.dataFooter.firstPage"
    },
    prevPageLabel: {
      type: String,
      "default": "$vuetify.dataFooter.prevPage"
    },
    nextPageLabel: {
      type: String,
      "default": "$vuetify.dataFooter.nextPage"
    },
    lastPageLabel: {
      type: String,
      "default": "$vuetify.dataFooter.lastPage"
    },
    itemsPerPageOptions: {
      type: Array,
      "default": function () {
        return [{
          value: 10,
          title: "10"
        }, {
          value: 25,
          title: "25"
        }, {
          value: 50,
          title: "50"
        }, {
          value: 100,
          title: "100"
        }, {
          value: -1,
          title: "$vuetify.dataFooter.itemsPerPageAll"
        }];
      }
    },
    showCurrentPage: Boolean
  }, "VDataTableFooter");
  var VDataTableFooter = genericComponent()({
    name: "VDataTableFooter",
    props: makeVDataTableFooterProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useLocale12 = useLocale(),
        t = _useLocale12.t;
      var _usePagination = usePagination(),
        page = _usePagination.page,
        pageCount = _usePagination.pageCount,
        startIndex = _usePagination.startIndex,
        stopIndex = _usePagination.stopIndex,
        itemsLength = _usePagination.itemsLength,
        itemsPerPage = _usePagination.itemsPerPage,
        setItemsPerPage = _usePagination.setItemsPerPage;
      var itemsPerPageOptions = computed(function () {
        return props.itemsPerPageOptions.map(function (option) {
          if (typeof option === "number") {
            return {
              value: option,
              title: option === -1 ? t("$vuetify.dataFooter.itemsPerPageAll") : String(option)
            };
          }
          return _objectSpread(_objectSpread({}, option), {}, {
            title: !isNaN(Number(option.title)) ? option.title : t(option.title)
          });
        });
      });
      useRender(function () {
        var _a2;
        var paginationProps = VPagination.filterProps(props);
        return createVNode("div", {
          "class": "v-data-table-footer"
        }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots), createVNode("div", {
          "class": "v-data-table-footer__items-per-page"
        }, [createVNode("span", null, [t(props.itemsPerPageText)]), createVNode(VSelect, {
          "items": itemsPerPageOptions.value,
          "modelValue": itemsPerPage.value,
          "onUpdate:modelValue": function (v) {
            return setItemsPerPage(Number(v));
          },
          "density": "compact",
          "variant": "outlined",
          "hide-details": true
        }, null)]), createVNode("div", {
          "class": "v-data-table-footer__info"
        }, [createVNode("div", null, [t(props.pageText, !itemsLength.value ? 0 : startIndex.value + 1, stopIndex.value, itemsLength.value)])]), createVNode("div", {
          "class": "v-data-table-footer__pagination"
        }, [createVNode(VPagination, mergeProps({
          "modelValue": page.value,
          "onUpdate:modelValue": function ($event) {
            return page.value = $event;
          },
          "density": "comfortable",
          "first-aria-label": props.firstPageLabel,
          "last-aria-label": props.lastPageLabel,
          "length": pageCount.value,
          "next-aria-label": props.nextPageLabel,
          "previous-aria-label": props.prevPageLabel,
          "rounded": true,
          "show-first-last-page": true,
          "total-visible": props.showCurrentPage ? 1 : 0,
          "variant": "plain"
        }, paginationProps), null)])]);
      });
      return {};
    }
  });
  var VDataTableColumn = defineFunctionalComponent({
    align: {
      type: String,
      "default": "start"
    },
    fixed: Boolean,
    fixedOffset: [Number, String],
    height: [Number, String],
    lastFixed: Boolean,
    noPadding: Boolean,
    tag: String,
    width: [Number, String],
    maxWidth: [Number, String],
    nowrap: Boolean
  }, function (props, _ref) {
    var _a2;
    var slots = _ref.slots;
    var Tag = (_a2 = props.tag) != null ? _a2 : "td";
    return createVNode(Tag, {
      "class": ["v-data-table__td", {
        "v-data-table-column--fixed": props.fixed,
        "v-data-table-column--last-fixed": props.lastFixed,
        "v-data-table-column--no-padding": props.noPadding,
        "v-data-table-column--nowrap": props.nowrap
      }, "v-data-table-column--align-" + props.align],
      "style": {
        height: convertToUnit(props.height),
        width: convertToUnit(props.width),
        maxWidth: convertToUnit(props.maxWidth),
        left: convertToUnit(props.fixedOffset || null)
      }
    }, {
      "default": function () {
        var _a3;
        return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
      }
    });
  });
  var makeDataTableHeaderProps = propsFactory({
    headers: Array
  }, "DataTable-header");
  var VDataTableHeadersSymbol = Symbol.for("vuetify:data-table-headers");
  var defaultHeader = {
    title: "",
    sortable: false
  };
  var defaultActionHeader = _objectSpread(_objectSpread({}, defaultHeader), {}, {
    width: 48
  });
  function priorityQueue() {
    var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var queue2 = arr.map(function (element) {
      return {
        element: element,
        priority: 0
      };
    });
    return {
      enqueue: function (element, priority) {
        var added = false;
        for (var _i280 = 0; _i280 < queue2.length; _i280++) {
          var item = queue2[_i280];
          if (item.priority > priority) {
            queue2.splice(_i280, 0, {
              element: element,
              priority: priority
            });
            added = true;
            break;
          }
        }
        if (!added) queue2.push({
          element: element,
          priority: priority
        });
      },
      size: function () {
        return queue2.length;
      },
      count: function () {
        var count = 0;
        if (!queue2.length) return 0;
        var whole = Math.floor(queue2[0].priority);
        for (var _i281 = 0; _i281 < queue2.length; _i281++) {
          if (Math.floor(queue2[_i281].priority) === whole) count += 1;
        }
        return count;
      },
      dequeue: function () {
        return queue2.shift();
      }
    };
  }
  function extractLeaves(item) {
    var columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (!item.children) {
      columns.push(item);
    } else {
      for (var _iterator63 = _createForOfIteratorHelperLoose(item.children), _step65; !(_step65 = _iterator63()).done;) {
        var child = _step65.value;
        extractLeaves(child, columns);
      }
    }
    return columns;
  }
  function extractKeys(headers) {
    var keys2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */new Set();
    for (var _iterator64 = _createForOfIteratorHelperLoose(headers), _step66; !(_step66 = _iterator64()).done;) {
      var item = _step66.value;
      if (item.key) keys2.add(item.key);
      if (item.children) {
        extractKeys(item.children, keys2);
      }
    }
    return keys2;
  }
  function getDefaultItem(item) {
    if (!item.key) return void 0;
    if (item.key === "data-table-group") return defaultHeader;
    if (["data-table-expand", "data-table-select"].includes(item.key)) return defaultActionHeader;
    return void 0;
  }
  function getDepth(item) {
    var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!item.children) return depth;
    return Math.max.apply(Math, [depth].concat(_toConsumableArray(item.children.map(function (child) {
      return getDepth(child, depth + 1);
    }))));
  }
  function parseFixedColumns(items) {
    var seenFixed = false;
    function setFixed(item) {
      var parentFixed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!item) return;
      if (parentFixed) {
        item.fixed = true;
      }
      if (item.fixed) {
        if (item.children) {
          for (var _i282 = item.children.length - 1; _i282 >= 0; _i282--) {
            setFixed(item.children[_i282], true);
          }
        } else {
          if (!seenFixed) {
            item.lastFixed = true;
          } else if (isNaN(+item.width)) {
            consoleError("Multiple fixed columns should have a static width (key: " + item.key + ")");
          }
          seenFixed = true;
        }
      } else {
        if (item.children) {
          for (var _i283 = item.children.length - 1; _i283 >= 0; _i283--) {
            setFixed(item.children[_i283]);
          }
        } else {
          seenFixed = false;
        }
      }
    }
    for (var _i284 = items.length - 1; _i284 >= 0; _i284--) {
      setFixed(items[_i284]);
    }
    function setFixedOffset(item) {
      var fixedOffset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!item) return fixedOffset2;
      if (item.children) {
        item.fixedOffset = fixedOffset2;
        for (var _iterator65 = _createForOfIteratorHelperLoose(item.children), _step67; !(_step67 = _iterator65()).done;) {
          var child = _step67.value;
          fixedOffset2 = setFixedOffset(child, fixedOffset2);
        }
      } else if (item.fixed) {
        item.fixedOffset = fixedOffset2;
        fixedOffset2 += parseFloat(item.width || "0") || 0;
      }
      return fixedOffset2;
    }
    var fixedOffset = 0;
    for (var _iterator66 = _createForOfIteratorHelperLoose(items), _step68; !(_step68 = _iterator66()).done;) {
      var item = _step68.value;
      fixedOffset = setFixedOffset(item, fixedOffset);
    }
  }
  function parse(items, maxDepth) {
    var headers = [];
    var currentDepth = 0;
    var queue2 = priorityQueue(items);
    while (queue2.size() > 0) {
      var rowSize = queue2.count();
      var row = [];
      var fraction = 1;
      while (rowSize > 0) {
        var _queue2$dequeue = queue2.dequeue(),
          item = _queue2$dequeue.element,
          priority = _queue2$dequeue.priority;
        var diff = maxDepth - currentDepth - getDepth(item);
        row.push(_objectSpread(_objectSpread({}, item), {}, {
          rowspan: diff != null ? diff : 1,
          colspan: item.children ? extractLeaves(item).length : 1
        }));
        if (item.children) {
          for (var _iterator67 = _createForOfIteratorHelperLoose(item.children), _step69; !(_step69 = _iterator67()).done;) {
            var child = _step69.value;
            var sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);
            queue2.enqueue(child, currentDepth + diff + sort);
          }
        }
        fraction += 1;
        rowSize -= 1;
      }
      currentDepth += 1;
      headers.push(row);
    }
    var columns = items.map(function (item) {
      return extractLeaves(item);
    }).flat();
    return {
      columns: columns,
      headers: headers
    };
  }
  function convertToInternalHeaders(items) {
    var _a2, _b, _c, _d;
    var internalHeaders = [];
    for (var _iterator68 = _createForOfIteratorHelperLoose(items), _step70; !(_step70 = _iterator68()).done;) {
      var item = _step70.value;
      var defaultItem = _objectSpread(_objectSpread({}, getDefaultItem(item)), item);
      var key = (_a2 = defaultItem.key) != null ? _a2 : typeof defaultItem.value === "string" ? defaultItem.value : null;
      var value = (_c = (_b = defaultItem.value) != null ? _b : key) != null ? _c : null;
      var internalItem = _objectSpread(_objectSpread({}, defaultItem), {}, {
        key: key,
        value: value,
        sortable: (_d = defaultItem.sortable) != null ? _d : defaultItem.key != null || !!defaultItem.sort,
        children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : void 0
      });
      internalHeaders.push(internalItem);
    }
    return internalHeaders;
  }
  function createHeaders(props, options) {
    var headers = ref([]);
    var columns = ref([]);
    var sortFunctions = ref({});
    var sortRawFunctions = ref({});
    var filterFunctions = ref({});
    watchEffect(function () {
      var _a2, _b, _c, _d;
      var _headers = props.headers || Object.keys((_a2 = props.items[0]) != null ? _a2 : {}).map(function (key) {
        return {
          key: key,
          title: capitalize(key)
        };
      });
      var items = _headers.slice();
      var keys2 = extractKeys(items);
      if (((_b = options == null ? void 0 : options.groupBy) == null ? void 0 : _b.value.length) && !keys2.has("data-table-group")) {
        items.unshift({
          key: "data-table-group",
          title: "Group"
        });
      }
      if (((_c = options == null ? void 0 : options.showSelect) == null ? void 0 : _c.value) && !keys2.has("data-table-select")) {
        items.unshift({
          key: "data-table-select"
        });
      }
      if (((_d = options == null ? void 0 : options.showExpand) == null ? void 0 : _d.value) && !keys2.has("data-table-expand")) {
        items.push({
          key: "data-table-expand"
        });
      }
      var internalHeaders = convertToInternalHeaders(items);
      parseFixedColumns(internalHeaders);
      var maxDepth = Math.max.apply(Math, _toConsumableArray(internalHeaders.map(function (item) {
        return getDepth(item);
      }))) + 1;
      var parsed = parse(internalHeaders, maxDepth);
      headers.value = parsed.headers;
      columns.value = parsed.columns;
      var flatHeaders = parsed.headers.flat(1);
      for (var _iterator69 = _createForOfIteratorHelperLoose(flatHeaders), _step71; !(_step71 = _iterator69()).done;) {
        var header = _step71.value;
        if (!header.key) continue;
        if (header.sortable) {
          if (header.sort) {
            sortFunctions.value[header.key] = header.sort;
          }
          if (header.sortRaw) {
            sortRawFunctions.value[header.key] = header.sortRaw;
          }
        }
        if (header.filter) {
          filterFunctions.value[header.key] = header.filter;
        }
      }
    });
    var data = {
      headers: headers,
      columns: columns,
      sortFunctions: sortFunctions,
      sortRawFunctions: sortRawFunctions,
      filterFunctions: filterFunctions
    };
    provide(VDataTableHeadersSymbol, data);
    return data;
  }
  function useHeaders() {
    var data = inject$1(VDataTableHeadersSymbol);
    if (!data) throw new Error("Missing headers!");
    return data;
  }
  var makeVDataTableHeadersProps = propsFactory(_objectSpread(_objectSpread({
    color: String,
    sticky: Boolean,
    disableSort: Boolean,
    multiSort: Boolean,
    sortAscIcon: {
      type: IconValue,
      "default": "$sortAsc"
    },
    sortDescIcon: {
      type: IconValue,
      "default": "$sortDesc"
    },
    headerProps: {
      type: Object
    }
  }, makeDisplayProps()), makeLoaderProps()), "VDataTableHeaders");
  var VDataTableHeaders = genericComponent()({
    name: "VDataTableHeaders",
    props: makeVDataTableHeadersProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useLocale13 = useLocale(),
        t = _useLocale13.t;
      var _useSort = useSort(),
        toggleSort = _useSort.toggleSort,
        sortBy = _useSort.sortBy,
        isSorted = _useSort.isSorted;
      var _useSelection = useSelection(),
        someSelected = _useSelection.someSelected,
        allSelected = _useSelection.allSelected,
        selectAll2 = _useSelection.selectAll,
        showSelectAll = _useSelection.showSelectAll;
      var _useHeaders = useHeaders(),
        columns = _useHeaders.columns,
        headers = _useHeaders.headers;
      var _useLoader4 = useLoader(props),
        loaderClasses = _useLoader4.loaderClasses;
      function getFixedStyles(column, y) {
        if (!props.sticky && !column.fixed) return void 0;
        return {
          position: "sticky",
          left: column.fixed ? convertToUnit(column.fixedOffset) : void 0,
          top: props.sticky ? "calc(var(--v-table-header-height) * " + y + ")" : void 0
        };
      }
      function getSortIcon(column) {
        var item = sortBy.value.find(function (item2) {
          return item2.key === column.key;
        });
        if (!item) return props.sortAscIcon;
        return item.order === "asc" ? props.sortAscIcon : props.sortDescIcon;
      }
      var _useBackgroundColor16 = useBackgroundColor(props, "color"),
        backgroundColorClasses = _useBackgroundColor16.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor16.backgroundColorStyles;
      var _useDisplay5 = useDisplay(props),
        displayClasses = _useDisplay5.displayClasses,
        mobile = _useDisplay5.mobile;
      var slotProps = computed(function () {
        return {
          headers: headers.value,
          columns: columns.value,
          toggleSort: toggleSort,
          isSorted: isSorted,
          sortBy: sortBy.value,
          someSelected: someSelected.value,
          allSelected: allSelected.value,
          selectAll: selectAll2,
          getSortIcon: getSortIcon
        };
      });
      var headerCellClasses = computed(function () {
        return ["v-data-table__th", {
          "v-data-table__th--sticky": props.sticky
        }, displayClasses.value, loaderClasses.value];
      });
      var VDataTableHeaderCell = function (_ref2) {
        var _a2, _b;
        var column = _ref2.column,
          x = _ref2.x,
          y = _ref2.y;
        var noPadding = column.key === "data-table-select" || column.key === "data-table-expand";
        var headerProps = mergeProps((_a2 = props.headerProps) != null ? _a2 : {}, (_b = column.headerProps) != null ? _b : {});
        return createVNode(VDataTableColumn, mergeProps({
          "tag": "th",
          "align": column.align,
          "class": [{
            "v-data-table__th--sortable": column.sortable && !props.disableSort,
            "v-data-table__th--sorted": isSorted(column),
            "v-data-table__th--fixed": column.fixed
          }].concat(_toConsumableArray(headerCellClasses.value)),
          "style": _objectSpread({
            width: convertToUnit(column.width),
            minWidth: convertToUnit(column.minWidth),
            maxWidth: convertToUnit(column.maxWidth)
          }, getFixedStyles(column, y)),
          "colspan": column.colspan,
          "rowspan": column.rowspan,
          "onClick": column.sortable ? function () {
            return toggleSort(column);
          } : void 0,
          "fixed": column.fixed,
          "nowrap": column.nowrap,
          "lastFixed": column.lastFixed,
          "noPadding": noPadding
        }, headerProps), {
          "default": function () {
            var _a3, _b2;
            var columnSlotName = "header." + column.key;
            var columnSlotProps = {
              column: column,
              selectAll: selectAll2,
              isSorted: isSorted,
              toggleSort: toggleSort,
              sortBy: sortBy.value,
              someSelected: someSelected.value,
              allSelected: allSelected.value,
              getSortIcon: getSortIcon
            };
            if (slots[columnSlotName]) return slots[columnSlotName](columnSlotProps);
            if (column.key === "data-table-select") {
              return (_b2 = (_a3 = slots["header.data-table-select"]) == null ? void 0 : _a3.call(slots, columnSlotProps)) != null ? _b2 : showSelectAll.value && createVNode(VCheckboxBtn, {
                "modelValue": allSelected.value,
                "indeterminate": someSelected.value && !allSelected.value,
                "onUpdate:modelValue": selectAll2
              }, null);
            }
            return createVNode("div", {
              "class": "v-data-table-header__content"
            }, [createVNode("span", null, [column.title]), column.sortable && !props.disableSort && createVNode(VIcon, {
              "key": "icon",
              "class": "v-data-table-header__sort-icon",
              "icon": getSortIcon(column)
            }, null), props.multiSort && isSorted(column) && createVNode("div", {
              "key": "badge",
              "class": ["v-data-table-header__sort-badge"].concat(_toConsumableArray(backgroundColorClasses.value)),
              "style": backgroundColorStyles.value
            }, [sortBy.value.findIndex(function (x2) {
              return x2.key === column.key;
            }) + 1])]);
          }
        });
      };
      var VDataTableMobileHeaderCell = function () {
        var _a2, _b;
        var headerProps = mergeProps((_b = (_a2 = props.headerProps) != null ? _a2 : {}) != null ? _b : {});
        var displayItems = computed(function () {
          return columns.value.filter(function (column) {
            return (column == null ? void 0 : column.sortable) && !props.disableSort;
          });
        });
        var appendIcon = computed(function () {
          var showSelectColumn = columns.value.find(function (column) {
            return column.key === "data-table-select";
          });
          if (showSelectColumn == null) return;
          return allSelected.value ? "$checkboxOn" : someSelected.value ? "$checkboxIndeterminate" : "$checkboxOff";
        });
        return createVNode(VDataTableColumn, mergeProps({
          "tag": "th",
          "class": _toConsumableArray(headerCellClasses.value),
          "colspan": headers.value.length + 1
        }, headerProps), {
          "default": function () {
            return [createVNode("div", {
              "class": "v-data-table-header__content"
            }, [createVNode(VSelect, {
              "chips": true,
              "class": "v-data-table__td-sort-select",
              "clearable": true,
              "density": "default",
              "items": displayItems.value,
              "label": t("$vuetify.dataTable.sortBy"),
              "multiple": props.multiSort,
              "variant": "underlined",
              "onClick:clear": function () {
                return sortBy.value = [];
              },
              "appendIcon": appendIcon.value,
              "onClick:append": function () {
                return selectAll2(!allSelected.value);
              }
            }, _objectSpread(_objectSpread({}, slots), {}, {
              chip: function (props2) {
                var _a3;
                return createVNode(VChip, {
                  "onClick": ((_a3 = props2.item.raw) == null ? void 0 : _a3.sortable) ? function () {
                    return toggleSort(props2.item.raw);
                  } : void 0,
                  "onMousedown": function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                  }
                }, {
                  "default": function () {
                    return [props2.item.title, createVNode(VIcon, {
                      "class": ["v-data-table__td-sort-icon", isSorted(props2.item.raw) && "v-data-table__td-sort-icon-active"],
                      "icon": getSortIcon(props2.item.raw),
                      "size": "small"
                    }, null)];
                  }
                });
              }
            }))])];
          }
        });
      };
      useRender(function () {
        return mobile.value ? createVNode("tr", null, [createVNode(VDataTableMobileHeaderCell, null, null)]) : createVNode(Fragment$1, null, [slots.headers ? slots.headers(slotProps.value) : headers.value.map(function (row, y) {
          return createVNode("tr", null, [row.map(function (column, x) {
            return createVNode(VDataTableHeaderCell, {
              "column": column,
              "x": x,
              "y": y
            }, null);
          })]);
        }), props.loading && createVNode("tr", {
          "class": "v-data-table-progress"
        }, [createVNode("th", {
          "colspan": columns.value.length
        }, [createVNode(LoaderSlot, {
          "name": "v-data-table-progress",
          "absolute": true,
          "active": true,
          "color": typeof props.loading === "boolean" ? void 0 : props.loading,
          "indeterminate": true
        }, {
          "default": slots.loader
        })])])]);
      });
    }
  });
  var makeVDataTableGroupHeaderRowProps = propsFactory({
    item: {
      type: Object,
      required: true
    }
  }, "VDataTableGroupHeaderRow");
  var VDataTableGroupHeaderRow = genericComponent()({
    name: "VDataTableGroupHeaderRow",
    props: makeVDataTableGroupHeaderRowProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useGroupBy = useGroupBy(),
        isGroupOpen = _useGroupBy.isGroupOpen,
        toggleGroup = _useGroupBy.toggleGroup,
        extractRows = _useGroupBy.extractRows;
      var _useSelection2 = useSelection(),
        isSelected = _useSelection2.isSelected,
        isSomeSelected = _useSelection2.isSomeSelected,
        select = _useSelection2.select;
      var _useHeaders2 = useHeaders(),
        columns = _useHeaders2.columns;
      var rows = computed(function () {
        return extractRows([props.item]);
      });
      return function () {
        return createVNode("tr", {
          "class": "v-data-table-group-header-row",
          "style": {
            "--v-data-table-group-header-row-depth": props.item.depth
          }
        }, [columns.value.map(function (column) {
          var _a2, _b, _c, _d;
          if (column.key === "data-table-group") {
            var icon = isGroupOpen(props.item) ? "$expand" : "$next";
            var onClick = function () {
              return toggleGroup(props.item);
            };
            return (_b = (_a2 = slots["data-table-group"]) == null ? void 0 : _a2.call(slots, {
              item: props.item,
              count: rows.value.length,
              props: {
                icon: icon,
                onClick: onClick
              }
            })) != null ? _b : createVNode(VDataTableColumn, {
              "class": "v-data-table-group-header-row__column"
            }, {
              "default": function () {
                return [createVNode(VBtn, {
                  "size": "small",
                  "variant": "text",
                  "icon": icon,
                  "onClick": onClick
                }, null), createVNode("span", null, [props.item.value]), createVNode("span", null, [createTextVNode("("), rows.value.length, createTextVNode(")")])];
              }
            });
          }
          if (column.key === "data-table-select") {
            var modelValue = isSelected(rows.value);
            var indeterminate = isSomeSelected(rows.value) && !modelValue;
            var selectGroup = function (v) {
              return select(rows.value, v);
            };
            return (_d = (_c = slots["data-table-select"]) == null ? void 0 : _c.call(slots, {
              props: {
                modelValue: modelValue,
                indeterminate: indeterminate,
                "onUpdate:modelValue": selectGroup
              }
            })) != null ? _d : createVNode("td", null, [createVNode(VCheckboxBtn, {
              "modelValue": modelValue,
              "indeterminate": indeterminate,
              "onUpdate:modelValue": selectGroup
            }, null)]);
          }
          return createVNode("td", null, null);
        })]);
      };
    }
  });
  var makeVDataTableRowProps = propsFactory(_objectSpread({
    index: Number,
    item: Object,
    cellProps: [Object, Function],
    onClick: EventProp(),
    onContextmenu: EventProp(),
    onDblclick: EventProp()
  }, makeDisplayProps()), "VDataTableRow");
  var VDataTableRow = genericComponent()({
    name: "VDataTableRow",
    props: makeVDataTableRowProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useDisplay6 = useDisplay(props, "v-data-table__tr"),
        displayClasses = _useDisplay6.displayClasses,
        mobile = _useDisplay6.mobile;
      var _useSelection3 = useSelection(),
        isSelected = _useSelection3.isSelected,
        toggleSelect = _useSelection3.toggleSelect,
        someSelected = _useSelection3.someSelected,
        allSelected = _useSelection3.allSelected,
        selectAll2 = _useSelection3.selectAll;
      var _useExpanded = useExpanded(),
        isExpanded = _useExpanded.isExpanded,
        toggleExpand = _useExpanded.toggleExpand;
      var _useSort2 = useSort(),
        toggleSort = _useSort2.toggleSort,
        sortBy = _useSort2.sortBy,
        isSorted = _useSort2.isSorted;
      var _useHeaders3 = useHeaders(),
        columns = _useHeaders3.columns;
      useRender(function () {
        return createVNode("tr", {
          "class": ["v-data-table__tr", {
            "v-data-table__tr--clickable": !!(props.onClick || props.onContextmenu || props.onDblclick)
          }, displayClasses.value],
          "onClick": props.onClick,
          "onContextmenu": props.onContextmenu,
          "onDblclick": props.onDblclick
        }, [props.item && columns.value.map(function (column, i) {
          var item = props.item;
          var slotName = "item." + column.key;
          var headerSlotName = "header." + column.key;
          var slotProps = {
            index: props.index,
            item: item.raw,
            internalItem: item,
            value: getObjectValueByPath(item.columns, column.key),
            column: column,
            isSelected: isSelected,
            toggleSelect: toggleSelect,
            isExpanded: isExpanded,
            toggleExpand: toggleExpand
          };
          var columnSlotProps = {
            column: column,
            selectAll: selectAll2,
            isSorted: isSorted,
            toggleSort: toggleSort,
            sortBy: sortBy.value,
            someSelected: someSelected.value,
            allSelected: allSelected.value,
            getSortIcon: function () {
              return "";
            }
          };
          var cellProps = typeof props.cellProps === "function" ? props.cellProps({
            index: slotProps.index,
            item: slotProps.item,
            internalItem: slotProps.internalItem,
            value: slotProps.value,
            column: column
          }) : props.cellProps;
          var columnCellProps = typeof column.cellProps === "function" ? column.cellProps({
            index: slotProps.index,
            item: slotProps.item,
            internalItem: slotProps.internalItem,
            value: slotProps.value
          }) : column.cellProps;
          return createVNode(VDataTableColumn, mergeProps({
            "align": column.align,
            "class": {
              "v-data-table__td--expanded-row": column.key === "data-table-expand",
              "v-data-table__td--select-row": column.key === "data-table-select"
            },
            "fixed": column.fixed,
            "fixedOffset": column.fixedOffset,
            "lastFixed": column.lastFixed,
            "maxWidth": !mobile.value ? column.maxWidth : void 0,
            "noPadding": column.key === "data-table-select" || column.key === "data-table-expand",
            "nowrap": column.nowrap,
            "width": !mobile.value ? column.width : void 0
          }, cellProps, columnCellProps), {
            "default": function () {
              var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
              if (slots[slotName] && !mobile.value) return (_a2 = slots[slotName]) == null ? void 0 : _a2.call(slots, slotProps);
              if (column.key === "data-table-select") {
                return (_c = (_b = slots["item.data-table-select"]) == null ? void 0 : _b.call(slots, slotProps)) != null ? _c : createVNode(VCheckboxBtn, {
                  "disabled": !item.selectable,
                  "modelValue": isSelected([item]),
                  "onClick": withModifiers(function () {
                    return toggleSelect(item);
                  }, ["stop"])
                }, null);
              }
              if (column.key === "data-table-expand") {
                return (_e = (_d = slots["item.data-table-expand"]) == null ? void 0 : _d.call(slots, slotProps)) != null ? _e : createVNode(VBtn, {
                  "icon": isExpanded(item) ? "$collapse" : "$expand",
                  "size": "small",
                  "variant": "text",
                  "onClick": withModifiers(function () {
                    return toggleExpand(item);
                  }, ["stop"])
                }, null);
              }
              var displayValue = toDisplayString(slotProps.value);
              return !mobile.value ? displayValue : createVNode(Fragment$1, null, [createVNode("div", {
                "class": "v-data-table__td-title"
              }, [(_g = (_f = slots[headerSlotName]) == null ? void 0 : _f.call(slots, columnSlotProps)) != null ? _g : column.title]), createVNode("div", {
                "class": "v-data-table__td-value"
              }, [(_i = (_h = slots[slotName]) == null ? void 0 : _h.call(slots, slotProps)) != null ? _i : displayValue])]);
            }
          });
        })]);
      });
    }
  });
  var makeVDataTableRowsProps = propsFactory(_objectSpread({
    loading: [Boolean, String],
    loadingText: {
      type: String,
      "default": "$vuetify.dataIterator.loadingText"
    },
    hideNoData: Boolean,
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    noDataText: {
      type: String,
      "default": "$vuetify.noDataText"
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function]
  }, makeDisplayProps()), "VDataTableRows");
  var VDataTableRows = genericComponent()({
    name: "VDataTableRows",
    inheritAttrs: false,
    props: makeVDataTableRowsProps(),
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _useHeaders4 = useHeaders(),
        columns = _useHeaders4.columns;
      var _useExpanded2 = useExpanded(),
        expandOnClick = _useExpanded2.expandOnClick,
        toggleExpand = _useExpanded2.toggleExpand,
        isExpanded = _useExpanded2.isExpanded;
      var _useSelection4 = useSelection(),
        isSelected = _useSelection4.isSelected,
        toggleSelect = _useSelection4.toggleSelect;
      var _useGroupBy2 = useGroupBy(),
        toggleGroup = _useGroupBy2.toggleGroup,
        isGroupOpen = _useGroupBy2.isGroupOpen;
      var _useLocale14 = useLocale(),
        t = _useLocale14.t;
      var _useDisplay7 = useDisplay(props),
        mobile = _useDisplay7.mobile;
      useRender(function () {
        var _a2, _b, _c, _d;
        if (props.loading && (!props.items.length || slots.loading)) {
          return createVNode("tr", {
            "class": "v-data-table-rows-loading",
            "key": "loading"
          }, [createVNode("td", {
            "colspan": columns.value.length
          }, [(_b = (_a2 = slots.loading) == null ? void 0 : _a2.call(slots)) != null ? _b : t(props.loadingText)])]);
        }
        if (!props.loading && !props.items.length && !props.hideNoData) {
          return createVNode("tr", {
            "class": "v-data-table-rows-no-data",
            "key": "no-data"
          }, [createVNode("td", {
            "colspan": columns.value.length
          }, [(_d = (_c = slots["no-data"]) == null ? void 0 : _c.call(slots)) != null ? _d : t(props.noDataText)])]);
        }
        return createVNode(Fragment$1, null, [props.items.map(function (item, index) {
          var _a3, _b2;
          if (item.type === "group") {
            var slotProps2 = {
              index: index,
              item: item,
              columns: columns.value,
              isExpanded: isExpanded,
              toggleExpand: toggleExpand,
              isSelected: isSelected,
              toggleSelect: toggleSelect,
              toggleGroup: toggleGroup,
              isGroupOpen: isGroupOpen
            };
            return slots["group-header"] ? slots["group-header"](slotProps2) : createVNode(VDataTableGroupHeaderRow, mergeProps({
              "key": "group-header_" + item.id,
              "item": item
            }, getPrefixedEventHandlers(attrs, ":group-header", function () {
              return slotProps2;
            })), slots);
          }
          var slotProps = {
            index: index,
            item: item.raw,
            internalItem: item,
            columns: columns.value,
            isExpanded: isExpanded,
            toggleExpand: toggleExpand,
            isSelected: isSelected,
            toggleSelect: toggleSelect
          };
          var itemSlotProps = _objectSpread(_objectSpread({}, slotProps), {}, {
            props: mergeProps({
              key: "item_" + ((_a3 = item.key) != null ? _a3 : item.index),
              onClick: expandOnClick.value ? function () {
                toggleExpand(item);
              } : void 0,
              index: index,
              item: item,
              cellProps: props.cellProps,
              mobile: mobile.value
            }, getPrefixedEventHandlers(attrs, ":row", function () {
              return slotProps;
            }), typeof props.rowProps === "function" ? props.rowProps({
              item: slotProps.item,
              index: slotProps.index,
              internalItem: slotProps.internalItem
            }) : props.rowProps)
          });
          return createVNode(Fragment$1, {
            "key": itemSlotProps.props.key
          }, [slots.item ? slots.item(itemSlotProps) : createVNode(VDataTableRow, itemSlotProps.props, slots), isExpanded(item) && ((_b2 = slots["expanded-row"]) == null ? void 0 : _b2.call(slots, slotProps))]);
        })]);
      });
      return {};
    }
  });
  var VTable$1 = "";
  var makeVTableProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    fixedHeader: Boolean,
    fixedFooter: Boolean,
    height: [Number, String],
    hover: Boolean
  }, makeComponentProps()), makeDensityProps()), makeTagProps()), makeThemeProps()), "VTable");
  var VTable = genericComponent()({
    name: "VTable",
    props: makeVTableProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots,
        emit2 = _ref.emit;
      var _provideTheme22 = provideTheme(props),
        themeClasses = _provideTheme22.themeClasses;
      var _useDensity14 = useDensity(props),
        densityClasses = _useDensity14.densityClasses;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-table", {
            "v-table--fixed-height": !!props.height,
            "v-table--fixed-header": props.fixedHeader,
            "v-table--fixed-footer": props.fixedFooter,
            "v-table--has-top": !!slots.top,
            "v-table--has-bottom": !!slots.bottom,
            "v-table--hover": props.hover
          }, themeClasses.value, densityClasses.value, props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a2, _b, _c;
            return [(_a2 = slots.top) == null ? void 0 : _a2.call(slots), slots.default ? createVNode("div", {
              "class": "v-table__wrapper",
              "style": {
                height: convertToUnit(props.height)
              }
            }, [createVNode("table", null, [slots.default()])]) : (_b = slots.wrapper) == null ? void 0 : _b.call(slots), (_c = slots.bottom) == null ? void 0 : _c.call(slots)];
          }
        });
      });
      return {};
    }
  });
  var makeDataTableItemsProps = propsFactory({
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    itemValue: {
      type: [String, Array, Function],
      "default": "id"
    },
    itemSelectable: {
      type: [String, Array, Function],
      "default": null
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function],
    returnObject: Boolean
  }, "DataTable-items");
  function transformItem(props, item, index, columns) {
    var value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue);
    var selectable = getPropertyFromItem(item, props.itemSelectable, true);
    var itemColumns = columns.reduce(function (obj, column) {
      if (column.key != null) obj[column.key] = getPropertyFromItem(item, column.value);
      return obj;
    }, {});
    return {
      type: "item",
      key: props.returnObject ? getPropertyFromItem(item, props.itemValue) : value,
      index: index,
      value: value,
      selectable: selectable,
      columns: itemColumns,
      raw: item
    };
  }
  function transformItems(props, items, columns) {
    return items.map(function (item, index) {
      return transformItem(props, item, index, columns);
    });
  }
  function useDataTableItems(props, columns) {
    var items = computed(function () {
      return transformItems(props, props.items, columns.value);
    });
    return {
      items: items
    };
  }
  var makeDataTableProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeVDataTableRowsProps()), {}, {
    hideDefaultBody: Boolean,
    hideDefaultFooter: Boolean,
    hideDefaultHeader: Boolean,
    width: [String, Number],
    search: String
  }, makeDataTableExpandProps()), makeDataTableGroupProps()), makeDataTableHeaderProps()), makeDataTableItemsProps()), makeDataTableSelectProps()), makeDataTableSortProps()), makeVDataTableHeadersProps()), makeVTableProps()), "DataTable");
  var makeVDataTableProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeDataTablePaginateProps()), makeDataTableProps()), makeFilterProps()), makeVDataTableFooterProps()), "VDataTable");
  var VDataTable = genericComponent()({
    name: "VDataTable",
    props: makeVDataTableProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      "update:page": function (value) {
        return true;
      },
      "update:itemsPerPage": function (value) {
        return true;
      },
      "update:sortBy": function (value) {
        return true;
      },
      "update:options": function (value) {
        return true;
      },
      "update:groupBy": function (value) {
        return true;
      },
      "update:expanded": function (value) {
        return true;
      },
      "update:currentItems": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _createGroupBy = createGroupBy(props),
        groupBy = _createGroupBy.groupBy;
      var _createSort2 = createSort(props),
        sortBy = _createSort2.sortBy,
        multiSort = _createSort2.multiSort,
        mustSort = _createSort2.mustSort;
      var _createPagination2 = createPagination(props),
        page = _createPagination2.page,
        itemsPerPage = _createPagination2.itemsPerPage;
      var _toRefs2 = toRefs(props),
        disableSort = _toRefs2.disableSort;
      var _createHeaders = createHeaders(props, {
          groupBy: groupBy,
          showSelect: toRef(props, "showSelect"),
          showExpand: toRef(props, "showExpand")
        }),
        columns = _createHeaders.columns,
        headers = _createHeaders.headers,
        sortFunctions = _createHeaders.sortFunctions,
        sortRawFunctions = _createHeaders.sortRawFunctions,
        filterFunctions = _createHeaders.filterFunctions;
      var _useDataTableItems = useDataTableItems(props, columns),
        items = _useDataTableItems.items;
      var search = toRef(props, "search");
      var _useFilter4 = useFilter(props, items, search, {
          transform: function (item) {
            return item.columns;
          },
          customKeyFilter: filterFunctions
        }),
        filteredItems = _useFilter4.filteredItems;
      var _provideSort2 = provideSort({
          sortBy: sortBy,
          multiSort: multiSort,
          mustSort: mustSort,
          page: page
        }),
        toggleSort = _provideSort2.toggleSort;
      var _provideGroupBy2 = provideGroupBy({
          groupBy: groupBy,
          sortBy: sortBy,
          disableSort: disableSort
        }),
        sortByWithGroups = _provideGroupBy2.sortByWithGroups,
        opened = _provideGroupBy2.opened,
        extractRows = _provideGroupBy2.extractRows,
        isGroupOpen = _provideGroupBy2.isGroupOpen,
        toggleGroup = _provideGroupBy2.toggleGroup;
      var _useSortedItems2 = useSortedItems(props, filteredItems, sortByWithGroups, {
          transform: function (item) {
            return _objectSpread(_objectSpread({}, item.raw), item.columns);
          },
          sortFunctions: sortFunctions,
          sortRawFunctions: sortRawFunctions
        }),
        sortedItems = _useSortedItems2.sortedItems;
      var _useGroupedItems2 = useGroupedItems(sortedItems, groupBy, opened),
        flatItems = _useGroupedItems2.flatItems;
      var itemsLength = computed(function () {
        return flatItems.value.length;
      });
      var _providePagination2 = providePagination({
          page: page,
          itemsPerPage: itemsPerPage,
          itemsLength: itemsLength
        }),
        startIndex = _providePagination2.startIndex,
        stopIndex = _providePagination2.stopIndex,
        pageCount = _providePagination2.pageCount,
        setItemsPerPage = _providePagination2.setItemsPerPage;
      var _usePaginatedItems2 = usePaginatedItems({
          items: flatItems,
          startIndex: startIndex,
          stopIndex: stopIndex,
          itemsPerPage: itemsPerPage
        }),
        paginatedItems = _usePaginatedItems2.paginatedItems;
      var paginatedItemsWithoutGroups = computed(function () {
        return extractRows(paginatedItems.value);
      });
      var _provideSelection2 = provideSelection(props, {
          allItems: items,
          currentPage: paginatedItemsWithoutGroups
        }),
        isSelected = _provideSelection2.isSelected,
        select = _provideSelection2.select,
        selectAll2 = _provideSelection2.selectAll,
        toggleSelect = _provideSelection2.toggleSelect,
        someSelected = _provideSelection2.someSelected,
        allSelected = _provideSelection2.allSelected;
      var _provideExpanded2 = provideExpanded(props),
        isExpanded = _provideExpanded2.isExpanded,
        toggleExpand = _provideExpanded2.toggleExpand;
      useOptions({
        page: page,
        itemsPerPage: itemsPerPage,
        sortBy: sortBy,
        groupBy: groupBy,
        search: search
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(props, "hideNoData"),
          noDataText: toRef(props, "noDataText"),
          loading: toRef(props, "loading"),
          loadingText: toRef(props, "loadingText")
        }
      });
      var slotProps = computed(function () {
        return {
          page: page.value,
          itemsPerPage: itemsPerPage.value,
          sortBy: sortBy.value,
          pageCount: pageCount.value,
          toggleSort: toggleSort,
          setItemsPerPage: setItemsPerPage,
          someSelected: someSelected.value,
          allSelected: allSelected.value,
          isSelected: isSelected,
          select: select,
          selectAll: selectAll2,
          toggleSelect: toggleSelect,
          isExpanded: isExpanded,
          toggleExpand: toggleExpand,
          isGroupOpen: isGroupOpen,
          toggleGroup: toggleGroup,
          items: paginatedItemsWithoutGroups.value.map(function (item) {
            return item.raw;
          }),
          internalItems: paginatedItemsWithoutGroups.value,
          groupedItems: paginatedItems.value,
          columns: columns.value,
          headers: headers.value
        };
      });
      useRender(function () {
        var dataTableFooterProps = VDataTableFooter.filterProps(props);
        var dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        var dataTableRowsProps = VDataTableRows.filterProps(props);
        var tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--show-select": props.showSelect,
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps), {
          top: function () {
            var _a2;
            return (_a2 = slots.top) == null ? void 0 : _a2.call(slots, slotProps.value);
          },
          "default": function () {
            var _a2, _b, _c, _d, _e, _f;
            return slots.default ? slots.default(slotProps.value) : createVNode(Fragment$1, null, [(_a2 = slots.colgroup) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideDefaultHeader && createVNode("thead", {
              "key": "thead"
            }, [createVNode(VDataTableHeaders, dataTableHeadersProps, slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), !props.hideDefaultBody && createVNode("tbody", null, [(_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": paginatedItems.value
            }), slots), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value)]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)]);
          },
          bottom: function () {
            return slots.bottom ? slots.bottom(slotProps.value) : !props.hideDefaultFooter && createVNode(Fragment$1, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
              prepend: slots["footer.prepend"]
            })]);
          }
        });
      });
      return {};
    }
  });
  var makeVDataTableVirtualProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeDataTableProps()), makeDataTableGroupProps()), makeVirtualProps()), makeFilterProps()), "VDataTableVirtual");
  var VDataTableVirtual = genericComponent()({
    name: "VDataTableVirtual",
    props: makeVDataTableVirtualProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      "update:sortBy": function (value) {
        return true;
      },
      "update:options": function (value) {
        return true;
      },
      "update:groupBy": function (value) {
        return true;
      },
      "update:expanded": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _createGroupBy2 = createGroupBy(props),
        groupBy = _createGroupBy2.groupBy;
      var _createSort3 = createSort(props),
        sortBy = _createSort3.sortBy,
        multiSort = _createSort3.multiSort,
        mustSort = _createSort3.mustSort;
      var _toRefs3 = toRefs(props),
        disableSort = _toRefs3.disableSort;
      var _createHeaders2 = createHeaders(props, {
          groupBy: groupBy,
          showSelect: toRef(props, "showSelect"),
          showExpand: toRef(props, "showExpand")
        }),
        columns = _createHeaders2.columns,
        headers = _createHeaders2.headers,
        filterFunctions = _createHeaders2.filterFunctions,
        sortFunctions = _createHeaders2.sortFunctions,
        sortRawFunctions = _createHeaders2.sortRawFunctions;
      var _useDataTableItems2 = useDataTableItems(props, columns),
        items = _useDataTableItems2.items;
      var search = toRef(props, "search");
      var _useFilter5 = useFilter(props, items, search, {
          transform: function (item) {
            return item.columns;
          },
          customKeyFilter: filterFunctions
        }),
        filteredItems = _useFilter5.filteredItems;
      var _provideSort3 = provideSort({
          sortBy: sortBy,
          multiSort: multiSort,
          mustSort: mustSort
        }),
        toggleSort = _provideSort3.toggleSort;
      var _provideGroupBy3 = provideGroupBy({
          groupBy: groupBy,
          sortBy: sortBy,
          disableSort: disableSort
        }),
        sortByWithGroups = _provideGroupBy3.sortByWithGroups,
        opened = _provideGroupBy3.opened,
        extractRows = _provideGroupBy3.extractRows,
        isGroupOpen = _provideGroupBy3.isGroupOpen,
        toggleGroup = _provideGroupBy3.toggleGroup;
      var _useSortedItems3 = useSortedItems(props, filteredItems, sortByWithGroups, {
          transform: function (item) {
            return _objectSpread(_objectSpread({}, item.raw), item.columns);
          },
          sortFunctions: sortFunctions,
          sortRawFunctions: sortRawFunctions
        }),
        sortedItems = _useSortedItems3.sortedItems;
      var _useGroupedItems3 = useGroupedItems(sortedItems, groupBy, opened),
        flatItems = _useGroupedItems3.flatItems;
      var allItems = computed(function () {
        return extractRows(flatItems.value);
      });
      var _provideSelection3 = provideSelection(props, {
          allItems: allItems,
          currentPage: allItems
        }),
        isSelected = _provideSelection3.isSelected,
        select = _provideSelection3.select,
        selectAll2 = _provideSelection3.selectAll,
        toggleSelect = _provideSelection3.toggleSelect,
        someSelected = _provideSelection3.someSelected,
        allSelected = _provideSelection3.allSelected;
      var _provideExpanded3 = provideExpanded(props),
        isExpanded = _provideExpanded3.isExpanded,
        toggleExpand = _provideExpanded3.toggleExpand;
      var _useVirtual2 = useVirtual(props, flatItems),
        containerRef = _useVirtual2.containerRef,
        markerRef = _useVirtual2.markerRef,
        paddingTop = _useVirtual2.paddingTop,
        paddingBottom = _useVirtual2.paddingBottom,
        computedItems = _useVirtual2.computedItems,
        handleItemResize = _useVirtual2.handleItemResize,
        handleScroll = _useVirtual2.handleScroll,
        handleScrollend = _useVirtual2.handleScrollend;
      var displayItems = computed(function () {
        return computedItems.value.map(function (item) {
          return item.raw;
        });
      });
      useOptions({
        sortBy: sortBy,
        page: shallowRef(1),
        itemsPerPage: shallowRef(-1),
        groupBy: groupBy,
        search: search
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(props, "hideNoData"),
          noDataText: toRef(props, "noDataText"),
          loading: toRef(props, "loading"),
          loadingText: toRef(props, "loadingText")
        }
      });
      var slotProps = computed(function () {
        return {
          sortBy: sortBy.value,
          toggleSort: toggleSort,
          someSelected: someSelected.value,
          allSelected: allSelected.value,
          isSelected: isSelected,
          select: select,
          selectAll: selectAll2,
          toggleSelect: toggleSelect,
          isExpanded: isExpanded,
          toggleExpand: toggleExpand,
          isGroupOpen: isGroupOpen,
          toggleGroup: toggleGroup,
          items: allItems.value.map(function (item) {
            return item.raw;
          }),
          internalItems: allItems.value,
          groupedItems: flatItems.value,
          columns: columns.value,
          headers: headers.value
        };
      });
      useRender(function () {
        var dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        var dataTableRowsProps = VDataTableRows.filterProps(props);
        var tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps), {
          top: function () {
            var _a2;
            return (_a2 = slots.top) == null ? void 0 : _a2.call(slots, slotProps.value);
          },
          wrapper: function () {
            var _a2, _b, _c;
            return createVNode("div", {
              "ref": containerRef,
              "onScrollPassive": handleScroll,
              "onScrollend": handleScrollend,
              "class": "v-table__wrapper",
              "style": {
                height: convertToUnit(props.height)
              }
            }, [createVNode("table", null, [(_a2 = slots.colgroup) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideDefaultHeader && createVNode("thead", {
              "key": "thead"
            }, [createVNode(VDataTableHeaders, mergeProps(dataTableHeadersProps, {
              "sticky": props.fixedHeader
            }), slots)]), !props.hideDefaultBody && createVNode("tbody", null, [createVNode("tr", {
              "ref": markerRef,
              "style": {
                height: convertToUnit(paddingTop.value),
                border: 0
              }
            }, [createVNode("td", {
              "colspan": columns.value.length,
              "style": {
                height: 0,
                border: 0
              }
            }, null)]), (_b = slots["body.prepend"]) == null ? void 0 : _b.call(slots, slotProps.value), createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": displayItems.value
            }), _objectSpread(_objectSpread({}, slots), {}, {
              item: function (itemSlotProps) {
                return createVNode(VVirtualScrollItem, {
                  "key": itemSlotProps.internalItem.index,
                  "renderless": true,
                  "onUpdate:height": function (height) {
                    return handleItemResize(itemSlotProps.internalItem.index, height);
                  }
                }, {
                  "default": function (_ref2) {
                    var _a3, _b2;
                    var itemRef = _ref2.itemRef;
                    return (_b2 = (_a3 = slots.item) == null ? void 0 : _a3.call(slots, _objectSpread(_objectSpread({}, itemSlotProps), {}, {
                      itemRef: itemRef
                    }))) != null ? _b2 : createVNode(VDataTableRow, mergeProps(itemSlotProps.props, {
                      "ref": itemRef,
                      "key": itemSlotProps.internalItem.index,
                      "index": itemSlotProps.internalItem.index
                    }), slots);
                  }
                });
              }
            })), (_c = slots["body.append"]) == null ? void 0 : _c.call(slots, slotProps.value), createVNode("tr", {
              "style": {
                height: convertToUnit(paddingBottom.value),
                border: 0
              }
            }, [createVNode("td", {
              "colspan": columns.value.length,
              "style": {
                height: 0,
                border: 0
              }
            }, null)])])])]);
          },
          bottom: function () {
            var _a2;
            return (_a2 = slots.bottom) == null ? void 0 : _a2.call(slots, slotProps.value);
          }
        });
      });
    }
  });
  var makeVDataTableServerProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    itemsLength: {
      type: [Number, String],
      required: true
    }
  }, makeDataTablePaginateProps()), makeDataTableProps()), makeVDataTableFooterProps()), "VDataTableServer");
  var VDataTableServer = genericComponent()({
    name: "VDataTableServer",
    props: makeVDataTableServerProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      },
      "update:page": function (page) {
        return true;
      },
      "update:itemsPerPage": function (page) {
        return true;
      },
      "update:sortBy": function (sortBy) {
        return true;
      },
      "update:options": function (options) {
        return true;
      },
      "update:expanded": function (options) {
        return true;
      },
      "update:groupBy": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var _createGroupBy3 = createGroupBy(props),
        groupBy = _createGroupBy3.groupBy;
      var _createSort4 = createSort(props),
        sortBy = _createSort4.sortBy,
        multiSort = _createSort4.multiSort,
        mustSort = _createSort4.mustSort;
      var _createPagination3 = createPagination(props),
        page = _createPagination3.page,
        itemsPerPage = _createPagination3.itemsPerPage;
      var _toRefs4 = toRefs(props),
        disableSort = _toRefs4.disableSort;
      var itemsLength = computed(function () {
        return parseInt(props.itemsLength, 10);
      });
      var _createHeaders3 = createHeaders(props, {
          groupBy: groupBy,
          showSelect: toRef(props, "showSelect"),
          showExpand: toRef(props, "showExpand")
        }),
        columns = _createHeaders3.columns,
        headers = _createHeaders3.headers;
      var _useDataTableItems3 = useDataTableItems(props, columns),
        items = _useDataTableItems3.items;
      var _provideSort4 = provideSort({
          sortBy: sortBy,
          multiSort: multiSort,
          mustSort: mustSort,
          page: page
        }),
        toggleSort = _provideSort4.toggleSort;
      var _provideGroupBy4 = provideGroupBy({
          groupBy: groupBy,
          sortBy: sortBy,
          disableSort: disableSort
        }),
        opened = _provideGroupBy4.opened,
        isGroupOpen = _provideGroupBy4.isGroupOpen,
        toggleGroup = _provideGroupBy4.toggleGroup,
        extractRows = _provideGroupBy4.extractRows;
      var _providePagination3 = providePagination({
          page: page,
          itemsPerPage: itemsPerPage,
          itemsLength: itemsLength
        }),
        pageCount = _providePagination3.pageCount,
        setItemsPerPage = _providePagination3.setItemsPerPage;
      var _useGroupedItems4 = useGroupedItems(items, groupBy, opened),
        flatItems = _useGroupedItems4.flatItems;
      var _provideSelection4 = provideSelection(props, {
          allItems: items,
          currentPage: items
        }),
        isSelected = _provideSelection4.isSelected,
        select = _provideSelection4.select,
        selectAll2 = _provideSelection4.selectAll,
        toggleSelect = _provideSelection4.toggleSelect,
        someSelected = _provideSelection4.someSelected,
        allSelected = _provideSelection4.allSelected;
      var _provideExpanded4 = provideExpanded(props),
        isExpanded = _provideExpanded4.isExpanded,
        toggleExpand = _provideExpanded4.toggleExpand;
      var itemsWithoutGroups = computed(function () {
        return extractRows(items.value);
      });
      useOptions({
        page: page,
        itemsPerPage: itemsPerPage,
        sortBy: sortBy,
        groupBy: groupBy,
        search: toRef(props, "search")
      });
      provide("v-data-table", {
        toggleSort: toggleSort,
        sortBy: sortBy
      });
      provideDefaults({
        VDataTableRows: {
          hideNoData: toRef(props, "hideNoData"),
          noDataText: toRef(props, "noDataText"),
          loading: toRef(props, "loading"),
          loadingText: toRef(props, "loadingText")
        }
      });
      var slotProps = computed(function () {
        return {
          page: page.value,
          itemsPerPage: itemsPerPage.value,
          sortBy: sortBy.value,
          pageCount: pageCount.value,
          toggleSort: toggleSort,
          setItemsPerPage: setItemsPerPage,
          someSelected: someSelected.value,
          allSelected: allSelected.value,
          isSelected: isSelected,
          select: select,
          selectAll: selectAll2,
          toggleSelect: toggleSelect,
          isExpanded: isExpanded,
          toggleExpand: toggleExpand,
          isGroupOpen: isGroupOpen,
          toggleGroup: toggleGroup,
          items: itemsWithoutGroups.value.map(function (item) {
            return item.raw;
          }),
          internalItems: itemsWithoutGroups.value,
          groupedItems: flatItems.value,
          columns: columns.value,
          headers: headers.value
        };
      });
      useRender(function () {
        var dataTableFooterProps = VDataTableFooter.filterProps(props);
        var dataTableHeadersProps = VDataTableHeaders.filterProps(props);
        var dataTableRowsProps = VDataTableRows.filterProps(props);
        var tableProps = VTable.filterProps(props);
        return createVNode(VTable, mergeProps({
          "class": ["v-data-table", {
            "v-data-table--loading": props.loading
          }, props.class],
          "style": props.style
        }, tableProps), {
          top: function () {
            var _a2;
            return (_a2 = slots.top) == null ? void 0 : _a2.call(slots, slotProps.value);
          },
          "default": function () {
            var _a2, _b, _c, _d, _e, _f;
            return slots.default ? slots.default(slotProps.value) : createVNode(Fragment$1, null, [(_a2 = slots.colgroup) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideDefaultHeader && createVNode("thead", {
              "key": "thead",
              "class": "v-data-table__thead",
              "role": "rowgroup"
            }, [createVNode(VDataTableHeaders, mergeProps(dataTableHeadersProps, {
              "sticky": props.fixedHeader
            }), slots)]), (_b = slots.thead) == null ? void 0 : _b.call(slots, slotProps.value), !props.hideDefaultBody && createVNode("tbody", {
              "class": "v-data-table__tbody",
              "role": "rowgroup"
            }, [(_c = slots["body.prepend"]) == null ? void 0 : _c.call(slots, slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
              "items": flatItems.value
            }), slots), (_d = slots["body.append"]) == null ? void 0 : _d.call(slots, slotProps.value)]), (_e = slots.tbody) == null ? void 0 : _e.call(slots, slotProps.value), (_f = slots.tfoot) == null ? void 0 : _f.call(slots, slotProps.value)]);
          },
          bottom: function () {
            return slots.bottom ? slots.bottom(slotProps.value) : !props.hideDefaultFooter && createVNode(Fragment$1, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
              prepend: slots["footer.prepend"]
            })]);
          }
        });
      });
    }
  });
  var VDatePicker$1 = "";
  var VDatePickerControls$1 = "";
  var VGrid = "";
  var makeVContainerProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    fluid: {
      type: Boolean,
      "default": false
    }
  }, makeComponentProps()), makeDimensionProps()), makeTagProps()), "VContainer");
  var VContainer = genericComponent()({
    name: "VContainer",
    props: makeVContainerProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useRtl17 = useRtl(),
        rtlClasses = _useRtl17.rtlClasses;
      var _useDimension12 = useDimension(props),
        dimensionStyles = _useDimension12.dimensionStyles;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-container", {
            "v-container--fluid": props.fluid
          }, rtlClasses.value, props.class],
          "style": [dimensionStyles.value, props.style]
        }, slots);
      });
      return {};
    }
  });
  var breakpointProps = function () {
    return breakpoints.reduce(function (props, val) {
      props[val] = {
        type: [Boolean, String, Number],
        "default": false
      };
      return props;
    }, {});
  }();
  var offsetProps = function () {
    return breakpoints.reduce(function (props, val) {
      var offsetKey = "offset" + capitalize(val);
      props[offsetKey] = {
        type: [String, Number],
        "default": null
      };
      return props;
    }, {});
  }();
  var orderProps = function () {
    return breakpoints.reduce(function (props, val) {
      var orderKey = "order" + capitalize(val);
      props[orderKey] = {
        type: [String, Number],
        "default": null
      };
      return props;
    }, {});
  }();
  var propMap$1 = {
    col: Object.keys(breakpointProps),
    offset: Object.keys(offsetProps),
    order: Object.keys(orderProps)
  };
  function breakpointClass$1(type, prop, val) {
    var className = type;
    if (val == null || val === false) {
      return void 0;
    }
    if (prop) {
      var breakpoint = prop.replace(type, "");
      className += "-" + breakpoint;
    }
    if (type === "col") {
      className = "v-" + className;
    }
    if (type === "col" && (val === "" || val === true)) {
      return className.toLowerCase();
    }
    className += "-" + val;
    return className.toLowerCase();
  }
  var ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
  var makeVColProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    cols: {
      type: [Boolean, String, Number],
      "default": false
    }
  }, breakpointProps), {}, {
    offset: {
      type: [String, Number],
      "default": null
    }
  }, offsetProps), {}, {
    order: {
      type: [String, Number],
      "default": null
    }
  }, orderProps), {}, {
    alignSelf: {
      type: String,
      "default": null,
      validator: function (str) {
        return ALIGN_SELF_VALUES.includes(str);
      }
    }
  }, makeComponentProps()), makeTagProps()), "VCol");
  var VCol = genericComponent()({
    name: "VCol",
    props: makeVColProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var classes = computed(function () {
        var _classList$push;
        var classList = [];
        var type;
        for (type in propMap$1) {
          propMap$1[type].forEach(function (prop) {
            var value = props[prop];
            var className = breakpointClass$1(type, prop, value);
            if (className) classList.push(className);
          });
        }
        var hasColClasses = classList.some(function (className) {
          return className.startsWith("v-col-");
        });
        classList.push((_classList$push = {
          "v-col": !hasColClasses || !props.cols
        }, _classList$push["v-col-" + props.cols] = props.cols, _classList$push["offset-" + props.offset] = props.offset, _classList$push["order-" + props.order] = props.order, _classList$push["align-self-" + props.alignSelf] = props.alignSelf, _classList$push));
        return classList;
      });
      return function () {
        var _a2;
        return h(props.tag, {
          "class": [classes.value, props.class],
          style: props.style
        }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });
  var ALIGNMENT = ["start", "end", "center"];
  var SPACE = ["space-between", "space-around", "space-evenly"];
  function makeRowProps(prefix, def2) {
    return breakpoints.reduce(function (props, val) {
      var prefixKey = prefix + capitalize(val);
      props[prefixKey] = def2();
      return props;
    }, {});
  }
  var ALIGN_VALUES = [].concat(ALIGNMENT, ["baseline", "stretch"]);
  var alignValidator = function (str) {
    return ALIGN_VALUES.includes(str);
  };
  var alignProps = makeRowProps("align", function () {
    return {
      type: String,
      "default": null,
      validator: alignValidator
    };
  });
  var JUSTIFY_VALUES = [].concat(ALIGNMENT, SPACE);
  var justifyValidator = function (str) {
    return JUSTIFY_VALUES.includes(str);
  };
  var justifyProps = makeRowProps("justify", function () {
    return {
      type: String,
      "default": null,
      validator: justifyValidator
    };
  });
  var ALIGN_CONTENT_VALUES = [].concat(ALIGNMENT, SPACE, ["stretch"]);
  var alignContentValidator = function (str) {
    return ALIGN_CONTENT_VALUES.includes(str);
  };
  var alignContentProps = makeRowProps("alignContent", function () {
    return {
      type: String,
      "default": null,
      validator: alignContentValidator
    };
  });
  var propMap = {
    align: Object.keys(alignProps),
    justify: Object.keys(justifyProps),
    alignContent: Object.keys(alignContentProps)
  };
  var classMap = {
    align: "align",
    justify: "justify",
    alignContent: "align-content"
  };
  function breakpointClass(type, prop, val) {
    var className = classMap[type];
    if (val == null) {
      return void 0;
    }
    if (prop) {
      var breakpoint = prop.replace(type, "");
      className += "-" + breakpoint;
    }
    className += "-" + val;
    return className.toLowerCase();
  }
  var makeVRowProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      "default": null,
      validator: alignValidator
    }
  }, alignProps), {}, {
    justify: {
      type: String,
      "default": null,
      validator: justifyValidator
    }
  }, justifyProps), {}, {
    alignContent: {
      type: String,
      "default": null,
      validator: alignContentValidator
    }
  }, alignContentProps), makeComponentProps()), makeTagProps()), "VRow");
  var VRow = genericComponent()({
    name: "VRow",
    props: makeVRowProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var classes = computed(function () {
        var _classList$push2;
        var classList = [];
        var type;
        for (type in propMap) {
          propMap[type].forEach(function (prop) {
            var value = props[prop];
            var className = breakpointClass(type, prop, value);
            if (className) classList.push(className);
          });
        }
        classList.push((_classList$push2 = {
          "v-row--no-gutters": props.noGutters,
          "v-row--dense": props.dense
        }, _classList$push2["align-" + props.align] = props.align, _classList$push2["justify-" + props.justify] = props.justify, _classList$push2["align-content-" + props.alignContent] = props.alignContent, _classList$push2));
        return classList;
      });
      return function () {
        var _a2;
        return h(props.tag, {
          "class": ["v-row", classes.value, props.class],
          style: props.style
        }, (_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });
  var VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");
  var makeVDatePickerControlsProps = propsFactory({
    active: {
      type: [String, Array],
      "default": void 0
    },
    disabled: {
      type: [Boolean, String, Array],
      "default": false
    },
    nextIcon: {
      type: IconValue,
      "default": "$next"
    },
    prevIcon: {
      type: IconValue,
      "default": "$prev"
    },
    modeIcon: {
      type: IconValue,
      "default": "$subgroup"
    },
    text: String,
    viewMode: {
      type: String,
      "default": "month"
    }
  }, "VDatePickerControls");
  var VDatePickerControls = genericComponent()({
    name: "VDatePickerControls",
    props: makeVDatePickerControlsProps(),
    emits: {
      "click:year": function () {
        return true;
      },
      "click:month": function () {
        return true;
      },
      "click:prev": function () {
        return true;
      },
      "click:next": function () {
        return true;
      },
      "click:text": function () {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit;
      var disableMonth = computed(function () {
        return Array.isArray(props.disabled) ? props.disabled.includes("text") : !!props.disabled;
      });
      var disableYear = computed(function () {
        return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
      });
      var disablePrev = computed(function () {
        return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
      });
      var disableNext = computed(function () {
        return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
      });
      function onClickPrev() {
        emit2("click:prev");
      }
      function onClickNext() {
        emit2("click:next");
      }
      function onClickYear() {
        emit2("click:year");
      }
      function onClickMonth() {
        emit2("click:month");
      }
      useRender(function () {
        return createVNode("div", {
          "class": ["v-date-picker-controls"]
        }, [createVNode(VBtn, {
          "class": "v-date-picker-controls__month-btn",
          "disabled": disableMonth.value,
          "text": props.text,
          "variant": "text",
          "rounded": true,
          "onClick": onClickMonth
        }, null), createVNode(VBtn, {
          "key": "mode-btn",
          "class": "v-date-picker-controls__mode-btn",
          "disabled": disableYear.value,
          "density": "comfortable",
          "icon": props.modeIcon,
          "variant": "text",
          "onClick": onClickYear
        }, null), createVNode(VSpacer, {
          "key": "mode-spacer"
        }, null), createVNode("div", {
          "key": "month-buttons",
          "class": "v-date-picker-controls__month"
        }, [createVNode(VBtn, {
          "disabled": disablePrev.value,
          "icon": props.prevIcon,
          "variant": "text",
          "onClick": onClickPrev
        }, null), createVNode(VBtn, {
          "disabled": disableNext.value,
          "icon": props.nextIcon,
          "variant": "text",
          "onClick": onClickNext
        }, null)])]);
      });
      return {};
    }
  });
  var VDatePickerHeader$1 = "";
  var makeVDatePickerHeaderProps = propsFactory({
    appendIcon: String,
    color: String,
    header: String,
    transition: String,
    onClick: EventProp()
  }, "VDatePickerHeader");
  var VDatePickerHeader = genericComponent()({
    name: "VDatePickerHeader",
    props: makeVDatePickerHeaderProps(),
    emits: {
      click: function () {
        return true;
      },
      "click:append": function () {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var _useBackgroundColor17 = useBackgroundColor(props, "color"),
        backgroundColorClasses = _useBackgroundColor17.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor17.backgroundColorStyles;
      function onClick() {
        emit2("click");
      }
      function onClickAppend() {
        emit2("click:append");
      }
      useRender(function () {
        var hasContent = !!(slots.default || props.header);
        var hasAppend = !!(slots.append || props.appendIcon);
        return createVNode("div", {
          "class": ["v-date-picker-header", {
            "v-date-picker-header--clickable": !!props.onClick
          }, backgroundColorClasses.value],
          "style": backgroundColorStyles.value,
          "onClick": onClick
        }, [slots.prepend && createVNode("div", {
          "key": "prepend",
          "class": "v-date-picker-header__prepend"
        }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
          "key": "content",
          "name": props.transition
        }, {
          "default": function () {
            var _a2, _b;
            return [createVNode("div", {
              "key": props.header,
              "class": "v-date-picker-header__content"
            }, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.header])];
          }
        }), hasAppend && createVNode("div", {
          "class": "v-date-picker-header__append"
        }, [!slots.append ? createVNode(VBtn, {
          "key": "append-btn",
          "icon": props.appendIcon,
          "variant": "text",
          "onClick": onClickAppend
        }, null) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !props.appendIcon,
          "defaults": {
            VBtn: {
              icon: props.appendIcon,
              variant: "text"
            }
          }
        }, {
          "default": function () {
            var _a2;
            return [(_a2 = slots.append) == null ? void 0 : _a2.call(slots)];
          }
        })])]);
      });
      return {};
    }
  });
  var VDatePickerMonth$1 = "";
  var makeCalendarProps = propsFactory({
    allowedDates: [Array, Function],
    disabled: Boolean,
    displayValue: null,
    modelValue: Array,
    month: [Number, String],
    max: null,
    min: null,
    showAdjacentMonths: Boolean,
    year: [Number, String],
    weekdays: {
      type: Array,
      "default": function () {
        return [0, 1, 2, 3, 4, 5, 6];
      }
    },
    weeksInMonth: {
      type: String,
      "default": "dynamic"
    },
    firstDayOfWeek: [Number, String]
  }, "calendar");
  function useCalendar(props) {
    var adapter = useDate();
    var model = useProxiedModel(props, "modelValue", [], function (v) {
      return wrapInArray(v);
    });
    var displayValue = computed(function () {
      if (props.displayValue) return adapter.date(props.displayValue);
      if (model.value.length > 0) return adapter.date(model.value[0]);
      if (props.min) return adapter.date(props.min);
      if (Array.isArray(props.allowedDates)) return adapter.date(props.allowedDates[0]);
      return adapter.date();
    });
    var year = useProxiedModel(props, "year", void 0, function (v) {
      var value = v != null ? Number(v) : adapter.getYear(displayValue.value);
      return adapter.startOfYear(adapter.setYear(adapter.date(), value));
    }, function (v) {
      return adapter.getYear(v);
    });
    var month = useProxiedModel(props, "month", void 0, function (v) {
      var value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
      var date2 = adapter.setYear(adapter.startOfMonth(adapter.date()), adapter.getYear(year.value));
      return adapter.setMonth(date2, value);
    }, function (v) {
      return adapter.getMonth(v);
    });
    var weekDays = computed(function () {
      var _a2;
      var firstDayOfWeek = Number((_a2 = props.firstDayOfWeek) != null ? _a2 : 0);
      return props.weekdays.map(function (day) {
        return (day + firstDayOfWeek) % 7;
      });
    });
    var weeksInMonth = computed(function () {
      var weeks = adapter.getWeekArray(month.value, props.firstDayOfWeek);
      var days = weeks.flat();
      var daysInMonth2 = 6 * 7;
      if (props.weeksInMonth === "static" && days.length < daysInMonth2) {
        var lastDay = days[days.length - 1];
        var week = [];
        for (var day = 1; day <= daysInMonth2 - days.length; day++) {
          week.push(adapter.addDays(lastDay, day));
          if (day % 7 === 0) {
            weeks.push(week);
            week = [];
          }
        }
      }
      return weeks;
    });
    function genDays(days, today) {
      return days.filter(function (date2) {
        return weekDays.value.includes(adapter.toJsDate(date2).getDay());
      }).map(function (date2, index) {
        var isoDate = adapter.toISO(date2);
        var isAdjacent = !adapter.isSameMonth(date2, month.value);
        var isStart = adapter.isSameDay(date2, adapter.startOfMonth(month.value));
        var isEnd = adapter.isSameDay(date2, adapter.endOfMonth(month.value));
        var isSame = adapter.isSameDay(date2, month.value);
        return {
          date: date2,
          isoDate: isoDate,
          formatted: adapter.format(date2, "keyboardDate"),
          year: adapter.getYear(date2),
          month: adapter.getMonth(date2),
          isDisabled: isDisabled(date2),
          isWeekStart: index % 7 === 0,
          isWeekEnd: index % 7 === 6,
          isToday: adapter.isSameDay(date2, today),
          isAdjacent: isAdjacent,
          isHidden: isAdjacent && !props.showAdjacentMonths,
          isStart: isStart,
          isSelected: model.value.some(function (value) {
            return adapter.isSameDay(date2, value);
          }),
          isEnd: isEnd,
          isSame: isSame,
          localized: adapter.format(date2, "dayOfMonth")
        };
      });
    }
    var daysInWeek = computed(function () {
      var lastDay = adapter.startOfWeek(displayValue.value, props.firstDayOfWeek);
      var week = [];
      for (var day = 0; day <= 6; day++) {
        week.push(adapter.addDays(lastDay, day));
      }
      var today = adapter.date();
      return genDays(week, today);
    });
    var daysInMonth = computed(function () {
      var days = weeksInMonth.value.flat();
      var today = adapter.date();
      return genDays(days, today);
    });
    var weekNumbers = computed(function () {
      return weeksInMonth.value.map(function (week) {
        return week.length ? getWeek(adapter, week[0]) : null;
      });
    });
    function isDisabled(value) {
      if (props.disabled) return true;
      var date2 = adapter.date(value);
      if (props.min && adapter.isAfter(adapter.date(props.min), date2)) return true;
      if (props.max && adapter.isAfter(date2, adapter.date(props.max))) return true;
      if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
        return !props.allowedDates.some(function (d) {
          return adapter.isSameDay(adapter.date(d), date2);
        });
      }
      if (typeof props.allowedDates === "function") {
        return !props.allowedDates(date2);
      }
      return false;
    }
    return {
      displayValue: displayValue,
      daysInMonth: daysInMonth,
      daysInWeek: daysInWeek,
      genDays: genDays,
      model: model,
      weeksInMonth: weeksInMonth,
      weekDays: weekDays,
      weekNumbers: weekNumbers
    };
  }
  var makeVDatePickerMonthProps = propsFactory(_objectSpread({
    color: String,
    hideWeekdays: Boolean,
    multiple: [Boolean, Number, String],
    showWeek: Boolean,
    transition: {
      type: String,
      "default": "picker-transition"
    },
    reverseTransition: {
      type: String,
      "default": "picker-reverse-transition"
    }
  }, makeCalendarProps()), "VDatePickerMonth");
  var VDatePickerMonth = genericComponent()({
    name: "VDatePickerMonth",
    props: makeVDatePickerMonthProps(),
    emits: {
      "update:modelValue": function (date2) {
        return true;
      },
      "update:month": function (date2) {
        return true;
      },
      "update:year": function (date2) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var daysRef = ref();
      var _useCalendar = useCalendar(props),
        daysInMonth = _useCalendar.daysInMonth,
        model = _useCalendar.model,
        weekNumbers = _useCalendar.weekNumbers;
      var adapter = useDate();
      var rangeStart = shallowRef();
      var rangeStop = shallowRef();
      var isReverse = shallowRef(false);
      var transition = computed(function () {
        return !isReverse.value ? props.transition : props.reverseTransition;
      });
      if (props.multiple === "range" && model.value.length > 0) {
        rangeStart.value = model.value[0];
        if (model.value.length > 1) {
          rangeStop.value = model.value[model.value.length - 1];
        }
      }
      var atMax = computed(function () {
        var max = ["number", "string"].includes(_typeof(props.multiple)) ? Number(props.multiple) : Infinity;
        return model.value.length >= max;
      });
      watch(daysInMonth, function (val, oldVal) {
        if (!oldVal) return;
        isReverse.value = adapter.isBefore(val[0].date, oldVal[0].date);
      });
      function onRangeClick(value) {
        var _value = adapter.startOfDay(value);
        if (model.value.length === 0) {
          rangeStart.value = void 0;
        } else if (model.value.length === 1) {
          rangeStart.value = model.value[0];
          rangeStop.value = void 0;
        }
        if (!rangeStart.value) {
          rangeStart.value = _value;
          model.value = [rangeStart.value];
        } else if (!rangeStop.value) {
          if (adapter.isSameDay(_value, rangeStart.value)) {
            rangeStart.value = void 0;
            model.value = [];
            return;
          } else if (adapter.isBefore(_value, rangeStart.value)) {
            rangeStop.value = adapter.endOfDay(rangeStart.value);
            rangeStart.value = _value;
          } else {
            rangeStop.value = adapter.endOfDay(_value);
          }
          var diff = adapter.getDiff(rangeStop.value, rangeStart.value, "days");
          var datesInRange = [rangeStart.value];
          for (var _i285 = 1; _i285 < diff; _i285++) {
            var nextDate = adapter.addDays(rangeStart.value, _i285);
            datesInRange.push(nextDate);
          }
          datesInRange.push(rangeStop.value);
          model.value = datesInRange;
        } else {
          rangeStart.value = value;
          rangeStop.value = void 0;
          model.value = [rangeStart.value];
        }
      }
      function onMultipleClick(value) {
        var index = model.value.findIndex(function (selection) {
          return adapter.isSameDay(selection, value);
        });
        if (index === -1) {
          model.value = [].concat(_toConsumableArray(model.value), [value]);
        } else {
          var value2 = _toConsumableArray(model.value);
          value2.splice(index, 1);
          model.value = value2;
        }
      }
      function onClick(value) {
        if (props.multiple === "range") {
          onRangeClick(value);
        } else if (props.multiple) {
          onMultipleClick(value);
        } else {
          model.value = [value];
        }
      }
      return function () {
        return createVNode("div", {
          "class": "v-date-picker-month"
        }, [props.showWeek && createVNode("div", {
          "key": "weeks",
          "class": "v-date-picker-month__weeks"
        }, [!props.hideWeekdays && createVNode("div", {
          "key": "hide-week-days",
          "class": "v-date-picker-month__day"
        }, [createTextVNode("\xA0")]), weekNumbers.value.map(function (week) {
          return createVNode("div", {
            "class": ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
          }, [week]);
        })]), createVNode(MaybeTransition, {
          "name": transition.value
        }, {
          "default": function () {
            var _a2;
            return [createVNode("div", {
              "ref": daysRef,
              "key": (_a2 = daysInMonth.value[0].date) == null ? void 0 : _a2.toString(),
              "class": "v-date-picker-month__days"
            }, [!props.hideWeekdays && adapter.getWeekdays(props.firstDayOfWeek).map(function (weekDay) {
              return createVNode("div", {
                "class": ["v-date-picker-month__day", "v-date-picker-month__weekday"]
              }, [weekDay]);
            }), daysInMonth.value.map(function (item, i) {
              var slotProps = {
                props: {
                  onClick: function () {
                    return onClick(item.date);
                  }
                },
                item: item,
                i: i
              };
              if (atMax.value && !item.isSelected) {
                item.isDisabled = true;
              }
              return createVNode("div", {
                "class": ["v-date-picker-month__day", {
                  "v-date-picker-month__day--adjacent": item.isAdjacent,
                  "v-date-picker-month__day--hide-adjacent": item.isHidden,
                  "v-date-picker-month__day--selected": item.isSelected,
                  "v-date-picker-month__day--week-end": item.isWeekEnd,
                  "v-date-picker-month__day--week-start": item.isWeekStart
                }],
                "data-v-date": !item.isDisabled ? item.isoDate : void 0
              }, [(props.showAdjacentMonths || !item.isAdjacent) && createVNode(VDefaultsProvider, {
                "defaults": {
                  VBtn: {
                    "class": "v-date-picker-month__day-btn",
                    color: (item.isSelected || item.isToday) && !item.isDisabled ? props.color : void 0,
                    disabled: item.isDisabled,
                    icon: true,
                    ripple: false,
                    text: item.localized,
                    variant: item.isDisabled ? item.isToday ? "outlined" : "text" : item.isToday && !item.isSelected ? "outlined" : "flat",
                    onClick: function () {
                      return onClick(item.date);
                    }
                  }
                }
              }, {
                "default": function () {
                  var _a3, _b;
                  return [(_b = (_a3 = slots.day) == null ? void 0 : _a3.call(slots, slotProps)) != null ? _b : createVNode(VBtn, slotProps.props, null)];
                }
              })]);
            })])];
          }
        })]);
      };
    }
  });
  var VDatePickerMonths$1 = "";
  var makeVDatePickerMonthsProps = propsFactory({
    color: String,
    height: [String, Number],
    min: null,
    max: null,
    modelValue: Number,
    year: Number
  }, "VDatePickerMonths");
  var VDatePickerMonths = genericComponent()({
    name: "VDatePickerMonths",
    props: makeVDatePickerMonthsProps(),
    emits: {
      "update:modelValue": function (date2) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var adapter = useDate();
      var model = useProxiedModel(props, "modelValue");
      var months = computed(function () {
        var date2 = adapter.startOfYear(adapter.date());
        if (props.year) {
          date2 = adapter.setYear(date2, props.year);
        }
        return createRange(12).map(function (i) {
          var text = adapter.format(date2, "monthShort");
          var isDisabled = !!(props.min && adapter.isAfter(adapter.startOfMonth(adapter.date(props.min)), date2) || props.max && adapter.isAfter(date2, adapter.startOfMonth(adapter.date(props.max))));
          date2 = adapter.getNextMonth(date2);
          return {
            isDisabled: isDisabled,
            text: text,
            value: i
          };
        });
      });
      watchEffect(function () {
        var _a2;
        model.value = (_a2 = model.value) != null ? _a2 : adapter.getMonth(adapter.date());
      });
      useRender(function () {
        return createVNode("div", {
          "class": "v-date-picker-months",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("div", {
          "class": "v-date-picker-months__content"
        }, [months.value.map(function (month, i) {
          var _a2, _b;
          var btnProps = {
            active: model.value === i,
            color: model.value === i ? props.color : void 0,
            disabled: month.isDisabled,
            rounded: true,
            text: month.text,
            variant: model.value === month.value ? "flat" : "text",
            onClick: function () {
              return onClick(i);
            }
          };
          function onClick(i2) {
            if (model.value === i2) {
              emit2("update:modelValue", model.value);
              return;
            }
            model.value = i2;
          }
          return (_b = (_a2 = slots.month) == null ? void 0 : _a2.call(slots, {
            month: month,
            i: i,
            props: btnProps
          })) != null ? _b : createVNode(VBtn, mergeProps({
            "key": "month"
          }, btnProps), null);
        })])]);
      });
      return {};
    }
  });
  var VDatePickerYears$1 = "";
  var makeVDatePickerYearsProps = propsFactory({
    color: String,
    height: [String, Number],
    min: null,
    max: null,
    modelValue: Number
  }, "VDatePickerYears");
  var VDatePickerYears = genericComponent()({
    name: "VDatePickerYears",
    props: makeVDatePickerYearsProps(),
    emits: {
      "update:modelValue": function (year) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var adapter = useDate();
      var model = useProxiedModel(props, "modelValue");
      var years = computed(function () {
        var year = adapter.getYear(adapter.date());
        var min = year - 100;
        var max = year + 52;
        if (props.min) {
          min = adapter.getYear(adapter.date(props.min));
        }
        if (props.max) {
          max = adapter.getYear(adapter.date(props.max));
        }
        var date2 = adapter.startOfYear(adapter.date());
        date2 = adapter.setYear(date2, min);
        return createRange(max - min + 1, min).map(function (i) {
          var text = adapter.format(date2, "year");
          date2 = adapter.setYear(date2, adapter.getYear(date2) + 1);
          return {
            text: text,
            value: i
          };
        });
      });
      watchEffect(function () {
        var _a2;
        model.value = (_a2 = model.value) != null ? _a2 : adapter.getYear(adapter.date());
      });
      var yearRef = templateRef();
      onMounted(function _callee8() {
        var _a2;
        return _regeneratorRuntime.async(function _callee8$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return _regeneratorRuntime.awrap(nextTick());
            case 2:
              (_a2 = yearRef.el) == null ? void 0 : _a2.scrollIntoView({
                block: "center"
              });
            case 3:
            case "end":
              return _context19.stop();
          }
        }, null, null, null, Promise);
      });
      useRender(function () {
        return createVNode("div", {
          "class": "v-date-picker-years",
          "style": {
            height: convertToUnit(props.height)
          }
        }, [createVNode("div", {
          "class": "v-date-picker-years__content"
        }, [years.value.map(function (year, i) {
          var _a2, _b;
          var btnProps = {
            ref: model.value === year.value ? yearRef : void 0,
            active: model.value === year.value,
            color: model.value === year.value ? props.color : void 0,
            rounded: true,
            text: year.text,
            variant: model.value === year.value ? "flat" : "text",
            onClick: function () {
              if (model.value === year.value) {
                emit2("update:modelValue", model.value);
                return;
              }
              model.value = year.value;
            }
          };
          return (_b = (_a2 = slots.year) == null ? void 0 : _a2.call(slots, {
            year: year,
            i: i,
            props: btnProps
          })) != null ? _b : createVNode(VBtn, mergeProps({
            "key": "month"
          }, btnProps), null);
        })])]);
      });
      return {};
    }
  });
  var VPicker$1 = "";
  var VPickerTitle = createSimpleFunctional("v-picker-title");
  var makeVPickerProps = propsFactory(_objectSpread({
    bgColor: String,
    landscape: Boolean,
    title: String,
    hideHeader: Boolean
  }, makeVSheetProps()), "VPicker");
  var VPicker = genericComponent()({
    name: "VPicker",
    props: makeVPickerProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useBackgroundColor18 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor18.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor18.backgroundColorStyles;
      useRender(function () {
        var sheetProps = VSheet.filterProps(props);
        var hasTitle = !!(props.title || slots.title);
        return createVNode(VSheet, mergeProps(sheetProps, {
          "color": props.bgColor,
          "class": ["v-picker", {
            "v-picker--landscape": props.landscape,
            "v-picker--with-actions": !!slots.actions
          }, props.class],
          "style": props.style
        }), {
          "default": function () {
            var _a2;
            return [!props.hideHeader && createVNode("div", {
              "key": "header",
              "class": [backgroundColorClasses.value],
              "style": [backgroundColorStyles.value]
            }, [hasTitle && createVNode(VPickerTitle, {
              "key": "picker-title"
            }, {
              "default": function () {
                var _a3, _b;
                return [(_b = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b : props.title];
              }
            }), slots.header && createVNode("div", {
              "class": "v-picker__header"
            }, [slots.header()])]), createVNode("div", {
              "class": "v-picker__body"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  slim: true,
                  variant: "text"
                }
              }
            }, {
              "default": function () {
                return [createVNode("div", {
                  "class": "v-picker__actions"
                }, [slots.actions()])];
              }
            })];
          }
        });
      });
      return {};
    }
  });
  var makeVDatePickerProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    header: {
      type: String,
      "default": "$vuetify.datePicker.header"
    }
  }, makeVDatePickerControlsProps()), makeVDatePickerMonthProps({
    weeksInMonth: "static"
  })), omit(makeVDatePickerMonthsProps(), ["modelValue"])), omit(makeVDatePickerYearsProps(), ["modelValue"])), makeVPickerProps({
    title: "$vuetify.datePicker.title"
  })), {}, {
    modelValue: null
  }), "VDatePicker");
  var VDatePicker = genericComponent()({
    name: "VDatePicker",
    props: makeVDatePickerProps(),
    emits: {
      "update:modelValue": function (date2) {
        return true;
      },
      "update:month": function (date2) {
        return true;
      },
      "update:year": function (date2) {
        return true;
      },
      "update:viewMode": function (date2) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var _a2, _b;
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var adapter = useDate();
      var _useLocale15 = useLocale(),
        t = _useLocale15.t;
      var model = useProxiedModel(props, "modelValue", void 0, function (v) {
        return wrapInArray(v);
      }, function (v) {
        return props.multiple ? v : v[0];
      });
      var viewMode = useProxiedModel(props, "viewMode");
      var internal = computed(function () {
        var _a3;
        var value = adapter.date((_a3 = model.value) == null ? void 0 : _a3[0]);
        return value && adapter.isValid(value) ? value : adapter.date();
      });
      var month = ref(Number((_a2 = props.month) != null ? _a2 : adapter.getMonth(adapter.startOfMonth(internal.value))));
      var year = ref(Number((_b = props.year) != null ? _b : adapter.getYear(adapter.startOfYear(adapter.setMonth(internal.value, month.value)))));
      var isReversing = shallowRef(false);
      var header = computed(function () {
        if (props.multiple && model.value.length > 1) {
          return t("$vuetify.datePicker.itemsSelected", model.value.length);
        }
        return model.value[0] && adapter.isValid(model.value[0]) ? adapter.format(adapter.date(model.value[0]), "normalDateWithWeekday") : t(props.header);
      });
      var text = computed(function () {
        var date2 = adapter.date();
        date2 = adapter.setDate(date2, 1);
        date2 = adapter.setMonth(date2, month.value);
        date2 = adapter.setYear(date2, year.value);
        return adapter.format(date2, "monthAndYear");
      });
      var headerTransition = computed(function () {
        return "date-picker-header" + (isReversing.value ? "-reverse" : "") + "-transition";
      });
      var minDate = computed(function () {
        var date2 = adapter.date(props.min);
        return props.min && adapter.isValid(date2) ? date2 : null;
      });
      var maxDate = computed(function () {
        var date2 = adapter.date(props.max);
        return props.max && adapter.isValid(date2) ? date2 : null;
      });
      var disabled = computed(function () {
        if (props.disabled) return true;
        var targets = [];
        if (viewMode.value !== "month") {
          targets.push.apply(targets, ["prev", "next"]);
        } else {
          var _date = adapter.date();
          _date = adapter.setYear(_date, year.value);
          _date = adapter.setMonth(_date, month.value);
          if (minDate.value) {
            var date2 = adapter.addDays(adapter.startOfMonth(_date), -1);
            adapter.isAfter(minDate.value, date2) && targets.push("prev");
          }
          if (maxDate.value) {
            var _date3 = adapter.addDays(adapter.endOfMonth(_date), 1);
            adapter.isAfter(_date3, maxDate.value) && targets.push("next");
          }
        }
        return targets;
      });
      function onClickNext() {
        if (month.value < 11) {
          month.value++;
        } else {
          year.value++;
          month.value = 0;
          onUpdateYear(year.value);
        }
        onUpdateMonth(month.value);
      }
      function onClickPrev() {
        if (month.value > 0) {
          month.value--;
        } else {
          year.value--;
          month.value = 11;
          onUpdateYear(year.value);
        }
        onUpdateMonth(month.value);
      }
      function onClickDate() {
        viewMode.value = "month";
      }
      function onClickMonth() {
        viewMode.value = viewMode.value === "months" ? "month" : "months";
      }
      function onClickYear() {
        viewMode.value = viewMode.value === "year" ? "month" : "year";
      }
      function onUpdateMonth(value) {
        if (viewMode.value === "months") onClickMonth();
        emit2("update:month", value);
      }
      function onUpdateYear(value) {
        if (viewMode.value === "year") onClickYear();
        emit2("update:year", value);
      }
      watch(model, function (val, oldVal) {
        var arrBefore = wrapInArray(oldVal);
        var arrAfter = wrapInArray(val);
        if (!arrAfter.length) return;
        var before = adapter.date(arrBefore[arrBefore.length - 1]);
        var after = adapter.date(arrAfter[arrAfter.length - 1]);
        var newMonth = adapter.getMonth(after);
        var newYear = adapter.getYear(after);
        if (newMonth !== month.value) {
          month.value = newMonth;
          onUpdateMonth(month.value);
        }
        if (newYear !== year.value) {
          year.value = newYear;
          onUpdateYear(year.value);
        }
        isReversing.value = adapter.isBefore(before, after);
      });
      useRender(function () {
        var pickerProps = VPicker.filterProps(props);
        var datePickerControlsProps = VDatePickerControls.filterProps(props);
        var datePickerHeaderProps = VDatePickerHeader.filterProps(props);
        var datePickerMonthProps = VDatePickerMonth.filterProps(props);
        var datePickerMonthsProps = omit(VDatePickerMonths.filterProps(props), ["modelValue"]);
        var datePickerYearsProps = omit(VDatePickerYears.filterProps(props), ["modelValue"]);
        var headerProps = {
          header: header.value,
          transition: headerTransition.value
        };
        return createVNode(VPicker, mergeProps(pickerProps, {
          "class": ["v-date-picker", "v-date-picker--" + viewMode.value, {
            "v-date-picker--show-week": props.showWeek
          }, props.class],
          "style": props.style
        }), {
          title: function () {
            var _a3, _b2;
            return (_b2 = (_a3 = slots.title) == null ? void 0 : _a3.call(slots)) != null ? _b2 : createVNode("div", {
              "class": "v-date-picker__title"
            }, [t(props.title)]);
          },
          header: function () {
            return slots.header ? createVNode(VDefaultsProvider, {
              "defaults": {
                VDatePickerHeader: _objectSpread({}, headerProps)
              }
            }, {
              "default": function () {
                var _a3;
                return [(_a3 = slots.header) == null ? void 0 : _a3.call(slots, headerProps)];
              }
            }) : createVNode(VDatePickerHeader, mergeProps({
              "key": "header"
            }, datePickerHeaderProps, headerProps, {
              "onClick": viewMode.value !== "month" ? onClickDate : void 0
            }), _objectSpread(_objectSpread({}, slots), {}, {
              "default": void 0
            }));
          },
          "default": function () {
            return createVNode(Fragment$1, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
              "disabled": disabled.value,
              "text": text.value,
              "onClick:next": onClickNext,
              "onClick:prev": onClickPrev,
              "onClick:month": onClickMonth,
              "onClick:year": onClickYear
            }), null), createVNode(VFadeTransition, {
              "hideOnLeave": true
            }, {
              "default": function () {
                return [viewMode.value === "months" ? createVNode(VDatePickerMonths, mergeProps({
                  "key": "date-picker-months"
                }, datePickerMonthsProps, {
                  "modelValue": month.value,
                  "onUpdate:modelValue": [function ($event) {
                    return month.value = $event;
                  }, onUpdateMonth],
                  "min": minDate.value,
                  "max": maxDate.value,
                  "year": year.value
                }), null) : viewMode.value === "year" ? createVNode(VDatePickerYears, mergeProps({
                  "key": "date-picker-years"
                }, datePickerYearsProps, {
                  "modelValue": year.value,
                  "onUpdate:modelValue": [function ($event) {
                    return year.value = $event;
                  }, onUpdateYear],
                  "min": minDate.value,
                  "max": maxDate.value
                }), null) : createVNode(VDatePickerMonth, mergeProps({
                  "key": "date-picker-month"
                }, datePickerMonthProps, {
                  "modelValue": model.value,
                  "onUpdate:modelValue": function ($event) {
                    return model.value = $event;
                  },
                  "month": month.value,
                  "onUpdate:month": [function ($event) {
                    return month.value = $event;
                  }, onUpdateMonth],
                  "year": year.value,
                  "onUpdate:year": [function ($event) {
                    return year.value = $event;
                  }, onUpdateYear],
                  "min": minDate.value,
                  "max": maxDate.value
                }), null)];
              }
            })]);
          },
          actions: slots.actions
        });
      });
      return {};
    }
  });
  var VEmptyState$1 = "";
  var makeVEmptyStateProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    actionText: String,
    bgColor: String,
    color: String,
    icon: IconValue,
    image: String,
    justify: {
      type: String,
      "default": "center"
    },
    headline: String,
    title: String,
    text: String,
    textWidth: {
      type: [Number, String],
      "default": 500
    },
    href: String,
    to: String
  }, makeComponentProps()), makeDimensionProps()), makeSizeProps({
    size: void 0
  })), makeThemeProps()), "VEmptyState");
  var VEmptyState = genericComponent()({
    name: "VEmptyState",
    props: makeVEmptyStateProps(),
    emits: {
      "click:action": function (e) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var _provideTheme23 = provideTheme(props),
        themeClasses = _provideTheme23.themeClasses;
      var _useBackgroundColor19 = useBackgroundColor(toRef(props, "bgColor")),
        backgroundColorClasses = _useBackgroundColor19.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor19.backgroundColorStyles;
      var _useDimension13 = useDimension(props),
        dimensionStyles = _useDimension13.dimensionStyles;
      var _useDisplay8 = useDisplay(),
        displayClasses = _useDisplay8.displayClasses;
      function onClickAction(e) {
        emit2("click:action", e);
      }
      useRender(function () {
        var _ref288;
        var _a2, _b, _c, _d, _e, _f, _g;
        var hasActions = !!(slots.actions || props.actionText);
        var hasHeadline = !!(slots.headline || props.headline);
        var hasTitle = !!(slots.title || props.title);
        var hasText = !!(slots.text || props.text);
        var hasMedia = !!(slots.media || props.image || props.icon);
        var size = props.size || (props.image ? 200 : 96);
        return createVNode("div", {
          "class": ["v-empty-state", (_ref288 = {}, _ref288["v-empty-state--" + props.justify] = true, _ref288), themeClasses.value, backgroundColorClasses.value, displayClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, props.style]
        }, [hasMedia && createVNode("div", {
          "key": "media",
          "class": "v-empty-state__media"
        }, [!slots.media ? createVNode(Fragment$1, null, [props.image ? createVNode(VImg, {
          "key": "image",
          "src": props.image,
          "height": size
        }, null) : props.icon ? createVNode(VIcon, {
          "key": "icon",
          "color": props.color,
          "size": size,
          "icon": props.icon
        }, null) : void 0]) : createVNode(VDefaultsProvider, {
          "key": "media-defaults",
          "defaults": {
            VImg: {
              src: props.image,
              height: size
            },
            VIcon: {
              size: size,
              icon: props.icon
            }
          }
        }, {
          "default": function () {
            return [slots.media()];
          }
        })]), hasHeadline && createVNode("div", {
          "key": "headline",
          "class": "v-empty-state__headline"
        }, [(_b = (_a2 = slots.headline) == null ? void 0 : _a2.call(slots)) != null ? _b : props.headline]), hasTitle && createVNode("div", {
          "key": "title",
          "class": "v-empty-state__title"
        }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasText && createVNode("div", {
          "key": "text",
          "class": "v-empty-state__text",
          "style": {
            maxWidth: convertToUnit(props.textWidth)
          }
        }, [(_f = (_e = slots.text) == null ? void 0 : _e.call(slots)) != null ? _f : props.text]), slots.default && createVNode("div", {
          "key": "content",
          "class": "v-empty-state__content"
        }, [slots.default()]), hasActions && createVNode("div", {
          "key": "actions",
          "class": "v-empty-state__actions"
        }, [createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              "class": "v-empty-state__action-btn",
              color: (_g = props.color) != null ? _g : "surface-variant",
              text: props.actionText
            }
          }
        }, {
          "default": function () {
            var _a3, _b2;
            return [(_b2 = (_a3 = slots.actions) == null ? void 0 : _a3.call(slots, {
              props: {
                onClick: onClickAction
              }
            })) != null ? _b2 : createVNode(VBtn, {
              "onClick": onClickAction
            }, null)];
          }
        })])]);
      });
      return {};
    }
  });
  var VExpansionPanel$1 = "";
  var VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
  var makeVExpansionPanelTextProps = propsFactory(_objectSpread(_objectSpread({}, makeComponentProps()), makeLazyProps()), "VExpansionPanelText");
  var VExpansionPanelText = genericComponent()({
    name: "VExpansionPanelText",
    props: makeVExpansionPanelTextProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var expansionPanel = inject$1(VExpansionPanelSymbol);
      if (!expansionPanel) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
      var _useLazy3 = useLazy(props, expansionPanel.isSelected),
        hasContent = _useLazy3.hasContent,
        onAfterLeave = _useLazy3.onAfterLeave;
      useRender(function () {
        return createVNode(VExpandTransition, {
          "onAfterLeave": onAfterLeave
        }, {
          "default": function () {
            var _a2;
            return [withDirectives(createVNode("div", {
              "class": ["v-expansion-panel-text", props.class],
              "style": props.style
            }, [slots.default && hasContent.value && createVNode("div", {
              "class": "v-expansion-panel-text__wrapper"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]), [[vShow, expansionPanel.isSelected.value]])];
          }
        });
      });
      return {};
    }
  });
  var makeVExpansionPanelTitleProps = propsFactory(_objectSpread(_objectSpread({
    color: String,
    expandIcon: {
      type: IconValue,
      "default": "$expand"
    },
    collapseIcon: {
      type: IconValue,
      "default": "$collapse"
    },
    hideActions: Boolean,
    focusable: Boolean,
    "static": Boolean,
    ripple: {
      type: [Boolean, Object],
      "default": false
    },
    readonly: Boolean
  }, makeComponentProps()), makeDimensionProps()), "VExpansionPanelTitle");
  var VExpansionPanelTitle = genericComponent()({
    name: "VExpansionPanelTitle",
    directives: {
      Ripple: Ripple
    },
    props: makeVExpansionPanelTitleProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var expansionPanel = inject$1(VExpansionPanelSymbol);
      if (!expansionPanel) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
      var _useBackgroundColor20 = useBackgroundColor(props, "color"),
        backgroundColorClasses = _useBackgroundColor20.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor20.backgroundColorStyles;
      var _useDimension14 = useDimension(props),
        dimensionStyles = _useDimension14.dimensionStyles;
      var slotProps = computed(function () {
        return {
          collapseIcon: props.collapseIcon,
          disabled: expansionPanel.disabled.value,
          expanded: expansionPanel.isSelected.value,
          expandIcon: props.expandIcon,
          readonly: props.readonly
        };
      });
      var icon = computed(function () {
        return expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon;
      });
      useRender(function () {
        var _a2;
        return withDirectives(createVNode("button", {
          "class": ["v-expansion-panel-title", {
            "v-expansion-panel-title--active": expansionPanel.isSelected.value,
            "v-expansion-panel-title--focusable": props.focusable,
            "v-expansion-panel-title--static": props.static
          }, backgroundColorClasses.value, props.class],
          "style": [backgroundColorStyles.value, dimensionStyles.value, props.style],
          "type": "button",
          "tabindex": expansionPanel.disabled.value ? -1 : void 0,
          "disabled": expansionPanel.disabled.value,
          "aria-expanded": expansionPanel.isSelected.value,
          "onClick": !props.readonly ? expansionPanel.toggle : void 0
        }, [createVNode("span", {
          "class": "v-expansion-panel-title__overlay"
        }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps.value), !props.hideActions && createVNode(VDefaultsProvider, {
          "defaults": {
            VIcon: {
              icon: icon.value
            }
          }
        }, {
          "default": function () {
            var _a3, _b;
            return [createVNode("span", {
              "class": "v-expansion-panel-title__icon"
            }, [(_b = (_a3 = slots.actions) == null ? void 0 : _a3.call(slots, slotProps.value)) != null ? _b : createVNode(VIcon, null, null)])];
          }
        })]), [[resolveDirective("ripple"), props.ripple]]);
      });
      return {};
    }
  });
  var makeVExpansionPanelProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    title: String,
    text: String,
    bgColor: String
  }, makeElevationProps()), makeGroupItemProps()), makeRoundedProps()), makeTagProps()), makeVExpansionPanelTitleProps()), makeVExpansionPanelTextProps()), "VExpansionPanel");
  var VExpansionPanel = genericComponent()({
    name: "VExpansionPanel",
    props: makeVExpansionPanelProps(),
    emits: {
      "group:selected": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var groupItem = useGroupItem(props, VExpansionPanelSymbol);
      var _useBackgroundColor21 = useBackgroundColor(props, "bgColor"),
        backgroundColorClasses = _useBackgroundColor21.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor21.backgroundColorStyles;
      var _useElevation13 = useElevation(props),
        elevationClasses = _useElevation13.elevationClasses;
      var _useRounded19 = useRounded(props),
        roundedClasses = _useRounded19.roundedClasses;
      var isDisabled = computed(function () {
        return (groupItem == null ? void 0 : groupItem.disabled.value) || props.disabled;
      });
      var selectedIndices = computed(function () {
        return groupItem.group.items.value.reduce(function (arr, item, index) {
          if (groupItem.group.selected.value.includes(item.id)) arr.push(index);
          return arr;
        }, []);
      });
      var isBeforeSelected = computed(function () {
        var index = groupItem.group.items.value.findIndex(function (item) {
          return item.id === groupItem.id;
        });
        return !groupItem.isSelected.value && selectedIndices.value.some(function (selectedIndex) {
          return selectedIndex - index === 1;
        });
      });
      var isAfterSelected = computed(function () {
        var index = groupItem.group.items.value.findIndex(function (item) {
          return item.id === groupItem.id;
        });
        return !groupItem.isSelected.value && selectedIndices.value.some(function (selectedIndex) {
          return selectedIndex - index === -1;
        });
      });
      provide(VExpansionPanelSymbol, groupItem);
      useRender(function () {
        var hasText = !!(slots.text || props.text);
        var hasTitle = !!(slots.title || props.title);
        var expansionPanelTitleProps = VExpansionPanelTitle.filterProps(props);
        var expansionPanelTextProps = VExpansionPanelText.filterProps(props);
        return createVNode(props.tag, {
          "class": ["v-expansion-panel", {
            "v-expansion-panel--active": groupItem.isSelected.value,
            "v-expansion-panel--before-active": isBeforeSelected.value,
            "v-expansion-panel--after-active": isAfterSelected.value,
            "v-expansion-panel--disabled": isDisabled.value
          }, roundedClasses.value, backgroundColorClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.style]
        }, {
          "default": function () {
            return [createVNode("div", {
              "class": ["v-expansion-panel__shadow"].concat(_toConsumableArray(elevationClasses.value))
            }, null), createVNode(VDefaultsProvider, {
              "defaults": {
                VExpansionPanelTitle: _objectSpread({}, expansionPanelTitleProps),
                VExpansionPanelText: _objectSpread({}, expansionPanelTextProps)
              }
            }, {
              "default": function () {
                var _a2;
                return [hasTitle && createVNode(VExpansionPanelTitle, {
                  "key": "title"
                }, {
                  "default": function () {
                    return [slots.title ? slots.title() : props.title];
                  }
                }), hasText && createVNode(VExpansionPanelText, {
                  "key": "text"
                }, {
                  "default": function () {
                    return [slots.text ? slots.text() : props.text];
                  }
                }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
              }
            })];
          }
        });
      });
      return {
        groupItem: groupItem
      };
    }
  });
  var allowedVariants = ["default", "accordion", "inset", "popout"];
  var makeVExpansionPanelsProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    flat: Boolean
  }, makeGroupProps()), pick(makeVExpansionPanelProps(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"])), makeThemeProps()), makeComponentProps()), makeTagProps()), {}, {
    variant: {
      type: String,
      "default": "default",
      validator: function (v) {
        return allowedVariants.includes(v);
      }
    }
  }), "VExpansionPanels");
  var VExpansionPanels = genericComponent()({
    name: "VExpansionPanels",
    props: makeVExpansionPanelsProps(),
    emits: {
      "update:modelValue": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useGroup3 = useGroup(props, VExpansionPanelSymbol),
        next = _useGroup3.next,
        prev = _useGroup3.prev;
      var _provideTheme24 = provideTheme(props),
        themeClasses = _provideTheme24.themeClasses;
      var variantClass = computed(function () {
        return props.variant && "v-expansion-panels--variant-" + props.variant;
      });
      provideDefaults({
        VExpansionPanel: {
          bgColor: toRef(props, "bgColor"),
          collapseIcon: toRef(props, "collapseIcon"),
          color: toRef(props, "color"),
          eager: toRef(props, "eager"),
          elevation: toRef(props, "elevation"),
          expandIcon: toRef(props, "expandIcon"),
          focusable: toRef(props, "focusable"),
          hideActions: toRef(props, "hideActions"),
          readonly: toRef(props, "readonly"),
          ripple: toRef(props, "ripple"),
          rounded: toRef(props, "rounded"),
          "static": toRef(props, "static")
        }
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-expansion-panels", {
            "v-expansion-panels--flat": props.flat,
            "v-expansion-panels--tile": props.tile
          }, themeClasses.value, variantClass.value, props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              prev: prev,
              next: next
            })];
          }
        });
      });
      return {
        next: next,
        prev: prev
      };
    }
  });
  var VFab$1 = "";
  var makeVFabProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    app: Boolean,
    appear: Boolean,
    extended: Boolean,
    layout: Boolean,
    offset: Boolean,
    modelValue: {
      type: Boolean,
      "default": true
    }
  }, omit(makeVBtnProps({
    active: true
  }), ["location"])), makeLayoutItemProps()), makeLocationProps()), makeTransitionProps({
    transition: "fab-transition"
  })), "VFab");
  var VFab = genericComponent()({
    name: "VFab",
    props: makeVFabProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var height = shallowRef(56);
      var layoutItemStyles = ref();
      var _useResizeObserver9 = useResizeObserver(function (entries) {
          if (!entries.length) return;
          height.value = entries[0].target.clientHeight;
        }),
        resizeRef = _useResizeObserver9.resizeRef;
      var hasPosition = computed(function () {
        return props.app || props.absolute;
      });
      var position = computed(function () {
        var _a2, _b;
        if (!hasPosition.value) return false;
        return (_b = (_a2 = props.location) == null ? void 0 : _a2.split(" ").shift()) != null ? _b : "bottom";
      });
      var orientation = computed(function () {
        var _a2, _b;
        if (!hasPosition.value) return false;
        return (_b = (_a2 = props.location) == null ? void 0 : _a2.split(" ")[1]) != null ? _b : "end";
      });
      useToggleScope(function () {
        return props.app;
      }, function () {
        var layout = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: position,
          layoutSize: computed(function () {
            return props.layout ? height.value + 24 : 0;
          }),
          elementSize: computed(function () {
            return height.value + 24;
          }),
          active: computed(function () {
            return props.app && model.value;
          }),
          absolute: toRef(props, "absolute")
        });
        watchEffect(function () {
          layoutItemStyles.value = layout.layoutItemStyles.value;
        });
      });
      var vFabRef = ref();
      useRender(function () {
        var _ref289;
        var btnProps = VBtn.filterProps(props);
        return createVNode("div", {
          "ref": vFabRef,
          "class": ["v-fab", (_ref289 = {
            "v-fab--absolute": props.absolute,
            "v-fab--app": !!props.app,
            "v-fab--extended": props.extended,
            "v-fab--offset": props.offset
          }, _ref289["v-fab--" + position.value] = hasPosition.value, _ref289["v-fab--" + orientation.value] = hasPosition.value, _ref289), props.class],
          "style": [props.app ? _objectSpread({}, layoutItemStyles.value) : {
            height: "inherit",
            width: void 0
          }, props.style]
        }, [createVNode("div", {
          "class": "v-fab__container"
        }, [createVNode(MaybeTransition, {
          "appear": props.appear,
          "transition": props.transition
        }, {
          "default": function () {
            return [withDirectives(createVNode(VBtn, mergeProps({
              "ref": resizeRef
            }, btnProps, {
              "active": void 0,
              "location": void 0
            }), slots), [[vShow, props.active]])];
          }
        })])]);
      });
      return {};
    }
  });
  var VFileInput$1 = "";
  var makeVFileInputProps = propsFactory(_objectSpread(_objectSpread({
    chips: Boolean,
    counter: Boolean,
    counterSizeString: {
      type: String,
      "default": "$vuetify.fileInput.counterSize"
    },
    counterString: {
      type: String,
      "default": "$vuetify.fileInput.counter"
    },
    hideInput: Boolean,
    multiple: Boolean,
    showSize: {
      type: [Boolean, Number, String],
      "default": false,
      validator: function (v) {
        return typeof v === "boolean" || [1e3, 1024].includes(Number(v));
      }
    }
  }, makeVInputProps({
    prependIcon: "$file"
  })), {}, {
    modelValue: {
      type: [Array, Object],
      "default": function (props) {
        return props.multiple ? [] : null;
      },
      validator: function (val) {
        return wrapInArray(val).every(function (v) {
          return v != null && _typeof(v) === "object";
        });
      }
    }
  }, makeVFieldProps({
    clearable: true
  })), "VFileInput");
  var VFileInput = genericComponent()({
    name: "VFileInput",
    inheritAttrs: false,
    props: makeVFileInputProps(),
    emits: {
      "click:control": function (e) {
        return true;
      },
      "mousedown:control": function (e) {
        return true;
      },
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (files) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var _useLocale16 = useLocale(),
        t = _useLocale16.t;
      var model = useProxiedModel(props, "modelValue", props.modelValue, function (val) {
        return wrapInArray(val);
      }, function (val) {
        return !props.multiple && Array.isArray(val) ? val[0] : val;
      });
      var _useFocus5 = useFocus(props),
        isFocused = _useFocus5.isFocused,
        focus2 = _useFocus5.focus,
        blur2 = _useFocus5.blur;
      var base2 = computed(function () {
        return typeof props.showSize !== "boolean" ? props.showSize : void 0;
      });
      var totalBytes = computed(function () {
        var _a2;
        return ((_a2 = model.value) != null ? _a2 : []).reduce(function (bytes, _ref2) {
          var _ref2$size = _ref2.size,
            size = _ref2$size === void 0 ? 0 : _ref2$size;
          return bytes + size;
        }, 0);
      });
      var totalBytesReadable = computed(function () {
        return humanReadableFileSize(totalBytes.value, base2.value);
      });
      var fileNames = computed(function () {
        var _a2;
        return ((_a2 = model.value) != null ? _a2 : []).map(function (file) {
          var _file$name = file.name,
            name = _file$name === void 0 ? "" : _file$name,
            _file$size = file.size,
            size = _file$size === void 0 ? 0 : _file$size;
          return !props.showSize ? name : name + " (" + humanReadableFileSize(size, base2.value) + ")";
        });
      });
      var counterValue = computed(function () {
        var _a2, _b;
        var fileCount = (_b = (_a2 = model.value) == null ? void 0 : _a2.length) != null ? _b : 0;
        if (props.showSize) return t(props.counterSizeString, fileCount, totalBytesReadable.value);else return t(props.counterString, fileCount);
      });
      var vInputRef = ref();
      var vFieldRef = ref();
      var inputRef = ref();
      var isActive2 = computed(function () {
        return isFocused.value || props.active;
      });
      var isPlainOrUnderlined = computed(function () {
        return ["plain", "underlined"].includes(props.variant);
      });
      function onFocus() {
        var _a2;
        if (inputRef.value !== document.activeElement) {
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        }
        if (!isFocused.value) focus2();
      }
      function onClickPrepend(e) {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.click();
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
      }
      function onControlClick(e) {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.click();
        emit2("click:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(function () {
          model.value = [];
          callEvent(props["onClick:clear"], e);
        });
      }
      watch(model, function (newValue) {
        var hasModelReset = !Array.isArray(newValue) || !newValue.length;
        if (hasModelReset && inputRef.value) {
          inputRef.value.value = "";
        }
      });
      useRender(function () {
        var hasCounter = !!(slots.counter || props.counter);
        var hasDetails = !!(hasCounter || slots.details);
        var _filterInputAttrs7 = filterInputAttrs(attrs),
          _filterInputAttrs8 = _slicedToArray(_filterInputAttrs7, 2),
          rootAttrs = _filterInputAttrs8[0],
          inputAttrs = _filterInputAttrs8[1];
        var _VInput$filterProps2 = VInput.filterProps(props),
          _ = _VInput$filterProps2.modelValue,
          inputProps = _objectWithoutProperties(_VInput$filterProps2, _excluded17);
        var fieldProps = filterFieldProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-file-input", {
            "v-file-input--chips": !!props.chips,
            "v-file-input--hide": props.hideInput,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style,
          "onClick:prepend": onClickPrepend
        }, rootAttrs, inputProps, {
          "centerAffix": !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (_ref3) {
            var id = _ref3.id,
              isDisabled = _ref3.isDisabled,
              isDirty2 = _ref3.isDirty,
              isReadonly2 = _ref3.isReadonly,
              isValid2 = _ref3.isValid;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "prepend-icon": props.prependIcon,
              "onMousedown": onControlMousedown,
              "onClick": onControlClick,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"]
            }, fieldProps, {
              "id": id.value,
              "active": isActive2.value || isDirty2.value,
              "dirty": isDirty2.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid2.value === false
            }), _objectSpread(_objectSpread({}, slots), {}, {
              "default": function (_ref4) {
                var _a2;
                var _ref4$props = _ref4.props,
                  fieldClass = _ref4$props.class,
                  slotProps = _objectWithoutProperties(_ref4$props, _excluded18);
                return createVNode(Fragment$1, null, [createVNode("input", mergeProps({
                  "ref": inputRef,
                  "type": "file",
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "multiple": props.multiple,
                  "name": props.name,
                  "onClick": function (e) {
                    e.stopPropagation();
                    if (isReadonly2.value) e.preventDefault();
                    onFocus();
                  },
                  "onChange": function (e) {
                    var _a3;
                    if (!e.target) return;
                    var target = e.target;
                    model.value = _toConsumableArray((_a3 = target.files) != null ? _a3 : []);
                  },
                  "onFocus": onFocus,
                  "onBlur": blur2
                }, slotProps, inputAttrs), null), createVNode("div", {
                  "class": fieldClass
                }, [!!((_a2 = model.value) == null ? void 0 : _a2.length) && !props.hideInput && (slots.selection ? slots.selection({
                  fileNames: fileNames.value,
                  totalBytes: totalBytes.value,
                  totalBytesReadable: totalBytesReadable.value
                }) : props.chips ? fileNames.value.map(function (text) {
                  return createVNode(VChip, {
                    "key": text,
                    "size": "small",
                    "text": text
                  }, null);
                }) : fileNames.value.join(", "))])]);
              }
            }));
          },
          details: hasDetails ? function (slotProps) {
            var _a2, _b;
            return createVNode(Fragment$1, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment$1, null, [createVNode("span", null, null), createVNode(VCounter, {
              "active": !!((_b = model.value) == null ? void 0 : _b.length),
              "value": counterValue.value,
              "disabled": props.disabled
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, inputRef);
    }
  });
  var VFooter$1 = "";
  var makeVFooterProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    app: Boolean,
    color: String,
    height: {
      type: [Number, String],
      "default": "auto"
    }
  }, makeBorderProps()), makeComponentProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps({
    tag: "footer"
  })), makeThemeProps()), "VFooter");
  var VFooter = genericComponent()({
    name: "VFooter",
    props: makeVFooterProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var layoutItemStyles = ref();
      var _provideTheme25 = provideTheme(props),
        themeClasses = _provideTheme25.themeClasses;
      var _useBackgroundColor22 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor22.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor22.backgroundColorStyles;
      var _useBorder12 = useBorder(props),
        borderClasses = _useBorder12.borderClasses;
      var _useElevation14 = useElevation(props),
        elevationClasses = _useElevation14.elevationClasses;
      var _useRounded20 = useRounded(props),
        roundedClasses = _useRounded20.roundedClasses;
      var autoHeight = shallowRef(32);
      var _useResizeObserver10 = useResizeObserver(function (entries) {
          if (!entries.length) return;
          autoHeight.value = entries[0].target.clientHeight;
        }),
        resizeRef = _useResizeObserver10.resizeRef;
      var height = computed(function () {
        return props.height === "auto" ? autoHeight.value : parseInt(props.height, 10);
      });
      useToggleScope(function () {
        return props.app;
      }, function () {
        var layout = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: computed(function () {
            return "bottom";
          }),
          layoutSize: height,
          elementSize: computed(function () {
            return props.height === "auto" ? void 0 : height.value;
          }),
          active: computed(function () {
            return props.app;
          }),
          absolute: toRef(props, "absolute")
        });
        watchEffect(function () {
          layoutItemStyles.value = layout.layoutItemStyles.value;
        });
      });
      useRender(function () {
        return createVNode(props.tag, {
          "ref": resizeRef,
          "class": ["v-footer", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, props.app ? layoutItemStyles.value : {
            height: convertToUnit(props.height)
          }, props.style]
        }, slots);
      });
      return {};
    }
  });
  var makeVFormProps = propsFactory(_objectSpread(_objectSpread({}, makeComponentProps()), makeFormProps()), "VForm");
  var VForm = genericComponent()({
    name: "VForm",
    props: makeVFormProps(),
    emits: {
      "update:modelValue": function (val) {
        return true;
      },
      submit: function (e) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots,
        emit2 = _ref.emit;
      var form = createForm(props);
      var formRef = ref();
      function onReset(e) {
        e.preventDefault();
        form.reset();
      }
      function onSubmit(_e) {
        var e = _e;
        var ready = form.validate();
        e.then = ready.then.bind(ready);
        e.catch = ready.catch.bind(ready);
        e.finally = ready.finally.bind(ready);
        emit2("submit", e);
        if (!e.defaultPrevented) {
          ready.then(function (_ref2) {
            var _a2;
            var valid = _ref2.valid;
            if (valid) {
              (_a2 = formRef.value) == null ? void 0 : _a2.submit();
            }
          });
        }
        e.preventDefault();
      }
      useRender(function () {
        var _a2;
        return createVNode("form", {
          "ref": formRef,
          "class": ["v-form", props.class],
          "style": props.style,
          "novalidate": true,
          "onReset": onReset,
          "onSubmit": onSubmit
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, form)]);
      });
      return forwardRefs(form, formRef);
    }
  });
  var makeVHoverProps = propsFactory(_objectSpread({
    disabled: Boolean,
    modelValue: {
      type: Boolean,
      "default": null
    }
  }, makeDelayProps()), "VHover");
  var VHover = genericComponent()({
    name: "VHover",
    props: makeVHoverProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var isHovering = useProxiedModel(props, "modelValue");
      var _useDelay2 = useDelay(props, function (value) {
          return !props.disabled && (isHovering.value = value);
        }),
        runOpenDelay = _useDelay2.runOpenDelay,
        runCloseDelay = _useDelay2.runCloseDelay;
      return function () {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isHovering: isHovering.value,
          props: {
            onMouseenter: runOpenDelay,
            onMouseleave: runCloseDelay
          }
        });
      };
    }
  });
  var VInfiniteScroll$1 = "";
  var makeVInfiniteScrollProps = propsFactory(_objectSpread(_objectSpread({
    color: String,
    direction: {
      type: String,
      "default": "vertical",
      validator: function (v) {
        return ["vertical", "horizontal"].includes(v);
      }
    },
    side: {
      type: String,
      "default": "end",
      validator: function (v) {
        return ["start", "end", "both"].includes(v);
      }
    },
    mode: {
      type: String,
      "default": "intersect",
      validator: function (v) {
        return ["intersect", "manual"].includes(v);
      }
    },
    margin: [Number, String],
    loadMoreText: {
      type: String,
      "default": "$vuetify.infiniteScroll.loadMore"
    },
    emptyText: {
      type: String,
      "default": "$vuetify.infiniteScroll.empty"
    }
  }, makeDimensionProps()), makeTagProps()), "VInfiniteScroll");
  var VInfiniteScrollIntersect = defineComponent({
    name: "VInfiniteScrollIntersect",
    props: {
      side: {
        type: String,
        required: true
      },
      rootMargin: String
    },
    emits: {
      intersect: function (side, isIntersecting) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit;
      var _useIntersectionObser3 = useIntersectionObserver(),
        intersectionRef = _useIntersectionObser3.intersectionRef,
        isIntersecting = _useIntersectionObser3.isIntersecting;
      watch(isIntersecting, function _callee9(val) {
        return _regeneratorRuntime.async(function _callee9$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              emit2("intersect", props.side, val);
            case 1:
            case "end":
              return _context20.stop();
          }
        }, null, null, null, Promise);
      });
      useRender(function () {
        return createVNode("div", {
          "class": "v-infinite-scroll-intersect",
          "style": {
            "--v-infinite-margin-size": props.rootMargin
          },
          "ref": intersectionRef
        }, [createTextVNode("\xA0")]);
      });
      return {};
    }
  });
  var VInfiniteScroll = genericComponent()({
    name: "VInfiniteScroll",
    props: makeVInfiniteScrollProps(),
    emits: {
      load: function (options) {
        return true;
      }
    },
    setup: function (props, _ref2) {
      var slots = _ref2.slots,
        emit2 = _ref2.emit;
      var rootEl = ref();
      var startStatus = shallowRef("ok");
      var endStatus = shallowRef("ok");
      var margin = computed(function () {
        return convertToUnit(props.margin);
      });
      var isIntersecting = shallowRef(false);
      function setScrollAmount(amount) {
        if (!rootEl.value) return;
        var property = props.direction === "vertical" ? "scrollTop" : "scrollLeft";
        rootEl.value[property] = amount;
      }
      function getScrollAmount() {
        if (!rootEl.value) return 0;
        var property = props.direction === "vertical" ? "scrollTop" : "scrollLeft";
        return rootEl.value[property];
      }
      function getScrollSize2() {
        if (!rootEl.value) return 0;
        var property = props.direction === "vertical" ? "scrollHeight" : "scrollWidth";
        return rootEl.value[property];
      }
      function getContainerSize() {
        if (!rootEl.value) return 0;
        var property = props.direction === "vertical" ? "clientHeight" : "clientWidth";
        return rootEl.value[property];
      }
      onMounted(function () {
        if (!rootEl.value) return;
        if (props.side === "start") {
          setScrollAmount(getScrollSize2());
        } else if (props.side === "both") {
          setScrollAmount(getScrollSize2() / 2 - getContainerSize() / 2);
        }
      });
      function setStatus(side, status) {
        if (side === "start") {
          startStatus.value = status;
        } else if (side === "end") {
          endStatus.value = status;
        }
      }
      function getStatus(side) {
        return side === "start" ? startStatus.value : endStatus.value;
      }
      var previousScrollSize = 0;
      function handleIntersect(side, _isIntersecting) {
        isIntersecting.value = _isIntersecting;
        if (isIntersecting.value) {
          intersecting(side);
        }
      }
      function intersecting(side) {
        if (props.mode !== "manual" && !isIntersecting.value) return;
        var status = getStatus(side);
        if (!rootEl.value || ["empty", "loading"].includes(status)) return;
        previousScrollSize = getScrollSize2();
        setStatus(side, "loading");
        function done(status2) {
          setStatus(side, status2);
          nextTick(function () {
            if (status2 === "empty" || status2 === "error") return;
            if (status2 === "ok" && side === "start") {
              setScrollAmount(getScrollSize2() - previousScrollSize + getScrollAmount());
            }
            if (props.mode !== "manual") {
              nextTick(function () {
                window.requestAnimationFrame(function () {
                  window.requestAnimationFrame(function () {
                    window.requestAnimationFrame(function () {
                      intersecting(side);
                    });
                  });
                });
              });
            }
          });
        }
        emit2("load", {
          side: side,
          done: done
        });
      }
      var _useLocale17 = useLocale(),
        t = _useLocale17.t;
      function renderSide(side, status) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        if (props.side !== side && props.side !== "both") return;
        var onClick = function () {
          return intersecting(side);
        };
        var slotProps = {
          side: side,
          props: {
            onClick: onClick,
            color: props.color
          }
        };
        if (status === "error") return (_a2 = slots.error) == null ? void 0 : _a2.call(slots, slotProps);
        if (status === "empty") return (_c = (_b = slots.empty) == null ? void 0 : _b.call(slots, slotProps)) != null ? _c : createVNode("div", null, [t(props.emptyText)]);
        if (props.mode === "manual") {
          if (status === "loading") {
            return (_e = (_d = slots.loading) == null ? void 0 : _d.call(slots, slotProps)) != null ? _e : createVNode(VProgressCircular, {
              "indeterminate": true,
              "color": props.color
            }, null);
          }
          return (_g = (_f = slots["load-more"]) == null ? void 0 : _f.call(slots, slotProps)) != null ? _g : createVNode(VBtn, {
            "variant": "outlined",
            "color": props.color,
            "onClick": onClick
          }, {
            "default": function () {
              return [t(props.loadMoreText)];
            }
          });
        }
        return (_i = (_h = slots.loading) == null ? void 0 : _h.call(slots, slotProps)) != null ? _i : createVNode(VProgressCircular, {
          "indeterminate": true,
          "color": props.color
        }, null);
      }
      var _useDimension15 = useDimension(props),
        dimensionStyles = _useDimension15.dimensionStyles;
      useRender(function () {
        var Tag = props.tag;
        var hasStartIntersect = props.side === "start" || props.side === "both";
        var hasEndIntersect = props.side === "end" || props.side === "both";
        var intersectMode = props.mode === "intersect";
        return createVNode(Tag, {
          "ref": rootEl,
          "class": ["v-infinite-scroll", "v-infinite-scroll--" + props.direction, {
            "v-infinite-scroll--start": hasStartIntersect,
            "v-infinite-scroll--end": hasEndIntersect
          }],
          "style": dimensionStyles.value
        }, {
          "default": function () {
            var _a2;
            return [createVNode("div", {
              "class": "v-infinite-scroll__side"
            }, [renderSide("start", startStatus.value)]), hasStartIntersect && intersectMode && createVNode(VInfiniteScrollIntersect, {
              "key": "start",
              "side": "start",
              "onIntersect": handleIntersect,
              "rootMargin": margin.value
            }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots), hasEndIntersect && intersectMode && createVNode(VInfiniteScrollIntersect, {
              "key": "end",
              "side": "end",
              "onIntersect": handleIntersect,
              "rootMargin": margin.value
            }, null), createVNode("div", {
              "class": "v-infinite-scroll__side"
            }, [renderSide("end", endStatus.value)])];
          }
        });
      });
    }
  });
  var VItemGroup$1 = "";
  var VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
  var makeVItemGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeComponentProps()), makeGroupProps({
    selectedClass: "v-item--selected"
  })), makeTagProps()), makeThemeProps()), "VItemGroup");
  var VItemGroup = genericComponent()({
    name: "VItemGroup",
    props: makeVItemGroupProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme26 = provideTheme(props),
        themeClasses = _provideTheme26.themeClasses;
      var _useGroup4 = useGroup(props, VItemGroupSymbol),
        isSelected = _useGroup4.isSelected,
        select = _useGroup4.select,
        next = _useGroup4.next,
        prev = _useGroup4.prev,
        selected = _useGroup4.selected;
      return function () {
        return createVNode(props.tag, {
          "class": ["v-item-group", themeClasses.value, props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a2;
            return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              isSelected: isSelected,
              select: select,
              next: next,
              prev: prev,
              selected: selected.value
            })];
          }
        });
      };
    }
  });
  var VItem = genericComponent()({
    name: "VItem",
    props: makeGroupItemProps(),
    emits: {
      "group:selected": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useGroupItem = useGroupItem(props, VItemGroupSymbol),
        isSelected = _useGroupItem.isSelected,
        select = _useGroupItem.select,
        toggle = _useGroupItem.toggle,
        selectedClass = _useGroupItem.selectedClass,
        value = _useGroupItem.value,
        disabled = _useGroupItem.disabled;
      return function () {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isSelected: isSelected.value,
          selectedClass: selectedClass.value,
          select: select,
          toggle: toggle,
          value: value.value,
          disabled: disabled.value
        });
      };
    }
  });
  var VKbd$1 = "";
  var VKbd = createSimpleFunctional("v-kbd");
  var VLayout$1 = "";
  var makeVLayoutProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({}, makeComponentProps()), makeDimensionProps()), makeLayoutProps()), "VLayout");
  var VLayout = genericComponent()({
    name: "VLayout",
    props: makeVLayoutProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _createLayout2 = createLayout(props),
        layoutClasses = _createLayout2.layoutClasses,
        layoutStyles = _createLayout2.layoutStyles,
        getLayoutItem = _createLayout2.getLayoutItem,
        items = _createLayout2.items,
        layoutRef = _createLayout2.layoutRef;
      var _useDimension16 = useDimension(props),
        dimensionStyles = _useDimension16.dimensionStyles;
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "ref": layoutRef,
          "class": [layoutClasses.value, props.class],
          "style": [dimensionStyles.value, layoutStyles.value, props.style]
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {
        getLayoutItem: getLayoutItem,
        items: items
      };
    }
  });
  var VLayoutItem$1 = "";
  var makeVLayoutItemProps = propsFactory(_objectSpread(_objectSpread({
    position: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      "default": 300
    },
    modelValue: Boolean
  }, makeComponentProps()), makeLayoutItemProps()), "VLayoutItem");
  var VLayoutItem = genericComponent()({
    name: "VLayoutItem",
    props: makeVLayoutItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useLayoutItem3 = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: toRef(props, "position"),
          elementSize: toRef(props, "size"),
          layoutSize: toRef(props, "size"),
          active: toRef(props, "modelValue"),
          absolute: toRef(props, "absolute")
        }),
        layoutItemStyles = _useLayoutItem3.layoutItemStyles;
      return function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-layout-item", props.class],
          "style": [layoutItemStyles.value, props.style]
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      };
    }
  });
  var makeVLazyProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    modelValue: Boolean,
    options: {
      type: Object,
      "default": function () {
        return {
          root: void 0,
          rootMargin: void 0,
          threshold: void 0
        };
      }
    }
  }, makeComponentProps()), makeDimensionProps()), makeTagProps()), makeTransitionProps({
    transition: "fade-transition"
  })), "VLazy");
  var VLazy = genericComponent()({
    name: "VLazy",
    directives: {
      intersect: Intersect
    },
    props: makeVLazyProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useDimension17 = useDimension(props),
        dimensionStyles = _useDimension17.dimensionStyles;
      var isActive2 = useProxiedModel(props, "modelValue");
      function onIntersect(isIntersecting) {
        if (isActive2.value) return;
        isActive2.value = isIntersecting;
      }
      useRender(function () {
        return withDirectives(createVNode(props.tag, {
          "class": ["v-lazy", props.class],
          "style": [dimensionStyles.value, props.style]
        }, {
          "default": function () {
            return [isActive2.value && createVNode(MaybeTransition, {
              "transition": props.transition,
              "appear": true
            }, {
              "default": function () {
                var _a2;
                return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
              }
            })];
          }
        }), [[resolveDirective("intersect"), {
          handler: onIntersect,
          options: props.options
        }, null]]);
      });
      return {};
    }
  });
  var VLocaleProvider$1 = "";
  var makeVLocaleProviderProps = propsFactory(_objectSpread({
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
      type: Boolean,
      "default": void 0
    }
  }, makeComponentProps()), "VLocaleProvider");
  var VLocaleProvider = genericComponent()({
    name: "VLocaleProvider",
    props: makeVLocaleProviderProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideLocale = provideLocale(props),
        rtlClasses = _provideLocale.rtlClasses;
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-locale-provider", rtlClasses.value, props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var VMain$1 = "";
  var makeVMainProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    scrollable: Boolean
  }, makeComponentProps()), makeDimensionProps()), makeTagProps({
    tag: "main"
  })), "VMain");
  var VMain = genericComponent()({
    name: "VMain",
    props: makeVMainProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useDimension18 = useDimension(props),
        dimensionStyles = _useDimension18.dimensionStyles;
      var _useLayout = useLayout(),
        mainStyles = _useLayout.mainStyles;
      var _useSsrBoot5 = useSsrBoot(),
        ssrBootStyles = _useSsrBoot5.ssrBootStyles;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-main", {
            "v-main--scrollable": props.scrollable
          }, props.class],
          "style": [mainStyles.value, ssrBootStyles.value, dimensionStyles.value, props.style]
        }, {
          "default": function () {
            var _a2, _b;
            return [props.scrollable ? createVNode("div", {
              "class": "v-main__scroller"
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]) : (_b = slots.default) == null ? void 0 : _b.call(slots)];
          }
        });
      });
      return {};
    }
  });
  var VNavigationDrawer$1 = "";
  function useSticky(_ref) {
    var rootEl = _ref.rootEl,
      isSticky = _ref.isSticky,
      layoutItemStyles = _ref.layoutItemStyles;
    var isStuck = shallowRef(false);
    var stuckPosition = shallowRef(0);
    var stickyStyles = computed(function () {
      var _ref290;
      var side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
      return [isSticky.value ? {
        top: "auto",
        bottom: "auto",
        height: void 0
      } : void 0, isStuck.value ? (_ref290 = {}, _ref290[side] = convertToUnit(stuckPosition.value), _ref290) : {
        top: layoutItemStyles.value.top
      }];
    });
    onMounted(function () {
      watch(isSticky, function (val) {
        if (val) {
          window.addEventListener("scroll", onScroll, {
            passive: true
          });
        } else {
          window.removeEventListener("scroll", onScroll);
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(function () {
      window.removeEventListener("scroll", onScroll);
    });
    var lastScrollTop = 0;
    function onScroll() {
      var _a2;
      var direction = lastScrollTop > window.scrollY ? "up" : "down";
      var rect = rootEl.value.getBoundingClientRect();
      var layoutTop = parseFloat((_a2 = layoutItemStyles.value.top) != null ? _a2 : 0);
      var top = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
      var bottom = rect.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
      var bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
      if (rect.height < window.innerHeight - layoutTop) {
        isStuck.value = "top";
        stuckPosition.value = layoutTop;
      } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
        stuckPosition.value = window.scrollY + rect.top - bodyScroll;
        isStuck.value = true;
      } else if (direction === "down" && bottom <= 0) {
        stuckPosition.value = 0;
        isStuck.value = "bottom";
      } else if (direction === "up" && top <= 0) {
        if (!bodyScroll) {
          stuckPosition.value = rect.top + top;
          isStuck.value = "top";
        } else if (isStuck.value !== "top") {
          stuckPosition.value = -top + bodyScroll + layoutTop;
          isStuck.value = "top";
        }
      }
      lastScrollTop = window.scrollY;
    }
    return {
      isStuck: isStuck,
      stickyStyles: stickyStyles
    };
  }
  var HORIZON = 100;
  var HISTORY = 20;
  function kineticEnergyToVelocity(work) {
    var sqrt2 = 1.41421356237;
    return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
  }
  function calculateImpulseVelocity(samples) {
    if (samples.length < 2) {
      return 0;
    }
    if (samples.length === 2) {
      if (samples[1].t === samples[0].t) {
        return 0;
      }
      return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
    }
    var work = 0;
    for (var _i286 = samples.length - 1; _i286 > 0; _i286--) {
      if (samples[_i286].t === samples[_i286 - 1].t) {
        continue;
      }
      var vprev = kineticEnergyToVelocity(work);
      var vcurr = (samples[_i286].d - samples[_i286 - 1].d) / (samples[_i286].t - samples[_i286 - 1].t);
      work += (vcurr - vprev) * Math.abs(vcurr);
      if (_i286 === samples.length - 1) {
        work *= 0.5;
      }
    }
    return kineticEnergyToVelocity(work) * 1e3;
  }
  function useVelocity() {
    var touches = {};
    function addMovement(e) {
      Array.from(e.changedTouches).forEach(function (touch) {
        var _a2;
        var samples = (_a2 = touches[touch.identifier]) != null ? _a2 : touches[touch.identifier] = new CircularBuffer(HISTORY);
        samples.push([e.timeStamp, touch]);
      });
    }
    function endTouch(e) {
      Array.from(e.changedTouches).forEach(function (touch) {
        delete touches[touch.identifier];
      });
    }
    function getVelocity(id) {
      var _a2;
      var samples = (_a2 = touches[id]) == null ? void 0 : _a2.values().reverse();
      if (!samples) {
        throw new Error("No samples for touch id " + id);
      }
      var newest = samples[0];
      var x = [];
      var y = [];
      for (var _iterator70 = _createForOfIteratorHelperLoose(samples), _step72; !(_step72 = _iterator70()).done;) {
        var val = _step72.value;
        if (newest[0] - val[0] > HORIZON) break;
        x.push({
          t: val[0],
          d: val[1].clientX
        });
        y.push({
          t: val[0],
          d: val[1].clientY
        });
      }
      return {
        x: calculateImpulseVelocity(x),
        y: calculateImpulseVelocity(y),
        get direction() {
          var x2 = this.x,
            y2 = this.y;
          var _ref291 = [Math.abs(x2), Math.abs(y2)],
            absX = _ref291[0],
            absY = _ref291[1];
          return absX > absY && x2 >= 0 ? "right" : absX > absY && x2 <= 0 ? "left" : absY > absX && y2 >= 0 ? "down" : absY > absX && y2 <= 0 ? "up" : oops$1();
        }
      };
    }
    return {
      addMovement: addMovement,
      endTouch: endTouch,
      getVelocity: getVelocity
    };
  }
  function oops$1() {
    throw new Error();
  }
  function useTouch(_ref) {
    var el = _ref.el,
      isActive2 = _ref.isActive,
      isTemporary = _ref.isTemporary,
      width = _ref.width,
      touchless = _ref.touchless,
      position = _ref.position;
    onMounted(function () {
      window.addEventListener("touchstart", onTouchstart, {
        passive: true
      });
      window.addEventListener("touchmove", onTouchmove, {
        passive: false
      });
      window.addEventListener("touchend", onTouchend, {
        passive: true
      });
    });
    onBeforeUnmount(function () {
      window.removeEventListener("touchstart", onTouchstart);
      window.removeEventListener("touchmove", onTouchmove);
      window.removeEventListener("touchend", onTouchend);
    });
    var isHorizontal = computed(function () {
      return ["left", "right"].includes(position.value);
    });
    var _useVelocity = useVelocity(),
      addMovement = _useVelocity.addMovement,
      endTouch = _useVelocity.endTouch,
      getVelocity = _useVelocity.getVelocity;
    var maybeDragging = false;
    var isDragging = shallowRef(false);
    var dragProgress = shallowRef(0);
    var offset = shallowRef(0);
    var start;
    function getOffset2(pos, active) {
      return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops()) - (active ? width.value : 0);
    }
    function getProgress(pos) {
      var limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops();
      return limit ? Math.max(0, Math.min(1, progress)) : progress;
    }
    function onTouchstart(e) {
      if (touchless.value) return;
      var touchX = e.changedTouches[0].clientX;
      var touchY = e.changedTouches[0].clientY;
      var touchZone = 25;
      var inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops();
      var inElement = isActive2.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops());
      if (inTouchZone || inElement || isActive2.value && isTemporary.value) {
        start = [touchX, touchY];
        offset.value = getOffset2(isHorizontal.value ? touchX : touchY, isActive2.value);
        dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
        maybeDragging = offset.value > -20 && offset.value < 80;
        endTouch(e);
        addMovement(e);
      }
    }
    function onTouchmove(e) {
      var touchX = e.changedTouches[0].clientX;
      var touchY = e.changedTouches[0].clientY;
      if (maybeDragging) {
        if (!e.cancelable) {
          maybeDragging = false;
          return;
        }
        var dx = Math.abs(touchX - start[0]);
        var dy = Math.abs(touchY - start[1]);
        var thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
        if (thresholdMet) {
          isDragging.value = true;
          maybeDragging = false;
        } else if ((isHorizontal.value ? dy : dx) > 3) {
          maybeDragging = false;
        }
      }
      if (!isDragging.value) return;
      e.preventDefault();
      addMovement(e);
      var progress = getProgress(isHorizontal.value ? touchX : touchY, false);
      dragProgress.value = Math.max(0, Math.min(1, progress));
      if (progress > 1) {
        offset.value = getOffset2(isHorizontal.value ? touchX : touchY, true);
      } else if (progress < 0) {
        offset.value = getOffset2(isHorizontal.value ? touchX : touchY, false);
      }
    }
    function onTouchend(e) {
      maybeDragging = false;
      if (!isDragging.value) return;
      addMovement(e);
      isDragging.value = false;
      var velocity = getVelocity(e.changedTouches[0].identifier);
      var vx = Math.abs(velocity.x);
      var vy = Math.abs(velocity.y);
      var thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
      if (thresholdMet) {
        isActive2.value = velocity.direction === ({
          left: "right",
          right: "left",
          top: "down",
          bottom: "up"
        }[position.value] || oops());
      } else {
        isActive2.value = dragProgress.value > 0.5;
      }
    }
    var dragStyles = computed(function () {
      return isDragging.value ? {
        transform: position.value === "left" ? "translateX(calc(-100% + " + dragProgress.value * width.value + "px))" : position.value === "right" ? "translateX(calc(100% - " + dragProgress.value * width.value + "px))" : position.value === "top" ? "translateY(calc(-100% + " + dragProgress.value * width.value + "px))" : position.value === "bottom" ? "translateY(calc(100% - " + dragProgress.value * width.value + "px))" : oops(),
        transition: "none"
      } : void 0;
    });
    useToggleScope(isDragging, function () {
      var _a2, _b, _c, _d;
      var transform2 = (_b = (_a2 = el.value) == null ? void 0 : _a2.style.transform) != null ? _b : null;
      var transition = (_d = (_c = el.value) == null ? void 0 : _c.style.transition) != null ? _d : null;
      watchEffect(function () {
        var _a3, _b2, _c2, _d2;
        (_b2 = el.value) == null ? void 0 : _b2.style.setProperty("transform", ((_a3 = dragStyles.value) == null ? void 0 : _a3.transform) || "none");
        (_d2 = el.value) == null ? void 0 : _d2.style.setProperty("transition", ((_c2 = dragStyles.value) == null ? void 0 : _c2.transition) || null);
      });
      onScopeDispose(function () {
        var _a3, _b2;
        (_a3 = el.value) == null ? void 0 : _a3.style.setProperty("transform", transform2);
        (_b2 = el.value) == null ? void 0 : _b2.style.setProperty("transition", transition);
      });
    });
    return {
      isDragging: isDragging,
      dragProgress: dragProgress,
      dragStyles: dragStyles
    };
  }
  function oops() {
    throw new Error();
  }
  var locations = ["start", "end", "left", "right", "top", "bottom"];
  var makeVNavigationDrawerProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    color: String,
    disableResizeWatcher: Boolean,
    disableRouteWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
      type: Boolean,
      "default": null
    },
    permanent: Boolean,
    rail: {
      type: Boolean,
      "default": null
    },
    railWidth: {
      type: [Number, String],
      "default": 56
    },
    scrim: {
      type: [Boolean, String],
      "default": true
    },
    image: String,
    temporary: Boolean,
    persistent: Boolean,
    touchless: Boolean,
    width: {
      type: [Number, String],
      "default": 256
    },
    location: {
      type: String,
      "default": "start",
      validator: function (value) {
        return locations.includes(value);
      }
    },
    sticky: Boolean
  }, makeBorderProps()), makeComponentProps()), makeDelayProps()), makeDisplayProps({
    mobile: null
  })), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps({
    tag: "nav"
  })), makeThemeProps()), "VNavigationDrawer");
  var VNavigationDrawer = genericComponent()({
    name: "VNavigationDrawer",
    props: makeVNavigationDrawerProps(),
    emits: {
      "update:modelValue": function (val) {
        return true;
      },
      "update:rail": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var _useRtl18 = useRtl(),
        isRtl = _useRtl18.isRtl;
      var _provideTheme27 = provideTheme(props),
        themeClasses = _provideTheme27.themeClasses;
      var _useBorder13 = useBorder(props),
        borderClasses = _useBorder13.borderClasses;
      var _useBackgroundColor23 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor23.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor23.backgroundColorStyles;
      var _useElevation15 = useElevation(props),
        elevationClasses = _useElevation15.elevationClasses;
      var _useDisplay9 = useDisplay(props),
        displayClasses = _useDisplay9.displayClasses,
        mobile = _useDisplay9.mobile;
      var _useRounded21 = useRounded(props),
        roundedClasses = _useRounded21.roundedClasses;
      var router2 = useRouter();
      var isActive2 = useProxiedModel(props, "modelValue", null, function (v) {
        return !!v;
      });
      var _useSsrBoot6 = useSsrBoot(),
        ssrBootStyles = _useSsrBoot6.ssrBootStyles;
      var _useScopeId4 = useScopeId(),
        scopeId = _useScopeId4.scopeId;
      var rootEl = ref();
      var isHovering = shallowRef(false);
      var _useDelay3 = useDelay(props, function (value) {
          isHovering.value = value;
        }),
        runOpenDelay = _useDelay3.runOpenDelay,
        runCloseDelay = _useDelay3.runCloseDelay;
      var width = computed(function () {
        return props.rail && props.expandOnHover && isHovering.value ? Number(props.width) : Number(props.rail ? props.railWidth : props.width);
      });
      var location2 = computed(function () {
        return toPhysical(props.location, isRtl.value);
      });
      var isPersistent = computed(function () {
        return props.persistent;
      });
      var isTemporary = computed(function () {
        return !props.permanent && (mobile.value || props.temporary);
      });
      var isSticky = computed(function () {
        return props.sticky && !isTemporary.value && location2.value !== "bottom";
      });
      useToggleScope(function () {
        return props.expandOnHover && props.rail != null;
      }, function () {
        watch(isHovering, function (val) {
          return emit2("update:rail", !val);
        });
      });
      useToggleScope(function () {
        return !props.disableResizeWatcher;
      }, function () {
        watch(isTemporary, function (val) {
          return !props.permanent && nextTick(function () {
            return isActive2.value = !val;
          });
        });
      });
      useToggleScope(function () {
        return !props.disableRouteWatcher && !!router2;
      }, function () {
        watch(router2.currentRoute, function () {
          return isTemporary.value && (isActive2.value = false);
        });
      });
      watch(function () {
        return props.permanent;
      }, function (val) {
        if (val) isActive2.value = true;
      });
      if (props.modelValue == null && !isTemporary.value) {
        isActive2.value = props.permanent || !mobile.value;
      }
      var _useTouch = useTouch({
          el: rootEl,
          isActive: isActive2,
          isTemporary: isTemporary,
          width: width,
          touchless: toRef(props, "touchless"),
          position: location2
        }),
        isDragging = _useTouch.isDragging,
        dragProgress = _useTouch.dragProgress;
      var layoutSize = computed(function () {
        var size = isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value;
        return isDragging.value ? size * dragProgress.value : size;
      });
      var elementSize = computed(function () {
        return ["top", "bottom"].includes(props.location) ? 0 : width.value;
      });
      var _useLayoutItem4 = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: location2,
          layoutSize: layoutSize,
          elementSize: elementSize,
          active: computed(function () {
            return isActive2.value || isDragging.value;
          }),
          disableTransitions: computed(function () {
            return isDragging.value;
          }),
          absolute: computed(function () {
            return props.absolute || isSticky.value && typeof isStuck.value !== "string";
          })
        }),
        layoutItemStyles = _useLayoutItem4.layoutItemStyles,
        layoutItemScrimStyles = _useLayoutItem4.layoutItemScrimStyles;
      var _useSticky = useSticky({
          rootEl: rootEl,
          isSticky: isSticky,
          layoutItemStyles: layoutItemStyles
        }),
        isStuck = _useSticky.isStuck,
        stickyStyles = _useSticky.stickyStyles;
      var scrimColor = useBackgroundColor(computed(function () {
        return typeof props.scrim === "string" ? props.scrim : null;
      }));
      var scrimStyles = computed(function () {
        return _objectSpread(_objectSpread({}, isDragging.value ? {
          opacity: dragProgress.value * 0.2,
          transition: "none"
        } : void 0), layoutItemScrimStyles.value);
      });
      provideDefaults({
        VList: {
          bgColor: "transparent"
        }
      });
      useRender(function () {
        var hasImage = slots.image || props.image;
        return createVNode(Fragment$1, null, [createVNode(props.tag, mergeProps({
          "ref": rootEl,
          "onMouseenter": runOpenDelay,
          "onMouseleave": runCloseDelay,
          "class": ["v-navigation-drawer", "v-navigation-drawer--" + location2.value, {
            "v-navigation-drawer--expand-on-hover": props.expandOnHover,
            "v-navigation-drawer--floating": props.floating,
            "v-navigation-drawer--is-hovering": isHovering.value,
            "v-navigation-drawer--rail": props.rail,
            "v-navigation-drawer--temporary": isTemporary.value,
            "v-navigation-drawer--persistent": isPersistent.value,
            "v-navigation-drawer--active": isActive2.value,
            "v-navigation-drawer--sticky": isSticky.value
          }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, displayClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, stickyStyles.value, props.style, ["top", "bottom"].includes(location2.value) ? {
            height: "auto"
          } : {}]
        }, scopeId, attrs), {
          "default": function () {
            var _a2, _b, _c;
            return [hasImage && createVNode("div", {
              "key": "image",
              "class": "v-navigation-drawer__img"
            }, [!slots.image ? createVNode(VImg, {
              "key": "image-img",
              "alt": "",
              "cover": true,
              "height": "inherit",
              "src": props.image
            }, null) : createVNode(VDefaultsProvider, {
              "key": "image-defaults",
              "disabled": !props.image,
              "defaults": {
                VImg: {
                  alt: "",
                  cover: true,
                  height: "inherit",
                  src: props.image
                }
              }
            }, slots.image)]), slots.prepend && createVNode("div", {
              "class": "v-navigation-drawer__prepend"
            }, [(_a2 = slots.prepend) == null ? void 0 : _a2.call(slots)]), createVNode("div", {
              "class": "v-navigation-drawer__content"
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]), slots.append && createVNode("div", {
              "class": "v-navigation-drawer__append"
            }, [(_c = slots.append) == null ? void 0 : _c.call(slots)])];
          }
        }), createVNode(Transition, {
          "name": "fade-transition"
        }, {
          "default": function () {
            return [isTemporary.value && (isDragging.value || isActive2.value) && !!props.scrim && createVNode("div", mergeProps({
              "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
              "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
              "onClick": function () {
                if (isPersistent.value) return;
                isActive2.value = false;
              }
            }, scopeId), null)];
          }
        })]);
      });
      return {
        isStuck: isStuck
      };
    }
  });
  var VNoSsr = defineComponent({
    name: "VNoSsr",
    setup: function (_, _ref) {
      var slots = _ref.slots;
      var show = useHydration();
      return function () {
        var _a2;
        return show.value && ((_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      };
    }
  });
  var VOtpInput$1 = "";
  var makeVOtpInputProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    autofocus: Boolean,
    divider: String,
    focusAll: Boolean,
    label: {
      type: String,
      "default": "$vuetify.input.otp"
    },
    length: {
      type: [Number, String],
      "default": 6
    },
    modelValue: {
      type: [Number, String],
      "default": void 0
    },
    placeholder: String,
    type: {
      type: String,
      "default": "number"
    }
  }, makeDimensionProps()), makeFocusProps()), only(makeVFieldProps({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])), "VOtpInput");
  var VOtpInput = genericComponent()({
    name: "VOtpInput",
    props: makeVOtpInputProps(),
    emits: {
      finish: function (val) {
        return true;
      },
      "update:focused": function (val) {
        return true;
      },
      "update:modelValue": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var _useDimension19 = useDimension(props),
        dimensionStyles = _useDimension19.dimensionStyles;
      var _useFocus6 = useFocus(props),
        isFocused = _useFocus6.isFocused,
        focus2 = _useFocus6.focus,
        blur2 = _useFocus6.blur;
      var model = useProxiedModel(props, "modelValue", "", function (val) {
        return val == null ? [] : String(val).split("");
      }, function (val) {
        return val.join("");
      });
      var _useLocale18 = useLocale(),
        t = _useLocale18.t;
      var length = computed(function () {
        return Number(props.length);
      });
      var fields = computed(function () {
        return Array(length.value).fill(0);
      });
      var focusIndex = ref(-1);
      var contentRef = ref();
      var inputRef = ref([]);
      var current = computed(function () {
        return inputRef.value[focusIndex.value];
      });
      function onInput() {
        if (isValidNumber(current.value.value)) {
          current.value.value = "";
          return;
        }
        var array = model.value.slice();
        var value = current.value.value;
        array[focusIndex.value] = value;
        var target = null;
        if (focusIndex.value > model.value.length) {
          target = model.value.length + 1;
        } else if (focusIndex.value + 1 !== length.value) {
          target = "next";
        }
        model.value = array;
        if (target) focusChild(contentRef.value, target);
      }
      function onKeydown(e) {
        var array = model.value.slice();
        var index = focusIndex.value;
        var target = null;
        if (!["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key)) return;
        e.preventDefault();
        if (e.key === "ArrowLeft") {
          target = "prev";
        } else if (e.key === "ArrowRight") {
          target = "next";
        } else if (["Backspace", "Delete"].includes(e.key)) {
          array[focusIndex.value] = "";
          model.value = array;
          if (focusIndex.value > 0 && e.key === "Backspace") {
            target = "prev";
          } else {
            requestAnimationFrame(function () {
              var _a2;
              (_a2 = inputRef.value[index]) == null ? void 0 : _a2.select();
            });
          }
        }
        requestAnimationFrame(function () {
          if (target != null) {
            focusChild(contentRef.value, target);
          }
        });
      }
      function onPaste(index, e) {
        var _a2, _b, _c;
        e.preventDefault();
        e.stopPropagation();
        var clipboardText = (_b = (_a2 = e == null ? void 0 : e.clipboardData) == null ? void 0 : _a2.getData("Text").slice(0, length.value)) != null ? _b : "";
        if (isValidNumber(clipboardText)) return;
        model.value = clipboardText.split("");
        (_c = inputRef.value) == null ? void 0 : _c[index].blur();
      }
      function reset() {
        model.value = [];
      }
      function onFocus(e, index) {
        focus2();
        focusIndex.value = index;
      }
      function onBlur() {
        blur2();
        focusIndex.value = -1;
      }
      function isValidNumber(value) {
        return props.type === "number" && /[^0-9]/g.test(value);
      }
      provideDefaults({
        VField: {
          color: computed(function () {
            return props.color;
          }),
          bgColor: computed(function () {
            return props.color;
          }),
          baseColor: computed(function () {
            return props.baseColor;
          }),
          disabled: computed(function () {
            return props.disabled;
          }),
          error: computed(function () {
            return props.error;
          }),
          variant: computed(function () {
            return props.variant;
          })
        }
      }, {
        scoped: true
      });
      watch(model, function (val) {
        if (val.length === length.value) emit2("finish", val.join(""));
      }, {
        deep: true
      });
      watch(focusIndex, function (val) {
        if (val < 0) return;
        nextTick(function () {
          var _a2;
          (_a2 = inputRef.value[val]) == null ? void 0 : _a2.select();
        });
      });
      useRender(function () {
        var _a2;
        var _filterInputAttrs9 = filterInputAttrs(attrs),
          _filterInputAttrs10 = _slicedToArray(_filterInputAttrs9, 2),
          rootAttrs = _filterInputAttrs10[0],
          inputAttrs = _filterInputAttrs10[1];
        return createVNode("div", mergeProps({
          "class": ["v-otp-input", {
            "v-otp-input--divided": !!props.divider
          }, props.class],
          "style": [props.style]
        }, rootAttrs), [createVNode("div", {
          "ref": contentRef,
          "class": "v-otp-input__content",
          "style": [dimensionStyles.value]
        }, [fields.value.map(function (_, i) {
          return createVNode(Fragment$1, null, [props.divider && i !== 0 && createVNode("span", {
            "class": "v-otp-input__divider"
          }, [props.divider]), createVNode(VField, {
            "focused": isFocused.value && props.focusAll || focusIndex.value === i,
            "key": i
          }, _objectSpread(_objectSpread({}, slots), {}, {
            loader: void 0,
            "default": function () {
              return createVNode("input", {
                "ref": function (val) {
                  return inputRef.value[i] = val;
                },
                "aria-label": t(props.label, i + 1),
                "autofocus": i === 0 && props.autofocus,
                "autocomplete": "one-time-code",
                "class": ["v-otp-input__field"],
                "disabled": props.disabled,
                "inputmode": props.type === "number" ? "numeric" : "text",
                "min": props.type === "number" ? 0 : void 0,
                "maxlength": "1",
                "placeholder": props.placeholder,
                "type": props.type === "number" ? "text" : props.type,
                "value": model.value[i],
                "onInput": onInput,
                "onFocus": function (e) {
                  return onFocus(e, i);
                },
                "onBlur": onBlur,
                "onKeydown": onKeydown,
                "onPaste": function (event) {
                  return onPaste(i, event);
                }
              }, null);
            }
          }))]);
        }), createVNode("input", mergeProps({
          "class": "v-otp-input-input",
          "type": "hidden"
        }, inputAttrs, {
          "value": model.value.join("")
        }), null), createVNode(VOverlay, {
          "contained": true,
          "content-class": "v-otp-input__loader",
          "model-value": !!props.loading,
          "persistent": true
        }, {
          "default": function () {
            var _a3, _b;
            return [(_b = (_a3 = slots.loader) == null ? void 0 : _a3.call(slots)) != null ? _b : createVNode(VProgressCircular, {
              "color": typeof props.loading === "boolean" ? void 0 : props.loading,
              "indeterminate": true,
              "size": "24",
              "width": "2"
            }, null)];
          }
        }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
      });
      return {
        blur: function () {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.some(function (input) {
            return input.blur();
          });
        },
        focus: function () {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2[0].focus();
        },
        reset: reset,
        isFocused: isFocused
      };
    }
  });
  var VParallax$1 = "";
  function floor(val) {
    return Math.floor(Math.abs(val)) * Math.sign(val);
  }
  var makeVParallaxProps = propsFactory(_objectSpread({
    scale: {
      type: [Number, String],
      "default": 0.5
    }
  }, makeComponentProps()), "VParallax");
  var VParallax = genericComponent()({
    name: "VParallax",
    props: makeVParallaxProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useIntersectionObser4 = useIntersectionObserver(),
        intersectionRef = _useIntersectionObser4.intersectionRef,
        isIntersecting = _useIntersectionObser4.isIntersecting;
      var _useResizeObserver11 = useResizeObserver(),
        resizeRef = _useResizeObserver11.resizeRef,
        contentRect = _useResizeObserver11.contentRect;
      var _useDisplay10 = useDisplay(),
        displayHeight = _useDisplay10.height;
      var root = ref();
      watchEffect(function () {
        var _a2;
        intersectionRef.value = resizeRef.value = (_a2 = root.value) == null ? void 0 : _a2.$el;
      });
      var scrollParent;
      watch(isIntersecting, function (val) {
        if (val) {
          scrollParent = getScrollParent(intersectionRef.value);
          scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;
          scrollParent.addEventListener("scroll", onScroll, {
            passive: true
          });
          onScroll();
        } else {
          scrollParent.removeEventListener("scroll", onScroll);
        }
      });
      onBeforeUnmount(function () {
        scrollParent == null ? void 0 : scrollParent.removeEventListener("scroll", onScroll);
      });
      watch(displayHeight, onScroll);
      watch(function () {
        var _a2;
        return (_a2 = contentRect.value) == null ? void 0 : _a2.height;
      }, onScroll);
      var scale = computed(function () {
        return 1 - clamp(+props.scale);
      });
      var frame = -1;
      function onScroll() {
        if (!isIntersecting.value) return;
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(function () {
          var _a2;
          var el = ((_a2 = root.value) == null ? void 0 : _a2.$el).querySelector(".v-img__img");
          if (!el) return;
          var scrollHeight = scrollParent instanceof Document ? document.documentElement.clientHeight : scrollParent.clientHeight;
          var scrollPos = scrollParent instanceof Document ? window.scrollY : scrollParent.scrollTop;
          var top = intersectionRef.value.getBoundingClientRect().top + scrollPos;
          var height = contentRect.value.height;
          var center = top + (height - scrollHeight) / 2;
          var translate = floor((scrollPos - center) * scale.value);
          var sizeScale = Math.max(1, (scale.value * (scrollHeight - height) + height) / height);
          el.style.setProperty("transform", "translateY(" + translate + "px) scale(" + sizeScale + ")");
        });
      }
      useRender(function () {
        return createVNode(VImg, {
          "class": ["v-parallax", {
            "v-parallax--active": isIntersecting.value
          }, props.class],
          "style": props.style,
          "ref": root,
          "cover": true,
          "onLoadstart": onScroll,
          "onLoad": onScroll
        }, slots);
      });
      return {};
    }
  });
  var makeVRadioProps = propsFactory(_objectSpread({}, makeVSelectionControlProps({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })), "VRadio");
  var VRadio = genericComponent()({
    name: "VRadio",
    props: makeVRadioProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var controlProps = VSelectionControl.filterProps(props);
        return createVNode(VSelectionControl, mergeProps(controlProps, {
          "class": ["v-radio", props.class],
          "style": props.style,
          "type": "radio"
        }), slots);
      });
      return {};
    }
  });
  var VRadioGroup$1 = "";
  var makeVRadioGroupProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    height: {
      type: [Number, String],
      "default": "auto"
    }
  }, makeVInputProps()), omit(makeSelectionControlGroupProps(), ["multiple"])), {}, {
    trueIcon: {
      type: IconValue,
      "default": "$radioOn"
    },
    falseIcon: {
      type: IconValue,
      "default": "$radioOff"
    },
    type: {
      type: String,
      "default": "radio"
    }
  }), "VRadioGroup");
  var VRadioGroup = genericComponent()({
    name: "VRadioGroup",
    inheritAttrs: false,
    props: makeVRadioGroupProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "radio-group-" + uid2;
      });
      var model = useProxiedModel(props, "modelValue");
      useRender(function () {
        var _filterInputAttrs11 = filterInputAttrs(attrs),
          _filterInputAttrs12 = _slicedToArray(_filterInputAttrs11, 2),
          rootAttrs = _filterInputAttrs12[0],
          controlAttrs = _filterInputAttrs12[1];
        var inputProps = VInput.filterProps(props);
        var controlProps = VSelectionControl.filterProps(props);
        var label = slots.label ? slots.label({
          label: props.label,
          props: {
            "for": id.value
          }
        }) : props.label;
        return createVNode(VInput, mergeProps({
          "class": ["v-radio-group", props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "id": id.value
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (_ref2) {
            var id2 = _ref2.id,
              messagesId = _ref2.messagesId,
              isDisabled = _ref2.isDisabled,
              isReadonly2 = _ref2.isReadonly;
            return createVNode(Fragment$1, null, [label && createVNode(VLabel, {
              "id": id2.value
            }, {
              "default": function () {
                return [label];
              }
            }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "defaultsTarget": "VRadio",
              "trueIcon": props.trueIcon,
              "falseIcon": props.falseIcon,
              "type": props.type,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value,
              "aria-labelledby": label ? id2.value : void 0,
              "multiple": false
            }, controlAttrs, {
              "modelValue": model.value,
              "onUpdate:modelValue": function ($event) {
                return model.value = $event;
              }
            }), slots)]);
          }
        }));
      });
      return {};
    }
  });
  var makeVRangeSliderProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeFocusProps()), makeVInputProps()), makeSliderProps()), {}, {
    strict: Boolean,
    modelValue: {
      type: Array,
      "default": function () {
        return [0, 0];
      }
    }
  }), "VRangeSlider");
  var VRangeSlider = genericComponent()({
    name: "VRangeSlider",
    props: makeVRangeSliderProps(),
    emits: {
      "update:focused": function (value) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      end: function (value) {
        return true;
      },
      start: function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots,
        emit2 = _ref.emit;
      var startThumbRef = ref();
      var stopThumbRef = ref();
      var inputRef = ref();
      var _useRtl19 = useRtl(),
        rtlClasses = _useRtl19.rtlClasses;
      function getActiveThumb(e) {
        if (!startThumbRef.value || !stopThumbRef.value) return;
        var startOffset = getOffset(e, startThumbRef.value.$el, props.direction);
        var stopOffset = getOffset(e, stopThumbRef.value.$el, props.direction);
        var a = Math.abs(startOffset);
        var b = Math.abs(stopOffset);
        return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;
      }
      var steps = useSteps(props);
      var model = useProxiedModel(props, "modelValue", void 0, function (arr) {
        if (!(arr == null ? void 0 : arr.length)) return [0, 0];
        return arr.map(function (value) {
          return steps.roundValue(value);
        });
      });
      var _useSlider2 = useSlider({
          props: props,
          steps: steps,
          onSliderStart: function () {
            emit2("start", model.value);
          },
          onSliderEnd: function (_ref2) {
            var _a2;
            var value = _ref2.value;
            var newValue = activeThumbRef.value === ((_a2 = startThumbRef.value) == null ? void 0 : _a2.$el) ? [value, model.value[1]] : [model.value[0], value];
            if (!props.strict && newValue[0] < newValue[1]) {
              model.value = newValue;
            }
            emit2("end", model.value);
          },
          onSliderMove: function (_ref3) {
            var _a2, _b, _c, _d;
            var value = _ref3.value;
            var _model$value = _slicedToArray(model.value, 2),
              start = _model$value[0],
              stop = _model$value[1];
            if (!props.strict && start === stop && start !== min.value) {
              activeThumbRef.value = value > start ? (_a2 = stopThumbRef.value) == null ? void 0 : _a2.$el : (_b = startThumbRef.value) == null ? void 0 : _b.$el;
              (_c = activeThumbRef.value) == null ? void 0 : _c.focus();
            }
            if (activeThumbRef.value === ((_d = startThumbRef.value) == null ? void 0 : _d.$el)) {
              model.value = [Math.min(value, stop), stop];
            } else {
              model.value = [start, Math.max(start, value)];
            }
          },
          getActiveThumb: getActiveThumb
        }),
        activeThumbRef = _useSlider2.activeThumbRef,
        hasLabels = _useSlider2.hasLabels,
        max = _useSlider2.max,
        min = _useSlider2.min,
        mousePressed = _useSlider2.mousePressed,
        onSliderMousedown = _useSlider2.onSliderMousedown,
        onSliderTouchstart = _useSlider2.onSliderTouchstart,
        position = _useSlider2.position,
        trackContainerRef = _useSlider2.trackContainerRef,
        readonly2 = _useSlider2.readonly;
      var _useFocus7 = useFocus(props),
        isFocused = _useFocus7.isFocused,
        focus2 = _useFocus7.focus,
        blur2 = _useFocus7.blur;
      var trackStart = computed(function () {
        return position(model.value[0]);
      });
      var trackStop = computed(function () {
        return position(model.value[1]);
      });
      useRender(function () {
        var inputProps = VInput.filterProps(props);
        var hasPrepend = !!(props.label || slots.label || slots.prepend);
        return createVNode(VInput, mergeProps({
          "class": ["v-slider", "v-range-slider", {
            "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
            "v-slider--focused": isFocused.value,
            "v-slider--pressed": mousePressed.value,
            "v-slider--disabled": props.disabled
          }, rtlClasses.value, props.class],
          "style": props.style,
          "ref": inputRef
        }, inputProps, {
          "focused": isFocused.value
        }), _objectSpread(_objectSpread({}, slots), {}, {
          prepend: hasPrepend ? function (slotProps) {
            var _a2, _b, _c;
            return createVNode(Fragment$1, null, [(_b = (_a2 = slots.label) == null ? void 0 : _a2.call(slots, slotProps)) != null ? _b : props.label ? createVNode(VLabel, {
              "class": "v-slider__label",
              "text": props.label
            }, null) : void 0, (_c = slots.prepend) == null ? void 0 : _c.call(slots, slotProps)]);
          } : void 0,
          "default": function (_ref4) {
            var _a2, _b;
            var id = _ref4.id,
              messagesId = _ref4.messagesId;
            return createVNode("div", {
              "class": "v-slider__container",
              "onMousedown": !readonly2.value ? onSliderMousedown : void 0,
              "onTouchstartPassive": !readonly2.value ? onSliderTouchstart : void 0
            }, [createVNode("input", {
              "id": id.value + "_start",
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value[0]
            }, null), createVNode("input", {
              "id": id.value + "_stop",
              "name": props.name || id.value,
              "disabled": !!props.disabled,
              "readonly": !!props.readonly,
              "tabindex": "-1",
              "value": model.value[1]
            }, null), createVNode(VSliderTrack, {
              "ref": trackContainerRef,
              "start": trackStart.value,
              "stop": trackStop.value
            }, {
              "tick-label": slots["tick-label"]
            }), createVNode(VSliderThumb, {
              "ref": startThumbRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused && activeThumbRef.value === ((_a2 = startThumbRef.value) == null ? void 0 : _a2.$el),
              "modelValue": model.value[0],
              "onUpdate:modelValue": function (v) {
                return model.value = [v, model.value[1]];
              },
              "onFocus": function (e) {
                var _a3, _b2, _c, _d;
                focus2();
                activeThumbRef.value = (_a3 = startThumbRef.value) == null ? void 0 : _a3.$el;
                if (model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== ((_b2 = stopThumbRef.value) == null ? void 0 : _b2.$el)) {
                  (_c = startThumbRef.value) == null ? void 0 : _c.$el.blur();
                  (_d = stopThumbRef.value) == null ? void 0 : _d.$el.focus();
                }
              },
              "onBlur": function () {
                blur2();
                activeThumbRef.value = void 0;
              },
              "min": min.value,
              "max": model.value[1],
              "position": trackStart.value,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            }), createVNode(VSliderThumb, {
              "ref": stopThumbRef,
              "aria-describedby": messagesId.value,
              "focused": isFocused && activeThumbRef.value === ((_b = stopThumbRef.value) == null ? void 0 : _b.$el),
              "modelValue": model.value[1],
              "onUpdate:modelValue": function (v) {
                return model.value = [model.value[0], v];
              },
              "onFocus": function (e) {
                var _a3, _b2, _c, _d;
                focus2();
                activeThumbRef.value = (_a3 = stopThumbRef.value) == null ? void 0 : _a3.$el;
                if (model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== ((_b2 = startThumbRef.value) == null ? void 0 : _b2.$el)) {
                  (_c = stopThumbRef.value) == null ? void 0 : _c.$el.blur();
                  (_d = startThumbRef.value) == null ? void 0 : _d.$el.focus();
                }
              },
              "onBlur": function () {
                blur2();
                activeThumbRef.value = void 0;
              },
              "min": model.value[0],
              "max": max.value,
              "position": trackStop.value,
              "ripple": props.ripple
            }, {
              "thumb-label": slots["thumb-label"]
            })]);
          }
        }));
      });
      return {};
    }
  });
  var VRating$1 = "";
  var makeVRatingProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    name: String,
    itemAriaLabel: {
      type: String,
      "default": "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
      type: IconValue,
      "default": "$ratingEmpty"
    },
    fullIcon: {
      type: IconValue,
      "default": "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      "default": 5
    },
    readonly: Boolean,
    modelValue: {
      type: [Number, String],
      "default": 0
    },
    itemLabels: Array,
    itemLabelPosition: {
      type: String,
      "default": "top",
      validator: function (v) {
        return ["top", "bottom"].includes(v);
      }
    },
    ripple: Boolean
  }, makeComponentProps()), makeDensityProps()), makeSizeProps()), makeTagProps()), makeThemeProps()), "VRating");
  var VRating = genericComponent()({
    name: "VRating",
    props: makeVRatingProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useLocale19 = useLocale(),
        t = _useLocale19.t;
      var _provideTheme28 = provideTheme(props),
        themeClasses = _provideTheme28.themeClasses;
      var rating = useProxiedModel(props, "modelValue");
      var normalizedValue = computed(function () {
        return clamp(parseFloat(rating.value), 0, +props.length);
      });
      var range = computed(function () {
        return createRange(Number(props.length), 1);
      });
      var increments = computed(function () {
        return range.value.flatMap(function (v) {
          return props.halfIncrements ? [v - 0.5, v] : [v];
        });
      });
      var hoverIndex = shallowRef(-1);
      var itemState = computed(function () {
        return increments.value.map(function (value) {
          var _a2;
          var isHovering = props.hover && hoverIndex.value > -1;
          var isFilled = normalizedValue.value >= value;
          var isHovered = hoverIndex.value >= value;
          var isFullIcon = isHovering ? isHovered : isFilled;
          var icon = isFullIcon ? props.fullIcon : props.emptyIcon;
          var activeColor = (_a2 = props.activeColor) != null ? _a2 : props.color;
          var color = isFilled || isHovered ? activeColor : props.color;
          return {
            isFilled: isFilled,
            isHovered: isHovered,
            icon: icon,
            color: color
          };
        });
      });
      var eventState = computed(function () {
        return [0].concat(_toConsumableArray(increments.value)).map(function (value) {
          function onMouseenter() {
            hoverIndex.value = value;
          }
          function onMouseleave() {
            hoverIndex.value = -1;
          }
          function onClick() {
            if (props.disabled || props.readonly) return;
            rating.value = normalizedValue.value === value && props.clearable ? 0 : value;
          }
          return {
            onMouseenter: props.hover ? onMouseenter : void 0,
            onMouseleave: props.hover ? onMouseleave : void 0,
            onClick: onClick
          };
        });
      });
      var name = computed(function () {
        var _a2;
        return (_a2 = props.name) != null ? _a2 : "v-rating-" + getUid();
      });
      function VRatingItem(_ref2) {
        var _a2, _b;
        var value = _ref2.value,
          index = _ref2.index,
          _ref2$showStar = _ref2.showStar,
          showStar = _ref2$showStar === void 0 ? true : _ref2$showStar;
        var _eventState$value = eventState.value[index + 1],
          onMouseenter = _eventState$value.onMouseenter,
          onMouseleave = _eventState$value.onMouseleave,
          onClick = _eventState$value.onClick;
        var id = name.value + "-" + String(value).replace(".", "-");
        var btnProps = {
          color: (_a2 = itemState.value[index]) == null ? void 0 : _a2.color,
          density: props.density,
          disabled: props.disabled,
          icon: (_b = itemState.value[index]) == null ? void 0 : _b.icon,
          ripple: props.ripple,
          size: props.size,
          variant: "plain"
        };
        return createVNode(Fragment$1, null, [createVNode("label", {
          "for": id,
          "class": {
            "v-rating__item--half": props.halfIncrements && value % 1 > 0,
            "v-rating__item--full": props.halfIncrements && value % 1 === 0
          },
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave,
          "onClick": onClick
        }, [createVNode("span", {
          "class": "v-rating__hidden"
        }, [t(props.itemAriaLabel, value, props.length)]), !showStar ? void 0 : slots.item ? slots.item(_objectSpread(_objectSpread({}, itemState.value[index]), {}, {
          props: btnProps,
          value: value,
          index: index,
          rating: normalizedValue.value
        })) : createVNode(VBtn, mergeProps({
          "aria-label": t(props.itemAriaLabel, value, props.length)
        }, btnProps), null)]), createVNode("input", {
          "class": "v-rating__hidden",
          "name": name.value,
          "id": id,
          "type": "radio",
          "value": value,
          "checked": normalizedValue.value === value,
          "tabindex": -1,
          "readonly": props.readonly,
          "disabled": props.disabled
        }, null)]);
      }
      function createLabel(labelProps) {
        if (slots["item-label"]) return slots["item-label"](labelProps);
        if (labelProps.label) return createVNode("span", null, [labelProps.label]);
        return createVNode("span", null, [createTextVNode("\xA0")]);
      }
      useRender(function () {
        var _a2;
        var hasLabels = !!((_a2 = props.itemLabels) == null ? void 0 : _a2.length) || slots["item-label"];
        return createVNode(props.tag, {
          "class": ["v-rating", {
            "v-rating--hover": props.hover,
            "v-rating--readonly": props.readonly
          }, themeClasses.value, props.class],
          "style": props.style
        }, {
          "default": function () {
            return [createVNode(VRatingItem, {
              "value": 0,
              "index": -1,
              "showStar": false
            }, null), range.value.map(function (value, i) {
              var _a3, _b;
              return createVNode("div", {
                "class": "v-rating__wrapper"
              }, [hasLabels && props.itemLabelPosition === "top" ? createLabel({
                value: value,
                index: i,
                label: (_a3 = props.itemLabels) == null ? void 0 : _a3[i]
              }) : void 0, createVNode("div", {
                "class": "v-rating__item"
              }, [props.halfIncrements ? createVNode(Fragment$1, null, [createVNode(VRatingItem, {
                "value": value - 0.5,
                "index": i * 2
              }, null), createVNode(VRatingItem, {
                "value": value,
                "index": i * 2 + 1
              }, null)]) : createVNode(VRatingItem, {
                "value": value,
                "index": i
              }, null)]), hasLabels && props.itemLabelPosition === "bottom" ? createLabel({
                value: value,
                index: i,
                label: (_b = props.itemLabels) == null ? void 0 : _b[i]
              }) : void 0]);
            })];
          }
        });
      });
      return {};
    }
  });
  var VSkeletonLoader$1 = "";
  var rootTypes = {
    actions: "button@2",
    article: "heading, paragraph",
    avatar: "avatar",
    button: "button",
    card: "image, heading",
    "card-avatar": "image, list-item-avatar",
    chip: "chip",
    "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
    "date-picker-options": "text, avatar@2",
    "date-picker-days": "avatar@28",
    divider: "divider",
    heading: "heading",
    image: "image",
    "list-item": "text",
    "list-item-avatar": "avatar, text",
    "list-item-two-line": "sentences",
    "list-item-avatar-two-line": "avatar, sentences",
    "list-item-three-line": "paragraph",
    "list-item-avatar-three-line": "avatar, paragraph",
    ossein: "ossein",
    paragraph: "text@3",
    sentences: "text@2",
    subtitle: "text",
    table: "table-heading, table-thead, table-tbody, table-tfoot",
    "table-heading": "chip, text",
    "table-thead": "heading@6",
    "table-tbody": "table-row-divider@6",
    "table-row-divider": "table-row, divider",
    "table-row": "text@6",
    "table-tfoot": "text@2, avatar@2",
    text: "text"
  };
  function genBone(type) {
    var children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return createVNode("div", {
      "class": ["v-skeleton-loader__bone", "v-skeleton-loader__" + type]
    }, [children]);
  }
  function genBones(bone) {
    var _bone$split = bone.split("@"),
      _bone$split2 = _slicedToArray(_bone$split, 2),
      type = _bone$split2[0],
      length = _bone$split2[1];
    return Array.from({
      length: length
    }).map(function () {
      return genStructure(type);
    });
  }
  function genStructure(type) {
    var children = [];
    if (!type) return children;
    var bone = rootTypes[type];
    if (type === bone) ;else if (type.includes(",")) return mapBones(type);else if (type.includes("@")) return genBones(type);else if (bone.includes(",")) children = mapBones(bone);else if (bone.includes("@")) children = genBones(bone);else if (bone) children.push(genStructure(bone));
    return [genBone(type, children)];
  }
  function mapBones(bones) {
    return bones.replace(/\s/g, "").split(",").map(genStructure);
  }
  var makeVSkeletonLoaderProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    boilerplate: Boolean,
    color: String,
    loading: Boolean,
    loadingText: {
      type: String,
      "default": "$vuetify.loading"
    },
    type: {
      type: [String, Array],
      "default": "ossein"
    }
  }, makeDimensionProps()), makeElevationProps()), makeThemeProps()), "VSkeletonLoader");
  var VSkeletonLoader = genericComponent()({
    name: "VSkeletonLoader",
    props: makeVSkeletonLoaderProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useBackgroundColor24 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor24.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor24.backgroundColorStyles;
      var _useDimension20 = useDimension(props),
        dimensionStyles = _useDimension20.dimensionStyles;
      var _useElevation16 = useElevation(props),
        elevationClasses = _useElevation16.elevationClasses;
      var _provideTheme29 = provideTheme(props),
        themeClasses = _provideTheme29.themeClasses;
      var _useLocale20 = useLocale(),
        t = _useLocale20.t;
      var items = computed(function () {
        return genStructure(wrapInArray(props.type).join(","));
      });
      useRender(function () {
        var _a2;
        var isLoading = !slots.default || props.loading;
        var loadingProps = props.boilerplate || !isLoading ? {} : {
          ariaLive: "polite",
          ariaLabel: t(props.loadingText),
          role: "alert"
        };
        return createVNode("div", mergeProps({
          "class": ["v-skeleton-loader", {
            "v-skeleton-loader--boilerplate": props.boilerplate
          }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value],
          "style": [backgroundColorStyles.value, isLoading ? dimensionStyles.value : {}]
        }, loadingProps), [isLoading ? items.value : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var VSlideGroupItem = genericComponent()({
    name: "VSlideGroupItem",
    props: makeGroupItemProps(),
    emits: {
      "group:selected": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var slideGroupItem = useGroupItem(props, VSlideGroupSymbol);
      return function () {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          isSelected: slideGroupItem.isSelected.value,
          select: slideGroupItem.select,
          toggle: slideGroupItem.toggle,
          selectedClass: slideGroupItem.selectedClass.value
        });
      };
    }
  });
  var VSnackbar$1 = "";
  function useCountdown(milliseconds) {
    var time = shallowRef(milliseconds());
    var timer = -1;
    function clear() {
      clearInterval(timer);
    }
    function reset() {
      clear();
      nextTick(function () {
        return time.value = milliseconds();
      });
    }
    function start(el) {
      var style2 = el ? getComputedStyle(el) : {
        transitionDuration: 0.2
      };
      var interval = parseFloat(style2.transitionDuration) * 1e3 || 200;
      clear();
      if (time.value <= 0) return;
      var startTime = performance.now();
      timer = window.setInterval(function () {
        var elapsed = performance.now() - startTime + interval;
        time.value = Math.max(milliseconds() - elapsed, 0);
        if (time.value <= 0) clear();
      }, interval);
    }
    onScopeDispose(clear);
    return {
      clear: clear,
      time: time,
      start: start,
      reset: reset
    };
  }
  var makeVSnackbarProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    multiLine: Boolean,
    text: String,
    timer: [Boolean, String],
    timeout: {
      type: [Number, String],
      "default": 5e3
    },
    vertical: Boolean
  }, makeLocationProps({
    location: "bottom"
  })), makePositionProps()), makeRoundedProps()), makeVariantProps()), makeThemeProps()), omit(makeVOverlayProps({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])), "VSnackbar");
  var VSnackbar = genericComponent()({
    name: "VSnackbar",
    props: makeVSnackbarProps(),
    emits: {
      "update:modelValue": function (v) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var isActive2 = useProxiedModel(props, "modelValue");
      var _usePosition6 = usePosition(props),
        positionClasses = _usePosition6.positionClasses;
      var _useScopeId5 = useScopeId(),
        scopeId = _useScopeId5.scopeId;
      var _provideTheme30 = provideTheme(props),
        themeClasses = _provideTheme30.themeClasses;
      var _useVariant7 = useVariant(props),
        colorClasses = _useVariant7.colorClasses,
        colorStyles = _useVariant7.colorStyles,
        variantClasses = _useVariant7.variantClasses;
      var _useRounded22 = useRounded(props),
        roundedClasses = _useRounded22.roundedClasses;
      var countdown = useCountdown(function () {
        return Number(props.timeout);
      });
      var overlay = ref();
      var timerRef = ref();
      var isHovering = shallowRef(false);
      var startY = shallowRef(0);
      var mainStyles = ref();
      var hasLayout = inject$1(VuetifyLayoutKey, void 0);
      useToggleScope(function () {
        return !!hasLayout;
      }, function () {
        var layout = useLayout();
        watchEffect(function () {
          mainStyles.value = layout.mainStyles.value;
        });
      });
      watch(isActive2, startTimeout);
      watch(function () {
        return props.timeout;
      }, startTimeout);
      onMounted(function () {
        if (isActive2.value) startTimeout();
      });
      var activeTimeout = -1;
      function startTimeout() {
        countdown.reset();
        window.clearTimeout(activeTimeout);
        var timeout = Number(props.timeout);
        if (!isActive2.value || timeout === -1) return;
        var element = refElement(timerRef.value);
        countdown.start(element);
        activeTimeout = window.setTimeout(function () {
          isActive2.value = false;
        }, timeout);
      }
      function clearTimeout2() {
        countdown.reset();
        window.clearTimeout(activeTimeout);
      }
      function onPointerenter() {
        isHovering.value = true;
        clearTimeout2();
      }
      function onPointerleave() {
        isHovering.value = false;
        startTimeout();
      }
      function onTouchstart(event) {
        startY.value = event.touches[0].clientY;
      }
      function onTouchend(event) {
        if (Math.abs(startY.value - event.changedTouches[0].clientY) > 50) {
          isActive2.value = false;
        }
      }
      function onAfterLeave() {
        if (isHovering.value) onPointerleave();
      }
      var locationClasses = computed(function () {
        return props.location.split(" ").reduce(function (acc, loc) {
          acc["v-snackbar--" + loc] = true;
          return acc;
        }, {});
      });
      useRender(function () {
        var overlayProps = VOverlay.filterProps(props);
        var hasContent = !!(slots.default || slots.text || props.text);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-snackbar", {
            "v-snackbar--active": isActive2.value,
            "v-snackbar--multi-line": props.multiLine && !props.vertical,
            "v-snackbar--timer": !!props.timer,
            "v-snackbar--vertical": props.vertical
          }, locationClasses.value, positionClasses.value, props.class],
          "style": [mainStyles.value, props.style]
        }, overlayProps, {
          "modelValue": isActive2.value,
          "onUpdate:modelValue": function ($event) {
            return isActive2.value = $event;
          },
          "contentProps": mergeProps({
            "class": ["v-snackbar__wrapper", themeClasses.value, colorClasses.value, roundedClasses.value, variantClasses.value],
            style: [colorStyles.value],
            onPointerenter: onPointerenter,
            onPointerleave: onPointerleave
          }, overlayProps.contentProps),
          "persistent": true,
          "noClickAnimation": true,
          "scrim": false,
          "scrollStrategy": "none",
          "_disableGlobalStack": true,
          "onTouchstartPassive": onTouchstart,
          "onTouchend": onTouchend,
          "onAfterLeave": onAfterLeave
        }, scopeId), {
          "default": function () {
            var _a2, _b, _c;
            return [genOverlays(false, "v-snackbar"), props.timer && !isHovering.value && createVNode("div", {
              "key": "timer",
              "class": "v-snackbar__timer"
            }, [createVNode(VProgressLinear, {
              "ref": timerRef,
              "color": typeof props.timer === "string" ? props.timer : "info",
              "max": props.timeout,
              "model-value": countdown.time.value
            }, null)]), hasContent && createVNode("div", {
              "key": "content",
              "class": "v-snackbar__content",
              "role": "status",
              "aria-live": "polite"
            }, [(_b = (_a2 = slots.text) == null ? void 0 : _a2.call(slots)) != null ? _b : props.text, (_c = slots.default) == null ? void 0 : _c.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  variant: "text",
                  ripple: false,
                  slim: true
                }
              }
            }, {
              "default": function () {
                return [createVNode("div", {
                  "class": "v-snackbar__actions"
                }, [slots.actions({
                  isActive: isActive2
                })])];
              }
            })];
          },
          activator: slots.activator
        });
      });
      return forwardRefs({}, overlay);
    }
  });
  var makeLineProps = propsFactory({
    autoDraw: Boolean,
    autoDrawDuration: [Number, String],
    autoDrawEasing: {
      type: String,
      "default": "ease"
    },
    color: String,
    gradient: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    gradientDirection: {
      type: String,
      validator: function (val) {
        return ["top", "bottom", "left", "right"].includes(val);
      },
      "default": "top"
    },
    height: {
      type: [String, Number],
      "default": 75
    },
    labels: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    labelSize: {
      type: [Number, String],
      "default": 7
    },
    lineWidth: {
      type: [String, Number],
      "default": 4
    },
    id: String,
    itemValue: {
      type: String,
      "default": "value"
    },
    modelValue: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    min: [String, Number],
    max: [String, Number],
    padding: {
      type: [String, Number],
      "default": 8
    },
    showLabels: Boolean,
    smooth: Boolean,
    width: {
      type: [Number, String],
      "default": 300
    }
  }, "Line");
  var makeVBarlineProps = propsFactory(_objectSpread({
    autoLineWidth: Boolean
  }, makeLineProps()), "VBarline");
  var VBarline = genericComponent()({
    name: "VBarline",
    props: makeVBarlineProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "barline-" + uid2;
      });
      var autoDrawDuration = computed(function () {
        return Number(props.autoDrawDuration) || 500;
      });
      var hasLabels = computed(function () {
        return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
      });
      var lineWidth = computed(function () {
        return parseFloat(props.lineWidth) || 4;
      });
      var totalWidth = computed(function () {
        return Math.max(props.modelValue.length * lineWidth.value, Number(props.width));
      });
      var boundary = computed(function () {
        return {
          minX: 0,
          maxX: totalWidth.value,
          minY: 0,
          maxY: parseInt(props.height, 10)
        };
      });
      var items = computed(function () {
        return props.modelValue.map(function (item) {
          return getPropertyFromItem(item, props.itemValue, item);
        });
      });
      function genBars(values, boundary2) {
        var minX = boundary2.minX,
          maxX = boundary2.maxX,
          minY = boundary2.minY,
          maxY = boundary2.maxY;
        var totalValues = values.length;
        var maxValue = props.max != null ? Number(props.max) : Math.max.apply(Math, _toConsumableArray(values));
        var minValue = props.min != null ? Number(props.min) : Math.min.apply(Math, _toConsumableArray(values));
        if (minValue > 0 && props.min == null) minValue = 0;
        if (maxValue < 0 && props.max == null) maxValue = 0;
        var gridX = maxX / totalValues;
        var gridY = (maxY - minY) / (maxValue - minValue || 1);
        var horizonY = maxY - Math.abs(minValue * gridY);
        return values.map(function (value, index) {
          var height = Math.abs(gridY * value);
          return {
            x: minX + index * gridX,
            y: horizonY - height + +(value < 0) * height,
            height: height,
            value: value
          };
        });
      }
      var parsedLabels = computed(function () {
        var labels = [];
        var points = genBars(items.value, boundary.value);
        var len = points.length;
        for (var _i287 = 0; labels.length < len; _i287++) {
          var item = points[_i287];
          var value = props.labels[_i287];
          if (!value) {
            value = _typeof(item) === "object" ? item.value : item;
          }
          labels.push({
            x: item.x,
            value: String(value)
          });
        }
        return labels;
      });
      var bars = computed(function () {
        return genBars(items.value, boundary.value);
      });
      var offsetX = computed(function () {
        return (Math.abs(bars.value[0].x - bars.value[1].x) - lineWidth.value) / 2;
      });
      useRender(function () {
        var gradientData = !props.gradient.slice().length ? [""] : props.gradient.slice().reverse();
        return createVNode("svg", {
          "display": "block"
        }, [createVNode("defs", null, [createVNode("linearGradient", {
          "id": id.value,
          "gradientUnits": "userSpaceOnUse",
          "x1": props.gradientDirection === "left" ? "100%" : "0",
          "y1": props.gradientDirection === "top" ? "100%" : "0",
          "x2": props.gradientDirection === "right" ? "100%" : "0",
          "y2": props.gradientDirection === "bottom" ? "100%" : "0"
        }, [gradientData.map(function (color, index) {
          return createVNode("stop", {
            "offset": index / Math.max(gradientData.length - 1, 1),
            "stop-color": color || "currentColor"
          }, null);
        })])]), createVNode("clipPath", {
          "id": id.value + "-clip"
        }, [bars.value.map(function (item) {
          return createVNode("rect", {
            "x": item.x + offsetX.value,
            "y": item.y,
            "width": lineWidth.value,
            "height": item.height,
            "rx": typeof props.smooth === "number" ? props.smooth : props.smooth ? 2 : 0,
            "ry": typeof props.smooth === "number" ? props.smooth : props.smooth ? 2 : 0
          }, [props.autoDraw && createVNode(Fragment$1, null, [createVNode("animate", {
            "attributeName": "y",
            "from": item.y + item.height,
            "to": item.y,
            "dur": autoDrawDuration.value + "ms",
            "fill": "freeze"
          }, null), createVNode("animate", {
            "attributeName": "height",
            "from": "0",
            "to": item.height,
            "dur": autoDrawDuration.value + "ms",
            "fill": "freeze"
          }, null)])]);
        })]), hasLabels.value && createVNode("g", {
          "key": "labels",
          "style": {
            textAnchor: "middle",
            dominantBaseline: "mathematical",
            fill: "currentColor"
          }
        }, [parsedLabels.value.map(function (item, i) {
          var _a2, _b;
          return createVNode("text", {
            "x": item.x + offsetX.value + lineWidth.value / 2,
            "y": parseInt(props.height, 10) - 2 + (parseInt(props.labelSize, 10) || 7 * 0.75),
            "font-size": Number(props.labelSize) || 7
          }, [(_b = (_a2 = slots.label) == null ? void 0 : _a2.call(slots, {
            index: i,
            value: item.value
          })) != null ? _b : item.value]);
        })]), createVNode("g", {
          "clip-path": "url(#" + id.value + "-clip)",
          "fill": "url(#" + id.value + ")"
        }, [createVNode("rect", {
          "x": 0,
          "y": 0,
          "width": Math.max(props.modelValue.length * lineWidth.value, Number(props.width)),
          "height": props.height
        }, null)])]);
      });
    }
  });
  function genPath(points, radius) {
    var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
    if (points.length === 0) return "";
    var start = points.shift();
    var end = points[points.length - 1];
    return (fill ? "M" + start.x + " " + (height - start.x + 2) + " L" + start.x + " " + start.y : "M" + start.x + " " + start.y) + points.map(function (point, index) {
      var next = points[index + 1];
      var prev = points[index - 1] || start;
      var isCollinear = next && checkCollinear(next, point, prev);
      if (!next || isCollinear) {
        return "L" + point.x + " " + point.y;
      }
      var threshold = Math.min(getDistance(prev, point), getDistance(next, point));
      var isTooCloseForRadius = threshold / 2 < radius;
      var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
      var before = moveTo(prev, point, radiusForPoint);
      var after = moveTo(next, point, radiusForPoint);
      return "L" + before.x + " " + before.y + "S" + point.x + " " + point.y + " " + after.x + " " + after.y;
    }).join("") + (fill ? "L" + end.x + " " + (height - start.x + 2) + " Z" : "");
  }
  function int(value) {
    return parseInt(value, 10);
  }
  function checkCollinear(p0, p1, p2) {
    return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y);
  }
  function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  }
  function moveTo(to, from2, radius) {
    var vector = {
      x: to.x - from2.x,
      y: to.y - from2.y
    };
    var length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    var unitVector = {
      x: vector.x / length,
      y: vector.y / length
    };
    return {
      x: from2.x + unitVector.x * radius,
      y: from2.y + unitVector.y * radius
    };
  }
  var makeVTrendlineProps = propsFactory(_objectSpread({
    fill: Boolean
  }, makeLineProps()), "VTrendline");
  var VTrendline = genericComponent()({
    name: "VTrendline",
    props: makeVTrendlineProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "trendline-" + uid2;
      });
      var autoDrawDuration = computed(function () {
        return Number(props.autoDrawDuration) || (props.fill ? 500 : 2e3);
      });
      var lastLength = ref(0);
      var path = ref(null);
      function genPoints(values, boundary2) {
        var minX = boundary2.minX,
          maxX = boundary2.maxX,
          minY = boundary2.minY,
          maxY = boundary2.maxY;
        var totalValues = values.length;
        var maxValue = props.max != null ? Number(props.max) : Math.max.apply(Math, _toConsumableArray(values));
        var minValue = props.min != null ? Number(props.min) : Math.min.apply(Math, _toConsumableArray(values));
        var gridX = (maxX - minX) / (totalValues - 1);
        var gridY = (maxY - minY) / (maxValue - minValue || 1);
        return values.map(function (value, index) {
          return {
            x: minX + index * gridX,
            y: maxY - (value - minValue) * gridY,
            value: value
          };
        });
      }
      var hasLabels = computed(function () {
        return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
      });
      var lineWidth = computed(function () {
        return parseFloat(props.lineWidth) || 4;
      });
      var totalWidth = computed(function () {
        return Number(props.width);
      });
      var boundary = computed(function () {
        var padding = Number(props.padding);
        return {
          minX: padding,
          maxX: totalWidth.value - padding,
          minY: padding,
          maxY: parseInt(props.height, 10) - padding
        };
      });
      var items = computed(function () {
        return props.modelValue.map(function (item) {
          return getPropertyFromItem(item, props.itemValue, item);
        });
      });
      var parsedLabels = computed(function () {
        var labels = [];
        var points = genPoints(items.value, boundary.value);
        var len = points.length;
        for (var _i288 = 0; labels.length < len; _i288++) {
          var item = points[_i288];
          var value = props.labels[_i288];
          if (!value) {
            value = _typeof(item) === "object" ? item.value : item;
          }
          labels.push({
            x: item.x,
            value: String(value)
          });
        }
        return labels;
      });
      watch(function () {
        return props.modelValue;
      }, function _callee10() {
        var pathRef, length;
        return _regeneratorRuntime.async(function _callee10$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return _regeneratorRuntime.awrap(nextTick());
            case 2:
              if (!(!props.autoDraw || !path.value)) {
                _context21.next = 4;
                break;
              }
              return _context21.abrupt("return");
            case 4:
              pathRef = path.value;
              length = pathRef.getTotalLength();
              if (!props.fill) {
                pathRef.style.strokeDasharray = "" + length;
                pathRef.style.strokeDashoffset = "" + length;
                pathRef.getBoundingClientRect();
                pathRef.style.transition = "stroke-dashoffset " + autoDrawDuration.value + "ms " + props.autoDrawEasing;
                pathRef.style.strokeDashoffset = "0";
              } else {
                pathRef.style.transformOrigin = "bottom center";
                pathRef.style.transition = "none";
                pathRef.style.transform = "scaleY(0)";
                pathRef.getBoundingClientRect();
                pathRef.style.transition = "transform " + autoDrawDuration.value + "ms " + props.autoDrawEasing;
                pathRef.style.transform = "scaleY(1)";
              }
              lastLength.value = length;
            case 8:
            case "end":
              return _context21.stop();
          }
        }, null, null, null, Promise);
      }, {
        immediate: true
      });
      function genPath$1(fill) {
        return genPath(genPoints(items.value, boundary.value), props.smooth ? 8 : Number(props.smooth), fill, parseInt(props.height, 10));
      }
      useRender(function () {
        var _a2, _b, _c;
        var gradientData = !props.gradient.slice().length ? [""] : props.gradient.slice().reverse();
        return createVNode("svg", {
          "display": "block",
          "stroke-width": (_a2 = parseFloat(props.lineWidth)) != null ? _a2 : 4
        }, [createVNode("defs", null, [createVNode("linearGradient", {
          "id": id.value,
          "gradientUnits": "userSpaceOnUse",
          "x1": props.gradientDirection === "left" ? "100%" : "0",
          "y1": props.gradientDirection === "top" ? "100%" : "0",
          "x2": props.gradientDirection === "right" ? "100%" : "0",
          "y2": props.gradientDirection === "bottom" ? "100%" : "0"
        }, [gradientData.map(function (color, index) {
          return createVNode("stop", {
            "offset": index / Math.max(gradientData.length - 1, 1),
            "stop-color": color || "currentColor"
          }, null);
        })])]), hasLabels.value && createVNode("g", {
          "key": "labels",
          "style": {
            textAnchor: "middle",
            dominantBaseline: "mathematical",
            fill: "currentColor"
          }
        }, [parsedLabels.value.map(function (item, i) {
          var _a3, _b2;
          return createVNode("text", {
            "x": item.x + lineWidth.value / 2 + lineWidth.value / 2,
            "y": parseInt(props.height, 10) - 4 + (parseInt(props.labelSize, 10) || 7 * 0.75),
            "font-size": Number(props.labelSize) || 7
          }, [(_b2 = (_a3 = slots.label) == null ? void 0 : _a3.call(slots, {
            index: i,
            value: item.value
          })) != null ? _b2 : item.value]);
        })]), createVNode("path", {
          "ref": path,
          "d": genPath$1(props.fill),
          "fill": props.fill ? "url(#" + id.value + ")" : "none",
          "stroke": props.fill ? "none" : "url(#" + id.value + ")"
        }, null), props.fill && createVNode("path", {
          "d": genPath$1(false),
          "fill": "none",
          "stroke": (_c = props.color) != null ? _c : (_b = props.gradient) == null ? void 0 : _b[0]
        }, null)]);
      });
    }
  });
  var makeVSparklineProps = propsFactory(_objectSpread(_objectSpread({
    type: {
      type: String,
      "default": "trend"
    }
  }, makeVBarlineProps()), makeVTrendlineProps()), "VSparkline");
  var VSparkline = genericComponent()({
    name: "VSparkline",
    props: makeVSparklineProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useTextColor16 = useTextColor(toRef(props, "color")),
        textColorClasses = _useTextColor16.textColorClasses,
        textColorStyles = _useTextColor16.textColorStyles;
      var hasLabels = computed(function () {
        return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
      });
      var totalHeight = computed(function () {
        var height = parseInt(props.height, 10);
        if (hasLabels.value) height += parseInt(props.labelSize, 10) * 1.5;
        return height;
      });
      useRender(function () {
        var Tag = props.type === "trend" ? VTrendline : VBarline;
        var lineProps = props.type === "trend" ? VTrendline.filterProps(props) : VBarline.filterProps(props);
        return createVNode(Tag, mergeProps({
          "key": props.type,
          "class": textColorClasses.value,
          "style": textColorStyles.value,
          "viewBox": "0 0 " + props.width + " " + parseInt(totalHeight.value, 10)
        }, lineProps), slots);
      });
    }
  });
  var VSpeedDial$1 = "";
  var makeVSpeedDialProps = propsFactory(_objectSpread(_objectSpread({}, makeComponentProps()), makeVMenuProps({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })), "VSpeedDial");
  var VSpeedDial = genericComponent()({
    name: "VSpeedDial",
    props: makeVSpeedDialProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var menuRef = ref();
      var location2 = computed(function () {
        var _a2, _b;
        var _ref292 = (_b = (_a2 = props.location) == null ? void 0 : _a2.split(" ")) != null ? _b : [],
          _ref293 = _slicedToArray(_ref292, 2),
          y = _ref293[0],
          _ref293$ = _ref293[1],
          x = _ref293$ === void 0 ? "center" : _ref293$;
        return y + " " + x;
      });
      var locationClasses = computed(function () {
        var _ref294;
        return _ref294 = {}, _ref294["v-speed-dial__content--" + location2.value.replace(" ", "-")] = true, _ref294;
      });
      useRender(function () {
        var menuProps = VMenu.filterProps(props);
        return createVNode(VMenu, mergeProps(menuProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": props.class,
          "style": props.style,
          "contentClass": ["v-speed-dial__content", locationClasses.value, props.contentClass],
          "location": location2.value,
          "ref": menuRef,
          "transition": "fade-transition"
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (slotProps) {
            return createVNode(VDefaultsProvider, {
              "defaults": {
                VBtn: {
                  size: "small"
                }
              }
            }, {
              "default": function () {
                return [createVNode(MaybeTransition, {
                  "appear": true,
                  "group": true,
                  "transition": props.transition
                }, {
                  "default": function () {
                    var _a2;
                    return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, slotProps)];
                  }
                })];
              }
            });
          }
        }));
      });
      return {};
    }
  });
  var VStepper$1 = "";
  var VStepperSymbol = Symbol.for("vuetify:v-stepper");
  var makeVStepperActionsProps = propsFactory({
    color: String,
    disabled: {
      type: [Boolean, String],
      "default": false
    },
    prevText: {
      type: String,
      "default": "$vuetify.stepper.prev"
    },
    nextText: {
      type: String,
      "default": "$vuetify.stepper.next"
    }
  }, "VStepperActions");
  var VStepperActions = genericComponent()({
    name: "VStepperActions",
    props: makeVStepperActionsProps(),
    emits: {
      "click:prev": function () {
        return true;
      },
      "click:next": function () {
        return true;
      }
    },
    setup: function (props, _ref) {
      var emit2 = _ref.emit,
        slots = _ref.slots;
      var _useLocale21 = useLocale(),
        t = _useLocale21.t;
      function onClickPrev() {
        emit2("click:prev");
      }
      function onClickNext() {
        emit2("click:next");
      }
      useRender(function () {
        var prevSlotProps = {
          onClick: onClickPrev
        };
        var nextSlotProps = {
          onClick: onClickNext
        };
        return createVNode("div", {
          "class": "v-stepper-actions"
        }, [createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              disabled: ["prev", true].includes(props.disabled),
              text: t(props.prevText),
              variant: "text"
            }
          }
        }, {
          "default": function () {
            var _a2, _b;
            return [(_b = (_a2 = slots.prev) == null ? void 0 : _a2.call(slots, {
              props: prevSlotProps
            })) != null ? _b : createVNode(VBtn, prevSlotProps, null)];
          }
        }), createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              color: props.color,
              disabled: ["next", true].includes(props.disabled),
              text: t(props.nextText),
              variant: "tonal"
            }
          }
        }, {
          "default": function () {
            var _a2, _b;
            return [(_b = (_a2 = slots.next) == null ? void 0 : _a2.call(slots, {
              props: nextSlotProps
            })) != null ? _b : createVNode(VBtn, nextSlotProps, null)];
          }
        })]);
      });
      return {};
    }
  });
  var VStepperHeader = createSimpleFunctional("v-stepper-header");
  var VStepperItem$1 = "";
  var makeStepperItemProps = propsFactory({
    color: String,
    title: String,
    subtitle: String,
    complete: Boolean,
    completeIcon: {
      type: String,
      "default": "$complete"
    },
    editable: Boolean,
    editIcon: {
      type: String,
      "default": "$edit"
    },
    error: Boolean,
    errorIcon: {
      type: String,
      "default": "$error"
    },
    icon: String,
    ripple: {
      type: [Boolean, Object],
      "default": true
    },
    rules: {
      type: Array,
      "default": function () {
        return [];
      }
    }
  }, "StepperItem");
  var makeVStepperItemProps = propsFactory(_objectSpread(_objectSpread({}, makeStepperItemProps()), makeGroupItemProps()), "VStepperItem");
  var VStepperItem = genericComponent()({
    name: "VStepperItem",
    directives: {
      Ripple: Ripple
    },
    props: makeVStepperItemProps(),
    emits: {
      "group:selected": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var group = useGroupItem(props, VStepperSymbol, true);
      var step = computed(function () {
        var _a2;
        return (_a2 = group == null ? void 0 : group.value.value) != null ? _a2 : props.value;
      });
      var isValid2 = computed(function () {
        return props.rules.every(function (handler) {
          return handler() === true;
        });
      });
      var isClickable = computed(function () {
        return !props.disabled && props.editable;
      });
      var canEdit = computed(function () {
        return !props.disabled && props.editable;
      });
      var hasError = computed(function () {
        return props.error || !isValid2.value;
      });
      var hasCompleted = computed(function () {
        return props.complete || props.rules.length > 0 && isValid2.value;
      });
      var icon = computed(function () {
        if (hasError.value) return props.errorIcon;
        if (hasCompleted.value) return props.completeIcon;
        if (group.isSelected.value && props.editable) return props.editIcon;
        return props.icon;
      });
      var slotProps = computed(function () {
        return {
          canEdit: canEdit.value,
          hasError: hasError.value,
          hasCompleted: hasCompleted.value,
          title: props.title,
          subtitle: props.subtitle,
          step: step.value,
          value: props.value
        };
      });
      useRender(function () {
        var _a2, _b, _c, _d, _e;
        var hasColor = (!group || group.isSelected.value || hasCompleted.value || canEdit.value) && !hasError.value && !props.disabled;
        var hasTitle = !!(props.title != null || slots.title);
        var hasSubtitle = !!(props.subtitle != null || slots.subtitle);
        function onClick() {
          group == null ? void 0 : group.toggle();
        }
        return withDirectives(createVNode("button", {
          "class": ["v-stepper-item", {
            "v-stepper-item--complete": hasCompleted.value,
            "v-stepper-item--disabled": props.disabled,
            "v-stepper-item--error": hasError.value
          }, group == null ? void 0 : group.selectedClass.value],
          "disabled": !props.editable,
          "onClick": onClick
        }, [isClickable.value && genOverlays(true, "v-stepper-item"), createVNode(VAvatar, {
          "key": "stepper-avatar",
          "class": "v-stepper-item__avatar",
          "color": hasColor ? props.color : void 0,
          "size": 24
        }, {
          "default": function () {
            var _a3, _b2;
            return [(_b2 = (_a3 = slots.icon) == null ? void 0 : _a3.call(slots, slotProps.value)) != null ? _b2 : icon.value ? createVNode(VIcon, {
              "icon": icon.value
            }, null) : step.value];
          }
        }), createVNode("div", {
          "class": "v-stepper-item__content"
        }, [hasTitle && createVNode("div", {
          "key": "title",
          "class": "v-stepper-item__title"
        }, [(_b = (_a2 = slots.title) == null ? void 0 : _a2.call(slots, slotProps.value)) != null ? _b : props.title]), hasSubtitle && createVNode("div", {
          "key": "subtitle",
          "class": "v-stepper-item__subtitle"
        }, [(_d = (_c = slots.subtitle) == null ? void 0 : _c.call(slots, slotProps.value)) != null ? _d : props.subtitle]), (_e = slots.default) == null ? void 0 : _e.call(slots, slotProps.value)])]), [[resolveDirective("ripple"), props.ripple && props.editable, null]]);
      });
      return {};
    }
  });
  var makeVStepperWindowProps = propsFactory(_objectSpread({}, omit(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])), "VStepperWindow");
  var VStepperWindow = genericComponent()({
    name: "VStepperWindow",
    props: makeVStepperWindowProps(),
    emits: {
      "update:modelValue": function (v) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var group = inject$1(VStepperSymbol, null);
      var _model = useProxiedModel(props, "modelValue");
      var model = computed({
        get: function () {
          var _a2;
          if (_model.value != null || !group) return _model.value;
          return (_a2 = group.items.value.find(function (item) {
            return group.selected.value.includes(item.id);
          })) == null ? void 0 : _a2.value;
        },
        set: function (val) {
          _model.value = val;
        }
      });
      useRender(function () {
        var windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "_as": "VStepperWindow"
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-stepper-window", props.class],
          "style": props.style,
          "mandatory": false,
          "touch": false
        }), slots);
      });
      return {};
    }
  });
  var makeVStepperWindowItemProps = propsFactory(_objectSpread({}, makeVWindowItemProps()), "VStepperWindowItem");
  var VStepperWindowItem = genericComponent()({
    name: "VStepperWindowItem",
    props: makeVStepperWindowItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "_as": "VStepperWindowItem"
        }, windowItemProps, {
          "class": ["v-stepper-window-item", props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });
  var makeStepperProps = propsFactory(_objectSpread({
    altLabels: Boolean,
    bgColor: String,
    completeIcon: String,
    editIcon: String,
    editable: Boolean,
    errorIcon: String,
    hideActions: Boolean,
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    itemTitle: {
      type: String,
      "default": "title"
    },
    itemValue: {
      type: String,
      "default": "value"
    },
    nonLinear: Boolean,
    flat: Boolean
  }, makeDisplayProps()), "Stepper");
  var makeVStepperProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, makeStepperProps()), makeGroupProps({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  })), makeVSheetProps()), only(makeVStepperActionsProps(), ["prevText", "nextText"])), "VStepper");
  var VStepper = genericComponent()({
    name: "VStepper",
    props: makeVStepperProps(),
    emits: {
      "update:modelValue": function (v) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useGroup5 = useGroup(props, VStepperSymbol),
        _items = _useGroup5.items,
        next = _useGroup5.next,
        prev = _useGroup5.prev,
        selected = _useGroup5.selected;
      var _useDisplay11 = useDisplay(props),
        displayClasses = _useDisplay11.displayClasses,
        mobile = _useDisplay11.mobile;
      var _toRefs5 = toRefs(props),
        completeIcon = _toRefs5.completeIcon,
        editIcon = _toRefs5.editIcon,
        errorIcon = _toRefs5.errorIcon,
        color = _toRefs5.color,
        editable = _toRefs5.editable,
        prevText = _toRefs5.prevText,
        nextText = _toRefs5.nextText;
      var items = computed(function () {
        return props.items.map(function (item, index) {
          var title = getPropertyFromItem(item, props.itemTitle, item);
          var value = getPropertyFromItem(item, props.itemValue, index + 1);
          return {
            title: title,
            value: value,
            raw: item
          };
        });
      });
      var activeIndex = computed(function () {
        return _items.value.findIndex(function (item) {
          return selected.value.includes(item.id);
        });
      });
      var disabled = computed(function () {
        if (props.disabled) return props.disabled;
        if (activeIndex.value === 0) return "prev";
        if (activeIndex.value === _items.value.length - 1) return "next";
        return false;
      });
      provideDefaults({
        VStepperItem: {
          editable: editable,
          errorIcon: errorIcon,
          completeIcon: completeIcon,
          editIcon: editIcon,
          prevText: prevText,
          nextText: nextText
        },
        VStepperActions: {
          color: color,
          disabled: disabled,
          prevText: prevText,
          nextText: nextText
        }
      });
      useRender(function () {
        var sheetProps = VSheet.filterProps(props);
        var hasHeader = !!(slots.header || props.items.length);
        var hasWindow = props.items.length > 0;
        var hasActions = !props.hideActions && !!(hasWindow || slots.actions);
        return createVNode(VSheet, mergeProps(sheetProps, {
          "color": props.bgColor,
          "class": ["v-stepper", {
            "v-stepper--alt-labels": props.altLabels,
            "v-stepper--flat": props.flat,
            "v-stepper--non-linear": props.nonLinear,
            "v-stepper--mobile": mobile.value
          }, displayClasses.value, props.class],
          "style": props.style
        }), {
          "default": function () {
            var _a2, _b, _c;
            return [hasHeader && createVNode(VStepperHeader, {
              "key": "stepper-header"
            }, {
              "default": function () {
                return [items.value.map(function (_ref2, index) {
                  var _a3;
                  var raw = _ref2.raw,
                    item = _objectWithoutProperties(_ref2, _excluded19);
                  return createVNode(Fragment$1, null, [!!index && createVNode(VDivider, null, null), createVNode(VStepperItem, item, {
                    "default": (_a3 = slots["header-item." + item.value]) != null ? _a3 : slots.header,
                    icon: slots.icon,
                    title: slots.title,
                    subtitle: slots.subtitle
                  })]);
                })];
              }
            }), hasWindow && createVNode(VStepperWindow, {
              "key": "stepper-window"
            }, {
              "default": function () {
                return [items.value.map(function (item) {
                  return createVNode(VStepperWindowItem, {
                    "value": item.value
                  }, {
                    "default": function () {
                      var _a3, _b2, _c2;
                      return (_c2 = (_a3 = slots["item." + item.value]) == null ? void 0 : _a3.call(slots, item)) != null ? _c2 : (_b2 = slots.item) == null ? void 0 : _b2.call(slots, item);
                    }
                  });
                })];
              }
            }), (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
              prev: prev,
              next: next
            }), hasActions && ((_c = (_b = slots.actions) == null ? void 0 : _b.call(slots, {
              next: next,
              prev: prev
            })) != null ? _c : createVNode(VStepperActions, {
              "key": "stepper-actions",
              "onClick:prev": prev,
              "onClick:next": next
            }, slots))];
          }
        });
      });
      return {
        prev: prev,
        next: next
      };
    }
  });
  var VSwitch$1 = "";
  var makeVSwitchProps = propsFactory(_objectSpread(_objectSpread({
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean,
    loading: {
      type: [Boolean, String],
      "default": false
    }
  }, makeVInputProps()), makeVSelectionControlProps()), "VSwitch");
  var VSwitch = genericComponent()({
    name: "VSwitch",
    inheritAttrs: false,
    props: makeVSwitchProps(),
    emits: {
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (value) {
        return true;
      },
      "update:indeterminate": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var indeterminate = useProxiedModel(props, "indeterminate");
      var model = useProxiedModel(props, "modelValue");
      var _useLoader5 = useLoader(props),
        loaderClasses = _useLoader5.loaderClasses;
      var _useFocus8 = useFocus(props),
        isFocused = _useFocus8.isFocused,
        focus2 = _useFocus8.focus,
        blur2 = _useFocus8.blur;
      var control = ref();
      var isForcedColorsModeActive = IN_BROWSER && window.matchMedia("(forced-colors: active)").matches;
      var loaderColor = computed(function () {
        return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
      });
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "switch-" + uid2;
      });
      function onChange() {
        if (indeterminate.value) {
          indeterminate.value = false;
        }
      }
      function onTrackClick(e) {
        var _a2, _b;
        e.stopPropagation();
        e.preventDefault();
        (_b = (_a2 = control.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.click();
      }
      useRender(function () {
        var _filterInputAttrs13 = filterInputAttrs(attrs),
          _filterInputAttrs14 = _slicedToArray(_filterInputAttrs13, 2),
          rootAttrs = _filterInputAttrs14[0],
          controlAttrs = _filterInputAttrs14[1];
        var inputProps = VInput.filterProps(props);
        var controlProps = VSelectionControl.filterProps(props);
        return createVNode(VInput, mergeProps({
          "class": ["v-switch", {
            "v-switch--flat": props.flat
          }, {
            "v-switch--inset": props.inset
          }, {
            "v-switch--indeterminate": indeterminate.value
          }, loaderClasses.value, props.class]
        }, rootAttrs, inputProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "id": id.value,
          "focused": isFocused.value,
          "style": props.style
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (_ref2) {
            var id2 = _ref2.id,
              messagesId = _ref2.messagesId,
              isDisabled = _ref2.isDisabled,
              isReadonly2 = _ref2.isReadonly,
              isValid2 = _ref2.isValid;
            var slotProps = {
              model: model,
              isValid: isValid2
            };
            return createVNode(VSelectionControl, mergeProps({
              "ref": control
            }, controlProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": [function ($event) {
                return model.value = $event;
              }, onChange],
              "id": id2.value,
              "aria-describedby": messagesId.value,
              "type": "checkbox",
              "aria-checked": indeterminate.value ? "mixed" : void 0,
              "disabled": isDisabled.value,
              "readonly": isReadonly2.value,
              "onFocus": focus2,
              "onBlur": blur2
            }, controlAttrs), _objectSpread(_objectSpread({}, slots), {}, {
              "default": function (_ref3) {
                var backgroundColorClasses = _ref3.backgroundColorClasses,
                  backgroundColorStyles = _ref3.backgroundColorStyles;
                return createVNode("div", {
                  "class": ["v-switch__track", !isForcedColorsModeActive ? backgroundColorClasses.value : void 0],
                  "style": backgroundColorStyles.value,
                  "onClick": onTrackClick
                }, [slots["track-true"] && createVNode("div", {
                  "key": "prepend",
                  "class": "v-switch__track-true"
                }, [slots["track-true"](slotProps)]), slots["track-false"] && createVNode("div", {
                  "key": "append",
                  "class": "v-switch__track-false"
                }, [slots["track-false"](slotProps)])]);
              },
              input: function (_ref4) {
                var inputNode = _ref4.inputNode,
                  icon = _ref4.icon,
                  backgroundColorClasses = _ref4.backgroundColorClasses,
                  backgroundColorStyles = _ref4.backgroundColorStyles;
                return createVNode(Fragment$1, null, [inputNode, createVNode("div", {
                  "class": ["v-switch__thumb", {
                    "v-switch__thumb--filled": icon || props.loading
                  }, props.inset || isForcedColorsModeActive ? void 0 : backgroundColorClasses.value],
                  "style": props.inset ? void 0 : backgroundColorStyles.value
                }, [slots.thumb ? createVNode(VDefaultsProvider, {
                  "defaults": {
                    VIcon: {
                      icon: icon,
                      size: "x-small"
                    }
                  }
                }, {
                  "default": function () {
                    return [slots.thumb(_objectSpread(_objectSpread({}, slotProps), {}, {
                      icon: icon
                    }))];
                  }
                }) : createVNode(VScaleTransition, null, {
                  "default": function () {
                    return [!props.loading ? icon && createVNode(VIcon, {
                      "key": String(icon),
                      "icon": icon,
                      "size": "x-small"
                    }, null) : createVNode(LoaderSlot, {
                      "name": "v-switch",
                      "active": true,
                      "color": isValid2.value === false ? void 0 : loaderColor.value
                    }, {
                      "default": function (slotProps2) {
                        return slots.loader ? slots.loader(slotProps2) : createVNode(VProgressCircular, {
                          "active": slotProps2.isActive,
                          "color": slotProps2.color,
                          "indeterminate": true,
                          "size": "16",
                          "width": "2"
                        }, null);
                      }
                    })];
                  }
                })])]);
              }
            }));
          }
        }));
      });
      return {};
    }
  });
  var VSystemBar$1 = "";
  var makeVSystemBarProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    color: String,
    height: [Number, String],
    window: Boolean
  }, makeComponentProps()), makeElevationProps()), makeLayoutItemProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), "VSystemBar");
  var VSystemBar = genericComponent()({
    name: "VSystemBar",
    props: makeVSystemBarProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme31 = provideTheme(props),
        themeClasses = _provideTheme31.themeClasses;
      var _useBackgroundColor25 = useBackgroundColor(toRef(props, "color")),
        backgroundColorClasses = _useBackgroundColor25.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor25.backgroundColorStyles;
      var _useElevation17 = useElevation(props),
        elevationClasses = _useElevation17.elevationClasses;
      var _useRounded23 = useRounded(props),
        roundedClasses = _useRounded23.roundedClasses;
      var _useSsrBoot7 = useSsrBoot(),
        ssrBootStyles = _useSsrBoot7.ssrBootStyles;
      var height = computed(function () {
        var _a2;
        return (_a2 = props.height) != null ? _a2 : props.window ? 32 : 24;
      });
      var _useLayoutItem5 = useLayoutItem({
          id: props.name,
          order: computed(function () {
            return parseInt(props.order, 10);
          }),
          position: shallowRef("top"),
          layoutSize: height,
          elementSize: height,
          active: computed(function () {
            return true;
          }),
          absolute: toRef(props, "absolute")
        }),
        layoutItemStyles = _useLayoutItem5.layoutItemStyles;
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-system-bar", {
            "v-system-bar--window": props.window
          }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value, roundedClasses.value, props.class],
          "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, props.style]
        }, slots);
      });
      return {};
    }
  });
  var VTab$1 = "";
  var VTabsSymbol = Symbol.for("vuetify:v-tabs");
  var makeVTabProps = propsFactory(_objectSpread({
    fixed: Boolean,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
      type: String,
      "default": "horizontal"
    }
  }, omit(makeVBtnProps({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])), "VTab");
  var VTab = genericComponent()({
    name: "VTab",
    props: makeVTabProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots,
        attrs = _ref.attrs;
      var _useTextColor17 = useTextColor(props, "sliderColor"),
        sliderColorClasses = _useTextColor17.textColorClasses,
        sliderColorStyles = _useTextColor17.textColorStyles;
      var rootEl = ref();
      var sliderEl = ref();
      var isHorizontal = computed(function () {
        return props.direction === "horizontal";
      });
      var isSelected = computed(function () {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = rootEl.value) == null ? void 0 : _a2.group) == null ? void 0 : _b.isSelected.value) != null ? _c : false;
      });
      function updateSlider(_ref2) {
        var _a2, _b;
        var value = _ref2.value;
        if (value) {
          var prevEl = (_b = (_a2 = rootEl.value) == null ? void 0 : _a2.$el.parentElement) == null ? void 0 : _b.querySelector(".v-tab--selected .v-tab__slider");
          var nextEl = sliderEl.value;
          if (!prevEl || !nextEl) return;
          var color = getComputedStyle(prevEl).color;
          var prevBox = prevEl.getBoundingClientRect();
          var nextBox = nextEl.getBoundingClientRect();
          var xy = isHorizontal.value ? "x" : "y";
          var XY = isHorizontal.value ? "X" : "Y";
          var rightBottom = isHorizontal.value ? "right" : "bottom";
          var widthHeight = isHorizontal.value ? "width" : "height";
          var prevPos = prevBox[xy];
          var nextPos = nextBox[xy];
          var delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
          var origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
          var size = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
          var scale = size / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
          var initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
          var sigma = 1.5;
          animate(nextEl, {
            backgroundColor: [color, "currentcolor"],
            transform: ["translate" + XY + "(" + delta2 + "px) scale" + XY + "(" + initialScale + ")", "translate" + XY + "(" + delta2 / sigma + "px) scale" + XY + "(" + ((scale - 1) / sigma + 1) + ")", "none"],
            transformOrigin: Array(3).fill(origin)
          }, {
            duration: 225,
            easing: standardEasing
          });
        }
      }
      useRender(function () {
        var btnProps = VBtn.filterProps(props);
        return createVNode(VBtn, mergeProps({
          "symbol": VTabsSymbol,
          "ref": rootEl,
          "class": ["v-tab", props.class],
          "style": props.style,
          "tabindex": isSelected.value ? 0 : -1,
          "role": "tab",
          "aria-selected": String(isSelected.value),
          "active": false
        }, btnProps, attrs, {
          "block": props.fixed,
          "maxWidth": props.fixed ? 300 : void 0,
          "onGroup:selected": updateSlider
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function () {
            var _a2, _b;
            return createVNode(Fragment$1, null, [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : props.text, !props.hideSlider && createVNode("div", {
              "ref": sliderEl,
              "class": ["v-tab__slider", sliderColorClasses.value],
              "style": sliderColorStyles.value
            }, null)]);
          }
        }));
      });
      return forwardRefs({}, rootEl);
    }
  });
  var VTabs$1 = "";
  var makeVTabsWindowProps = propsFactory(_objectSpread({}, omit(makeVWindowProps(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])), "VTabsWindow");
  var VTabsWindow = genericComponent()({
    name: "VTabsWindow",
    props: makeVTabsWindowProps(),
    emits: {
      "update:modelValue": function (v) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var group = inject$1(VTabsSymbol, null);
      var _model = useProxiedModel(props, "modelValue");
      var model = computed({
        get: function () {
          var _a2;
          if (_model.value != null || !group) return _model.value;
          return (_a2 = group.items.value.find(function (item) {
            return group.selected.value.includes(item.id);
          })) == null ? void 0 : _a2.value;
        },
        set: function (val) {
          _model.value = val;
        }
      });
      useRender(function () {
        var windowProps = VWindow.filterProps(props);
        return createVNode(VWindow, mergeProps({
          "_as": "VTabsWindow"
        }, windowProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-tabs-window", props.class],
          "style": props.style,
          "mandatory": false,
          "touch": false
        }), slots);
      });
      return {};
    }
  });
  var makeVTabsWindowItemProps = propsFactory(_objectSpread({}, makeVWindowItemProps()), "VTabsWindowItem");
  var VTabsWindowItem = genericComponent()({
    name: "VTabsWindowItem",
    props: makeVTabsWindowItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      useRender(function () {
        var windowItemProps = VWindowItem.filterProps(props);
        return createVNode(VWindowItem, mergeProps({
          "_as": "VTabsWindowItem"
        }, windowItemProps, {
          "class": ["v-tabs-window-item", props.class],
          "style": props.style
        }), slots);
      });
      return {};
    }
  });
  function parseItems(items) {
    if (!items) return [];
    return items.map(function (item) {
      if (!isObject(item)) return {
        text: item,
        value: item
      };
      return item;
    });
  }
  var makeVTabsProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    alignTabs: {
      type: String,
      "default": "start"
    },
    color: String,
    fixedTabs: Boolean,
    items: {
      type: Array,
      "default": function () {
        return [];
      }
    },
    stacked: Boolean,
    bgColor: String,
    grow: Boolean,
    height: {
      type: [Number, String],
      "default": void 0
    },
    hideSlider: Boolean,
    sliderColor: String
  }, makeVSlideGroupProps({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  })), makeDensityProps()), makeTagProps()), "VTabs");
  var VTabs = genericComponent()({
    name: "VTabs",
    props: makeVTabsProps(),
    emits: {
      "update:modelValue": function (v) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var items = computed(function () {
        return parseItems(props.items);
      });
      var _useDensity15 = useDensity(props),
        densityClasses = _useDensity15.densityClasses;
      var _useBackgroundColor26 = useBackgroundColor(toRef(props, "bgColor")),
        backgroundColorClasses = _useBackgroundColor26.backgroundColorClasses,
        backgroundColorStyles = _useBackgroundColor26.backgroundColorStyles;
      var _useScopeId6 = useScopeId(),
        scopeId = _useScopeId6.scopeId;
      provideDefaults({
        VTab: {
          color: toRef(props, "color"),
          direction: toRef(props, "direction"),
          stacked: toRef(props, "stacked"),
          fixed: toRef(props, "fixedTabs"),
          sliderColor: toRef(props, "sliderColor"),
          hideSlider: toRef(props, "hideSlider")
        }
      });
      useRender(function () {
        var slideGroupProps = VSlideGroup.filterProps(props);
        var hasWindow = !!(slots.window || props.items.length > 0);
        return createVNode(Fragment$1, null, [createVNode(VSlideGroup, mergeProps(slideGroupProps, {
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-tabs", "v-tabs--" + props.direction, "v-tabs--align-tabs-" + props.alignTabs, {
            "v-tabs--fixed-tabs": props.fixedTabs,
            "v-tabs--grow": props.grow,
            "v-tabs--stacked": props.stacked
          }, densityClasses.value, backgroundColorClasses.value, props.class],
          "style": [{
            "--v-tabs-height": convertToUnit(props.height)
          }, backgroundColorStyles.value, props.style],
          "role": "tablist",
          "symbol": VTabsSymbol
        }, scopeId, attrs), {
          "default": function () {
            var _a2, _b;
            return [(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : items.value.map(function (item) {
              var _a3, _b2;
              return (_b2 = (_a3 = slots.tab) == null ? void 0 : _a3.call(slots, {
                item: item
              })) != null ? _b2 : createVNode(VTab, mergeProps(item, {
                "key": item.text,
                "value": item.value
              }), {
                "default": slots["tab." + item.value] ? function () {
                  var _a4;
                  return (_a4 = slots["tab." + item.value]) == null ? void 0 : _a4.call(slots, {
                    item: item
                  });
                } : void 0
              });
            })];
          }
        }), hasWindow && createVNode(VTabsWindow, mergeProps({
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "key": "tabs-window"
        }, scopeId), {
          "default": function () {
            var _a2;
            return [items.value.map(function (item) {
              var _a3, _b;
              return (_b = (_a3 = slots.item) == null ? void 0 : _a3.call(slots, {
                item: item
              })) != null ? _b : createVNode(VTabsWindowItem, {
                "value": item.value
              }, {
                "default": function () {
                  var _a4;
                  return (_a4 = slots["item." + item.value]) == null ? void 0 : _a4.call(slots, {
                    item: item
                  });
                }
              });
            }), (_a2 = slots.window) == null ? void 0 : _a2.call(slots)];
          }
        })]);
      });
      return {};
    }
  });
  var VTextarea$1 = "";
  var makeVTextareaProps = propsFactory(_objectSpread(_objectSpread({
    autoGrow: Boolean,
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    noResize: Boolean,
    rows: {
      type: [Number, String],
      "default": 5,
      validator: function (v) {
        return !isNaN(parseFloat(v));
      }
    },
    maxRows: {
      type: [Number, String],
      validator: function (v) {
        return !isNaN(parseFloat(v));
      }
    },
    suffix: String,
    modelModifiers: Object
  }, makeVInputProps()), makeVFieldProps()), "VTextarea");
  var VTextarea = genericComponent()({
    name: "VTextarea",
    directives: {
      Intersect: Intersect
    },
    inheritAttrs: false,
    props: makeVTextareaProps(),
    emits: {
      "click:control": function (e) {
        return true;
      },
      "mousedown:control": function (e) {
        return true;
      },
      "update:focused": function (focused) {
        return true;
      },
      "update:modelValue": function (val) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var attrs = _ref.attrs,
        emit2 = _ref.emit,
        slots = _ref.slots;
      var model = useProxiedModel(props, "modelValue");
      var _useFocus9 = useFocus(props),
        isFocused = _useFocus9.isFocused,
        focus2 = _useFocus9.focus,
        blur2 = _useFocus9.blur;
      var counterValue = computed(function () {
        return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value || "").toString().length;
      });
      var max = computed(function () {
        if (attrs.maxlength) return attrs.maxlength;
        if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string") return void 0;
        return props.counter;
      });
      function onIntersect(isIntersecting, entries) {
        var _a2, _b;
        if (!props.autofocus || !isIntersecting) return;
        (_b = (_a2 = entries[0].target) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
      }
      var vInputRef = ref();
      var vFieldRef = ref();
      var controlHeight = shallowRef("");
      var textareaRef = ref();
      var isActive2 = computed(function () {
        return props.persistentPlaceholder || isFocused.value || props.active;
      });
      function onFocus() {
        var _a2;
        if (textareaRef.value !== document.activeElement) {
          (_a2 = textareaRef.value) == null ? void 0 : _a2.focus();
        }
        if (!isFocused.value) focus2();
      }
      function onControlClick(e) {
        onFocus();
        emit2("click:control", e);
      }
      function onControlMousedown(e) {
        emit2("mousedown:control", e);
      }
      function onClear(e) {
        e.stopPropagation();
        onFocus();
        nextTick(function () {
          model.value = "";
          callEvent(props["onClick:clear"], e);
        });
      }
      function onInput(e) {
        var _a2;
        var el = e.target;
        model.value = el.value;
        if ((_a2 = props.modelModifiers) == null ? void 0 : _a2.trim) {
          var caretPosition = [el.selectionStart, el.selectionEnd];
          nextTick(function () {
            el.selectionStart = caretPosition[0];
            el.selectionEnd = caretPosition[1];
          });
        }
      }
      var sizerRef = ref();
      var rows = ref(+props.rows);
      var isPlainOrUnderlined = computed(function () {
        return ["plain", "underlined"].includes(props.variant);
      });
      watchEffect(function () {
        if (!props.autoGrow) rows.value = +props.rows;
      });
      function calculateInputHeight() {
        if (!props.autoGrow) return;
        nextTick(function () {
          if (!sizerRef.value || !vFieldRef.value) return;
          var style2 = getComputedStyle(sizerRef.value);
          var fieldStyle = getComputedStyle(vFieldRef.value.$el);
          var padding = parseFloat(style2.getPropertyValue("--v-field-padding-top")) + parseFloat(style2.getPropertyValue("--v-input-padding-top")) + parseFloat(style2.getPropertyValue("--v-field-padding-bottom"));
          var height = sizerRef.value.scrollHeight;
          var lineHeight = parseFloat(style2.lineHeight);
          var minHeight = Math.max(parseFloat(props.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
          var maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;
          var newHeight = clamp(height != null ? height : 0, minHeight, maxHeight);
          rows.value = Math.floor((newHeight - padding) / lineHeight);
          controlHeight.value = convertToUnit(newHeight);
        });
      }
      onMounted(calculateInputHeight);
      watch(model, calculateInputHeight);
      watch(function () {
        return props.rows;
      }, calculateInputHeight);
      watch(function () {
        return props.maxRows;
      }, calculateInputHeight);
      watch(function () {
        return props.density;
      }, calculateInputHeight);
      var observer;
      watch(sizerRef, function (val) {
        if (val) {
          observer = new ResizeObserver(calculateInputHeight);
          observer.observe(sizerRef.value);
        } else {
          observer == null ? void 0 : observer.disconnect();
        }
      });
      onBeforeUnmount(function () {
        observer == null ? void 0 : observer.disconnect();
      });
      useRender(function () {
        var hasCounter = !!(slots.counter || props.counter || props.counterValue);
        var hasDetails = !!(hasCounter || slots.details);
        var _filterInputAttrs15 = filterInputAttrs(attrs),
          _filterInputAttrs16 = _slicedToArray(_filterInputAttrs15, 2),
          rootAttrs = _filterInputAttrs16[0],
          inputAttrs = _filterInputAttrs16[1];
        var _VInput$filterProps3 = VInput.filterProps(props),
          _ = _VInput$filterProps3.modelValue,
          inputProps = _objectWithoutProperties(_VInput$filterProps3, _excluded20);
        var fieldProps = filterFieldProps(props);
        return createVNode(VInput, mergeProps({
          "ref": vInputRef,
          "modelValue": model.value,
          "onUpdate:modelValue": function ($event) {
            return model.value = $event;
          },
          "class": ["v-textarea v-text-field", {
            "v-textarea--prefixed": props.prefix,
            "v-textarea--suffixed": props.suffix,
            "v-text-field--prefixed": props.prefix,
            "v-text-field--suffixed": props.suffix,
            "v-textarea--auto-grow": props.autoGrow,
            "v-textarea--no-resize": props.noResize || props.autoGrow,
            "v-input--plain-underlined": isPlainOrUnderlined.value
          }, props.class],
          "style": props.style
        }, rootAttrs, inputProps, {
          "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
          "focused": isFocused.value
        }), _objectSpread(_objectSpread({}, slots), {}, {
          "default": function (_ref2) {
            var id = _ref2.id,
              isDisabled = _ref2.isDisabled,
              isDirty2 = _ref2.isDirty,
              isReadonly2 = _ref2.isReadonly,
              isValid2 = _ref2.isValid;
            return createVNode(VField, mergeProps({
              "ref": vFieldRef,
              "style": {
                "--v-textarea-control-height": controlHeight.value
              },
              "onClick": onControlClick,
              "onMousedown": onControlMousedown,
              "onClick:clear": onClear,
              "onClick:prependInner": props["onClick:prependInner"],
              "onClick:appendInner": props["onClick:appendInner"]
            }, fieldProps, {
              "id": id.value,
              "active": isActive2.value || isDirty2.value,
              "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
              "dirty": isDirty2.value || props.dirty,
              "disabled": isDisabled.value,
              "focused": isFocused.value,
              "error": isValid2.value === false
            }), _objectSpread(_objectSpread({}, slots), {}, {
              "default": function (_ref3) {
                var _ref3$props2 = _ref3.props,
                  fieldClass = _ref3$props2.class,
                  slotProps = _objectWithoutProperties(_ref3$props2, _excluded21);
                return createVNode(Fragment$1, null, [props.prefix && createVNode("span", {
                  "class": "v-text-field__prefix"
                }, [props.prefix]), withDirectives(createVNode("textarea", mergeProps({
                  "ref": textareaRef,
                  "class": fieldClass,
                  "value": model.value,
                  "onInput": onInput,
                  "autofocus": props.autofocus,
                  "readonly": isReadonly2.value,
                  "disabled": isDisabled.value,
                  "placeholder": props.placeholder,
                  "rows": props.rows,
                  "name": props.name,
                  "onFocus": onFocus,
                  "onBlur": blur2
                }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                  handler: onIntersect
                }, null, {
                  once: true
                }]]), props.autoGrow && withDirectives(createVNode("textarea", {
                  "class": [fieldClass, "v-textarea__sizer"],
                  "id": slotProps.id + "-sizer",
                  "onUpdate:modelValue": function ($event) {
                    return model.value = $event;
                  },
                  "ref": sizerRef,
                  "readonly": true,
                  "aria-hidden": "true"
                }, null), [[vModelText, model.value]]), props.suffix && createVNode("span", {
                  "class": "v-text-field__suffix"
                }, [props.suffix])]);
              }
            }));
          },
          details: hasDetails ? function (slotProps) {
            var _a2;
            return createVNode(Fragment$1, null, [(_a2 = slots.details) == null ? void 0 : _a2.call(slots, slotProps), hasCounter && createVNode(Fragment$1, null, [createVNode("span", null, null), createVNode(VCounter, {
              "active": props.persistentCounter || isFocused.value,
              "value": counterValue.value,
              "max": max.value,
              "disabled": props.disabled
            }, slots.counter)])]);
          } : void 0
        }));
      });
      return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
    }
  });
  var VThemeProvider$1 = "";
  var makeVThemeProviderProps = propsFactory(_objectSpread(_objectSpread(_objectSpread({
    withBackground: Boolean
  }, makeComponentProps()), makeThemeProps()), makeTagProps()), "VThemeProvider");
  var VThemeProvider = genericComponent()({
    name: "VThemeProvider",
    props: makeVThemeProviderProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme32 = provideTheme(props),
        themeClasses = _provideTheme32.themeClasses;
      return function () {
        var _a2;
        if (!props.withBackground) return (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        return createVNode(props.tag, {
          "class": ["v-theme-provider", themeClasses.value, props.class],
          "style": props.style
        }, {
          "default": function () {
            var _a3;
            return [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)];
          }
        });
      };
    }
  });
  var VTimeline$1 = "";
  var makeVTimelineDividerProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    icon: IconValue,
    iconColor: String,
    lineColor: String
  }, makeComponentProps()), makeRoundedProps()), makeSizeProps()), makeElevationProps()), "VTimelineDivider");
  var VTimelineDivider = genericComponent()({
    name: "VTimelineDivider",
    props: makeVTimelineDividerProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useSize6 = useSize(props, "v-timeline-divider__dot"),
        sizeClasses = _useSize6.sizeClasses,
        sizeStyles = _useSize6.sizeStyles;
      var _useBackgroundColor27 = useBackgroundColor(toRef(props, "dotColor")),
        backgroundColorStyles = _useBackgroundColor27.backgroundColorStyles,
        backgroundColorClasses = _useBackgroundColor27.backgroundColorClasses;
      var _useRounded24 = useRounded(props, "v-timeline-divider__dot"),
        roundedClasses = _useRounded24.roundedClasses;
      var _useElevation18 = useElevation(props),
        elevationClasses = _useElevation18.elevationClasses;
      var _useBackgroundColor28 = useBackgroundColor(toRef(props, "lineColor")),
        lineColorClasses = _useBackgroundColor28.backgroundColorClasses,
        lineColorStyles = _useBackgroundColor28.backgroundColorStyles;
      useRender(function () {
        return createVNode("div", {
          "class": ["v-timeline-divider", {
            "v-timeline-divider--fill-dot": props.fillDot
          }, props.class],
          "style": props.style
        }, [createVNode("div", {
          "class": ["v-timeline-divider__before", lineColorClasses.value],
          "style": lineColorStyles.value
        }, null), !props.hideDot && createVNode("div", {
          "key": "dot",
          "class": ["v-timeline-divider__dot", elevationClasses.value, roundedClasses.value, sizeClasses.value],
          "style": sizeStyles.value
        }, [createVNode("div", {
          "class": ["v-timeline-divider__inner-dot", backgroundColorClasses.value, roundedClasses.value],
          "style": backgroundColorStyles.value
        }, [!slots.default ? createVNode(VIcon, {
          "key": "icon",
          "color": props.iconColor,
          "icon": props.icon,
          "size": props.size
        }, null) : createVNode(VDefaultsProvider, {
          "key": "icon-defaults",
          "disabled": !props.icon,
          "defaults": {
            VIcon: {
              color: props.iconColor,
              icon: props.icon,
              size: props.size
            }
          }
        }, slots.default)])]), createVNode("div", {
          "class": ["v-timeline-divider__after", lineColorClasses.value],
          "style": lineColorStyles.value
        }, null)]);
      });
      return {};
    }
  });
  var makeVTimelineItemProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    density: String,
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
      type: Boolean,
      "default": void 0
    },
    icon: IconValue,
    iconColor: String,
    lineInset: [Number, String]
  }, makeComponentProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeSizeProps()), makeTagProps()), "VTimelineItem");
  var VTimelineItem = genericComponent()({
    name: "VTimelineItem",
    props: makeVTimelineItemProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _useDimension21 = useDimension(props),
        dimensionStyles = _useDimension21.dimensionStyles;
      var dotSize = shallowRef(0);
      var dotRef = ref();
      watch(dotRef, function (newValue) {
        var _a2, _b;
        if (!newValue) return;
        dotSize.value = (_b = (_a2 = newValue.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : _a2.getBoundingClientRect().width) != null ? _b : 0;
      }, {
        flush: "post"
      });
      useRender(function () {
        var _a2, _b;
        return createVNode("div", {
          "class": ["v-timeline-item", {
            "v-timeline-item--fill-dot": props.fillDot
          }, props.class],
          "style": [{
            "--v-timeline-dot-size": convertToUnit(dotSize.value),
            "--v-timeline-line-inset": props.lineInset ? "calc(var(--v-timeline-dot-size) / 2 + " + convertToUnit(props.lineInset) + ")" : convertToUnit(0)
          }, props.style]
        }, [createVNode("div", {
          "class": "v-timeline-item__body",
          "style": dimensionStyles.value
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), createVNode(VTimelineDivider, {
          "ref": dotRef,
          "hideDot": props.hideDot,
          "icon": props.icon,
          "iconColor": props.iconColor,
          "size": props.size,
          "elevation": props.elevation,
          "dotColor": props.dotColor,
          "fillDot": props.fillDot,
          "rounded": props.rounded
        }, {
          "default": slots.icon
        }), props.density !== "compact" && createVNode("div", {
          "class": "v-timeline-item__opposite"
        }, [!props.hideOpposite && ((_b = slots.opposite) == null ? void 0 : _b.call(slots))])]);
      });
      return {};
    }
  });
  var makeVTimelineProps = propsFactory(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
    align: {
      type: String,
      "default": "center",
      validator: function (v) {
        return ["center", "start"].includes(v);
      }
    },
    direction: {
      type: String,
      "default": "vertical",
      validator: function (v) {
        return ["vertical", "horizontal"].includes(v);
      }
    },
    justify: {
      type: String,
      "default": "auto",
      validator: function (v) {
        return ["auto", "center"].includes(v);
      }
    },
    side: {
      type: String,
      validator: function (v) {
        return v == null || ["start", "end"].includes(v);
      }
    },
    lineThickness: {
      type: [String, Number],
      "default": 2
    },
    lineColor: String,
    truncateLine: {
      type: String,
      validator: function (v) {
        return ["start", "end", "both"].includes(v);
      }
    }
  }, only(makeVTimelineItemProps({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"])), makeComponentProps()), makeDensityProps()), makeTagProps()), makeThemeProps()), "VTimeline");
  var VTimeline = genericComponent()({
    name: "VTimeline",
    props: makeVTimelineProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var _provideTheme33 = provideTheme(props),
        themeClasses = _provideTheme33.themeClasses;
      var _useDensity16 = useDensity(props),
        densityClasses = _useDensity16.densityClasses;
      var _useRtl20 = useRtl(),
        rtlClasses = _useRtl20.rtlClasses;
      provideDefaults({
        VTimelineDivider: {
          lineColor: toRef(props, "lineColor")
        },
        VTimelineItem: {
          density: toRef(props, "density"),
          dotColor: toRef(props, "dotColor"),
          fillDot: toRef(props, "fillDot"),
          hideOpposite: toRef(props, "hideOpposite"),
          iconColor: toRef(props, "iconColor"),
          lineColor: toRef(props, "lineColor"),
          lineInset: toRef(props, "lineInset"),
          size: toRef(props, "size")
        }
      });
      var sideClasses = computed(function () {
        var side = props.side ? props.side : props.density !== "default" ? "end" : null;
        return side && "v-timeline--side-" + side;
      });
      var truncateClasses = computed(function () {
        var classes = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
        switch (props.truncateLine) {
          case "both":
            return classes;
          case "start":
            return classes[0];
          case "end":
            return classes[1];
          default:
            return null;
        }
      });
      useRender(function () {
        return createVNode(props.tag, {
          "class": ["v-timeline", "v-timeline--" + props.direction, "v-timeline--align-" + props.align, "v-timeline--justify-" + props.justify, truncateClasses.value, {
            "v-timeline--inset-line": !!props.lineInset
          }, themeClasses.value, densityClasses.value, sideClasses.value, rtlClasses.value, props.class],
          "style": [{
            "--v-timeline-line-thickness": convertToUnit(props.lineThickness)
          }, props.style]
        }, slots);
      });
      return {};
    }
  });
  var makeVToolbarItemsProps = propsFactory(_objectSpread(_objectSpread({}, makeComponentProps()), makeVariantProps({
    variant: "text"
  })), "VToolbarItems");
  var VToolbarItems = genericComponent()({
    name: "VToolbarItems",
    props: makeVToolbarItemsProps(),
    setup: function (props, _ref) {
      var slots = _ref.slots;
      provideDefaults({
        VBtn: {
          color: toRef(props, "color"),
          height: "inherit",
          variant: toRef(props, "variant")
        }
      });
      useRender(function () {
        var _a2;
        return createVNode("div", {
          "class": ["v-toolbar-items", props.class],
          "style": props.style
        }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
      });
      return {};
    }
  });
  var VTooltip$1 = "";
  var makeVTooltipProps = propsFactory(_objectSpread({
    id: String,
    text: String
  }, omit(makeVOverlayProps({
    closeOnBack: false,
    location: "end",
    locationStrategy: "connected",
    eager: true,
    minWidth: 0,
    offset: 10,
    openOnClick: false,
    openOnHover: true,
    origin: "auto",
    scrim: false,
    scrollStrategy: "reposition",
    transition: false
  }), ["absolute", "persistent"])), "VTooltip");
  var VTooltip = genericComponent()({
    name: "VTooltip",
    props: makeVTooltipProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var isActive2 = useProxiedModel(props, "modelValue");
      var _useScopeId7 = useScopeId(),
        scopeId = _useScopeId7.scopeId;
      var uid2 = getUid();
      var id = computed(function () {
        return props.id || "v-tooltip-" + uid2;
      });
      var overlay = ref();
      var location2 = computed(function () {
        return props.location.split(" ").length > 1 ? props.location : props.location + " center";
      });
      var origin = computed(function () {
        return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
      });
      var transition = computed(function () {
        if (props.transition) return props.transition;
        return isActive2.value ? "scale-transition" : "fade-transition";
      });
      var activatorProps = computed(function () {
        return mergeProps({
          "aria-describedby": id.value
        }, props.activatorProps);
      });
      useRender(function () {
        var overlayProps = VOverlay.filterProps(props);
        return createVNode(VOverlay, mergeProps({
          "ref": overlay,
          "class": ["v-tooltip", props.class],
          "style": props.style,
          "id": id.value
        }, overlayProps, {
          "modelValue": isActive2.value,
          "onUpdate:modelValue": function ($event) {
            return isActive2.value = $event;
          },
          "transition": transition.value,
          "absolute": true,
          "location": location2.value,
          "origin": origin.value,
          "persistent": true,
          "role": "tooltip",
          "activatorProps": activatorProps.value,
          "_disableGlobalStack": true
        }, scopeId), {
          activator: slots.activator,
          "default": function () {
            var _a12;
            var _a2, _b;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return (_b = (_a2 = slots.default) == null ? void 0 : (_a12 = _a2).call.apply(_a12, [slots].concat(args))) != null ? _b : props.text;
          }
        });
      });
      return forwardRefs({}, overlay);
    }
  });
  var VValidation = genericComponent()({
    name: "VValidation",
    props: makeValidationProps(),
    emits: {
      "update:modelValue": function (value) {
        return true;
      }
    },
    setup: function (props, _ref) {
      var slots = _ref.slots;
      var validation = useValidation(props, "validation");
      return function () {
        var _a2;
        return (_a2 = slots.default) == null ? void 0 : _a2.call(slots, validation);
      };
    }
  });
  var components = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({
    __proto__: null,
    VApp: VApp,
    VAppBar: VAppBar,
    VAppBarNavIcon: VAppBarNavIcon,
    VAppBarTitle: VAppBarTitle,
    VAlert: VAlert,
    VAlertTitle: VAlertTitle,
    VAutocomplete: VAutocomplete,
    VAvatar: VAvatar,
    VBadge: VBadge,
    VBanner: VBanner,
    VBannerActions: VBannerActions,
    VBannerText: VBannerText,
    VBottomNavigation: VBottomNavigation,
    VBottomSheet: VBottomSheet,
    VBreadcrumbs: VBreadcrumbs,
    VBreadcrumbsItem: VBreadcrumbsItem,
    VBreadcrumbsDivider: VBreadcrumbsDivider,
    VBtn: VBtn,
    VBtnGroup: VBtnGroup,
    VBtnToggle: VBtnToggle,
    VCard: VCard,
    VCardActions: VCardActions,
    VCardItem: VCardItem,
    VCardSubtitle: VCardSubtitle,
    VCardText: VCardText,
    VCardTitle: VCardTitle,
    VCarousel: VCarousel,
    VCarouselItem: VCarouselItem,
    VCheckbox: VCheckbox,
    VCheckboxBtn: VCheckboxBtn,
    VChip: VChip,
    VChipGroup: VChipGroup,
    VCode: VCode,
    VColorPicker: VColorPicker,
    VCombobox: VCombobox,
    VConfirmEdit: VConfirmEdit,
    VCounter: VCounter,
    VDataIterator: VDataIterator,
    VDataTable: VDataTable,
    VDataTableHeaders: VDataTableHeaders,
    VDataTableFooter: VDataTableFooter,
    VDataTableRows: VDataTableRows,
    VDataTableRow: VDataTableRow,
    VDataTableVirtual: VDataTableVirtual,
    VDataTableServer: VDataTableServer,
    VDatePicker: VDatePicker,
    VDatePickerControls: VDatePickerControls,
    VDatePickerHeader: VDatePickerHeader,
    VDatePickerMonth: VDatePickerMonth,
    VDatePickerMonths: VDatePickerMonths,
    VDatePickerYears: VDatePickerYears,
    VDefaultsProvider: VDefaultsProvider,
    VDialog: VDialog,
    VDivider: VDivider,
    VEmptyState: VEmptyState,
    VExpansionPanels: VExpansionPanels,
    VExpansionPanel: VExpansionPanel,
    VExpansionPanelText: VExpansionPanelText,
    VExpansionPanelTitle: VExpansionPanelTitle,
    VFab: VFab,
    VField: VField,
    VFieldLabel: VFieldLabel,
    VFileInput: VFileInput,
    VFooter: VFooter,
    VForm: VForm,
    VContainer: VContainer,
    VCol: VCol,
    VRow: VRow,
    VSpacer: VSpacer,
    VHover: VHover,
    VIcon: VIcon,
    VComponentIcon: VComponentIcon,
    VSvgIcon: VSvgIcon,
    VLigatureIcon: VLigatureIcon,
    VClassIcon: VClassIcon,
    VImg: VImg,
    VInfiniteScroll: VInfiniteScroll,
    VInput: VInput,
    VItemGroup: VItemGroup,
    VItem: VItem,
    VKbd: VKbd,
    VLabel: VLabel,
    VLayout: VLayout,
    VLayoutItem: VLayoutItem,
    VLazy: VLazy,
    VList: VList,
    VListGroup: VListGroup,
    VListImg: VListImg,
    VListItem: VListItem,
    VListItemAction: VListItemAction,
    VListItemMedia: VListItemMedia,
    VListItemSubtitle: VListItemSubtitle,
    VListItemTitle: VListItemTitle,
    VListSubheader: VListSubheader,
    VLocaleProvider: VLocaleProvider,
    VMain: VMain,
    VMenu: VMenu,
    VMessages: VMessages,
    VNavigationDrawer: VNavigationDrawer,
    VNoSsr: VNoSsr,
    VOtpInput: VOtpInput,
    VOverlay: VOverlay,
    VPagination: VPagination,
    VParallax: VParallax,
    VProgressCircular: VProgressCircular,
    VProgressLinear: VProgressLinear,
    VRadio: VRadio,
    VRadioGroup: VRadioGroup,
    VRangeSlider: VRangeSlider,
    VRating: VRating,
    VResponsive: VResponsive,
    VSelect: VSelect,
    VSelectionControl: VSelectionControl,
    VSelectionControlGroup: VSelectionControlGroup,
    VSheet: VSheet,
    VSkeletonLoader: VSkeletonLoader,
    VSlideGroup: VSlideGroup,
    VSlideGroupItem: VSlideGroupItem,
    VSlider: VSlider,
    VSnackbar: VSnackbar,
    VSparkline: VSparkline,
    VSpeedDial: VSpeedDial,
    VStepper: VStepper,
    VStepperActions: VStepperActions,
    VStepperHeader: VStepperHeader,
    VStepperItem: VStepperItem,
    VStepperWindow: VStepperWindow,
    VStepperWindowItem: VStepperWindowItem,
    VSwitch: VSwitch,
    VSystemBar: VSystemBar,
    VTab: VTab,
    VTabs: VTabs,
    VTabsWindow: VTabsWindow,
    VTabsWindowItem: VTabsWindowItem,
    VTable: VTable,
    VTextarea: VTextarea,
    VTextField: VTextField,
    VThemeProvider: VThemeProvider,
    VTimeline: VTimeline,
    VTimelineItem: VTimelineItem,
    VToolbar: VToolbar,
    VToolbarTitle: VToolbarTitle,
    VToolbarItems: VToolbarItems,
    VTooltip: VTooltip,
    VValidation: VValidation,
    VVirtualScroll: VVirtualScroll,
    VWindow: VWindow,
    VWindowItem: VWindowItem,
    VDialogTransition: VDialogTransition,
    VFabTransition: VFabTransition,
    VDialogBottomTransition: VDialogBottomTransition,
    VDialogTopTransition: VDialogTopTransition,
    VFadeTransition: VFadeTransition,
    VScaleTransition: VScaleTransition,
    VScrollXTransition: VScrollXTransition,
    VScrollXReverseTransition: VScrollXReverseTransition,
    VScrollYTransition: VScrollYTransition,
    VScrollYReverseTransition: VScrollYReverseTransition,
    VSlideXTransition: VSlideXTransition,
    VSlideXReverseTransition: VSlideXReverseTransition,
    VSlideYTransition: VSlideYTransition,
    VSlideYReverseTransition: VSlideYReverseTransition,
    VExpandTransition: VExpandTransition,
    VExpandXTransition: VExpandXTransition
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function mounted$2(el, binding) {
    var _a2, _b, _c, _d;
    var modifiers2 = binding.modifiers || {};
    var value = binding.value;
    var once = modifiers2.once,
      immediate = modifiers2.immediate,
      modifierKeys = _objectWithoutProperties(modifiers2, _excluded22);
    var defaultValue = !Object.keys(modifierKeys).length;
    var _ref295 = _typeof(value) === "object" ? value : {
        handler: value,
        options: {
          attributes: (_a2 = modifierKeys == null ? void 0 : modifierKeys.attr) != null ? _a2 : defaultValue,
          characterData: (_b = modifierKeys == null ? void 0 : modifierKeys.char) != null ? _b : defaultValue,
          childList: (_c = modifierKeys == null ? void 0 : modifierKeys.child) != null ? _c : defaultValue,
          subtree: (_d = modifierKeys == null ? void 0 : modifierKeys.sub) != null ? _d : defaultValue
        }
      },
      handler = _ref295.handler,
      options = _ref295.options;
    var observer = new MutationObserver(function () {
      var mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var observer2 = arguments.length > 1 ? arguments[1] : void 0;
      handler == null ? void 0 : handler(mutations, observer2);
      if (once) unmounted$2(el, binding);
    });
    if (immediate) handler == null ? void 0 : handler([], observer);
    el._mutate = Object(el._mutate);
    el._mutate[binding.instance.$.uid] = {
      observer: observer
    };
    observer.observe(el, options);
  }
  function unmounted$2(el, binding) {
    var _a2;
    if (!((_a2 = el._mutate) == null ? void 0 : _a2[binding.instance.$.uid])) return;
    el._mutate[binding.instance.$.uid].observer.disconnect();
    delete el._mutate[binding.instance.$.uid];
  }
  var Mutate = {
    mounted: mounted$2,
    unmounted: unmounted$2
  };
  function mounted$1(el, binding) {
    var _a2, _b;
    var handler = binding.value;
    var options = {
      passive: !((_a2 = binding.modifiers) == null ? void 0 : _a2.active)
    };
    window.addEventListener("resize", handler, options);
    el._onResize = Object(el._onResize);
    el._onResize[binding.instance.$.uid] = {
      handler: handler,
      options: options
    };
    if (!((_b = binding.modifiers) == null ? void 0 : _b.quiet)) {
      handler();
    }
  }
  function unmounted$1(el, binding) {
    var _a2;
    if (!((_a2 = el._onResize) == null ? void 0 : _a2[binding.instance.$.uid])) return;
    var _el$_onResize$binding = el._onResize[binding.instance.$.uid],
      handler = _el$_onResize$binding.handler,
      options = _el$_onResize$binding.options;
    window.removeEventListener("resize", handler, options);
    delete el._onResize[binding.instance.$.uid];
  }
  var Resize = {
    mounted: mounted$1,
    unmounted: unmounted$1
  };
  function mounted(el, binding) {
    var _a2;
    var _ref296 = (_a2 = binding.modifiers) != null ? _a2 : {},
      _ref296$self = _ref296.self,
      self2 = _ref296$self === void 0 ? false : _ref296$self;
    var value = binding.value;
    var options = _typeof(value) === "object" && value.options || {
      passive: true
    };
    var handler = typeof value === "function" || "handleEvent" in value ? value : value.handler;
    var target = self2 ? el : binding.arg ? document.querySelector(binding.arg) : window;
    if (!target) return;
    target.addEventListener("scroll", handler, options);
    el._onScroll = Object(el._onScroll);
    el._onScroll[binding.instance.$.uid] = {
      handler: handler,
      options: options,
      target: self2 ? void 0 : target
    };
  }
  function unmounted(el, binding) {
    var _a2;
    if (!((_a2 = el._onScroll) == null ? void 0 : _a2[binding.instance.$.uid])) return;
    var _el$_onScroll$binding = el._onScroll[binding.instance.$.uid],
      handler = _el$_onScroll$binding.handler,
      options = _el$_onScroll$binding.options,
      _el$_onScroll$binding2 = _el$_onScroll$binding.target,
      target = _el$_onScroll$binding2 === void 0 ? el : _el$_onScroll$binding2;
    target.removeEventListener("scroll", handler, options);
    delete el._onScroll[binding.instance.$.uid];
  }
  function updated(el, binding) {
    if (binding.value === binding.oldValue) return;
    unmounted(el, binding);
    mounted(el, binding);
  }
  var Scroll = {
    mounted: mounted,
    unmounted: unmounted,
    updated: updated
  };
  function useDirectiveComponent(component, props) {
    var concreteComponent = typeof component === "string" ? resolveComponent(component) : component;
    var hook = mountComponent(concreteComponent, props);
    return {
      mounted: hook,
      updated: hook,
      unmounted: function (el) {
        render(null, el);
      }
    };
  }
  function mountComponent(component, props) {
    return function (el, binding, vnode) {
      var _a2, _b, _c, _d, _e, _f;
      var _props = typeof props === "function" ? props(binding) : props;
      var text = (_c = (_b = (_a2 = binding.value) == null ? void 0 : _a2.text) != null ? _b : binding.value) != null ? _c : _props == null ? void 0 : _props.text;
      var value = isObject(binding.value) ? binding.value : {};
      var children = function () {
        return text != null ? text : el.textContent;
      };
      var provides = (_f = vnode.ctx === binding.instance.$ ? (_d = findComponentParent(vnode, binding.instance.$)) == null ? void 0 : _d.provides : (_e = vnode.ctx) == null ? void 0 : _e.provides) != null ? _f : binding.instance.$.provides;
      var node = h(component, mergeProps(_props, value), children);
      node.appContext = Object.assign( /* @__PURE__ */Object.create(null), binding.instance.$.appContext, {
        provides: provides
      });
      render(node, el);
    };
  }
  function findComponentParent(vnode, root) {
    var stack2 = /* @__PURE__ */new Set();
    var walk = function (children) {
      var _a2, _b;
      for (var _iterator71 = _createForOfIteratorHelperLoose(children), _step73; !(_step73 = _iterator71()).done;) {
        var child = _step73.value;
        if (!child) continue;
        if (child === vnode || child.el && vnode.el && child.el === vnode.el) {
          return true;
        }
        stack2.add(child);
        var result2 = void 0;
        if (child.suspense) {
          result2 = walk([child.ssContent]);
        } else if (Array.isArray(child.children)) {
          result2 = walk(child.children);
        } else if ((_a2 = child.component) == null ? void 0 : _a2.vnode) {
          result2 = walk([(_b = child.component) == null ? void 0 : _b.subTree]);
        }
        if (result2) {
          return result2;
        }
        stack2.delete(child);
      }
      return false;
    };
    if (!walk([root.subTree])) {
      consoleError("Could not find original vnode, component will not inherit provides");
      return root;
    }
    var result = Array.from(stack2).reverse();
    for (var _iterator72 = _createForOfIteratorHelperLoose(result), _step74; !(_step74 = _iterator72()).done;) {
      var child = _step74.value;
      if (child.component) {
        return child.component;
      }
    }
    return root;
  }
  var Tooltip = useDirectiveComponent(VTooltip, function (binding) {
    var _a2;
    return {
      activator: "parent",
      location: (_a2 = binding.arg) == null ? void 0 : _a2.replace("-", " "),
      text: typeof binding.value === "boolean" ? void 0 : binding.value
    };
  });
  var directives = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({
    __proto__: null,
    ClickOutside: ClickOutside,
    Intersect: Intersect,
    Mutate: Mutate,
    Resize: Resize,
    Ripple: Ripple,
    Scroll: Scroll,
    Touch: Touch,
    Tooltip: Tooltip
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var vuetify = createVuetify({
    components: components,
    directives: directives
  });
  Meteor.startup(function () {
    var app = createApp(_sfc_main$6);
    app.use(vuetify);
    app.use(router);
    app.use(VueMeteor);
    app.mount("#app");
  });
}.call(this, module);